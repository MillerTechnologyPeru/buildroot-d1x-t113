From 15ad8ea4cf13e2a64758481c62ad4d7241f99b50 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 17:27:06 +0800
Subject: [PATCH 92/93] add mutimedia header support

---
 include/drm/drm_connector.h              |   21 +-
 include/drm/drm_dp_helper.h              |   10 +
 include/drm/drm_drv.h                    |   10 +
 include/drm/drm_mipi_dsi.h               |   12 +
 include/drm/drm_mode_config.h            |   12 -
 include/drm/drm_mode_object.h            |    2 +-
 include/drm/drm_panel.h                  |   37 +
 include/drm/drm_prime.h                  |    1 +
 include/media/sunxi_camera.h             |  169 ++++
 include/media/sunxi_camera_v2.h          |  408 +++++++++
 include/media/v4l2-fh.h                  |    2 -
 include/media/videobuf2-core.h           |    2 +-
 include/sound/aw_rpaf/common.h           |  344 ++++++++
 include/sound/aw_rpaf/component-core.h   |  213 +++++
 include/sound/aw_rpaf/component-driver.h |   35 +
 include/sound/aw_rpaf/component.h        |  175 ++++
 include/sound/aw_rpaf/debug.h            |   52 ++
 include/sound/aw_rpaf/mixer.h            |   70 ++
 include/sound/aw_rpaf/rpmsg_hifi.h       |   90 ++
 include/sound/aw_rpaf/substream.h        |  124 +++
 include/sound/compress_driver.h          |   10 +-
 include/sound/pcm.h                      |    1 +
 include/sound/simple_card_utils.h        |    2 +
 include/sound/soc.h                      |   26 +
 include/video/drv_hdmi.h                 |   49 ++
 include/video/sunxi_display2.h           | 1012 ++++++++++++++++++++++
 include/video/sunxi_metadata.h           |   70 ++
 27 files changed, 2933 insertions(+), 26 deletions(-)
 create mode 100644 include/media/sunxi_camera.h
 create mode 100644 include/media/sunxi_camera_v2.h
 create mode 100644 include/sound/aw_rpaf/common.h
 create mode 100644 include/sound/aw_rpaf/component-core.h
 create mode 100644 include/sound/aw_rpaf/component-driver.h
 create mode 100644 include/sound/aw_rpaf/component.h
 create mode 100644 include/sound/aw_rpaf/debug.h
 create mode 100644 include/sound/aw_rpaf/mixer.h
 create mode 100644 include/sound/aw_rpaf/rpmsg_hifi.h
 create mode 100644 include/sound/aw_rpaf/substream.h
 create mode 100644 include/video/drv_hdmi.h
 create mode 100644 include/video/sunxi_display2.h
 create mode 100644 include/video/sunxi_metadata.h

diff --git a/include/drm/drm_connector.h b/include/drm/drm_connector.h
index 681cb590f..1b4bf5186 100644
--- a/include/drm/drm_connector.h
+++ b/include/drm/drm_connector.h
@@ -40,6 +40,7 @@ struct drm_encoder;
 struct drm_property;
 struct drm_property_blob;
 struct drm_printer;
+struct drm_panel;
 struct edid;
 struct i2c_adapter;
 
@@ -281,6 +282,10 @@ enum drm_panel_orientation {
 /* Additional Colorimetry extension added as part of CTA 861.G */
 #define DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65		11
 #define DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER		12
+/* Additional Colorimetry Options added for DP 1.4a VSC Colorimetry Format */
+#define DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED		13
+#define DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT		14
+#define DRM_MODE_COLORIMETRY_BT601_YCC			15
 
 /**
  * enum drm_bus_flags - bus_flags info for &drm_display_info
@@ -1345,6 +1350,12 @@ struct drm_connector {
 	 * rev1.1 4.2.2.6
 	 */
 	bool edid_corrupt;
+	/**
+	 * @real_edid_checksum: real edid checksum for corrupted edid block.
+	 * Required in Displayport 1.4 compliance testing
+	 * rev1.1 4.2.2.6
+	 */
+	u8 real_edid_checksum;
 
 	/** @debugfs_entry: debugfs directory for this connector */
 	struct dentry *debugfs_entry;
@@ -1410,6 +1421,13 @@ struct drm_connector {
 
 	/** @hdr_sink_metadata: HDR Metadata Information read from sink */
 	struct hdr_sink_metadata hdr_sink_metadata;
+
+	/**
+	 * @panel:
+	 *
+	 * Can find the panel which connected to drm_connector.
+	 */
+	struct drm_panel *panel;
 };
 
 #define obj_to_connector(x) container_of(x, struct drm_connector, base)
@@ -1523,7 +1541,8 @@ int drm_connector_attach_scaling_mode_property(struct drm_connector *connector,
 int drm_connector_attach_vrr_capable_property(
 		struct drm_connector *connector);
 int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
-int drm_mode_create_colorspace_property(struct drm_connector *connector);
+int drm_mode_create_hdmi_colorspace_property(struct drm_connector *connector);
+int drm_mode_create_dp_colorspace_property(struct drm_connector *connector);
 int drm_mode_create_content_type_property(struct drm_device *dev);
 void drm_hdmi_avi_infoframe_content_type(struct hdmi_avi_infoframe *frame,
 					 const struct drm_connector_state *conn_state);
diff --git a/include/drm/drm_dp_helper.h b/include/drm/drm_dp_helper.h
index 8364502f9..02ecfdc47 100644
--- a/include/drm/drm_dp_helper.h
+++ b/include/drm/drm_dp_helper.h
@@ -649,6 +649,14 @@
 # define DP_TEST_COUNT_MASK		    0xf
 
 #define DP_TEST_PHY_PATTERN                 0x248
+# define DP_TEST_PHY_PATTERN_NONE			0x0
+# define DP_TEST_PHY_PATTERN_D10_2_NO_SCRAMBLING	0x1
+# define DP_TEST_PHY_PATTERN_SYMBOL_ERR_MEASUREMENT_CNT 0x2
+# define DP_TEST_PHY_PATTERN_PRBS7			0x3
+# define DP_TEST_PHY_PATTERN_80_BIT_CUSTOM_PATTERN	0x4
+# define DP_TEST_PHY_PATTERN_CP2520_PATTERN_1		0x5
+# define DP_TEST_PHY_PATTERN_CP2520_PATTERN_2		0x6
+# define DP_TEST_PHY_PATTERN_CP2520_PATTERN_3		0x7
 #define DP_TEST_80BIT_CUSTOM_PATTERN_7_0    0x250
 #define	DP_TEST_80BIT_CUSTOM_PATTERN_15_8   0x251
 #define	DP_TEST_80BIT_CUSTOM_PATTERN_23_16  0x252
@@ -1353,6 +1361,8 @@ static inline ssize_t drm_dp_dpcd_writeb(struct drm_dp_aux *aux,
 int drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,
 				 u8 status[DP_LINK_STATUS_SIZE]);
 
+bool drm_dp_send_real_edid_checksum(struct drm_dp_aux *aux,
+		u8 real_edid_checksum);
 /*
  * DisplayPort link
  */
diff --git a/include/drm/drm_drv.h b/include/drm/drm_drv.h
index 8976afe48..7e8ddea2a 100644
--- a/include/drm/drm_drv.h
+++ b/include/drm/drm_drv.h
@@ -29,6 +29,7 @@
 
 #include <linux/list.h>
 #include <linux/irqreturn.h>
+#include <linux/uuid.h>
 
 #include <drm/drm_device.h>
 
@@ -653,6 +654,15 @@ struct drm_driver {
 	int (*gem_prime_mmap)(struct drm_gem_object *obj,
 				struct vm_area_struct *vma);
 
+	/**
+	 * @gem_prime_get_uuid
+	 *
+	 * get_uuid hook for GEM drivers. Retrieves the virtio uuid of the
+	 * given GEM buffer.
+	 */
+	int (*gem_prime_get_uuid)(struct drm_gem_object *obj,
+				  uuid_t *uuid);
+
 	/**
 	 * @dumb_create:
 	 *
diff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h
index 13cf2ae59..efd059045 100644
--- a/include/drm/drm_mipi_dsi.h
+++ b/include/drm/drm_mipi_dsi.h
@@ -18,12 +18,18 @@ struct mipi_dsi_device;
 #define MIPI_DSI_MSG_REQ_ACK	BIT(0)
 /* use Low Power Mode to transmit message */
 #define MIPI_DSI_MSG_USE_LPM	BIT(1)
+/* read mipi_dsi_msg.ctrl and unicast to only that ctrls */
+#define MIPI_DSI_MSG_UNICAST	BIT(2)
+/* Stack all commands until lastcommand bit and trigger all in one go */
+#define MIPI_DSI_MSG_LASTCOMMAND BIT(3)
 
 /**
  * struct mipi_dsi_msg - read/write DSI buffer
  * @channel: virtual channel id
  * @type: payload data type
  * @flags: flags controlling this message transmission
+ * @ctrl: ctrl index to transmit on
+ * @wait_ms: duration in ms to wait after message transmission
  * @tx_len: length of @tx_buf
  * @tx_buf: data to be written
  * @rx_len: length of @rx_buf
@@ -33,6 +39,8 @@ struct mipi_dsi_msg {
 	u8 channel;
 	u8 type;
 	u16 flags;
+	u32 ctrl;
+	u32 wait_ms;
 
 	size_t tx_len;
 	const void *tx_buf;
@@ -131,6 +139,10 @@ struct mipi_dsi_host *of_find_mipi_dsi_host_by_node(struct device_node *node);
 #define MIPI_DSI_CLOCK_NON_CONTINUOUS	BIT(10)
 /* transmit data in low power */
 #define MIPI_DSI_MODE_LPM		BIT(11)
+/* disable BLLP area */
+#define MIPI_DSI_MODE_VIDEO_BLLP	BIT(12)
+/* disable EOF BLLP area */
+#define MIPI_DSI_MODE_VIDEO_EOF_BLLP	BIT(13)
 
 enum mipi_dsi_pixel_format {
 	MIPI_DSI_FMT_RGB888,
diff --git a/include/drm/drm_mode_config.h b/include/drm/drm_mode_config.h
index 198b9d060..3bcbe3033 100644
--- a/include/drm/drm_mode_config.h
+++ b/include/drm/drm_mode_config.h
@@ -865,18 +865,6 @@ struct drm_mode_config {
 	 */
 	bool prefer_shadow_fbdev;
 
-	/**
-	 * @fbdev_use_iomem:
-	 *
-	 * Set to true if framebuffer reside in iomem.
-	 * When set to true memcpy_toio() is used when copying the framebuffer in
-	 * drm_fb_helper.drm_fb_helper_dirty_blit_real().
-	 *
-	 * FIXME: This should be replaced with a per-mapping is_iomem
-	 * flag (like ttm does), and then used everywhere in fbdev code.
-	 */
-	bool fbdev_use_iomem;
-
 	/**
 	 * @quirk_addfb_prefer_xbgr_30bpp:
 	 *
diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index c34a3e803..6292fa663 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -60,7 +60,7 @@ struct drm_mode_object {
 	void (*free_cb)(struct kref *kref);
 };
 
-#define DRM_OBJECT_MAX_PROPERTY 24
+#define DRM_OBJECT_MAX_PROPERTY 64
 /**
  * struct drm_object_properties - property tracking for &drm_mode_object
  */
diff --git a/include/drm/drm_panel.h b/include/drm/drm_panel.h
index 624bd15ec..1f977fff3 100644
--- a/include/drm/drm_panel.h
+++ b/include/drm/drm_panel.h
@@ -27,6 +27,29 @@
 #include <linux/err.h>
 #include <linux/errno.h>
 #include <linux/list.h>
+#include <linux/notifier.h>
+
+/* A hardware display blank change occurred */
+#define DRM_PANEL_EVENT_BLANK		0x01
+/* A hardware display blank early change occurred */
+#define DRM_PANEL_EARLY_EVENT_BLANK	0x02
+
+enum {
+	/* panel: power on */
+	DRM_PANEL_BLANK_UNBLANK,
+	/* panel: power off */
+	DRM_PANEL_BLANK_POWERDOWN,
+	/* panel: low power mode */
+	DRM_PANEL_BLANK_LP,
+	/* fps change */
+	DRM_PANEL_BLANK_FPS_CHANGE,
+};
+
+struct drm_panel_notifier {
+	int refresh_rate;
+	void *data;
+	uint32_t id;
+};
 
 struct device_node;
 struct drm_connector;
@@ -145,6 +168,13 @@ struct drm_panel {
 	 * Panel entry in registry.
 	 */
 	struct list_head list;
+
+	/**
+	 * @nh:
+	 *
+	 * panel notifier list head
+	 */
+	struct blocking_notifier_head nh;
 };
 
 void drm_panel_init(struct drm_panel *panel);
@@ -155,6 +185,13 @@ void drm_panel_remove(struct drm_panel *panel);
 int drm_panel_attach(struct drm_panel *panel, struct drm_connector *connector);
 void drm_panel_detach(struct drm_panel *panel);
 
+int drm_panel_notifier_register(struct drm_panel *panel,
+	struct notifier_block *nb);
+int drm_panel_notifier_unregister(struct drm_panel *panel,
+	struct notifier_block *nb);
+int drm_panel_notifier_call_chain(struct drm_panel *panel,
+	unsigned long val, void *v);
+
 int drm_panel_prepare(struct drm_panel *panel);
 int drm_panel_unprepare(struct drm_panel *panel);
 
diff --git a/include/drm/drm_prime.h b/include/drm/drm_prime.h
index d89311b82..d920bc494 100644
--- a/include/drm/drm_prime.h
+++ b/include/drm/drm_prime.h
@@ -106,5 +106,6 @@ void drm_prime_gem_destroy(struct drm_gem_object *obj, struct sg_table *sg);
 int drm_prime_sg_to_page_addr_arrays(struct sg_table *sgt, struct page **pages,
 				     dma_addr_t *addrs, int max_pages);
 
+int drm_gem_dmabuf_get_uuid(struct dma_buf *dma_buf, uuid_t *uuid);
 
 #endif /* __DRM_PRIME_H__ */
diff --git a/include/media/sunxi_camera.h b/include/media/sunxi_camera.h
new file mode 100644
index 000000000..e64a29b58
--- /dev/null
+++ b/include/media/sunxi_camera.h
@@ -0,0 +1,169 @@
+/*
+ * include/media/sunxi_camera.h -- Ctrl IDs definitions for sunxi-vfe
+ *
+ * Copyright (C) 2014 Allwinnertech Co., Ltd.
+ * Copyright (C) 2015 Yang Feng
+ *
+ * Author: Yang Feng <yangfeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+#ifndef _SUNXI_CAMERA_H_
+#define _SUNXI_CAMERA_H_
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+
+/*  Flags for 'capability' and 'capturemode' fields */
+#define V4L2_MODE_HIGHQUALITY		0x0001
+#define V4L2_MODE_VIDEO				0x0002
+#define V4L2_MODE_IMAGE				0x0003
+#define V4L2_MODE_PREVIEW			0x0004
+/*
+ *	USER CIDS
+ */
+struct v4l2_win_coordinate {
+	__s32			x1;
+	__s32			y1;
+	__s32			x2;
+	__s32			y2;
+};
+
+#define V4L2_MAX_WIN_NUM	10
+
+#define V4L2_FLASH_LED_MODE_AUTO				(V4L2_FLASH_LED_MODE_TORCH+1)
+#define V4L2_FLASH_LED_MODE_RED_EYE				(V4L2_FLASH_LED_MODE_TORCH+2)
+
+struct v4l2_win_setting {
+	__s32 win_num;
+	struct v4l2_win_coordinate coor[V4L2_MAX_WIN_NUM];
+};
+
+enum v4l2_gain_shift {
+	V4L2_GAIN_SHIFT	= 0,
+	V4L2_SHARP_LEVEL_SHIFT	= 8,
+	V4L2_SHARP_MIN_SHIFT	= 20,
+	V4L2_NDF_SHIFT	= 26,
+};
+
+#define MAX_EXP_FRAMES     5
+
+/* The base for the sunxi-vfe controls. Total of 64 controls is reserved for this driver, add by yangfeng */
+#define V4L2_CID_USER_SUNXI_CAMERA_BASE		(V4L2_CID_USER_BASE + 0x1050)
+
+#define V4L2_CID_HFLIP_THUMB					(V4L2_CID_USER_SUNXI_CAMERA_BASE+0)
+#define V4L2_CID_VFLIP_THUMB					(V4L2_CID_USER_SUNXI_CAMERA_BASE+1)
+#define V4L2_CID_AUTO_FOCUS_INIT				(V4L2_CID_USER_SUNXI_CAMERA_BASE+2)
+#define V4L2_CID_AUTO_FOCUS_RELEASE				(V4L2_CID_USER_SUNXI_CAMERA_BASE+3)
+#define V4L2_CID_GSENSOR_ROTATION				(V4L2_CID_USER_SUNXI_CAMERA_BASE+4)
+#define V4L2_CID_FRAME_RATE			(V4L2_CID_USER_SUNXI_CAMERA_BASE+5)
+
+enum v4l2_take_picture {
+	V4L2_TAKE_PICTURE_STOP	= 0,
+	V4L2_TAKE_PICTURE_NORM	= 1,
+	V4L2_TAKE_PICTURE_FAST	= 2,
+	V4L2_TAKE_PICTURE_FLASH	= 3,
+	V4L2_TAKE_PICTURE_HDR	= 4,
+};
+struct isp_hdr_setting_t {
+	__s32 hdr_en;
+	__s32 hdr_mode;
+	__s32 frames_count;
+	__s32 total_frames;
+	__s32 values[MAX_EXP_FRAMES];
+};
+
+#define HDR_CTRL_GET    0
+#define HDR_CTRL_SET     1
+struct isp_hdr_ctrl {
+	__s32 flag;
+	__s32 count;
+	struct isp_hdr_setting_t hdr_t;
+};
+
+#define V4L2_CID_TAKE_PICTURE		(V4L2_CID_USER_SUNXI_CAMERA_BASE+6)
+
+typedef union {
+	unsigned int dwval;
+	struct {
+		unsigned int af_sharp		:  16;
+		unsigned int hdr_cnt		:  4;
+		unsigned int flash_ok		:  1;
+		unsigned int capture_ok		:  1;
+		unsigned int fast_capture_ok	:  1;
+		unsigned int res0		:  9;
+	} bits;
+} IMAGE_FLAG_t;
+
+#define  V4L2_CID_HOR_VISUAL_ANGLE	(V4L2_CID_USER_SUNXI_CAMERA_BASE+7)
+#define  V4L2_CID_VER_VISUAL_ANGLE	(V4L2_CID_USER_SUNXI_CAMERA_BASE+8)
+#define  V4L2_CID_FOCUS_LENGTH		(V4L2_CID_USER_SUNXI_CAMERA_BASE+9)
+#define  V4L2_CID_R_GAIN		(V4L2_CID_USER_SUNXI_CAMERA_BASE+10)
+#define  V4L2_CID_G_GAIN		(V4L2_CID_USER_SUNXI_CAMERA_BASE+11)
+#define  V4L2_CID_B_GAIN		(V4L2_CID_USER_SUNXI_CAMERA_BASE+12)
+
+enum v4l2_sensor_type {
+	V4L2_SENSOR_TYPE_YUV		= 0,
+	V4L2_SENSOR_TYPE_RAW		= 1,
+};
+
+#define V4L2_CID_SENSOR_TYPE			(V4L2_CID_USER_SUNXI_CAMERA_BASE+13)
+
+/*
+ *	PRIVATE IOCTRLS
+ */
+
+struct isp_stat_buf {
+	void __user *buf;
+	__u32 buf_size;
+};
+struct isp_exif_attribute {
+	struct v4l2_fract exposure_time;
+	struct v4l2_fract shutter_speed;
+	__u32 fnumber;
+	__u32 focal_length;
+	__s32 exposure_bias;
+	__u32 iso_speed;
+	__u32 flash_fire;
+	__u32 brightness;
+	__s32 reserved[16];
+};
+
+struct rot_channel_cfg {
+	__u32 sel_ch;
+	__u32 rotation;
+	struct v4l2_pix_format pix;
+};
+#define VIDIOC_ISP_AE_STAT_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct isp_stat_buf)
+#define VIDIOC_ISP_HIST_STAT_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 2, struct isp_stat_buf)
+#define VIDIOC_ISP_AF_STAT_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 3, struct isp_stat_buf)
+#define VIDIOC_ISP_EXIF_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 4, struct isp_exif_attribute)
+#define VIDIOC_ISP_GAMMA_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 5, struct isp_stat_buf)
+#define VIDIOC_AUTO_FOCUS_WIN \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct v4l2_win_setting)
+#define VIDIOC_AUTO_EXPOSURE_WIN \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 7, struct v4l2_win_setting)
+#define VIDIOC_HDR_CTRL \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 8, struct isp_hdr_ctrl)
+
+#define VIDIOC_SET_SUBCHANNEL \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 9, struct v4l2_pix_format)
+#define VIDIOC_SET_ROTCHANNEL \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 10, struct rot_channel_cfg)
+
+
+#endif /*_SUNXI_CAMERA_H_*/
diff --git a/include/media/sunxi_camera_v2.h b/include/media/sunxi_camera_v2.h
new file mode 100644
index 000000000..c173bf7d7
--- /dev/null
+++ b/include/media/sunxi_camera_v2.h
@@ -0,0 +1,408 @@
+/*
+ * include/media/sunxi_camera_v2.h -- Ctrl IDs definitions for sunxi-vin
+ *
+ * Copyright (C) 2014 Allwinnertech Co., Ltd.
+ * Copyright (C) 2015 Yang Feng
+ *
+ * Author: Yang Feng <yangfeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+#ifndef _SUNXI_CAMERA_H_
+#define _SUNXI_CAMERA_H_
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+/*  Flags for 'capability' and 'capturemode' fields */
+#define V4L2_MODE_HIGHQUALITY		0x0001
+#define V4L2_MODE_VIDEO			0x0002
+#define V4L2_MODE_IMAGE			0x0003
+#define V4L2_MODE_PREVIEW		0x0004
+
+/*  for yuv420 FBC mode*/
+#define V4L2_PIX_FMT_FBC           v4l2_fourcc('F', 'C', '2', '1')
+#define V4L2_PIX_FMT_LBC_2_0X      v4l2_fourcc('L', 'C', '2', '1')
+#define V4L2_PIX_FMT_LBC_2_5X      v4l2_fourcc('L', 'C', '2', '2')
+#define V4L2_PIX_FMT_LBC_1_0X      v4l2_fourcc('L', 'C', '2', '3')
+
+/*
+ *	USER CIDS
+ */
+struct v4l2_win_coordinate {
+	__s32 x1;
+	__s32 y1;
+	__s32 x2;
+	__s32 y2;
+};
+
+/*
+ *enum v4l2_flash_led_mode {
+ *	V4L2_FLASH_LED_MODE_NONE,
+ *	V4L2_FLASH_LED_MODE_FLASH,
+ *	V4L2_FLASH_LED_MODE_TORCH,
+ *};
+ */
+#define V4L2_FLASH_LED_MODE_AUTO		(V4L2_FLASH_LED_MODE_TORCH + 1)
+#define V4L2_FLASH_LED_MODE_RED_EYE		(V4L2_FLASH_LED_MODE_TORCH + 2)
+
+struct v4l2_win_setting {
+	struct v4l2_win_coordinate coor;
+};
+
+enum v4l2_gain_shift {
+	V4L2_GAIN_SHIFT = 0,
+	V4L2_SHARP_LEVEL_SHIFT = 8,
+	V4L2_SHARP_MIN_SHIFT = 20,
+	V4L2_NDF_SHIFT = 26,
+};
+
+#define MAX_EXP_FRAMES     5
+
+/*
+ * The base for the sunxi-vfe controls.
+ * Total of 64 controls is reserved for this driver, add by yangfeng
+ */
+#define V4L2_CID_USER_SUNXI_CAMERA_BASE		(V4L2_CID_USER_BASE + 0x1050)
+
+#define V4L2_CID_AUTO_FOCUS_INIT	(V4L2_CID_USER_SUNXI_CAMERA_BASE + 2)
+#define V4L2_CID_AUTO_FOCUS_RELEASE	(V4L2_CID_USER_SUNXI_CAMERA_BASE + 3)
+#define V4L2_CID_GSENSOR_ROTATION	(V4L2_CID_USER_SUNXI_CAMERA_BASE + 4)
+#define V4L2_CID_FRAME_RATE             (V4L2_CID_USER_SUNXI_CAMERA_BASE + 5)
+
+enum v4l2_take_picture {
+	V4L2_TAKE_PICTURE_STOP = 0,
+	V4L2_TAKE_PICTURE_NORM = 1,
+	V4L2_TAKE_PICTURE_FAST = 2,
+	V4L2_TAKE_PICTURE_FLASH = 3,
+	V4L2_TAKE_PICTURE_HDR = 4,
+};
+struct isp_hdr_setting_t {
+	__s32 hdr_en;
+	__s32 hdr_mode;
+	__s32 frames_count;
+	__s32 total_frames;
+	__s32 values[MAX_EXP_FRAMES];
+};
+struct csi_sync_ctrl {
+	__s32 type;
+	__s32 prs_sync_en;
+	__s32 prs_sync_scr_sel;
+	__s32 prs_sync_bench_sel;
+	__s32 prs_sync_input_vsync_en;
+	__s32 prs_sync_singal_via_by;
+	__s32 prs_sync_singal_scr_sel;
+	__s32 prs_sync_pulse_cfg;
+	__s32 prs_sync_dist;
+	__s32 prs_sync_wait_n;
+	__s32 prs_sync_wait_m;
+	__s32 dma_clr_dist;
+
+	__s32 prs_xvs_out_en;
+	__s32 prs_xhs_out_en;
+	__s32 prs_xvs_t;
+	__s32 prs_xhs_t;
+	__s32 prs_xvs_len;
+	__s32 prs_xhs_len;
+};
+
+#define HDR_CTRL_GET    0
+#define HDR_CTRL_SET     1
+struct isp_hdr_ctrl {
+	__s32 flag;
+	__s32 count;
+	struct isp_hdr_setting_t hdr_t;
+};
+
+#define V4L2_CID_TAKE_PICTURE	(V4L2_CID_USER_SUNXI_CAMERA_BASE + 6)
+
+typedef union {
+	unsigned int dwval;
+	struct {
+		unsigned int af_sharp:16;
+		unsigned int hdr_cnt:4;
+		unsigned int flash_ok:1;
+		unsigned int capture_ok:1;
+		unsigned int fast_capture_ok:1;
+		unsigned int res0:9;
+	} bits;
+} IMAGE_FLAG_t;
+
+#define  V4L2_CID_HOR_VISUAL_ANGLE	(V4L2_CID_USER_SUNXI_CAMERA_BASE + 7)
+#define  V4L2_CID_VER_VISUAL_ANGLE	(V4L2_CID_USER_SUNXI_CAMERA_BASE + 8)
+#define  V4L2_CID_FOCUS_LENGTH		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 9)
+#define  V4L2_CID_R_GAIN		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 10)
+#define  V4L2_CID_GR_GAIN		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 11)
+#define  V4L2_CID_GB_GAIN		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 12)
+#define  V4L2_CID_B_GAIN		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 13)
+
+enum v4l2_sensor_type {
+	V4L2_SENSOR_TYPE_YUV = 0,
+	V4L2_SENSOR_TYPE_RAW = 1,
+};
+
+#define V4L2_CID_SENSOR_TYPE		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 14)
+
+#define  V4L2_CID_AE_WIN_X1		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 15)
+#define  V4L2_CID_AE_WIN_Y1		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 16)
+#define  V4L2_CID_AE_WIN_X2		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 17)
+#define  V4L2_CID_AE_WIN_Y2		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 18)
+
+#define  V4L2_CID_AF_WIN_X1		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 19)
+#define  V4L2_CID_AF_WIN_Y1		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 20)
+#define  V4L2_CID_AF_WIN_X2		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 21)
+#define  V4L2_CID_AF_WIN_Y2		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 22)
+
+static const char *const flash_led_mode_v1[] = {
+	"Off",
+	"Auto",
+	"Red Eye",
+	NULL,
+};
+
+enum v4l2_flash_led_mode_v1{
+	V4L2_FLASH_MODE_NONE = 0,
+	V4L2_FLASH_MODE_AUTO,
+	V4L2_FLASH_MODE_RED_EYE,
+};
+
+#define	V4L2_CID_FLASH_LED_MODE_V1		(V4L2_CID_USER_SUNXI_CAMERA_BASE + 23)
+/*
+ *	PRIVATE IOCTRLS
+ */
+
+struct isp_stat_buf {
+	void __user *buf;
+	__u32 buf_size;
+};
+struct isp_exif_attribute {
+	struct v4l2_fract exposure_time;
+	struct v4l2_fract shutter_speed;
+	__u32 fnumber;
+	__u32 focal_length;
+	__s32 exposure_bias;
+	__u32 iso_speed;
+	__u32 flash_fire;
+	__u32 brightness;
+	__s32 reserved[16];
+};
+
+struct vin_top_clk {
+	__u32 clk_rate;
+};
+
+struct vin_fps_ds {
+	__u32 fps_ds;
+};
+
+struct isp_debug_mode {
+	__u32 debug_en;
+	__u32 debug_sel;
+};
+
+struct vin_pattern_config {
+	__u32 ptn_en;
+	void __user *ptn_addr;
+	void __user *drc_tab;
+	void __user *gamma_tab;
+	void __user *isp_reg;
+	__u32 ptn_size;
+	__u32 ptn_w;
+	__u32 ptn_h;
+	__u32 ptn_fmt;
+	__u32 ptn_type;
+};
+
+struct vin_reset_time {
+	__u32 reset_time;
+};
+
+struct parser_fps_ds {
+	__u32 ch0_fps_ds;
+	__u32 ch1_fps_ds;
+	__u32 ch2_fps_ds;
+	__u32 ch3_fps_ds;
+};
+
+#define VIDIOC_ISP_AE_STAT_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct isp_stat_buf)
+#define VIDIOC_ISP_HIST_STAT_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 2, struct isp_stat_buf)
+#define VIDIOC_ISP_AF_STAT_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 3, struct isp_stat_buf)
+#define VIDIOC_ISP_EXIF_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 4, struct isp_exif_attribute)
+#define VIDIOC_ISP_GAMMA_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 5, struct isp_stat_buf)
+#define VIDIOC_SET_TOP_CLK \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct vin_top_clk)
+#define VIDIOC_SET_FPS_DS \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 7, struct vin_fps_ds)
+#define VIDIOC_HDR_CTRL \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 8, struct isp_hdr_ctrl)
+#define VIDIOC_SYNC_CTRL \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 9, struct csi_sync_ctrl)
+#define VIDIOC_ISP_DEBUG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 10, struct isp_debug_mode)
+#define VIDIOC_VIN_PTN_CFG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 11, struct vin_pattern_config)
+#define VIDIOC_VIN_RESET_TIME \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 12, struct vin_reset_time)
+#define VIDIOC_SET_PARSER_FPS \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 13, struct parser_fps_ds)
+
+/*
+ * Events
+ *
+ * V4L2_EVENT_VIN_H3A: Histogram and AWB AE AF statistics data ready
+ * V4L2_EVENT_VIN_ISP_OFF: ISP stream off
+ */
+
+#define V4L2_EVENT_VIN_CLASS		(V4L2_EVENT_PRIVATE_START | 0x100)
+#define V4L2_EVENT_VIN_H3A		(V4L2_EVENT_VIN_CLASS | 0x1)
+#define V4L2_EVENT_VIN_HDR		(V4L2_EVENT_VIN_CLASS | 0x2)
+#define V4L2_EVENT_VIN_ISP_OFF		(V4L2_EVENT_VIN_CLASS | 0x3)
+
+struct vin_isp_h3a_config {
+	__u32 buf_size;
+	__u32 config_counter;
+};
+
+/**
+ * struct vin_isp_stat_data - Statistic data sent to or received from user
+ * @ts: Timestamp of returned framestats.
+ * @buf: Pointer to pass to user.
+ * @frame_number: Frame number of requested stats.
+ * @cur_frame: Current frame number being processed.
+ * @config_counter: Number of the configuration associated with the data.
+ */
+struct vin_isp_stat_data {
+	void __user *buf;
+	__u32 buf_size;
+	__u32 frame_number;
+	__u32 config_counter;
+};
+
+struct vin_isp_stat_event_status {
+	__u32 frame_number;
+	__u16 config_counter;
+	__u8 buf_err;
+};
+
+struct vin_isp_hdr_event_data {
+	__u32			cmd;
+	struct isp_hdr_ctrl	hdr;
+};
+
+struct vin_vsync_event_data {
+	__u64 frame_number;
+};
+
+/*
+ * Statistics IOCTLs
+ *
+ * VIDIOC_VIN_ISP_H3A_CFG: Set AE configuration
+ * VIDIOC_VIN_ISP_STAT_REQ: Read statistics (AE/AWB/AF/histogram) data
+ * VIDIOC_VIN_ISP_STAT_EN: Enable/disable a statistics module
+ */
+
+#define VIDIOC_VIN_ISP_H3A_CFG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 31, struct vin_isp_h3a_config)
+#define VIDIOC_VIN_ISP_STAT_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 32, struct vin_isp_stat_data)
+#define VIDIOC_VIN_ISP_STAT_EN \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 33, unsigned int)
+
+struct sensor_config {
+	int width;
+	int height;
+	unsigned int hoffset;	/*receive hoffset from sensor output*/
+	unsigned int voffset;	/*receive voffset from sensor output*/
+	unsigned int hts;	/*h size of timing, unit: pclk      */
+	unsigned int vts;	/*v size of timing, unit: line      */
+	unsigned int pclk;	/*pixel clock in Hz                 */
+	unsigned int fps_fixed;	/*sensor fps            */
+	unsigned int bin_factor;/*binning factor                    */
+	unsigned int intg_min;	/*integration min, unit: line, Q4   */
+	unsigned int intg_max;	/*integration max, unit: line, Q4   */
+	unsigned int gain_min;	/*sensor gain min, Q4               */
+	unsigned int gain_max;	/*sensor gain max, Q4               */
+	unsigned int mbus_code;	/*media bus code                    */
+	unsigned int wdr_mode;	/*isp wdr mode                    */
+};
+
+struct sensor_exp_gain {
+	int exp_val;
+	int gain_val;
+	int r_gain;
+	int b_gain;
+};
+
+struct sensor_fps {
+	int fps;
+};
+struct sensor_temp {
+	int temp;
+};
+
+struct isp_table_reg_map {
+	void __user *addr;
+	unsigned int size;
+};
+
+struct actuator_ctrl {
+	unsigned int code;
+};
+
+struct actuator_para {
+	unsigned short code_min;
+	unsigned short code_max;
+};
+
+struct flash_para {
+   enum v4l2_flash_led_mode mode;
+};
+
+/*
+ * Camera Sensor IOCTLs
+ */
+
+#define VIDIOC_VIN_SENSOR_CFG_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 60, struct sensor_config)
+
+#define VIDIOC_VIN_SENSOR_EXP_GAIN \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 61, struct sensor_exp_gain)
+#define VIDIOC_VIN_SENSOR_SET_FPS \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 62, struct sensor_fps)
+#define VIDIOC_VIN_SENSOR_GET_TEMP \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 63, struct sensor_temp)
+
+#define VIDIOC_VIN_ACT_SET_CODE \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 64, struct actuator_ctrl)
+#define VIDIOC_VIN_ACT_INIT \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 65, struct actuator_para)
+#define VIDIOC_VIN_FLASH_EN \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 66, struct flash_para)
+
+#define VIDIOC_VIN_ISP_LOAD_REG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 70, struct isp_table_reg_map)
+
+#define VIDIOC_VIN_ISP_TABLE1_MAP \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 71, struct isp_table_reg_map)
+
+#define VIDIOC_VIN_ISP_TABLE2_MAP \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 72, struct isp_table_reg_map)
+
+#define VIDIOC_VIN_GET_SENSOR_CODE \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 73, int)
+
+#endif /*_SUNXI_CAMERA_H_*/
+
diff --git a/include/media/v4l2-fh.h b/include/media/v4l2-fh.h
index 53b4dbb4a..b5b3e00c8 100644
--- a/include/media/v4l2-fh.h
+++ b/include/media/v4l2-fh.h
@@ -53,9 +53,7 @@ struct v4l2_fh {
 	unsigned int		navailable;
 	u32			sequence;
 
-#if IS_ENABLED(CONFIG_V4L2_MEM2MEM_DEV)
 	struct v4l2_m2m_ctx	*m2m_ctx;
-#endif
 };
 
 /**
diff --git a/include/media/videobuf2-core.h b/include/media/videobuf2-core.h
index 640aabe69..1168ed938 100644
--- a/include/media/videobuf2-core.h
+++ b/include/media/videobuf2-core.h
@@ -19,7 +19,7 @@
 #include <linux/bitops.h>
 #include <media/media-request.h>
 
-#define VB2_MAX_FRAME	(32)
+#define VB2_MAX_FRAME	(64)
 #define VB2_MAX_PLANES	(8)
 
 /**
diff --git a/include/sound/aw_rpaf/common.h b/include/sound/aw_rpaf/common.h
new file mode 100644
index 000000000..46a6e6a36
--- /dev/null
+++ b/include/sound/aw_rpaf/common.h
@@ -0,0 +1,344 @@
+/*
+ * linux/sound/aw_rpaf/common.h -- Remote Process Audio Framework Layer
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _AW_RPAF_COMMON_H_
+#define _AW_RPAF_COMMON_H_
+
+#define SRAM_PCM_CACHE_QUEUE 16U
+#define DSP_SOUND_CARDS 4U
+
+#include <uapi/sound/asound.h>
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+#include <sound/soc-topology.h>
+
+static const char *const awrpaf_info_pre = "AWRPAF_INFO";
+static const char *const awrpaf_debug_pre = "AWRPAF_DEBUG";
+static const char *const awrpaf_err_pre = "AWRPAF_ERR";
+
+#if 0
+#define awrpaf_info(fmt, ...) \
+	printk(KERN_INFO pr_fmt("[%s][%s:%d]"fmt), \
+			awrpaf_info_pre, __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define awrpaf_info(fmt, ...)
+#endif
+
+#if 0
+#define awrpaf_debug(fmt, ...) \
+	printk(KERN_DEBUG pr_fmt("[%s][%s:%d]"fmt), \
+			awrpaf_debug_pre, __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define awrpaf_debug(fmt, ...)
+#endif
+
+#define awrpaf_err(fmt, ...) \
+	printk(KERN_ERR pr_fmt("[%s][%s:%d]"fmt), \
+			awrpaf_err_pre, __func__, __LINE__, ##__VA_ARGS__)
+
+/* the arm is 64bit cpu and dsp is 32bit cpu */
+struct msg_audio_package {
+	uint32_t audioMsgVal;
+	uint32_t sharePointer;
+};
+
+/** PCM sample format */
+enum hifi_pcm_format {
+	/** Unknown */
+	SND_PCM_FORMAT_UNKNOWN = -1,
+	/** Signed 8 bit */
+	SND_PCM_FORMAT_S8 = 0,
+	/** Unsigned 8 bit */
+	SND_PCM_FORMAT_U8,
+	/** Signed 16 bit Little Endian */
+	SND_PCM_FORMAT_S16_LE,
+	/** Signed 16 bit Big Endian */
+	SND_PCM_FORMAT_S16_BE,
+	/** Unsigned 16 bit Little Endian */
+	SND_PCM_FORMAT_U16_LE,
+	/** Unsigned 16 bit Big Endian */
+	SND_PCM_FORMAT_U16_BE,
+	/** Signed 24 bit Little Endian using low three bytes in 32-bit word */
+	SND_PCM_FORMAT_S24_LE,
+	/** Signed 24 bit Big Endian using low three bytes in 32-bit word */
+	SND_PCM_FORMAT_S24_BE,
+	/** Unsigned 24 bit Little Endian using low three bytes in 32-bit word */
+	SND_PCM_FORMAT_U24_LE,
+	/** Unsigned 24 bit Big Endian using low three bytes in 32-bit word */
+	SND_PCM_FORMAT_U24_BE,
+	/** Signed 32 bit Little Endian */
+	SND_PCM_FORMAT_S32_LE,
+	/** Signed 32 bit Big Endian */
+	SND_PCM_FORMAT_S32_BE,
+	/** Unsigned 32 bit Little Endian */
+	SND_PCM_FORMAT_U32_LE,
+	/** Unsigned 32 bit Big Endian */
+	SND_PCM_FORMAT_U32_BE,
+
+	/* only support little endian */
+	/** Signed 16 bit CPU endian */
+	SND_PCM_FORMAT_S16 = SND_PCM_FORMAT_S16_LE,
+	/** Unsigned 16 bit CPU endian */
+	SND_PCM_FORMAT_U16 = SND_PCM_FORMAT_U16_LE,
+	/** Signed 24 bit CPU endian */
+	SND_PCM_FORMAT_S24 = SND_PCM_FORMAT_S24_LE,
+	/** Unsigned 24 bit CPU endian */
+	SND_PCM_FORMAT_U24 = SND_PCM_FORMAT_U24_LE,
+	/** Signed 32 bit CPU endian */
+	SND_PCM_FORMAT_S32 = SND_PCM_FORMAT_S32_LE,
+	/** Unsigned 32 bit CPU endian */
+	SND_PCM_FORMAT_U32 = SND_PCM_FORMAT_U32_LE,
+
+	SND_PCM_FORMAT_LAST = SND_PCM_FORMAT_U32_BE,
+};
+
+enum snd_stream_direction {
+	SND_STREAM_PLAYBACK = 0,
+	SND_STREAM_CAPTURE,
+};
+
+enum snd_codec_type {
+	SND_CODEC_TYPE_PCM,
+	SND_CODEC_TYPE_MP3,
+	SND_CODEC_TYPE_AAC,
+	SND_CODEC_TYPE_OTHER,
+};
+
+enum snd_data_type {
+	SND_DATA_TYPE_PCM,
+	SND_DATA_TYPE_RAW,
+	SND_DATA_TYPE_OTHER,
+};
+
+enum MSGBOX_SOC_DSP_AUDIO_COMMAND {
+	MSGBOX_SOC_DSP_AUDIO_NULL_COMMAND = 0,
+	/* PCM stream的同步操作接口 */
+	MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND,
+	/* 该定义各式各样并且种类过多， 暂不做全功能支持，后者后期迭代增加 */
+	MSGBOX_SOC_DSP_AUDIO_MIXER_COMMAND,
+
+	/* for misc driver */
+	/* 该定义用于调试，如：外挂codec寄存器的读写 */
+	MSGBOX_SOC_DSP_AUDIO_DEBUG_COMMAND,
+	/* 该定义用于组件数据读写 */
+	MSGBOX_SOC_DSP_AUDIO_COMPONENT_COMMAND,
+};
+
+/*
+ * param[0] = MSGBOX_SOC_DSP_AUDIO_COMMAND->MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND
+ * param[1] = *snd_soc_dsp_substream
+ * param[2] = SND_SOC_DSP_PCM_COMMAND
+ * param[3] = *params
+ */
+enum SND_SOC_DSP_PCM_COMMAND {
+	/*
+	 * for cpudai driver and machine driver
+	 * need to get status after execing at dsp & sync
+	 */
+	SND_SOC_DSP_PCM_PROBE,
+	SND_SOC_DSP_PCM_SUSPEND,
+	SND_SOC_DSP_PCM_RESUME,
+	SND_SOC_DSP_PCM_REMOVE,
+
+	/* the cmd of pcm stream interface & sync */
+	SND_SOC_DSP_PCM_STARTUP,
+	SND_SOC_DSP_PCM_HW_PARAMS,
+	SND_SOC_DSP_PCM_PREPARE,
+	SND_SOC_DSP_PCM_WRITEI,
+	SND_SOC_DSP_PCM_READI,
+	SND_SOC_DSP_PCM_START,
+	SND_SOC_DSP_PCM_STOP,
+	SND_SOC_DSP_PCM_DRAIN,
+	SND_SOC_DSP_PCM_SHUTDOWN,
+};
+
+/*
+ * param[0] = MSGBOX_DSP_AUDIO_COMMAND->MSGBOX_DSP_AUDIO_CTL_COMMAND
+ * param[1] = *snd_dsp_hal_mixer
+ * param[2] = SND_SOC_DSP_MIXER_COMMAND
+ * param[3] = NULL
+ */
+enum SND_SOC_DSP_MIXER_COMMAND {
+	/* the cmd of interface & sync */
+	SND_SOC_DSP_MIXER_OPEN = 0,
+	SND_SOC_DSP_MIXER_WRITE,
+	SND_SOC_DSP_MIXER_READ,
+	SND_SOC_DSP_MIXER_CLOSE,
+};
+
+/*
+ * param[0] = MSGBOX_SOC_DSP_AUDIO_COMMAND->MSGBOX_SOC_DSP_DEBUG_COMMAND
+ * param[1] = *snd_soc_dsp_substream
+ * param[2] = SND_SOC_DSP_DEBUG_COMMAND
+ * param[3] = *params
+ */
+enum SND_SOC_DSP_DEBUG_COMMAND {
+	/* for getting params */
+	SND_SOC_DSP_DEBUG_GET_REG,
+	/* for setting params */
+	SND_SOC_DSP_DEBUG_SET_REG,
+	/* the cmd of pcm stream status interface & sync */
+	SND_SOC_DSP_DEBUG_GET_HWPARAMS,
+	SND_SOC_DSP_DEBUG_GET_PCM_STATUS,
+};
+
+/*
+ * param[0] = MSGBOX_DSP_AUDIO_COMMAND->MSGBOX_DSP_AUDIO_COMPONENT_COMMAND
+ * param[1] = *snd_dsp_hal_component
+ * param[2] = SND_SOC_DSP_COMPONENT_COMMAND
+ * param[3] = NULL
+ */
+enum SND_SOC_DSP_COMPONENT_COMMAND {
+	/* the cmd of interface & sync */
+	SND_SOC_DSP_COMPONENT_CREATE,
+	SND_SOC_DSP_COMPONENT_REMOVE,
+	SND_SOC_DSP_COMPONENT_SUSPEND,
+	SND_SOC_DSP_COMPONENT_RESUME,
+	SND_SOC_DSP_COMPONENT_STATUS,
+	SND_SOC_DSP_COMPONENT_SW_PARAMS,
+	SND_SOC_DSP_COMPONENT_START,
+	SND_SOC_DSP_COMPONENT_STOP,
+	SND_SOC_DSP_COMPONENT_WRITE,
+	SND_SOC_DSP_COMPONENT_READ,
+
+	/* stream component */
+	SND_SOC_DSP_COMPONENT_SET_STREAM_PARAMS,
+
+	/* algo control */
+	SND_SOC_DSP_COMPONENT_ALGO_GET,
+	SND_SOC_DSP_COMPONENT_ALGO_SET,
+};
+
+/* 判断当前状态 */
+enum SND_DSP_COMPONENT_STATE {
+	SND_DSP_COMPONENT_STATE_OPEN,
+	SND_DSP_COMPONENT_STATE_CREATE,
+	SND_DSP_COMPONENT_STATE_SETUP,
+	SND_DSP_COMPONENT_STATE_START,
+	SND_DSP_COMPONENT_STATE_RUNNING,
+	SND_DSP_COMPONENT_STATE_STOP,
+	SND_DSP_COMPONENT_STATE_REMOVE,
+	SND_DSP_COMPONENT_STATE_CLOSE,
+};
+
+/* 用于dsp任务之间信息单元传递 */
+struct snd_dsp_hal_queue_item {
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_component *soc_component;
+	struct snd_soc_dsp_mixer *soc_mixer;
+	struct snd_soc_dsp_debug *soc_debug;
+
+	struct snd_dsp_hal_substream *hal_substream;
+	struct snd_dsp_hal_component *hal_component;
+	struct snd_dsp_hal_mixer *hal_mixer;
+
+	uint32_t pxAudioMsgVal;
+	unsigned char used;
+	struct list_head list;
+
+	int32_t ret_val;
+};
+
+/* 会缓存在dram中 */
+struct snd_soc_dsp_sdram_buf {
+	void *read_buf;
+	uint32_t read_size;
+	struct list_head list;
+};
+
+struct snd_dsp_hal_component_process_driver {
+	/* 分配自身算法需要的结构空间变量和配置参数 */
+	//int32_t (*create)(void **handle, struct snd_soc_dsp_native_component *native_component);
+	int32_t (*create)(void **handle, void *native_component);
+	/* 实现该算法处理buffer，并回填buffer, 算法设计不同时更改输入和输出buf */
+	int32_t (*process)(void *handle, void *input_buffer, uint32_t * const input_size,
+				void *output_buffer, uint32_t * const output_size);
+	/* 算法资源释放 */
+	int32_t (*release)(void *handle);
+};
+
+struct snd_soc_dsp_pcm_params {
+	/* eg:0 sndcodec; 1 snddmic; 2 snddaudio0; 3 snddaudio1 */
+	int32_t card;
+	int32_t device;
+	/*
+	 * 根据名字匹配:
+	 * 0: hw:audiocodec;
+	 * 1: hw:snddmic;
+	 * 2: hw:snddaudio0;
+	 * 3: hw:snddaudio1;
+	 */
+	char driver[32];
+	/* 1:capture; 0:playback */
+	enum snd_stream_direction stream;
+
+	/* -- HW params -- */
+	snd_pcm_format_t format;		/* SNDRV_PCM_FORMAT_* */
+	uint32_t rate;				/* rate in Hz */
+	uint32_t channels;
+	uint32_t resample_rate;
+	/* only for hw substream */
+	uint32_t period_size; /* 中断周期 */
+	uint32_t periods;          /* 中断周期个数 */
+	/* 在流中buffer务必一致大小, 代码中务必检查！ */
+	uint32_t buffer_size;	/* 共享buf大小 */
+	uint32_t pcm_frames;
+
+	/* data type */
+	enum snd_data_type data_type;
+	/* mp3 - aac */
+	enum snd_codec_type codec_type;
+	/* dsp pcm status */
+	int32_t status;
+
+	/* 从设备树种获取的私有数据 */
+	uint32_t dts_data;
+
+	/* for dsp0 is 1, for dsp1 is 0 */
+	uint32_t hw_stream;
+
+	/* dsp data transmission mode */
+	uint32_t data_mode;
+	/* soc stream wake/sleep */
+	uint32_t stream_wake;
+
+	/* 独立算法组件用到的参数:buffer大小 */
+	unsigned int input_size;
+	unsigned int output_size;
+	unsigned int dump_size;
+	/* 保存算法用到的参数，具体由算法定义，预留32字节 */
+	uint32_t algo_params[8];
+};
+
+enum snd_dsp_handle_type {
+	HANDLE_TYPE_NULL = 0,
+	HANDLE_TYPE_SOC_MIXER,
+	HANDLE_TYPE_HAL_MIXER,
+	HANDLE_TYPE_HAL_SUBSTREAM,
+	HANDLE_TYPE_HAL_COMPONENT,
+};
+
+enum snd_dsp_list_type {
+	LIST_TYPE_NULL = 0,
+	LIST_TYPE_HAL_MIXER,
+	LIST_TYPE_SOC_MIXER,
+	LIST_TYPE_HAL_SUBSTREAM,
+	LIST_TYPE_SOC_SUBSTREAM,
+	LIST_TYPE_HAL_COMPONENT,
+	LIST_TYPE_SOC_COMPONENT,
+};
+
+#endif
diff --git a/include/sound/aw_rpaf/component-core.h b/include/sound/aw_rpaf/component-core.h
new file mode 100644
index 000000000..719a3dabc
--- /dev/null
+++ b/include/sound/aw_rpaf/component-core.h
@@ -0,0 +1,213 @@
+/*
+ * sound\aw_rpaf\component-core.h -- Remote Process Audio Framework Layer
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _SUNXI_RPAF_COMPONENT_CORE_H
+#define _SUNXI_RPAF_COMPONENT_CORE_H
+
+#include <uapi/sound/asound.h>
+#include <sound/aw_rpaf/component.h>
+#include <linux/miscdevice.h>
+
+#define SUNXI_RPAF_INFO_NAME_LEN 32
+
+struct snd_rpaf_xferi {
+	int32_t result;
+	void __user *input_buf;
+	ssize_t input_length;
+	void __user *output_buf;
+	ssize_t output_length;
+	void __user *dump_buf;
+	ssize_t dump_length;
+	ssize_t dump_type; /* component type */
+};
+
+#ifdef CONFIG_COMPAT
+struct snd_rpaf_xferi32 {
+	int32_t result;
+	int32_t input_buf;
+	int32_t input_length;
+	int32_t output_buf;
+	int32_t output_length;
+	int32_t dump_buf;
+	int32_t dump_length;
+	int32_t dump_type;
+};
+#endif
+
+/*
+ * param[0] = MSGBOX_DSP_AUDIO_COMMAND->MSGBOX_DSP_AUDIO_COMPONENT_COMMAND
+ * param[1] = *snd_dsp_audio_framework_component
+ * param[2] = NULL
+ * param[3] = NULL
+ */
+enum SND_SOC_DSP_AUDIO_COMPONENT_COMMAND {
+	SND_SOC_DSP_COMPONENT_IOCTL_CREATE = _IOW('C', 0x00, struct snd_soc_dsp_component_config),
+	SND_SOC_DSP_COMPONENT_IOCTL_REMOVE = _IOW('C', 0x01, int),
+	SND_SOC_DSP_COMPONENT_IOCTL_STATUS = _IOR('C', 0x02, int),
+	SND_SOC_DSP_COMPONENT_IOCTL_SW_PARAMS = _IOWR('C', 0x03, struct snd_soc_dsp_pcm_params),
+	SND_SOC_DSP_COMPONENT_IOCTL_START = _IO('C', 0x04),
+	SND_SOC_DSP_COMPONENT_IOCTL_STOP = _IO('C', 0x05),
+	SND_SOC_DSP_COMPONENT_IOCTL_WRITE = _IOW('C', 0x06, struct snd_rpaf_xferi),
+#ifdef CONFIG_COMPAT
+	SND_SOC_DSP_COMPONENT_IOCTL_WRITE32 = _IOW('C', 0x06, struct snd_rpaf_xferi32),
+#endif
+	SND_SOC_DSP_COMPONENT_IOCTL_READ = _IOR('C', 0x07, struct snd_rpaf_xferi),
+#ifdef CONFIG_COMPAT
+	SND_SOC_DSP_COMPONENT_IOCTL_READ32 = _IOR('C', 0x07, struct snd_rpaf_xferi32),
+#endif
+	SND_SOC_DSP_COMPONENT_IOCTL_ALGO_SET = _IOW('C', 0x08, struct snd_soc_dsp_component_config),
+	SND_SOC_DSP_COMPONENT_IOCTL_ALGO_GET = _IOWR('C', 0x09, struct snd_soc_dsp_component_config),
+	SND_SOC_DSP_COMPONENT_IOCTL_UNLINK = _IO('C', 0x0A),
+};
+
+struct snd_soc_rpaf_info {
+	char name[SUNXI_RPAF_INFO_NAME_LEN];
+	struct device *dev;
+	uint32_t dsp_id;
+	struct miscdevice misc_dev;
+	void *driver_data;
+	struct list_head list;
+};
+
+struct snd_soc_rpaf_pcm_runtime {
+	uint32_t dump_start;
+	uint32_t dump_type;
+	snd_pcm_uframes_t pos;
+	snd_pcm_uframes_t hw_ptr;
+	snd_pcm_uframes_t appl_ptr;
+
+	/* -- Status -- */
+	snd_pcm_uframes_t avail_max;
+	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
+	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
+	u64 hw_ptr_wrap;		/* offset for hw_ptr due to boundary wrap-around */
+
+	/* -- HW params -- */
+	unsigned int frame_bits;
+	snd_pcm_uframes_t period_size;	/* period size */
+	snd_pcm_uframes_t buffer_size;	/* buffer size */
+
+	/* -- SW params -- */
+	snd_pcm_uframes_t silence_size;	/* Silence filling size */
+	snd_pcm_uframes_t boundary;	/* pointers wrap point */
+
+	snd_pcm_uframes_t silence_start; /* starting pointer to silence area */
+	snd_pcm_uframes_t silence_filled; /* size filled with silence */
+
+	/* -- locking / scheduling -- */
+	snd_pcm_uframes_t twake;	/* do transfer (!poll) wakeup if non-zero */
+	wait_queue_head_t tsleep;	/* transfer sleep */
+
+	unsigned int xrun_cnt;
+};
+
+struct snd_dsp_component {
+	struct snd_soc_rpaf_info *rpaf_info;
+	struct mutex comp_rw_lock;
+	spinlock_t lock;
+	uint32_t state;
+	struct msg_component_package msg_component;
+	void *write_area;
+	void *dump_area[RPAF_COMPONENT_MAX_NUM];
+	void *read_area;
+	struct snd_soc_rpaf_pcm_runtime runtime;
+	void *private_data;
+};
+
+struct snd_soc_rpaf_misc {
+	int32_t number;
+	struct module *module;
+
+	void *private_data;
+
+	bool registered;
+#ifdef CONFIG_PM
+	uint32_t power_state;
+	struct mutex power_lock;
+	wait_queue_head_t power_sleep;
+#endif
+};
+
+static inline void *snd_soc_rpaf_info_get_drvdata(const struct snd_soc_rpaf_info *rpaf_info)
+{
+	return rpaf_info->driver_data;
+}
+
+static inline void snd_soc_rpaf_info_set_drvdata(struct snd_soc_rpaf_info *rpaf_info,
+					      void *data)
+{
+	rpaf_info->driver_data = data;
+}
+
+typedef int32_t (*transfer_f)(struct snd_dsp_component *dsp_component,
+			unsigned int hwoff,
+			unsigned long data, unsigned int off,
+			snd_pcm_uframes_t frames);
+
+static inline snd_pcm_sframes_t snd_soc_rpaf_pcm_bytes_to_frames(
+	struct snd_soc_rpaf_pcm_runtime *runtime, ssize_t size)
+{
+	return size * 8 / runtime->frame_bits;
+}
+
+static inline ssize_t snd_soc_rpaf_pcm_frames_to_bytes(
+	struct snd_soc_rpaf_pcm_runtime *runtime, snd_pcm_sframes_t size)
+{
+	return size * runtime->frame_bits / 8;
+}
+
+static inline snd_pcm_uframes_t snd_soc_rpaf_pcm_pointer(
+	struct snd_soc_rpaf_pcm_runtime *runtime)
+{
+	return snd_soc_rpaf_pcm_bytes_to_frames(runtime, runtime->pos);
+}
+
+static inline snd_pcm_uframes_t snd_soc_rpaf_pcm_capture_avail(
+	struct snd_soc_rpaf_pcm_runtime *runtime)
+{
+	snd_pcm_sframes_t avail = runtime->hw_ptr - runtime->appl_ptr;
+
+	if (avail < 0)
+		avail += runtime->boundary;
+	return avail;
+}
+
+void snd_soc_dsp_component_list_add_tail(struct snd_soc_dsp_component *component);
+
+void snd_soc_dsp_component_list_del(struct snd_soc_dsp_component *component);
+
+struct snd_soc_dsp_component *snd_soc_dsp_component_get_from_list_by_pcmdev(
+			int32_t card, int32_t device, int32_t stream);
+
+/* for snd_soc_rpaf_info list operation api */
+void snd_soc_rpaf_info_list_add_tail(struct snd_soc_rpaf_info *rpaf_info);
+void snd_soc_rpaf_info_list_del(struct snd_soc_rpaf_info *rpaf_info);
+
+struct snd_soc_rpaf_info *snd_soc_rpaf_info_get_from_list_by_minor(int32_t minor);
+struct snd_soc_rpaf_info *snd_soc_rpaf_info_get_from_list_by_dspid(uint32_t id);
+struct snd_soc_rpaf_info *snd_soc_rpaf_info_get_from_list_by_miscdevice(
+				struct miscdevice *device);
+
+void snd_soc_rpaf_pcm_stream_component_lock(void);
+void snd_soc_rpaf_pcm_stream_component_unlock(void);
+
+void snd_soc_rpaf_pcm_stream_lock_irq(struct snd_dsp_component *dsp_component);
+void snd_soc_rpaf_pcm_stream_unlock_irq(struct snd_dsp_component *dsp_component);
+unsigned long snd_soc_rpaf_pcm_stream_lock_irqsave(struct snd_dsp_component *dsp_component);
+void snd_soc_rpaf_pcm_stream_unlock_irqrestore(struct snd_dsp_component *dsp_component,
+				      unsigned long flags);
+void snd_soc_rpaf_pcm_stream_update_complete(void *arg);
+#endif
diff --git a/include/sound/aw_rpaf/component-driver.h b/include/sound/aw_rpaf/component-driver.h
new file mode 100644
index 000000000..15e8486c8
--- /dev/null
+++ b/include/sound/aw_rpaf/component-driver.h
@@ -0,0 +1,35 @@
+/*
+ * sound\aw_rpaf\component-driver.h -- Remote Process Audio Framework Layer
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _SUNXI_RPAF_COMPONENT_DRIVER_H
+#define _SUNXI_RPAF_COMPONENT_DRIVER_H
+
+#include <uapi/sound/asound.h>
+
+#define SUNXI_RPAF_DEVICE_NAME_LEN 32
+
+struct snd_soc_rpaf_misc_priv {
+	char name[SUNXI_RPAF_DEVICE_NAME_LEN];
+	struct device *dev;
+	uint32_t dsp_id;
+	/* for status info */
+	struct attribute_group attr_group;
+};
+
+extern int32_t  snd_soc_rpaf_misc_register_device(struct device *dev, int32_t  dsp_id);
+extern int32_t  snd_soc_rpaf_misc_deregister_device(struct device *dev, int32_t  dsp_id);
+
+#endif
diff --git a/include/sound/aw_rpaf/component.h b/include/sound/aw_rpaf/component.h
new file mode 100644
index 000000000..26e23a6d1
--- /dev/null
+++ b/include/sound/aw_rpaf/component.h
@@ -0,0 +1,175 @@
+/*
+ * linux/sound/aw_rpaf/component.h -- Remote Process Audio Framework Layer
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _AW_RPAF_COMPONENT_H_
+#define _AW_RPAF_COMPONENT_H_
+
+#include <sound/aw_rpaf/common.h>
+
+/* 代表的是该音频流有多少个组件（最多支持32个for 32bit machine）在用 */
+#define RPAF_COMPONENT_MAX_NUM (sizeof(uint32_t) << 3)
+
+/*
+ * dsp 音频组件部分
+ */
+enum SND_DSP_COMPONENT_TYPE {
+	/* 前处理 */
+	SND_DSP_COMPONENT_AGC = 0, /* 自动增益控制 */
+	SND_DSP_COMPONENT_AEC = 1, /* 回声消除 */
+	SND_DSP_COMPONENT_NS,  /* 噪声抑制 */
+
+	/* 后处理 */
+	SND_DSP_COMPONENT_DECODEC, /* 解码，暂保留 */
+	SND_DSP_COMPONENT_EQ,	   /* 均衡器 */
+	SND_DSP_COMPONENT_MIXER,   /* 左右声道混音 */
+	SND_DSP_COMPONENT_DRC,	   /* 动态范围控制 */
+	SND_DSP_COMPONENT_REVERB,  /* 混响 */
+
+	/* 通用组件 */
+	SND_DSP_COMPONENT_RESAMPLE,	/* 重采样，暂保留 */
+	SND_DSP_COMPONENT_OTHER,
+
+	SND_DSP_COMPONENT_USER = 20,
+
+	SND_DSP_COMPONENT_MAX = 31,
+};
+
+enum snd_dsp_comp_mode {
+	SND_DSP_COMPONENT_MODE_INDEPENDENCE = 0,
+	SND_DSP_COMPONENT_MODE_STREAM,
+	SND_DSP_COMPONENT_MODE_ALGO,
+};
+
+#define LABEL_SND_DSP_COMPONENT_NAME(constant) {#constant, constant}
+
+struct label_snd_dsp_component_name {
+	char *name;
+	uint32_t value;
+};
+
+/* init at dsp after get component. */
+struct snd_soc_dsp_component {
+	uint32_t cmd_val;
+	uint32_t params_val;
+	uint32_t used;
+
+	struct snd_soc_dsp_pcm_params params;
+
+	/* 唯一身份识别号 */
+	uint32_t id;
+
+	/* share data address */
+	uint32_t write_addr;
+	/* buf_length < buf_size */
+	uint32_t write_length;
+	uint32_t write_size;
+
+	uint32_t dump_addr[RPAF_COMPONENT_MAX_NUM];
+	uint32_t dump_length[RPAF_COMPONENT_MAX_NUM];
+	uint32_t dump_size;
+
+	uint32_t read_addr;
+	/* buf_length < buf_size */
+	uint32_t read_length;
+	uint32_t read_size;
+
+	uint32_t transfer_type;
+
+	/* 代表的伴随音频流的组件还是独立操作用的组件 */
+	uint32_t comp_mode;
+	/* 代表的是该音频流有多少个组件（最多支持32个for 32bit machine）在用 */
+	uint32_t component_type; /* 0x1 << SND_DSP_AUDIO_COMPONENT_AGC/... */
+	uint32_t sort_index;
+	/* 当前流的各个组件状态值 */
+	int32_t status[RPAF_COMPONENT_MAX_NUM];
+	int32_t component_sort[RPAF_COMPONENT_MAX_NUM];
+
+	/*API调用完毕之后需要判断该值 */
+	int32_t ret_val;
+
+	/* dsp cannot used */
+	struct list_head list;
+};
+
+struct snd_soc_dsp_component_config {
+	uint32_t comp_mode;
+	/* 表示对于绑定alsa straem组件中dsp dump某个组件处理后数据 */
+	uint32_t transfer_type;
+	uint32_t component_used;
+	/* 代表的是该音频流有多少个组件（最多支持32个for 32bit machine）在用 */
+	uint32_t component_type; /* 0x1 << SND_DSP_AUDIO_COMPONENT_AGC/... */
+	uint32_t sort_index;
+	int32_t component_sort[RPAF_COMPONENT_MAX_NUM];
+	struct snd_soc_dsp_pcm_params pcm_params;
+};
+
+struct snd_soc_dsp_native_component {
+	struct snd_soc_dsp_component soc_component;
+
+	unsigned char soc_suspended;
+	unsigned char soc_resumed;
+
+	/* wakeup */
+	uint32_t keyword_wakeup;
+
+	/* dump flag */
+	uint32_t dump_start[RPAF_COMPONENT_MAX_NUM];
+
+	/* 给 algorithmic 分配使用 */
+	void *handle[RPAF_COMPONENT_MAX_NUM];
+	void *private_data[RPAF_COMPONENT_MAX_NUM];
+
+	struct list_head list;
+};
+
+/*
+ * For DSP Audio Framework API
+ * 均要考虑资源要访问互斥，尤其针对队列操作函数
+ */
+struct snd_dsp_hal_component_ops {
+	/* 实现初始化，包括配置初始化substream的组件 */
+	//int32_t (*create)(struct snd_dsp_hal_component *component);
+	int32_t (*create)(void *component);
+	/* 去初始化，释放相应资源 */
+	int32_t (*remove)(void *component);
+	/* 告知Linux音频组件挂起或者已经恢复 */
+	int32_t (*suspend)(void *component);
+	int32_t (*resume)(void *component);
+
+	int32_t (*status)(void *component);
+	int32_t (*sw_params)(void *component);
+
+	/*
+	 * 用于某个流的组件的启用和关闭，需配合substream使用，
+	 * dump数据可调用，内部需要引用计数
+	 */
+	int32_t (*start)(void *component);
+	int32_t (*stop)(void *component);
+	/* 主要用于播放经过编码的数据，保留 */
+	int32_t (*write)(void *component);
+	/* 主要用于dump 每个组件之后经过处理的数据 */
+	int32_t (*read)(void *component);
+};
+
+struct msg_component_package {
+	wait_queue_head_t tsleep;
+	spinlock_t lock;
+	int32_t wakeup_flag;
+	struct snd_soc_dsp_component soc_component;
+	struct list_head list;
+};
+
+#endif
diff --git a/include/sound/aw_rpaf/debug.h b/include/sound/aw_rpaf/debug.h
new file mode 100644
index 000000000..01b2a2fcf
--- /dev/null
+++ b/include/sound/aw_rpaf/debug.h
@@ -0,0 +1,52 @@
+/*
+ * linux/sound/aw_rpaf/debug.h -- Remote Process Audio Framework Layer
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _AW_RPAF_DEBUG_H
+#define _AW_RPAF_DEBUG_H
+
+#include <sound/aw_rpaf/common.h>
+
+/*
+ * param[0] = MSGBOX_SOC_DSP_AUDIO_COMMAND->MSGBOX_SOC_DSP_DEBUG_COMMAND
+ * param[1] = *snd_soc_dsp_substream
+ * param[2] = SND_SOC_DSP_DEBUG_COMMAND
+ * param[3] = *params
+ */
+struct snd_soc_dsp_debug {
+	uint32_t cmd_val;
+	uint32_t params_val;
+
+	struct snd_soc_dsp_pcm_params pcm_params;
+	/* 共享内存地址，根据首末地址差分配空间大小 */
+	uint32_t *buf;
+	/* 起始地址和结束地址 */
+	uint32_t addr_start;
+	uint32_t addr_end;
+	/* 读还是写数值 */
+	uint32_t mode;
+
+	/*API调用完毕之后需要判断该值 */
+	int32_t  ret_val;
+};
+
+struct msg_debug_package {
+	wait_queue_head_t tsleep;
+	spinlock_t lock;
+	int32_t wakeup_flag;
+	struct snd_soc_dsp_debug soc_debug;
+};
+
+#endif
diff --git a/include/sound/aw_rpaf/mixer.h b/include/sound/aw_rpaf/mixer.h
new file mode 100644
index 000000000..01e16f187
--- /dev/null
+++ b/include/sound/aw_rpaf/mixer.h
@@ -0,0 +1,70 @@
+/*
+ * linux/sound/aw_rpaf/mixer.h -- Remote Process Audio Framework Layer
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _AW_RPAF_MIXER_H_
+#define _AW_RPAF_MIXER_H_
+
+#include <sound/aw_rpaf/common.h>
+
+/*
+ * param[0] = MSGBOX_SOC_DSP_AUDIO_COMMAND->MSGBOX_SOC_DSP_AUDIO_MIXER_COMMAND
+ * param[1] = *snd_soc_dsp_mixer
+ * param[2] = SND_SOC_DSP_*_COMMAND
+ * param[3] = *params/NULL
+ */
+struct snd_soc_dsp_mixer {
+	uint32_t id;
+	unsigned char used;
+
+	uint32_t cmd_val;
+	uint32_t params_val;
+
+	/* eg:0 sndcodec; 1 snddmic; 2 snddaudio0; 3 snddaudio1 */
+	int32_t card;
+	int32_t device;
+	/*
+	 * 根据名字匹配:
+	 * 0: maudiocodec; 1: msnddmic; 2: msnddaudio0; 3: msnddaudio1;
+	 */
+	char driver[32];
+
+	/* ctl name length */
+	char ctl_name[44];
+	uint32_t value;
+
+	/*API调用完毕之后需要判断该值 */
+	int32_t ret_val;
+
+	struct list_head list;
+};
+
+struct snd_dsp_hal_mixer_ops {
+	//int32_t (*open)(struct snd_dsp_hal_mixer *mixer);
+	int32_t (*open)(void *mixer);
+	int32_t (*close)(void *mixer);
+	int32_t (*read)(void *mixer);
+	int32_t (*write)(void *mixer);
+};
+
+struct msg_mixer_package {
+	wait_queue_head_t tsleep;
+	spinlock_t lock;
+	int32_t wakeup_flag;
+	struct snd_soc_dsp_mixer soc_mixer;
+};
+
+#endif
+
diff --git a/include/sound/aw_rpaf/rpmsg_hifi.h b/include/sound/aw_rpaf/rpmsg_hifi.h
new file mode 100644
index 000000000..baaa18561
--- /dev/null
+++ b/include/sound/aw_rpaf/rpmsg_hifi.h
@@ -0,0 +1,90 @@
+/*
+ * linux/sound/aw_rpaf/rpmsg_hifi.h -- Remote Process Audio Framework Layer
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _RPMSG_HIFI_H
+#define _RPMSG_HIFI_H
+
+#include <sound/aw_rpaf/common.h>
+#include <sound/aw_rpaf/mixer.h>
+#include <sound/aw_rpaf/component-core.h>
+
+#if IS_ENABLED(CONFIG_ARM64)
+extern void rpaf_dma_flush_range(const void *, size_t);
+#endif
+
+static inline void sunxi_rpaf_dma_flush_range(const void *addr, size_t len)
+{
+#if IS_ENABLED(CONFIG_ARM64)
+	rpaf_dma_flush_range(addr, len);
+#else
+#if IS_ENABLED(CONFIG_64BIT) && IS_ENABLED(CONFIG_RISCV)
+	dma_usr_va_wb_range((void *)addr, (unsigned long)len);
+#else
+	dmac_flush_range((const void *)addr, (const void *)(addr + len));
+#endif
+#endif
+}
+
+
+enum SUNXI_HIFI_ID {
+	SUNXI_HIFI0 = 0,
+	SUNXI_HIFI1 = 1,
+};
+
+struct rpmsg_hifi_priv {
+	struct rpmsg_device *rpmsg_dev;
+	struct msg_audio_package msg_pack;
+	struct workqueue_struct *wq;
+	char wq_name[32];
+	struct work_struct rpmsg_recv_work;
+	int32_t rx_count;
+};
+
+int32_t sunxi_hifi_register_sound_drv_info(const char *name, void *data);
+int32_t sunxi_hifi_unregister_sound_drv_info(const char *name, void *data);
+
+struct msg_component_package *sunxi_hifi_list_msg_component_find_item(
+	struct msg_component_package *msg_component);
+int sunxi_hifi_list_msg_component_add_tail(struct msg_component_package *msg_component);
+int sunxi_hifi_list_msg_component_remove_item(struct msg_component_package *msg_component);
+
+int32_t sunxi_hifi_nonblock_send(uint32_t hifi_id,
+				struct msg_audio_package *msg_package);
+
+int32_t sunxi_hifi_component_block_send(uint32_t hifi_id,
+				struct msg_component_package *msg_component);
+int32_t sunxi_hifi_component_nonblock_send(uint32_t hifi_id,
+				struct msg_component_package *msg_component);
+
+int32_t sunxi_hifi_substream_set_stream_component(uint32_t hifi_id,
+		struct snd_soc_dai *dai,
+		struct snd_soc_dsp_substream *soc_substream,
+		struct snd_dsp_component *dsp_component);
+int32_t snd_soc_rpaf_pcm_update_stream_process(struct snd_dsp_component *stream_dsp_component);
+int32_t sunxi_hifi_substream_release_stream_component(struct snd_soc_dai *dai,
+		struct snd_dsp_component *dsp_component);
+
+int32_t sunxi_hifi_cpudai_substream_block_send(uint32_t hifi_id,
+		struct snd_pcm_substream *substream, struct snd_soc_dai *dai,
+		int32_t stream, unsigned long msg_cmd);
+
+int32_t sunxi_hifi_daudio_substream_block_send(uint32_t hifi_id,
+		struct snd_pcm_substream *substream, struct snd_soc_dai *dai,
+		int32_t stream, unsigned long msg_cmd);
+
+int32_t sunxi_hifi_dmic_substream_block_send(uint32_t hifi_id,
+		struct snd_pcm_substream *substream, struct snd_soc_dai *dai,
+		int32_t stream, unsigned long msg_cmd);
+#endif
diff --git a/include/sound/aw_rpaf/substream.h b/include/sound/aw_rpaf/substream.h
new file mode 100644
index 000000000..9dadd41be
--- /dev/null
+++ b/include/sound/aw_rpaf/substream.h
@@ -0,0 +1,124 @@
+/*
+ * linux/sound/aw_rpaf/substream.h -- Remote Process Audio Framework Layer
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _AW_RPAF_SUBSTREAM_H_
+#define _AW_RPAF_SUBSTREAM_H_
+
+#include <sound/pcm.h>
+#include <sound/aw_rpaf/common.h>
+#include <sound/aw_rpaf/component.h>
+
+struct sram_buffer {
+	void *buf_addr;
+	unsigned char used;
+	struct list_head list;
+};
+
+/*
+ * param[0] = MSGBOX_SOC_DSP_AUDIO_COMMAND->MSGBOX_SOC_DSP_*_COMMAND
+ * param[1] = *snd_soc_dsp_substream
+ * param[2] = SND_SOC_DSP_*_COMMAND
+ * param[3] = *params/NULL
+ */
+struct snd_soc_dsp_substream {
+	uint32_t id;
+	unsigned char used;
+
+	uint32_t cmd_val;
+	uint32_t params_val;
+	uint32_t audio_standby;
+
+	struct snd_soc_dsp_pcm_params params;
+
+	/* share data address */
+	uint32_t input_addr;
+	uint32_t output_addr;
+	/* data_length < buf_size */
+	uint32_t input_size;
+	uint32_t output_size;
+
+	/*API调用完毕之后需要判断该值 */
+	int32_t ret_val;
+
+	struct list_head list;
+};
+
+//共享内存分配：
+//（1）用于音频对象的存储
+//（2）用于音频共享数据
+
+//策略：
+//每次都会传输共用一个对象区域，附带共享音频buffer
+struct snd_soc_dsp_queue_item {
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_component *soc_comp;
+	struct snd_soc_dsp_mixer *soc_mixer;
+	struct snd_soc_dsp_debug *soc_debug;
+
+	uint32_t msg_val;
+	uint32_t cmd_val;
+	uint32_t param_val;
+};
+
+/*
+ * For DSP Audio Framework API
+ */
+struct snd_dsp_hal_substream_ops {
+	/*
+	 * ALSA PCM audio operations - all optional.
+	 * Called by soc-core during audio PCM operations.
+	 */
+	/* 对接声卡的开关操作 */
+	//int32_t (*startup)(struct snd_dsp_hal_substream *substream);
+	int32_t (*startup)(void *substream);
+	void (*shutdown)(void *substream);
+
+	int32_t (*prepare)(void *substream);
+	int32_t (*start)(void *substream);
+	int32_t (*stop)(void *substream);
+
+	/* 将音频PCM格式传入进行设置 */
+	int32_t (*hw_params)(void *substream);
+
+	/* 用于数据的读操作, 数据最后才给到substream->soc_substream->buf_addr */
+	snd_pcm_sframes_t (*readi)(void *substream);
+	/* 用于数据的写操作, 数据最后才给到substream->soc_substream->buf_addr */
+	snd_pcm_sframes_t (*writei)(void *substream);
+
+	uint32_t (*status_params)(void *substream,
+				//enum SND_SOC_DSP_PARAMS_COMMAND
+				enum SND_SOC_DSP_PCM_COMMAND cmd,
+				void *params);
+};
+
+struct snd_dsp_hal_substream_driver {
+	//int32_t (*probe)(struct snd_dsp_hal_substream *substream);
+	int32_t (*probe)(void *substream);
+	int32_t (*remove)(void *substream);
+	int32_t (*suspend)(void *substream);
+	int32_t (*resume)(void *substream);
+};
+
+struct msg_substream_package {
+	wait_queue_head_t tsleep;
+	spinlock_t lock;
+	int32_t wakeup_flag;
+	struct snd_soc_dsp_substream soc_substream;
+	struct snd_pcm_substream *substream;
+};
+
+#endif
+
diff --git a/include/sound/compress_driver.h b/include/sound/compress_driver.h
index 006f01922..bc88d6f96 100644
--- a/include/sound/compress_driver.h
+++ b/include/sound/compress_driver.h
@@ -59,7 +59,6 @@ struct snd_compr_runtime {
  * @direction: stream direction, playback/recording
  * @metadata_set: metadata set flag, true when set
  * @next_track: has userspace signal next track transition, true when set
- * @partial_drain: undergoing partial_drain for stream, true when set
  * @private_data: pointer to DSP private data
  */
 struct snd_compr_stream {
@@ -71,7 +70,6 @@ struct snd_compr_stream {
 	enum snd_compr_direction direction;
 	bool metadata_set;
 	bool next_track;
-	bool partial_drain;
 	void *private_data;
 };
 
@@ -175,13 +173,7 @@ static inline void snd_compr_drain_notify(struct snd_compr_stream *stream)
 	if (snd_BUG_ON(!stream))
 		return;
 
-	/* for partial_drain case we are back to running state on success */
-	if (stream->partial_drain) {
-		stream->runtime->state = SNDRV_PCM_STATE_RUNNING;
-		stream->partial_drain = false; /* clear this flag as well */
-	} else {
-		stream->runtime->state = SNDRV_PCM_STATE_SETUP;
-	}
+	stream->runtime->state = SNDRV_PCM_STATE_SETUP;
 
 	wake_up(&stream->runtime->sleep);
 }
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index bbe6eb1ff..b8f638e07 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -475,6 +475,7 @@ struct snd_pcm_substream {
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 	/* misc flags */
 	unsigned int hw_opened: 1;
+	unsigned int hw_no_buffer: 1; /* substream may not have a buffer */
 };
 
 #define SUBSTREAM_BUSY(substream) ((substream)->ref_count > 0)
diff --git a/include/sound/simple_card_utils.h b/include/sound/simple_card_utils.h
index bbdd1542d..9359318a0 100644
--- a/include/sound/simple_card_utils.h
+++ b/include/sound/simple_card_utils.h
@@ -56,6 +56,8 @@ struct asoc_simple_priv {
 	struct asoc_simple_dai *dais;
 	struct snd_soc_codec_conf *codec_conf;
 	struct gpio_desc *pa_gpio;
+
+	unsigned int hdmi_format;
 };
 #define simple_priv_to_card(priv)	(&(priv)->snd_card)
 #define simple_priv_to_props(priv, i)	((priv)->dai_props + (i))
diff --git a/include/sound/soc.h b/include/sound/soc.h
index 6d2662c31..ba0d7a643 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -239,6 +239,14 @@
 	.get = xhandler_get, .put = xhandler_put, \
 	.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \
 					    xmax, xinvert) }
+#define SOC_SINGLE_MULTI_EXT(xname, xreg, xshift, xmax, xinvert, xcount,\
+	xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_multi_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct soc_multi_mixer_control) \
+		{.reg = xreg, .shift = xshift, .rshift = xshift, .max = xmax, \
+		.count = xcount, .platform_max = xmax, .invert = xinvert} }
 #define SOC_SINGLE_EXT_TLV(xname, xreg, xshift, xmax, xinvert,\
 	 xhandler_get, xhandler_put, tlv_array) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
@@ -362,6 +370,10 @@
 #define SOC_ENUM_SINGLE_VIRT_DECL(name, xtexts) \
 	const struct soc_enum name = SOC_ENUM_SINGLE_VIRT(ARRAY_SIZE(xtexts), xtexts)
 
+/* DAI Link Host Mode Support */
+#define SND_SOC_DAI_LINK_NO_HOST		0x1
+#define SND_SOC_DAI_LINK_OPT_HOST		0x2
+
 /*
  * Bias levels
  *
@@ -621,6 +633,8 @@ int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_multi_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
 
 /**
  * struct snd_soc_jack_pin - Describes a pin to update based on jack detection
@@ -713,6 +727,7 @@ struct snd_soc_pcm_stream {
 	unsigned int channels_min;	/* min channels */
 	unsigned int channels_max;	/* max channels */
 	unsigned int sig_bits;		/* number of bits of content */
+	const char *aif_name;		/* DAPM AIF widget name */
 };
 
 /* SoC audio ops */
@@ -827,6 +842,12 @@ struct snd_soc_dai_link {
 	/* This DAI link can route to other DAI links at runtime (Frontend)*/
 	unsigned int dynamic:1;
 
+	/*
+	 * This DAI can support no host IO (no pcm data is
+	 * copied to from host)
+	 */
+	unsigned int no_host_mode:2;
+
 	/* DPCM capture and Playback support */
 	unsigned int dpcm_capture:1;
 	unsigned int dpcm_playback:1;
@@ -1195,6 +1216,11 @@ struct soc_mreg_control {
 	unsigned int regbase, regcount, nbits, invert;
 };
 
+struct soc_multi_mixer_control {
+	int min, max, platform_max, count;
+	unsigned int reg, rreg, shift, rshift, invert;
+};
+
 /* enumerated kcontrol */
 struct soc_enum {
 	int reg;
diff --git a/include/video/drv_hdmi.h b/include/video/drv_hdmi.h
new file mode 100644
index 000000000..9d0455431
--- /dev/null
+++ b/include/video/drv_hdmi.h
@@ -0,0 +1,49 @@
+/*
+ * Allwinner SoCs hdmi driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __DRV_HDMI_H__
+#define __DRV_HDMI_H__
+
+typedef struct {
+	__u8    hw_intf;        /* 0:iis  1:spdif 2:pcm */
+	__u16	fs_between;     /* fs */
+	__u32   sample_rate;    /*sample rate*/
+	__u8    clk_edge;       /* 0:*/
+	__u8    ch0_en;         /* 1 */
+	__u8    ch1_en;         /* 0 */
+	__u8	ch2_en;         /* 0 */
+	__u8	ch3_en;         /* 0 */
+	__u8	word_length;    /* 32 */
+	__u8    shift_ctl;      /* 0 */
+	__u8    dir_ctl;        /* 0 */
+	__u8    ws_pol;
+	__u8    just_pol;
+	__u8    channel_num;
+	__u8	data_raw;
+	__u8    sample_bit;
+	__u8    ca;     /* channel allocation */
+} hdmi_audio_t;
+
+typedef struct {
+	__s32 (*hdmi_audio_enable)(__u8 mode, __u8 channel);
+	__s32 (*hdmi_set_audio_para)(hdmi_audio_t *audio_para);
+	__s32 (*hdmi_is_playback)(void);
+} __audio_hdmi_func;
+
+enum hdmi_hpd_status {
+	STATUE_CLOSE = 0,
+	STATUE_OPEN = 1,
+};
+
+void audio_set_hdmi_func(__audio_hdmi_func *hdmi_func);
+#if defined(CONFIG_SND_SUNXI_SOC_AUDIOHUB_INTERFACE)
+void audio_set_muti_hdmi_func(__audio_hdmi_func *hdmi_func);
+#endif
+#endif
diff --git a/include/video/sunxi_display2.h b/include/video/sunxi_display2.h
new file mode 100644
index 000000000..599348523
--- /dev/null
+++ b/include/video/sunxi_display2.h
@@ -0,0 +1,1012 @@
+/*
+ * Allwinner SoCs display driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __SUNXI_DISPLAY2_H__
+#define __SUNXI_DISPLAY2_H__
+
+struct disp_manager;
+struct disp_device;
+struct disp_smbl;
+struct disp_enhance;
+struct disp_capture;
+
+struct disp_color {
+	unsigned char alpha;
+	unsigned char red;
+	unsigned char green;
+	unsigned char blue;
+};
+
+struct disp_rect {
+	int x;
+	int y;
+	unsigned int width;
+	unsigned int height;
+};
+
+struct disp_rectsz {
+	unsigned int width;
+	unsigned int height;
+};
+
+struct disp_position {
+	int x;
+	int y;
+};
+
+enum disp_pixel_format {
+	DISP_FORMAT_ARGB_8888 = 0x00,	/* MSB  A-R-G-B  LSB */
+	DISP_FORMAT_ABGR_8888 = 0x01,
+	DISP_FORMAT_RGBA_8888 = 0x02,
+	DISP_FORMAT_BGRA_8888 = 0x03,
+	DISP_FORMAT_XRGB_8888 = 0x04,
+	DISP_FORMAT_XBGR_8888 = 0x05,
+	DISP_FORMAT_RGBX_8888 = 0x06,
+	DISP_FORMAT_BGRX_8888 = 0x07,
+	DISP_FORMAT_RGB_888 = 0x08,
+	DISP_FORMAT_BGR_888 = 0x09,
+	DISP_FORMAT_RGB_565 = 0x0a,
+	DISP_FORMAT_BGR_565 = 0x0b,
+	DISP_FORMAT_ARGB_4444 = 0x0c,
+	DISP_FORMAT_ABGR_4444 = 0x0d,
+	DISP_FORMAT_RGBA_4444 = 0x0e,
+	DISP_FORMAT_BGRA_4444 = 0x0f,
+	DISP_FORMAT_ARGB_1555 = 0x10,
+	DISP_FORMAT_ABGR_1555 = 0x11,
+	DISP_FORMAT_RGBA_5551 = 0x12,
+	DISP_FORMAT_BGRA_5551 = 0x13,
+	DISP_FORMAT_A2R10G10B10                  = 0x14,
+	DISP_FORMAT_A2B10G10R10                  = 0x15,
+	DISP_FORMAT_R10G10B10A2                  = 0x16,
+	DISP_FORMAT_B10G10R10A2                  = 0x17,
+	DISP_FORMAT_1bpp_palette_LE				 = 0x18,
+	DISP_FORMAT_2bpp_palette_LE				 = 0x19,
+	DISP_FORMAT_4bpp_palette_LE				 = 0x1a,
+	DISP_FORMAT_8bpp_palette_LE				 = 0x1b,
+	/*
+	 * SP: semi-planar
+	 * P:planar
+	 * I:interleaved
+	 * UVUV: U in the LSBs;
+	 * VUVU: V in the LSBs
+	 */
+	DISP_FORMAT_YUV444_I_AYUV = 0x40,	/* MSB  A-Y-U-V  LSB */
+	DISP_FORMAT_YUV444_I_VUYA = 0x41,	/* MSB  V-U-Y-A  LSB */
+	DISP_FORMAT_YUV422_I_YVYU = 0x42,	/* MSB  Y-V-Y-U  LSB */
+	DISP_FORMAT_YUV422_I_YUYV = 0x43,	/* MSB  Y-U-Y-V  LSB */
+	DISP_FORMAT_YUV422_I_UYVY = 0x44,	/* MSB  U-Y-V-Y  LSB */
+	DISP_FORMAT_YUV422_I_VYUY = 0x45,	/* MSB  V-Y-U-Y  LSB */
+	DISP_FORMAT_YUV444_P = 0x46,	/* MSB  P3-2-1-0 LSB,  YYYY UUUU VVVV */
+	DISP_FORMAT_YUV422_P = 0x47,	/* MSB  P3-2-1-0 LSB   YYYY UU   VV */
+	DISP_FORMAT_YUV420_P = 0x48,	/* MSB  P3-2-1-0 LSB   YYYY U    V */
+	DISP_FORMAT_YUV411_P = 0x49,	/* MSB  P3-2-1-0 LSB   YYYY U    V */
+	DISP_FORMAT_YUV422_SP_UVUV = 0x4a,	/* MSB  V-U-V-U  LSB */
+	DISP_FORMAT_YUV422_SP_VUVU = 0x4b,	/* MSB  U-V-U-V  LSB */
+	DISP_FORMAT_YUV420_SP_UVUV = 0x4c,
+	DISP_FORMAT_YUV420_SP_VUVU = 0x4d,
+	DISP_FORMAT_YUV411_SP_UVUV = 0x4e,
+	DISP_FORMAT_YUV411_SP_VUVU = 0x4f,
+	DISP_FORMAT_8BIT_GRAY = 0x50,
+	DISP_FORMAT_YUV444_I_AYUV_10BIT          = 0x51,
+	DISP_FORMAT_YUV444_I_VUYA_10BIT          = 0x52,
+	DISP_FORMAT_YUV422_I_YVYU_10BIT          = 0x53,
+	DISP_FORMAT_YUV422_I_YUYV_10BIT          = 0x54,
+	DISP_FORMAT_YUV422_I_UYVY_10BIT          = 0x55,
+	DISP_FORMAT_YUV422_I_VYUY_10BIT          = 0x56,
+	DISP_FORMAT_YUV444_P_10BIT               = 0x57,
+	DISP_FORMAT_YUV422_P_10BIT               = 0x58,
+	DISP_FORMAT_YUV420_P_10BIT               = 0x59,
+	DISP_FORMAT_YUV411_P_10BIT               = 0x5a,
+	DISP_FORMAT_YUV422_SP_UVUV_10BIT         = 0x5b,
+	DISP_FORMAT_YUV422_SP_VUVU_10BIT         = 0x5c,
+	DISP_FORMAT_YUV420_SP_UVUV_10BIT         = 0x5d,
+	DISP_FORMAT_YUV420_SP_VUVU_10BIT         = 0x5e,
+	DISP_FORMAT_YUV411_SP_UVUV_10BIT         = 0x5f,
+	DISP_FORMAT_YUV411_SP_VUVU_10BIT         = 0x60,
+	DISP_FORMAT_MAX,
+};
+
+enum disp_3d_out_mode {
+	DISP_3D_OUT_MODE_CI_1 = 0x5,	/* column interlaved 1 */
+	DISP_3D_OUT_MODE_CI_2 = 0x6,	/* column interlaved 2 */
+	DISP_3D_OUT_MODE_CI_3 = 0x7,	/* column interlaved 3 */
+	DISP_3D_OUT_MODE_CI_4 = 0x8,	/* column interlaved 4 */
+	DISP_3D_OUT_MODE_LIRGB = 0x9,	/* line interleaved rgb */
+
+	DISP_3D_OUT_MODE_TB = 0x0,	/* top bottom */
+	DISP_3D_OUT_MODE_FP = 0x1,	/* frame packing */
+	DISP_3D_OUT_MODE_SSF = 0x2,	/* side by side full */
+	DISP_3D_OUT_MODE_SSH = 0x3,	/* side by side half */
+	DISP_3D_OUT_MODE_LI = 0x4,	/* line interleaved */
+	DISP_3D_OUT_MODE_FA = 0xa,	/* field alternative */
+};
+
+enum disp_color_space {
+	DISP_UNDEF = 0x00,
+	DISP_UNDEF_F = 0x01,
+	DISP_GBR = 0x100,
+	DISP_BT709 = 0x101,
+	DISP_FCC = 0x102,
+	DISP_BT470BG = 0x103,
+	DISP_BT601 = 0x104,
+	DISP_SMPTE240M = 0x105,
+	DISP_YCGCO = 0x106,
+	DISP_BT2020NC = 0x107,
+	DISP_BT2020C = 0x108,
+	DISP_GBR_F = 0x200,
+	DISP_BT709_F = 0x201,
+	DISP_FCC_F = 0x202,
+	DISP_BT470BG_F = 0x203,
+	DISP_BT601_F = 0x204,
+	DISP_SMPTE240M_F = 0x205,
+	DISP_YCGCO_F = 0x206,
+	DISP_BT2020NC_F = 0x207,
+	DISP_BT2020C_F = 0x208,
+	DISP_RESERVED = 0x300,
+	DISP_RESERVED_F = 0x301,
+};
+
+enum disp_csc_type {
+	DISP_CSC_TYPE_RGB        = 0,
+	DISP_CSC_TYPE_YUV444     = 1,
+	DISP_CSC_TYPE_YUV422     = 2,
+	DISP_CSC_TYPE_YUV420     = 3,
+};
+
+enum disp_data_bits {
+	DISP_DATA_8BITS    = 0,
+	DISP_DATA_10BITS   = 1,
+	DISP_DATA_12BITS   = 2,
+	DISP_DATA_16BITS   = 3,
+};
+enum disp_dvi_hdmi {
+	DISP_DVI_HDMI_UNDEFINED = 0,
+	DISP_DVI = 1,
+	DISP_HDMI = 2,
+};
+enum disp_scan_info {
+	DISP_SCANINFO_NO_DATA = 0,
+	OVERSCAN = 1,
+	UNDERSCAN = 2,
+};
+enum disp_color_range {
+	DISP_COLOR_RANGE_DEFAULT = 0, /*default*/
+	DISP_COLOR_RANGE_0_255 = 1,
+	DISP_COLOR_RANGE_16_235 = 2,
+};
+
+enum disp_output_type {
+	DISP_OUTPUT_TYPE_NONE = 0,
+	DISP_OUTPUT_TYPE_LCD = 1,
+	DISP_OUTPUT_TYPE_TV = 2,
+	DISP_OUTPUT_TYPE_HDMI = 4,
+	DISP_OUTPUT_TYPE_VGA = 8,
+	DISP_OUTPUT_TYPE_VDPO = 16,
+	DISP_OUTPUT_TYPE_EDP    = 32, /*16 for vdpo*/
+	DISP_OUTPUT_TYPE_RTWB    = 64,
+};
+
+enum disp_tv_mode {
+	DISP_TV_MOD_480I = 0,
+	DISP_TV_MOD_576I = 1,
+	DISP_TV_MOD_480P = 2,
+	DISP_TV_MOD_576P = 3,
+	DISP_TV_MOD_720P_50HZ = 4,
+	DISP_TV_MOD_720P_60HZ = 5,
+	DISP_TV_MOD_1080I_50HZ = 6,
+	DISP_TV_MOD_1080I_60HZ = 7,
+	DISP_TV_MOD_1080P_24HZ = 8,
+	DISP_TV_MOD_1080P_50HZ = 9,
+	DISP_TV_MOD_1080P_60HZ = 0xa,
+	DISP_TV_MOD_1080P_24HZ_3D_FP = 0x17,
+	DISP_TV_MOD_720P_50HZ_3D_FP = 0x18,
+	DISP_TV_MOD_720P_60HZ_3D_FP = 0x19,
+	DISP_TV_MOD_1080P_25HZ = 0x1a,
+	DISP_TV_MOD_1080P_30HZ = 0x1b,
+	DISP_TV_MOD_PAL = 0xb,
+	DISP_TV_MOD_PAL_SVIDEO = 0xc,
+	DISP_TV_MOD_NTSC = 0xe,
+	DISP_TV_MOD_NTSC_SVIDEO = 0xf,
+	DISP_TV_MOD_PAL_M = 0x11,
+	DISP_TV_MOD_PAL_M_SVIDEO = 0x12,
+	DISP_TV_MOD_PAL_NC = 0x14,
+	DISP_TV_MOD_PAL_NC_SVIDEO = 0x15,
+	DISP_TV_MOD_3840_2160P_30HZ = 0x1c,
+	DISP_TV_MOD_3840_2160P_25HZ = 0x1d,
+	DISP_TV_MOD_3840_2160P_24HZ = 0x1e,
+	DISP_TV_MOD_4096_2160P_24HZ     = 0x1f,
+	DISP_TV_MOD_4096_2160P_25HZ     = 0x20,
+	DISP_TV_MOD_4096_2160P_30HZ     = 0x21,
+	DISP_TV_MOD_3840_2160P_60HZ     = 0x22,
+	DISP_TV_MOD_4096_2160P_60HZ     = 0x23,
+	DISP_TV_MOD_3840_2160P_50HZ     = 0x24,
+	DISP_TV_MOD_4096_2160P_50HZ     = 0x25,
+	DISP_TV_MOD_2560_1440P_60HZ     = 0x26,
+	DISP_TV_MOD_1440_2560P_70HZ     = 0x27,
+	DISP_TV_MOD_1080_1920P_60HZ	= 0x28,
+	DISP_TV_MOD_1280_1024P_60HZ     = 0x41,
+	DISP_TV_MOD_1024_768P_60HZ      = 0x42,
+	DISP_TV_MOD_900_540P_60HZ       = 0x43,
+	DISP_TV_MOD_1920_720P_60HZ      = 0x44,
+	/* vga */
+	DISP_VGA_MOD_640_480P_60 = 0x50,
+	DISP_VGA_MOD_800_600P_60 = 0x51,
+	DISP_VGA_MOD_1024_768P_60 = 0x52,
+	DISP_VGA_MOD_1280_768P_60 = 0x53,
+	DISP_VGA_MOD_1280_800P_60 = 0x54,
+	DISP_VGA_MOD_1366_768P_60 = 0x55,
+	DISP_VGA_MOD_1440_900P_60 = 0x56,
+	DISP_VGA_MOD_1920_1080P_60 = 0x57,
+	DISP_VGA_MOD_1920_1200P_60 = 0x58,
+	DISP_TV_MOD_3840_1080P_30 = 0x59,
+	DISP_VGA_MOD_1280_720P_60        = 0x5a,
+	DISP_VGA_MOD_1600_900P_60        = 0x5b,
+	DISP_VGA_MOD_MAX_NUM             = 0x5c,
+	DISP_TV_MODE_NUM,
+};
+
+enum disp_exit_mode {
+	DISP_EXIT_MODE_CLEAN_ALL = 0,
+	DISP_EXIT_MODE_CLEAN_PARTLY = 1, /* only clean interrupt temply */
+};
+
+enum disp_buffer_flags {
+	DISP_BF_NORMAL = 0,	/* non-stereo */
+	DISP_BF_STEREO_TB = 1 << 0,	/* stereo top-bottom */
+	DISP_BF_STEREO_FP = 1 << 1,	/* stereo frame packing */
+	DISP_BF_STEREO_SSH = 1 << 2,	/* stereo side by side half */
+	DISP_BF_STEREO_SSF = 1 << 3,	/* stereo side by side full */
+	DISP_BF_STEREO_LI = 1 << 4,	/* stereo line interlace */
+	/*
+	 * 2d plus depth to convert into 3d,
+	 * left and right image using the same frame buffer
+	 */
+	DISP_BF_STEREO_2D_DEPTH  = 1 << 5,
+};
+
+enum disp_layer_mode {
+	LAYER_MODE_BUFFER = 0,
+	LAYER_MODE_COLOR = 1,
+};
+
+enum disp_scan_flags {
+	DISP_SCAN_PROGRESSIVE = 0,
+	DISP_SCAN_INTERLACED_ODD_FLD_FIRST = 1 << 0,
+	DISP_SCAN_INTERLACED_EVEN_FLD_FIRST = 1 << 1,
+};
+
+enum disp_eotf {
+	DISP_EOTF_RESERVED = 0x000,
+	DISP_EOTF_BT709 = 0x001,
+	DISP_EOTF_UNDEF = 0x002,
+	DISP_EOTF_GAMMA22 = 0x004, /* SDR */
+	DISP_EOTF_GAMMA28 = 0x005,
+	DISP_EOTF_BT601 = 0x006,
+	DISP_EOTF_SMPTE240M = 0x007,
+	DISP_EOTF_LINEAR = 0x008,
+	DISP_EOTF_LOG100 = 0x009,
+	DISP_EOTF_LOG100S10 = 0x00a,
+	DISP_EOTF_IEC61966_2_4 = 0x00b,
+	DISP_EOTF_BT1361 = 0x00c,
+	DISP_EOTF_IEC61966_2_1 = 0X00d,
+	DISP_EOTF_BT2020_0 = 0x00e,
+	DISP_EOTF_BT2020_1 = 0x00f,
+	DISP_EOTF_SMPTE2084 = 0x010, /* HDR10 */
+	DISP_EOTF_SMPTE428_1 = 0x011,
+	DISP_EOTF_ARIB_STD_B67 = 0x012, /* HLG */
+};
+/* disp_atw_mode - mode for asynchronous time warp
+ *
+ * @NORMAL_MODE: dual buffer, left eye and right eye buffer is individual
+ * @LEFT_RIGHT_MODE: single buffer, the left half of each line buffer
+ *		     is for left eye, the right half is for the right eye
+ * @UP_DOWN_MODE: single buffer, the first half of the total buffer
+ *		  is for the left eye, the second half is for the right eye
+ */
+enum disp_atw_mode {
+	NORMAL_MODE,
+	LEFT_RIGHT_MODE,
+	UP_DOWN_MODE,
+};
+struct disp_output {
+	unsigned int type;
+	unsigned int mode;
+};
+
+enum disp_transform {
+	DISP_TRANSFORM_ROT_0         = 0x00,
+	DISP_TRANSFORM_ROT_90        = 0x01,
+	DISP_TRANSFORM_ROT_180       = 0x02,
+	DISP_TRANSFORM_ROT_270       = 0x03,
+	DISP_TRANSFORM_FLIP_H        = 0x04,
+	DISP_TRANSFORM_ROT_90_FLIP_H = 0x05,
+	DISP_TRANSFORM_FLIP_V        = 0x06,
+	DISP_TRANSFORM_ROT_90_FLIP_V = 0x07,
+};
+
+struct disp_rect64 {
+	long long x;
+	long long y;
+	long long width;
+	long long height;
+};
+
+struct disp_lbc_info {
+	unsigned int is_lossy;
+	unsigned int rc_en;
+	unsigned int pitch;
+	unsigned int seg_bit;
+};
+
+struct disp_fb_info {
+	/* address of frame buffer,
+	 * single addr for interleaved fomart,
+	 * double addr for semi-planar fomart
+	 * triple addr for planar format
+	 */
+	unsigned long long addr[3];
+	struct disp_rectsz size[3];
+	/* align for 3 comonent,unit: bytes */
+	unsigned int align[3];
+	enum disp_pixel_format format;
+	enum disp_color_space color_space;	/* color space */
+	unsigned int trd_right_addr[3];	/* right address of 3d fb */
+	bool pre_multiply;	/* true: pre-multiply fb */
+	struct disp_rect64 crop;	/* crop rectangle boundaries */
+	enum disp_buffer_flags flags;
+	enum disp_scan_flags scan;
+	unsigned int             lbc_en;
+	struct disp_lbc_info     lbc_info;
+};
+
+struct disp_layer_info {
+	enum disp_layer_mode mode;
+	unsigned char zorder;
+	/* 0: pixel alpha;  1: global alpha;  2: global pixel alpha */
+	unsigned char alpha_mode;
+	unsigned char alpha_value;	/* global alpha value */
+	struct disp_rect screen_win;	/* display window on the screen */
+	bool b_trd_out;		/* 3d display */
+	enum disp_3d_out_mode out_trd_mode;	/* 3d display mode */
+	union {
+		unsigned int color;	/* valid when LAYER_MODE_COLOR */
+		struct disp_fb_info fb;	/* valid when LAYER_MODE_BUFFER */
+	};
+
+	unsigned int id; /* frame id, the id of frame display currently */
+};
+
+struct disp_layer_config {
+	struct disp_layer_info info;
+	bool enable;
+	unsigned int channel;
+	unsigned int layer_id;
+};
+
+/* disp_atw_info - asynchronous time wrap infomation
+ *
+ * @used: indicate if the atw funtion is used
+ * @mode: atw mode
+ * @b_row: the row number of the micro block
+ * @b_col: the column number of the micro block
+ * @cof_fd: dma_buf fd for the buffer contaied coefficient for atw
+ */
+struct disp_atw_info {
+	bool used;
+	enum disp_atw_mode mode;
+	unsigned int b_row;
+	unsigned int b_col;
+	int cof_fd;
+};
+/**
+ * disp_vdpo_config
+ */
+struct disp_vdpo_config {
+	unsigned int data_seq_sel;
+	unsigned int dclk_invt;
+	unsigned int dclk_dly_num;
+	unsigned int spl_type_u;
+	unsigned int spl_type_v;
+};
+
+/* disp_fb_info2 - image buffer info v2
+ *
+ * @fd: dma_buf  fd for frame buffer
+ * @size: size<width,height> for each buffer, unit:pixels
+ * @align: align for each buffer, unit:bytes
+ * @format: pixel format
+ * @color_space: color space
+ * @trd_right_fd: dma_buf fd for the right-eye frame buffer,
+ *                  valid when frame-packing 3d buffer input
+ * @pre_multiply: indicate the pixel use premultiplied alpha
+ * @crop: crop rectangle for buffer to be display
+ * @flag: indicate stereo/non-stereo buffer
+ * @scan: indicate interleave/progressive scan type, and the scan order
+ * @depth: depth perception for stereo image, only valid when stereo image input
+ *            unit: pixel
+ * @fbd_en: indicate if enable fbd function
+ * @lbc_en: indicate if enable lbc function
+ * @metadata_fd: dma_buf fd for the buffer contained metadata for fbc/hdr
+ * @metadata_size: the size of metadata buffer, unit:bytes
+ * @metadata_flag: the flag to indicate the type of metadata buffer
+ *	0     : no metadata
+ *	1 << 0: hdr static metadata
+ *	1 << 1: hdr dynamic metadata
+ *	1 << 4:	frame buffer compress(fbc) metadata
+ *	x     : all type could be "or" together
+ */
+struct disp_fb_info2 {
+	int                      fd;
+	struct disp_rectsz       size[3];
+	unsigned int             align[3];
+	enum disp_pixel_format   format;
+	enum disp_color_space    color_space;
+	int                      trd_right_fd;
+	bool                     pre_multiply;
+	struct disp_rect64       crop;
+	enum disp_buffer_flags   flags;
+	enum disp_scan_flags     scan;
+	enum disp_eotf           eotf;
+	int                      depth;
+	unsigned int             fbd_en;
+	unsigned int             lbc_en;
+	struct disp_lbc_info     lbc_info;
+	int                      metadata_fd;
+	unsigned int             metadata_size;
+	unsigned int             metadata_flag;
+};
+
+/**
+ * disp_snr_info
+ */
+struct disp_snr_info {
+	unsigned char en;
+	unsigned char demo_en;
+	struct disp_rect demo_win;
+	unsigned char y_strength;
+	unsigned char u_strength;
+	unsigned char v_strength;
+	unsigned char th_ver_line;
+	unsigned char th_hor_line;
+};
+
+/* disp_layer_info2 - layer info v2
+ *
+ * @mode: buffer/clolor mode, when in color mode, the layer is widthout buffer
+ * @zorder: the zorder of layer, 0~max-layer-number
+ * @alpha_mode:
+ *	0: pixel alpha;
+ *	1: global alpha
+ *	2: mixed alpha, compositing width pixel alpha before global alpha
+ * @alpha_value: global alpha value, valid when alpha_mode is not pixel alpha
+ * @screen_win: the rectangle on the screen for fb to be display
+ * @b_trd_out: indicate if 3d display output
+ * @out_trd_mode: 3d output mode, valid when b_trd_out is true
+ * @color: the color value to be display, valid when layer is in color mode
+ * @fb: the framebuffer info related width the layer, valid when in buffer mode
+ * @id: frame id, the user could get the frame-id display currently by
+ *	DISP_LAYER_GET_FRAME_ID ioctl
+ * @atw: asynchronous time wrap information
+ */
+struct disp_layer_info2 {
+	enum disp_layer_mode      mode;
+	unsigned char             zorder;
+	unsigned char             alpha_mode;
+	unsigned char             alpha_value;
+	struct disp_rect          screen_win;
+	bool                      b_trd_out;
+	enum disp_3d_out_mode     out_trd_mode;
+	union {
+		unsigned int            color;
+		struct disp_fb_info2    fb;
+	};
+
+	unsigned int              id;
+	struct disp_atw_info      atw;
+	enum disp_transform transform;
+	struct disp_snr_info snr;
+};
+
+/* disp_layer_config2 - layer config v2
+ *
+ * @info: layer info
+ * @enable: indicate to enable/disable the layer
+ * @channel: the channel index of the layer, 0~max-channel-number
+ * @layer_id: the layer index of the layer widthin it's channel
+ */
+struct disp_layer_config2 {
+	struct disp_layer_info2 info;
+	bool enable;
+	unsigned int channel;
+	unsigned int layer_id;
+};
+
+
+/* disp_palette_config - palette config
+ *
+ * @num: the num of palette
+ * @data: the palette data, each palette data takes 4 bytes,show as below
+ *      bits            description
+ *      31:24           alpha value
+ *      23:16           red value
+ *      15:8            green value
+ *      7:0             blue value
+ * @channel: the channel index of the layer, 0~max-channel-number
+ */
+struct disp_palette_config {
+	unsigned int num;
+	void *data;
+	unsigned int channel;
+};
+
+/**
+ * match rule: 0/1:always match;
+ *             2:match if min<=color<=max;
+ *             3:match if color>max or color<min
+ */
+struct disp_colorkey {
+	struct disp_color ck_max;
+	struct disp_color ck_min;
+	unsigned int red_match_rule;
+	unsigned int green_match_rule;
+	unsigned int blue_match_rule;
+};
+
+struct disp_s_frame {
+	enum disp_pixel_format format;
+	struct disp_rectsz size[3];
+	struct disp_rect crop;
+	unsigned long long addr[3];
+};
+
+struct disp_capture_info {
+	/* capture the whole screen if window eq ZERO */
+	struct disp_rect window;
+	struct disp_s_frame out_frame;
+};
+
+/* disp_s_frame2 - display simple frame buffer
+ *
+ * @format: pixel format of fb
+ * @size: size for each plane
+ * @crop: crop zone to be fill image data
+ * @fd: dma_buf fd
+ */
+struct disp_s_frame2 {
+	enum disp_pixel_format format;
+	struct disp_rectsz size[3];
+	struct disp_rect crop;
+	int fd;
+};
+
+/* disp_capture_info2 - display capture information
+ *
+ * @window: the rectange on the screen to be capture
+ * @out_frame: the framebuffer to be restore capture image data
+ */
+struct disp_capture_info2 {
+	struct disp_rect window;
+	struct disp_s_frame2 out_frame;
+};
+
+struct disp_capture_fmt {
+	enum disp_pixel_format format;   /* write-back ouput format, doson't support YUV ouput yet */
+	struct disp_rect window;         /* source crop */
+	struct disp_rect crop;           /* output crop */
+};
+
+struct disp_capture_buffer {
+	int handle;                      /* Unique integer id represent this buffer */
+	enum disp_pixel_format format;   /* write-back ouput format */
+	struct disp_rect window;         /* source crop */
+	struct disp_rect crop;           /* output crop */
+	struct disp_rectsz size[3];
+
+	int fd;
+	int width;                       /* buffer width  in pixels */
+	int height;                      /* buffer height in pixels */
+};
+
+struct disp_capture_handle {
+	int handle;    /* unique integer id represent a capture buffer */
+	int fencefd;   /* fence fd for this buffer */
+};
+
+enum disp_capture_extend_cmd {
+	DISP_CAPTURE_E_SET_FMT,
+	DISP_CAPTURE_E_BUFFER_LIST_INIT,
+	DISP_CAPTURE_E_BUFFER_LIST_CLEAR,
+	DISP_CAPTURE_E_ACQUIRE_BUFFER,
+	DISP_CAPTURE_E_RELEASE_BUFFER,
+	DISP_CAPTURE_E_CTRL,
+};
+
+/* disp_device_config - display deivce config
+ *
+ * @type: output type
+ * @mode: output mode
+ * @format: data format
+ * @bits:   data bits
+ * @eotf:   electro-optical transfer function
+ *	    SDR  : DISP_EOTF_GAMMA22
+ *	    HDR10: DISP_EOTF_SMPTE2084
+ *	    HLG  : DISP_EOTF_ARIB_STD_B67
+ * @cs:     color space type
+ *	    DISP_BT601: SDR for SD resolution(< 720P)
+ *	    DISP_BT709: SDR for HD resolution(>= 720P)
+ *	    DISP_BT2020NC: HDR10 or HLG or wide-color-gamut
+ * @dvi_hdmi: output mode
+ *        DVI: DISP_DVI
+ *        HDMI: DISP_HDMI
+ * @range:    RGB/YUV quantization range
+ *          DEFUALT: limited range when sending a CE video format
+ *                   full range when sending an IT video format
+ *          LIMITED: color limited range from 16 to 235
+ *          FULL: color full range from 0 to 255
+ * @scan info:
+ *        DISP_SCANINFO_NO_DATA: overscan if it is a CE format,
+ *                               underscan if it is an IT format
+ *        OVERSCAN: composed for overscan display
+ *        UNDERSCAN: composed for underscan display
+ * @aspect_ratio: active format aspect ratio
+ */
+struct disp_device_config {
+	enum disp_output_type		type;
+	enum disp_tv_mode			mode;
+	enum disp_csc_type			format;
+	enum disp_data_bits			bits;
+	enum disp_eotf				eotf;
+	enum disp_color_space		cs;
+	enum disp_dvi_hdmi	        dvi_hdmi;
+	enum disp_color_range		range;
+	enum disp_scan_info			scan;
+	unsigned int				aspect_ratio;
+	unsigned int				reserve1;
+};
+
+/* disp_device_dynamic_config - display deivce dynamic config
+ *
+ * @metadata_fd: dma_buf fd for the buffer contained metadata for fbc/hdr
+ * @metadata_size: the size of metadata buffer, unit:bytes
+ * @metadata_flag: the flag to indicate the type of metadata buffer
+ *	0     : no metadata
+ *	1 << 0: hdr static metadata
+ *	1 << 1: hdr dynamic metadata
+ *	1 << 4:	frame buffer compress(fbc) metadata
+ *	x     : all type could be "or" together
+ * @vmap:vmap a block contigous phys memory into virtual space
+ * @vunmap: release virtual mapping obtained by vmap()
+ */
+struct disp_device_dynamic_config {
+	int			 metadata_fd;
+	unsigned int             metadata_size;
+	unsigned int             metadata_flag;
+	void *(*vmap)(unsigned long phys_addr, unsigned long size);
+	void (*vunmap)(const void *vaddr);
+};
+struct disp_video_timings {
+	unsigned int vic;	/* video information code */
+	unsigned int tv_mode;
+	unsigned int pixel_clk;
+	unsigned int pixel_repeat; /* pixel repeat (pixel_repeat+1) times */
+	unsigned int x_res;
+	unsigned int y_res;
+	unsigned int hor_total_time;
+	unsigned int hor_back_porch;
+	unsigned int hor_front_porch;
+	unsigned int hor_sync_time;
+	unsigned int ver_total_time;
+	unsigned int ver_back_porch;
+	unsigned int ver_front_porch;
+	unsigned int ver_sync_time;
+	unsigned int hor_sync_polarity;	/* 0: negative, 1: positive */
+	unsigned int ver_sync_polarity;	/* 0: negative, 1: positive */
+	bool b_interlace;
+	unsigned int vactive_space;
+	unsigned int trd_mode;
+	unsigned long      dclk_rate_set; /*unit: hz */
+	unsigned long long frame_period; /* unit: ns */
+	int                start_delay; /* unit: line */
+};
+
+enum disp_fb_mode {
+	FB_MODE_SCREEN0 = 0,
+	FB_MODE_SCREEN1 = 1,
+	FB_MODE_SCREEN2 = 2,
+	FB_MODE_DUAL_SAME_SCREEN_TB = 3,/* two screen, top buffer for screen0, bottom buffer for screen1 */
+	FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS = 4,/* two screen, they have same contents; */
+};
+
+struct disp_fb_create_info {
+	enum disp_fb_mode fb_mode;
+	enum disp_layer_mode mode;
+	unsigned int buffer_num;
+	unsigned int width;
+	unsigned int height;
+
+	unsigned int output_width;	/* used when scaler mode */
+	unsigned int output_height;	/* used when scaler mode */
+};
+
+enum disp_init_mode {
+	DISP_INIT_MODE_SCREEN0 = 0,	/* fb0 for screen0 */
+	DISP_INIT_MODE_SCREEN1 = 1,	/* fb0 for screen1 */
+	DISP_INIT_MODE_SCREEN2 = 2,	/* fb0 for screen1 */
+	DISP_INIT_MODE_TWO_DIFF_SCREEN = 3,/* fb0 for screen0 and fb1 for screen1 */
+	DISP_INIT_MODE_TWO_SAME_SCREEN = 4,/* fb0(up buffer for screen0, down buffer for screen1) */
+	DISP_INIT_MODE_TWO_DIFF_SCREEN_SAME_CONTENTS = 5,/* fb0 for two different screen(screen0 layer is normal layer, screen1 layer is scaler layer); */
+};
+
+struct disp_tv_func {
+	int (*tv_enable)(u32 sel);
+	int (*tv_disable)(u32 sel);
+	int (*tv_suspend)(u32 sel);
+	int (*tv_resume)(u32 sel);
+	int (*tv_get_mode)(u32 sel);
+	int (*tv_set_mode)(u32 sel, enum disp_tv_mode tv_mod);
+	int (*tv_get_input_csc)(u32 sel);
+	int (*tv_get_video_timing_info)(u32 sel,
+					 struct disp_video_timings **
+					 video_info);
+	int (*tv_mode_support)(u32 sel, enum disp_tv_mode mode);
+	int (*tv_hot_plugging_detect)(u32 state);
+	int (*tv_set_enhance_mode)(u32 sel, u32 mode);
+	int (*tv_irq_enable)(u32 sel, u32 irq_id, u32 en);
+	int (*tv_irq_query)(u32 sel);
+	unsigned int (*tv_get_cur_line)(u32 sel);
+	int (*vdpo_set_config)(u32 sel, struct disp_vdpo_config *p_cfg);
+	int (*tv_get_startdelay)(u32 sel);
+	void (*tv_show_builtin_patten)(u32 sel, u32 patten);
+};
+
+/* disp_vdevice_interface_para - vdevice interaface parameter
+ *
+ * @intf:interface
+ *	0:hv, 1:cpu, 3:lvds, 4:dsi
+ * @sub_intf:  sub interface
+ *	rgb interface: 0:parallel hv, 8:serial hv, 10:dummy rgb
+ *                     11: rgb dummy, 12: ccir656
+ *	cpu interface: 0:18 pin, 10:9pin, 12:6pin, 8:16pin, 14:8pin
+ *	lvds interface:0:single link, 1:dual link
+ *	dsi inerafce:   0:video mode, 1:command mode, 2: video burst mode
+ * @sequence:output sequence
+ *	rgb output: 0:rgb rgb, 1:rgb brg, 2:rgb gbr, 4:brg rgb
+ *                  5:brg brg, 6:brg gbr
+ *	8:grb rgb, 9:grb brg, 10:grb gbr
+ *	yuv output:0:yuyv, 1: yvyu, 2:uyvy, 3:vyuy
+ * @fdelay:yuv eav/sav F line delay
+ *	0: F toggle right after active video line
+ *	1: delay 2 line(CCIR NTSC)
+ *	2: delay 3 line(CCIR PAL)
+ * @clk_phase:clk phase
+ *	0: 0 degree, 1:90 degree, 2: 180 degree, 3:270 degree
+ * @sync_polarity:sync signals polarity
+ *	0: vsync active low,hsync active low
+ *	1: vsync active high,hsync active low
+ *	2: vsync active low,hsync active high
+ *	3: vsync active high,hsync active high
+ */
+struct disp_vdevice_interface_para {
+	unsigned int intf;
+	unsigned int sub_intf;
+	unsigned int sequence;
+	unsigned int fdelay;
+	unsigned int clk_phase;
+	unsigned int sync_polarity;
+	unsigned int ccir_clk_div;
+	unsigned int input_csc;/*not need to config for user*/
+};
+
+struct disp_vdevice_source_ops {
+	int (*tcon_enable)(struct disp_device *dispdev);
+	int (*tcon_disable)(struct disp_device *dispdev);
+	int (*tcon_simple_enable)(struct disp_device *dispdev);
+	int (*tcon_simple_disable)(struct disp_device *dispdev);
+};
+
+struct disp_device_func {
+	int (*enable)(void);
+	int (*smooth_enable)(void);
+	int (*disable)(void);
+	int (*set_mode)(u32 mode);
+	int (*mode_support)(u32 mode);
+	int (*get_HPD_status)(void);
+	int (*get_input_csc)(void);
+	int (*get_input_color_range)(void);
+	int (*get_video_timing_info)(struct disp_video_timings **video_info);
+	int (*suspend)(void);
+	int (*resume)(void);
+	int (*early_suspend)(void);
+	int (*late_resume)(void);
+	int (*get_interface_para)(void *para);
+	int (*set_static_config)(struct disp_device_config *config);
+	int (*get_static_config)(struct disp_device_config *config);
+	int (*set_dynamic_config)(struct disp_device_dynamic_config *config);
+	int (*get_dynamic_config)(struct disp_device_dynamic_config *config);
+
+	/*for hdmi cec*/
+	s32 (*cec_standby_request)(void);
+	s32 (*cec_send_one_touch_play)(void);
+};
+
+struct disp_vdevice_init_data {
+	char name[32];
+	u32 disp;
+	u32 fix_timing;
+	enum disp_output_type type;
+	struct disp_device_func func;
+};
+
+enum disp_tv_dac_source {
+	DISP_TV_DAC_SRC_COMPOSITE = 0,
+	DISP_TV_DAC_SRC_LUMA = 1,
+	DISP_TV_DAC_SRC_CHROMA = 2,
+	DISP_TV_DAC_SRC_Y = 4,
+	DISP_TV_DAC_SRC_PB = 5,
+	DISP_TV_DAC_SRC_PR = 6,
+	DISP_TV_DAC_SRC_NONE = 7,
+};
+
+enum disp_tv_output {
+	DISP_TV_NONE = 0,
+	DISP_TV_CVBS = 1,
+	DISP_TV_YPBPR = 2,
+	DISP_TV_SVIDEO = 4,
+	DISP_VGA = 5,
+};
+
+enum tag_DISP_CMD {
+	/* ----disp global---- */
+	DISP_RESERVE0 = 0x00,
+	DISP_RESERVE1 = 0x01,
+	DISP_SET_BKCOLOR = 0x03,
+	DISP_GET_BKCOLOR = 0x04,
+	DISP_SET_COLORKEY = 0x05,
+	DISP_GET_COLORKEY = 0x06,
+	DISP_GET_SCN_WIDTH = 0x07,
+	DISP_GET_SCN_HEIGHT = 0x08,
+	DISP_GET_OUTPUT_TYPE = 0x09,
+	DISP_SET_EXIT_MODE = 0x0A,
+	DISP_VSYNC_EVENT_EN = 0x0B,
+	DISP_BLANK = 0x0C,
+	DISP_SHADOW_PROTECT = 0x0D,
+	DISP_HWC_COMMIT = 0x0E,
+	DISP_DEVICE_SWITCH = 0x0F,
+	DISP_GET_OUTPUT = 0x10,
+	DISP_SET_COLOR_RANGE = 0x11,
+	DISP_GET_COLOR_RANGE = 0x12,
+	DISP_HWC_CUSTOM = 0x13,
+	DISP_DEVICE_SET_CONFIG = 0x14,
+	DISP_DEVICE_GET_CONFIG = 0x15,
+	DISP_SET_KSC_PARA = 0x16,
+	DISP_RTWB_COMMIT = 0x17,
+	DISP_NODE_LCD_MESSAGE_REQUEST = 0x18,
+	DISP_RELOAD_LCD = 0x19,
+
+	/* ----layer---- */
+	DISP_LAYER_ENABLE = 0x40,
+	DISP_LAYER_DISABLE = 0x41,
+	DISP_LAYER_SET_INFO = 0x42,
+	DISP_LAYER_GET_INFO = 0x43,
+	DISP_LAYER_TOP = 0x44,
+	DISP_LAYER_BOTTOM = 0x45,
+	DISP_LAYER_GET_FRAME_ID = 0x46,
+	DISP_LAYER_SET_CONFIG = 0x47,
+	DISP_LAYER_GET_CONFIG = 0x48,
+	/*
+	 * LAYER_S(G)ET_CONFIG2 takes disp_layer_config2,
+	 * it will support more featuras
+	 */
+	DISP_LAYER_SET_CONFIG2 = 0x49,
+	DISP_LAYER_GET_CONFIG2 = 0x4a,
+	DISP_CHN_SET_PALETTE = 0x4b,
+
+	/* ----hdmi---- */
+	DISP_HDMI_SUPPORT_MODE = 0xc4,
+	DISP_SET_TV_HPD = 0xc5,
+	DISP_HDMI_GET_EDID = 0xc6,
+	DISP_CEC_ONE_TOUCH_PLAY = 0xc7,
+
+	/* ----lcd---- */
+	DISP_LCD_ENABLE = 0x100,
+	DISP_LCD_DISABLE = 0x101,
+	DISP_LCD_SET_BRIGHTNESS = 0x102,
+	DISP_LCD_GET_BRIGHTNESS = 0x103,
+	DISP_LCD_BACKLIGHT_ENABLE = 0x104,
+	DISP_LCD_BACKLIGHT_DISABLE = 0x105,
+	DISP_LCD_SET_SRC = 0x106,
+	DISP_LCD_SET_FPS = 0x107,
+	DISP_LCD_GET_FPS = 0x108,
+	DISP_LCD_GET_SIZE = 0x109,
+	DISP_LCD_GET_MODEL_NAME = 0x10a,
+	DISP_LCD_SET_GAMMA_TABLE = 0x10b,
+	DISP_LCD_GAMMA_CORRECTION_ENABLE = 0x10c,
+	DISP_LCD_GAMMA_CORRECTION_DISABLE = 0x10d,
+	DISP_LCD_USER_DEFINED_FUNC = 0x10e,
+	DISP_LCD_CHECK_OPEN_FINISH = 0x10f,
+	DISP_LCD_CHECK_CLOSE_FINISH = 0x110,
+
+	/*tv*/
+	DISP_TV_SET_GAMMA_TABLE = 0x111,
+	/* ---- capture --- */
+	DISP_CAPTURE_START = 0x140,/* caputre screen and scaler to dram */
+	DISP_CAPTURE_STOP = 0x141,
+	DISP_CAPTURE_COMMIT = 0x142,
+	DISP_CAPTURE_COMMIT2 = 0x143,
+	DISP_CAPTURE_QUERY = 0x144,
+	DISP_CAPTURE_EXTEND = 0x145,
+
+	/* ---enhance --- */
+	DISP_ENHANCE_ENABLE = 0x180,
+	DISP_ENHANCE_DISABLE = 0x181,
+	DISP_ENHANCE_GET_EN = 0x182,
+	DISP_ENHANCE_SET_WINDOW = 0x183,
+	DISP_ENHANCE_GET_WINDOW = 0x184,
+	DISP_ENHANCE_SET_MODE = 0x185,
+	DISP_ENHANCE_GET_MODE = 0x186,
+	DISP_ENHANCE_DEMO_ENABLE = 0x187,
+	DISP_ENHANCE_DEMO_DISABLE = 0x188,
+
+	/* ---smart backlight --- */
+	DISP_SMBL_ENABLE = 0x200,
+	DISP_SMBL_DISABLE = 0x201,
+	DISP_SMBL_GET_EN = 0x202,
+	DISP_SMBL_SET_WINDOW = 0x203,
+	DISP_SMBL_GET_WINDOW = 0x204,
+
+	/* ---- for test */
+	DISP_FB_REQUEST = 0x280,
+	DISP_FB_RELEASE = 0x281,
+
+	DISP_MEM_REQUEST = 0x2c0,
+	DISP_MEM_RELEASE = 0x2c1,
+	DISP_MEM_GETADR = 0x2c2,
+	DISP_VDPO_SET_CONFIG = 0x2c3,
+
+	DISP_EINK_UPDATE = 0x402,
+	DISP_EINK_SET_TEMP = 0x403,
+	DISP_EINK_GET_TEMP = 0x404,
+	DISP_EINK_OVERLAP_SKIP = 0x405,
+	DISP_EINK_UPDATE2 = 0x406,
+};
+
+enum {
+	ROTATION_SW_0 = 0,
+	ROTATION_SW_90 = 1,
+	ROTATION_SW_180 = 2,
+	ROTATION_SW_270 = 3,
+};
+
+/* struct disp_ksc_info - keystone correction struct
+ *
+ * @enable: 1:enable; 0:disable
+ * @first_line_width: the width in pixel of first line you want
+ * @ration: ration is 12-bit Fixed point decimal with 5-bit interger (<= 256)
+ *	    direction = 0:
+ *	    last_line_width = first_line_width + (lcd_y-1)*ration_double
+ *	    ration_double = (last_line_width - first_line_width) / (lcd_y -1)
+ *	    direction = 1:
+ *	    last_line_width = first_line_width - (lcd_y-1)*ration_double
+ *	    ration_double = (first_line_width - last_line_width) / (lcd_y -1)
+ *	    ration = int(ration_double * pow(2, 12))
+ * @direction: see above
+ *
+ */
+struct disp_ksc_info {
+	unsigned int enable;
+	unsigned int first_line_width;
+	unsigned int ration;
+	unsigned int direction;
+};
+
+#define FBIOGET_LAYER_HDL_0 0x4700
+#define FBIOGET_LAYER_HDL_1 0x4701
+
+#endif
diff --git a/include/video/sunxi_metadata.h b/include/video/sunxi_metadata.h
new file mode 100644
index 000000000..1bd91f99b
--- /dev/null
+++ b/include/video/sunxi_metadata.h
@@ -0,0 +1,70 @@
+/*
+ * Allwinner SoCs display driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef __SUNXI_METADATA_H__
+#define __SUNXI_METADATA_H__
+
+enum {
+	/* hdr static metadata is available */
+	SUNXI_METADATA_FLAG_HDR_SATIC_METADATA   = 0x00000001,
+	/* hdr dynamic metadata is available */
+	SUNXI_METADATA_FLAG_HDR_DYNAMIC_METADATA = 0x00000002,
+
+	/* afbc header data is available */
+	SUNXI_METADATA_FLAG_AFBC_HEADER          = 0x00000010,
+};
+
+struct afbc_header {
+	u32 signature;
+	u16 filehdr_size;
+	u16 version;
+	u32 body_size;
+	u8 ncomponents;
+	u8 header_layout;
+	u8 yuv_transform;
+	u8 block_split;
+	u8 inputbits[4];
+	u16 block_width;
+	u16 block_height;
+	u16 width;
+	u16 height;
+	u8  left_crop;
+	u8  top_crop;
+	u16 block_layout;
+};
+
+struct display_master_data {
+	/* display primaries */
+	u16 display_primaries_x[3];
+	u16 display_primaries_y[3];
+
+	/* white_point */
+	u16 white_point_x;
+	u16 white_point_y;
+
+	/* max/min display mastering luminance */
+	u32 max_display_mastering_luminance;
+	u32 min_display_mastering_luminance;
+};
+
+/* static metadata type 1 */
+struct hdr_static_metadata {
+	struct display_master_data disp_master;
+
+	u16 maximum_content_light_level;
+	u16 maximum_frame_average_light_level;
+};
+
+/* sunxi video metadata for ve and de */
+struct sunxi_metadata {
+	struct hdr_static_metadata hdr_smetada;
+	struct afbc_header afbc_head;
+};
+
+#endif /* #ifndef __SUNXI_METADATA_H__ */
-- 
2.17.1

