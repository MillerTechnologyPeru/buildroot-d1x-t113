From 8b1b591324bc35b04e12e2a2aaa6043a0c03b59e Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 16:49:27 +0800
Subject: [PATCH 24/93] add sunxi g2d build support

---
 drivers/char/Kconfig                          |   20 +-
 drivers/char/Makefile                         |    6 +
 drivers/char/agp/Kconfig                      |    2 +-
 drivers/char/dump_reg/Kconfig                 |   20 +
 drivers/char/dump_reg/Makefile                |    2 +
 drivers/char/dump_reg/dump_reg.c              | 1114 ++++++++
 drivers/char/dump_reg/dump_reg.h              |  132 +
 drivers/char/dump_reg/dump_reg_misc.c         |  209 ++
 drivers/char/misc.c                           |    2 +-
 drivers/char/random.c                         |  311 +--
 drivers/char/sunxi-bs83b16c.c                 |  504 ++++
 drivers/char/sunxi-bs83b16c.h                 |   67 +
 drivers/char/sunxi-di/Kconfig                 |   32 +
 drivers/char/sunxi-di/Makefile                |   22 +
 drivers/char/sunxi-di/common/di_debug.h       |   88 +
 drivers/char/sunxi-di/common/di_utils.c       |  373 +++
 drivers/char/sunxi-di/common/di_utils.h       |   74 +
 drivers/char/sunxi-di/drv_div1xx/Makefile     |    5 +
 drivers/char/sunxi-di/drv_div1xx/di110.c      |  382 +++
 drivers/char/sunxi-di/drv_div1xx/di110.h      |   29 +
 drivers/char/sunxi-di/drv_div1xx/di110_reg.h  |  412 +++
 drivers/char/sunxi-di/drv_div1xx/di_client.c  |  473 ++++
 drivers/char/sunxi-di/drv_div1xx/di_client.h  |   91 +
 drivers/char/sunxi-di/drv_div1xx/di_dev.h     |   21 +
 drivers/char/sunxi-di/drv_div1xx/di_driver.c  |  902 +++++++
 drivers/char/sunxi-di/drv_div1xx/di_driver.h  |   61 +
 drivers/char/sunxi-di/drv_div1xx/di_fops.c    |  146 +
 drivers/char/sunxi-di/drv_div1xx/di_fops.h    |   21 +
 drivers/char/sunxi-di/drv_div1xx/sunxi_di.h   |  179 ++
 drivers/char/sunxi-di/drv_div2x/Makefile      |   44 +
 drivers/char/sunxi-di/drv_div2x/di.h          |  149 ++
 .../char/sunxi-di/drv_div2x/lowlevel_v1x/di.c |  292 ++
 .../drv_div2x/lowlevel_v1x/di_ebios.c         |  533 ++++
 .../drv_div2x/lowlevel_v1x/di_ebios.h         | 1055 ++++++++
 .../drv_div2x/lowlevel_v1x/di_ebios_data.h    |  444 +++
 .../drv_div2x/lowlevel_v2x/di_type_v2x.h      |  414 +++
 .../sunxi-di/drv_div2x/lowlevel_v2x/di_v2x.c  |  678 +++++
 drivers/char/sunxi-di/drv_div2x/sunxi-di.c    | 1644 ++++++++++++
 drivers/char/sunxi-di/drv_div2x/sunxi-di.h    |   88 +
 drivers/char/sunxi-di/drv_div3x/Makefile      |   10 +
 drivers/char/sunxi-di/drv_div3x/di_client.c   |  681 +++++
 drivers/char/sunxi-di/drv_div3x/di_client.h   |  152 ++
 drivers/char/sunxi-di/drv_div3x/di_debug.h    |   88 +
 drivers/char/sunxi-di/drv_div3x/di_dev.h      |   25 +
 drivers/char/sunxi-di/drv_div3x/di_driver.c   | 1052 ++++++++
 drivers/char/sunxi-di/drv_div3x/di_driver.h   |   66 +
 drivers/char/sunxi-di/drv_div3x/di_fops.c     |  154 ++
 drivers/char/sunxi-di/drv_div3x/di_fops.h     |   21 +
 drivers/char/sunxi-di/drv_div3x/di_utils.c    |  375 +++
 drivers/char/sunxi-di/drv_div3x/di_utils.h    |   67 +
 .../sunxi-di/drv_div3x/lowlevel_v3x/di300.c   | 1158 ++++++++
 .../sunxi-di/drv_div3x/lowlevel_v3x/di300.h   |   54 +
 .../drv_div3x/lowlevel_v3x/di300_alg.c        | 2147 +++++++++++++++
 .../drv_div3x/lowlevel_v3x/di300_alg.h        |  374 +++
 .../drv_div3x/lowlevel_v3x/di300_reg.h        |  886 ++++++
 drivers/char/sunxi-di/drv_div3x/sunxi_di.h    |  195 ++
 drivers/char/sunxi-sysinfo/Kconfig            |   24 +
 drivers/char/sunxi-sysinfo/Makefile           |   10 +
 drivers/char/sunxi-sysinfo/sunxi-smc.c        |  233 ++
 .../char/sunxi-sysinfo/sunxi-sysinfo-user.h   |   24 +
 drivers/char/sunxi-sysinfo/sunxi-sysinfo.c    |  252 ++
 drivers/char/sunxi_g2d/Kconfig                |   29 +
 drivers/char/sunxi_g2d/Makefile               |   20 +
 drivers/char/sunxi_g2d/g2d_bsp.h              |  146 +
 drivers/char/sunxi_g2d/g2d_bsp_sun8iw11.c     | 1907 +++++++++++++
 drivers/char/sunxi_g2d/g2d_bsp_v2.c           | 2375 +++++++++++++++++
 drivers/char/sunxi_g2d/g2d_driver.c           | 1818 +++++++++++++
 drivers/char/sunxi_g2d/g2d_driver_i.h         |  130 +
 drivers/char/sunxi_g2d/g2d_rcq/Makefile       |   11 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d.c          | 1153 ++++++++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.c      |  740 +++++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.h      |   54 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_bsp.h      |  117 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_driver_i.h |  127 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.c    | 1050 ++++++++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.h    |  105 +
 .../char/sunxi_g2d/g2d_rcq/g2d_mixer_type.h   |  541 ++++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.c    |  285 ++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.h    |   50 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.c    |  395 +++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.h    |   50 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.c      |   73 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.h      |   96 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.c   |  605 +++++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.h   |   28 +
 .../char/sunxi_g2d/g2d_rcq/g2d_rotate_type.h  |  139 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.c     |  538 ++++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.h     |   43 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_top.c      |  156 ++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_top.h      |   40 +
 drivers/char/sunxi_g2d/g2d_rcq/g2d_top_type.h |  159 ++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.c       |  233 ++
 drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.h       |   42 +
 drivers/char/sunxi_g2d/g2d_regs.h             |  208 ++
 drivers/char/sunxi_g2d/g2d_regs_v2.h          |  234 ++
 drivers/char/sunxi_g2d/g2d_trace.h            |   45 +
 drivers/char/sunxi_g2d/syncfence.c            |  409 +++
 drivers/char/sunxi_standby/Kconfig            |   13 +
 drivers/char/sunxi_standby/Makefile           |    1 +
 drivers/char/sunxi_standby/sunxi_standby.c    |  133 +
 100 files changed, 33123 insertions(+), 264 deletions(-)
 create mode 100644 drivers/char/dump_reg/Kconfig
 create mode 100644 drivers/char/dump_reg/Makefile
 create mode 100644 drivers/char/dump_reg/dump_reg.c
 create mode 100644 drivers/char/dump_reg/dump_reg.h
 create mode 100644 drivers/char/dump_reg/dump_reg_misc.c
 create mode 100644 drivers/char/sunxi-bs83b16c.c
 create mode 100644 drivers/char/sunxi-bs83b16c.h
 create mode 100644 drivers/char/sunxi-di/Kconfig
 create mode 100644 drivers/char/sunxi-di/Makefile
 create mode 100644 drivers/char/sunxi-di/common/di_debug.h
 create mode 100644 drivers/char/sunxi-di/common/di_utils.c
 create mode 100644 drivers/char/sunxi-di/common/di_utils.h
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/Makefile
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di110.c
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di110.h
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di110_reg.h
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di_client.c
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di_client.h
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di_dev.h
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di_driver.c
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di_driver.h
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di_fops.c
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/di_fops.h
 create mode 100644 drivers/char/sunxi-di/drv_div1xx/sunxi_di.h
 create mode 100644 drivers/char/sunxi-di/drv_div2x/Makefile
 create mode 100644 drivers/char/sunxi-di/drv_div2x/di.h
 create mode 100644 drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di.c
 create mode 100644 drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios.c
 create mode 100644 drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios.h
 create mode 100644 drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios_data.h
 create mode 100644 drivers/char/sunxi-di/drv_div2x/lowlevel_v2x/di_type_v2x.h
 create mode 100644 drivers/char/sunxi-di/drv_div2x/lowlevel_v2x/di_v2x.c
 create mode 100644 drivers/char/sunxi-di/drv_div2x/sunxi-di.c
 create mode 100644 drivers/char/sunxi-di/drv_div2x/sunxi-di.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/Makefile
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_client.c
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_client.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_debug.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_dev.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_driver.c
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_driver.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_fops.c
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_fops.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_utils.c
 create mode 100644 drivers/char/sunxi-di/drv_div3x/di_utils.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300.c
 create mode 100644 drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_alg.c
 create mode 100644 drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_alg.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_reg.h
 create mode 100644 drivers/char/sunxi-di/drv_div3x/sunxi_di.h
 create mode 100644 drivers/char/sunxi-sysinfo/Kconfig
 create mode 100644 drivers/char/sunxi-sysinfo/Makefile
 create mode 100644 drivers/char/sunxi-sysinfo/sunxi-smc.c
 create mode 100644 drivers/char/sunxi-sysinfo/sunxi-sysinfo-user.h
 create mode 100644 drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
 create mode 100644 drivers/char/sunxi_g2d/Kconfig
 create mode 100644 drivers/char/sunxi_g2d/Makefile
 create mode 100644 drivers/char/sunxi_g2d/g2d_bsp.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_bsp_sun8iw11.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_bsp_v2.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_driver.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_driver_i.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/Makefile
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_bsp.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_driver_i.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer_type.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate_type.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_top.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_top.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_top_type.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.c
 create mode 100644 drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_regs.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_regs_v2.h
 create mode 100644 drivers/char/sunxi_g2d/g2d_trace.h
 create mode 100644 drivers/char/sunxi_g2d/syncfence.c
 create mode 100644 drivers/char/sunxi_standby/Kconfig
 create mode 100644 drivers/char/sunxi_standby/Makefile
 create mode 100644 drivers/char/sunxi_standby/sunxi_standby.c

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index df0fc997d..fef41556c 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -535,6 +535,18 @@ config ADI
 	  and SSM (Silicon Secured Memory).  Intended consumers of this
 	  driver include crash and makedumpfile.
 
+config SUNXI_BS83B16C
+	bool "sunxi bs83b16c driver"
+	depends on ARCH_SUNXI || LEDS_CLASS || OF_GPIO
+	default n
+	help
+	  This driver is used to control mcu-bs83b16c, which has the functions
+	  of matrix button and LED array. Through the driver, the function of
+	  detecting matrix key press and reporting input can be realized, and
+	  and the LED array can also be turned on. In addition, before using
+	  the driver, it is necessary to ensure that the MCU has burned the
+	  corresponding firmware.
+
 endmenu
 
 config RANDOM_TRUST_CPU
@@ -559,4 +571,10 @@ config RANDOM_TRUST_BOOTLOADER
 	device randomness. Say Y here to assume the entropy provided by the
 	booloader is trustworthy so it will be added to the kernel's entropy
 	pool. Otherwise, say N here so it will be regarded as device input that
-	only mixes the entropy pool.
\ No newline at end of file
+	only mixes the entropy pool.
+
+source "drivers/char/dump_reg/Kconfig"
+source "drivers/char/sunxi_g2d/Kconfig"
+source "drivers/char/sunxi-di/Kconfig"
+source "drivers/char/sunxi_standby/Kconfig"
+source "drivers/char/sunxi-sysinfo/Kconfig"
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 7c5ea6f9d..3c3119de0 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -52,3 +52,9 @@ js-rtc-y = rtc.o
 obj-$(CONFIG_XILLYBUS)		+= xillybus/
 obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
 obj-$(CONFIG_ADI)		+= adi.o
+obj-$(CONFIG_DUMP_REG)		+= dump_reg/
+obj-$(CONFIG_SUNXI_STANDBY_DEBUG)	+= sunxi_standby/
+obj-$(CONFIG_SUNXI_G2D) += sunxi_g2d/
+obj-$(CONFIG_SUNXI_DI) += sunxi-di/
+obj-$(CONFIG_ARCH_SUNXI)        += sunxi-sysinfo/
+obj-$(CONFIG_SUNXI_BS83B16C)	+= sunxi-bs83b16c.o
diff --git a/drivers/char/agp/Kconfig b/drivers/char/agp/Kconfig
index 812d6aa6e..961cf0643 100644
--- a/drivers/char/agp/Kconfig
+++ b/drivers/char/agp/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 menuconfig AGP
-	tristate "/dev/agpgart (AGP Support)"
+	bool "/dev/agpgart (AGP Support)"
 	depends on ALPHA || IA64 || PARISC || PPC || X86
 	depends on PCI
 	---help---
diff --git a/drivers/char/dump_reg/Kconfig b/drivers/char/dump_reg/Kconfig
new file mode 100644
index 000000000..897756d15
--- /dev/null
+++ b/drivers/char/dump_reg/Kconfig
@@ -0,0 +1,20 @@
+#
+# dump reg config.
+#
+
+config DUMP_REG
+	tristate "dump reg driver for sunxi platform"
+	default y
+	---help---
+	  Say y here if you want to support dump regs module.
+	  The dump regs module is used to dump regs of any device.
+	  When in doubt, say "Y".
+
+config DUMP_REG_MISC
+	tristate "dump reg misc driver"
+	depends on DUMP_REG
+	default y
+	---help---
+	  Add misc driver support, you can use dump regs function
+	  via ("/sys/class/...") sysfs interface.
+	  When in doubt, say "Y".
diff --git a/drivers/char/dump_reg/Makefile b/drivers/char/dump_reg/Makefile
new file mode 100644
index 000000000..e953f413b
--- /dev/null
+++ b/drivers/char/dump_reg/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_DUMP_REG) += dump_reg.o
+obj-$(CONFIG_DUMP_REG_MISC) += dump_reg_misc.o
diff --git a/drivers/char/dump_reg/dump_reg.c b/drivers/char/dump_reg/dump_reg.c
new file mode 100644
index 000000000..96c06eb16
--- /dev/null
+++ b/drivers/char/dump_reg/dump_reg.c
@@ -0,0 +1,1114 @@
+/*
+ * dump registers sysfs driver
+ *
+ * Copyright(c) 2015-2018 Allwinnertech Co., Ltd.
+ *      http://www.allwinnertech.com
+ *
+ * Author: Liugang <liugang@allwinnertech.com>
+ *         Xiafeng <xiafeng@allwinnertech.com>
+ *         Martin <wuyan@allwinnertech.com>
+ *         Lewis  <liuyu@allwinnertech.com>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/seq_file.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/mod_devicetable.h>
+
+#include <linux/suspend.h>
+#include <linux/syscore_ops.h>
+
+#include "dump_reg.h"
+
+/* the register and vaule to be test by dump_reg */
+static u32 test_addr;
+static u32 test_size;
+static struct class *dump_class;
+
+/* Access in byte mode ? 1: byte-mode, 0: word-mode */
+static unsigned int rw_byte_mode;
+
+/* for dump_reg class */
+static struct dump_addr dump_para;
+static struct write_group *wt_group;
+static struct compare_group *cmp_group;
+
+static u32   standby_dump_ctrl;
+static char *standby_dump_buff;
+
+
+enum {
+	DUMP_CTRL_DEV_PREPARE = 0,
+	DUMP_CTRL_DEV_SUSPEND,
+	DUMP_CTRL_DEV_SUSPEND_LATE,
+	DUMP_CTRL_DEV_SUSPEND_NOIRQ,
+	DUMP_CTRL_SYSCORE_SUSPEND,
+
+
+	DUMP_CTRL_DEV_COMPLETE = 8,
+	DUMP_CTRL_DEV_RESUME,
+	DUMP_CTRL_DEV_RESUME_EARLY,
+	DUMP_CTRL_DEV_RESUME_NOIRQ,
+	DUMP_CTRL_SYSCORE_RESUME,
+
+	DUMP_CTRL_SUSPEND_WRITE = 16,
+	DUMP_CTRL_RESUME_WRITE  = 17,
+};
+
+
+static u32 _read(void __iomem *vaddr)
+{
+	if (rw_byte_mode)
+		return (u32)readb(vaddr);
+	else
+		return readl(vaddr);
+}
+
+static void _write(u32 val, void __iomem *vaddr)
+{
+	if (rw_byte_mode)
+		writeb((u8)val, vaddr);
+	else
+		writel(val, vaddr);
+}
+
+static void __iomem *_io_remap(unsigned long paddr, size_t size)
+{
+	return ioremap(paddr, size);
+}
+
+static void _io_unmap(void __iomem *vaddr)
+{
+	iounmap(vaddr);
+}
+
+static void __iomem *_mem_remap(unsigned long paddr, size_t size)
+{
+	return (void __iomem *)phys_to_virt(paddr);
+}
+
+/*
+ * Convert a physical address (which is already mapped) to virtual address
+ */
+static void __iomem *_get_vaddr(struct dump_addr *dump_addr, unsigned long uaddr)
+{
+	unsigned long offset = uaddr - dump_addr->uaddr_start;
+	return (void __iomem *)(dump_addr->vaddr_start + offset);
+}
+
+const struct dump_struct dump_table[] = {
+	{
+		.addr_start = SUNXI_IO_PHYS_START,
+		.addr_end   = SUNXI_IO_PHYS_END,
+		.remap = _io_remap,
+		.unmap = _io_unmap,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+	{
+		.addr_start = SUNXI_PLAT_PHYS_START,
+		.addr_end   = SUNXI_PLAT_PHYS_END,
+		.remap = _mem_remap,
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+#if defined(SUNXI_IOMEM_START)
+	{
+		.addr_start = SUNXI_IOMEM_START,
+		.addr_end   = SUNXI_IOMEM_END,
+		.remap = NULL,  /* .remap = NULL: uaddr is a virtual address */
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+#endif
+	{
+		.addr_start = SUNXI_MEM_PHYS_START,
+		.addr_end   = SUNXI_MEM_PHYS_END,
+		.remap = NULL,  /* .remap = NULL: uaddr is a virtual address */
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+};
+EXPORT_SYMBOL(dump_table);
+
+/**
+ * __addr_valid - check if @uaddr is valid.
+ * @uaddr: addr to judge.
+ *
+ * return index if @addr is valid, -ENXIO if not.
+ */
+int __addr_valid(unsigned long uaddr)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dump_table); i++)
+		if (uaddr >= dump_table[i].addr_start &&
+		    uaddr <= dump_table[i].addr_end)
+			return i;
+	return -ENXIO;
+}
+EXPORT_SYMBOL(__addr_valid);
+
+/**
+ * __dump_regs_ex - dump a range of registers' value, copy to buf.
+ * @dump_addr: start and end address of registers.
+ * @buf: store the dump info.
+ * @buf_size: buf size
+ *
+ * return bytes written to buf, <=0 indicate err
+ */
+ssize_t __dump_regs_ex(struct dump_addr *dump_addr, char *buf, ssize_t buf_size)
+{
+	int index;
+	ssize_t cnt = 0;
+	unsigned long uaddr;
+	unsigned long remap_size;
+	const struct dump_struct *dump;
+
+	/* Make the address 4-bytes aligned */
+	dump_addr->uaddr_start &= (~0x3UL);
+	dump_addr->uaddr_end &= (~0x3UL);
+	remap_size = dump_addr->uaddr_end - dump_addr->uaddr_start + 4;
+
+	index = __addr_valid(dump_addr->uaddr_start);
+	if ((index < 0) || (index != __addr_valid(dump_addr->uaddr_end)) ||
+	    (buf == NULL)) {
+		pr_err("%s(): Invalid para: index=%d, start=0x%lx, end=0x%lx, buf=0x%p\n",
+		       __func__, index, dump_addr->uaddr_start, dump_addr->uaddr_end, buf);
+		return -EIO;
+	}
+
+	dump = &dump_table[index];
+	if (dump->remap) {
+		dump_addr->vaddr_start = dump->remap(dump_addr->uaddr_start, remap_size);
+		if (!dump_addr->vaddr_start) {
+			pr_err("%s(): remap failed\n", __func__);
+			return -EIO;
+		}
+	} else  /* if (dump->remap = NULL), then treat uaddr as a virtual address */
+		dump_addr->vaddr_start = (void __iomem *)dump_addr->uaddr_start;
+
+	if (dump_addr->uaddr_start == dump_addr->uaddr_end) {
+		cnt = sprintf(buf, "0x%08x\n", dump->read(dump_addr->vaddr_start));
+		goto out;
+	}
+
+	for (uaddr = (dump_addr->uaddr_start & ~0x0F); uaddr <= dump_addr->uaddr_end;
+	     uaddr += 4) {
+		if (!(uaddr & 0x0F))
+			cnt += snprintf(buf + cnt, buf_size - cnt,
+				     "\n" PRINT_ADDR_FMT ":", uaddr);
+
+		if (cnt >= buf_size) {
+			pr_warn("Range too large, strings buffer overflow\n");
+			cnt = buf_size;
+			goto out;
+		}
+
+		if (uaddr < dump_addr->uaddr_start)  /* Don't show unused uaddr */
+			/* "0x12345678 ", 11 space */
+			cnt += snprintf(buf + cnt, buf_size - cnt, "           ");
+		else
+			cnt += snprintf(buf + cnt, buf_size - cnt, " 0x%08x",
+				dump->read(dump->get_vaddr(dump_addr, uaddr)));
+	}
+	cnt += snprintf(buf + cnt, buf_size - cnt, "\n");
+
+	pr_debug("%s(): start=0x%lx, end=0x%lx, return=%zd\n", __func__,
+		 dump_addr->uaddr_start, dump_addr->uaddr_end, cnt);
+
+out:
+	if (dump->unmap)
+		dump->unmap(dump_addr->vaddr_start);
+
+	return cnt;
+}
+EXPORT_SYMBOL(__dump_regs_ex);
+
+/**
+ * __parse_dump_str - parse the input string for dump attri.
+ * @buf: the input string, eg: "0x01c20000,0x01c20300".
+ * @size: buf size.
+ * @start: store the start reg's addr parsed from buf, eg 0x01c20000.
+ * @end: store the end reg's addr parsed from buf, eg 0x01c20300.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __parse_dump_str(const char *buf, size_t size,
+			    unsigned long *start, unsigned long *end)
+{
+	char *ptr = NULL;
+	char *ptr2 = (char *)buf;
+	int ret = 0, times = 0;
+
+	/* Support single address mode, some time it haven't ',' */
+next:
+	/*
+	 * Default dump only one register(*start =*end).
+	 * If ptr is not NULL, we will cover the default value of end.
+	 */
+	if (times == 1)
+		*start = *end;
+
+	if (!ptr2 || (ptr2 - buf) >= size)
+		goto out;
+
+	ptr = ptr2;
+	ptr2 = strnchr(ptr, size - (ptr - buf), ',');
+	if (ptr2) {
+		*ptr2 = '\0';
+		ptr2++;
+	}
+
+	ptr = strim(ptr);
+	if (!strlen(ptr))
+		goto next;
+
+	ret = kstrtoul(ptr, 16, end);
+	if (!ret) {
+		times++;
+		goto next;
+	} else
+		pr_warn("String syntax errors: \"%s\"\n", ptr);
+
+out:
+	return ret;
+}
+EXPORT_SYMBOL(__parse_dump_str);
+
+/**
+ * __write_show - dump a register's value, copy to buf.
+ * @pgroup: the addresses to read.
+ * @buf: store the dump info.
+ *
+ * return bytes written to buf, <=0 indicate err.
+ */
+ssize_t __write_show(struct write_group *pgroup, char *buf, ssize_t len)
+{
+#define WR_DATA_FMT PRINT_ADDR_FMT"  0x%08x  %s"
+
+	int i = 0;
+	ssize_t cnt = 0;
+	unsigned long reg = 0;
+	u32 val;
+	u8 rval_buf[16];
+	struct dump_addr dump_addr;
+
+	if (!pgroup) {
+		pr_err("%s,%d err, pgroup is NULL!\n", __func__, __LINE__);
+		goto end;
+	}
+
+	cnt += snprintf(buf, len - cnt, WR_PRINT_FMT);
+	if (cnt > len) {
+		cnt = -EINVAL;
+		goto end;
+	}
+
+	for (i = 0; i < pgroup->num; i++) {
+		reg = pgroup->pitem[i].reg_addr;
+		val = pgroup->pitem[i].val;
+		dump_addr.uaddr_start = reg;
+		dump_addr.uaddr_end = reg;
+		if (__dump_regs_ex(&dump_addr, rval_buf, sizeof(rval_buf)) < 0)
+			return -EINVAL;
+
+		cnt +=
+		    snprintf(buf + cnt, len - cnt, WR_DATA_FMT, reg, val,
+			     rval_buf);
+		if (cnt > len) {
+			cnt = len;
+			goto end;
+		}
+	}
+
+end:
+	return cnt;
+}
+EXPORT_SYMBOL(__write_show);
+
+/**
+ * __parse_write_str - parse the input string for write attri.
+ * @str: string to be parsed, eg: "0x01c20818 0x55555555".
+ * @reg_addr: store the reg address. eg: 0x01c20818.
+ * @val: store the expect value. eg: 0x55555555.
+ *
+ * return 0 if success, otherwise failed.
+ */
+static int __parse_write_str(char *str, unsigned long *reg_addr, u32 *val)
+{
+	char *ptr = str;
+	char *tstr = NULL;
+	int ret = 0;
+
+	/*
+	 * Skip the leading whitespace, find the true split symbol.
+	 * And it must be 'address value'.
+	 */
+	tstr = strim(str);
+	ptr = strchr(tstr, ' ');
+	if (!ptr)
+		return -EINVAL;
+
+	/*
+	 * Replaced split symbol with a %NUL-terminator temporary.
+	 * Will be fixed at end.
+	 */
+	*ptr = '\0';
+	ret = kstrtoul(tstr, 16, reg_addr);
+	if (ret)
+		goto out;
+
+	ret = kstrtou32(skip_spaces(ptr + 1), 16, val);
+
+out:
+	return ret;
+}
+
+/**
+ * __write_item_init - init for write attri. parse input string,
+ *                     and construct write struct.
+ * @ppgroup: store the struct allocated, the struct contains items parsed from
+ *           input buf.
+ * @buf: input string, eg: "0x01c20800 0x00000031,0x01c20818 0x55555555,...".
+ * @size: buf size.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __write_item_init(struct write_group **ppgroup, const char *buf,
+			     size_t size)
+{
+	char *ptr, *ptr2;
+	unsigned long addr = 0;
+	u32 val;
+	struct write_group *pgroup;
+
+	/* alloc item buffer */
+	pgroup = kmalloc(sizeof(struct write_group), GFP_KERNEL);
+	if (!pgroup)
+		return -ENOMEM;
+
+	pgroup->pitem = kmalloc(sizeof(struct write_item) * MAX_WRITE_ITEM,
+				GFP_KERNEL);
+	if (!pgroup->pitem) {
+		kfree(pgroup);
+		return -ENOMEM;
+	}
+
+	pgroup->num = 0;
+	ptr = (char *)buf;
+	do {
+		ptr2 = strchr(ptr, ',');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		if (!__parse_write_str(ptr, &addr, &val)) {
+			pgroup->pitem[pgroup->num].reg_addr = addr;
+			pgroup->pitem[pgroup->num].val = val;
+			pgroup->num++;
+		} else
+			pr_err("%s: Failed to parse string: %s\n", __func__,
+			       ptr);
+
+		if (!ptr2)
+			break;
+
+		ptr = ptr2 + 1;
+		*ptr2 = ',';
+
+	} while (pgroup->num <= MAX_WRITE_ITEM);
+
+	/* free buffer if no valid item */
+	if (pgroup->num == 0) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	*ppgroup = pgroup;
+	return 0;
+}
+EXPORT_SYMBOL(__write_item_init);
+
+/**
+ * __write_item_deinit - reled_addrse memory that cred_addrted by
+ *                       __write_item_init.
+ * @pgroup: the write struct allocated in __write_item_init.
+ */
+void __write_item_deinit(struct write_group *pgroup)
+{
+	if (pgroup != NULL) {
+		if (pgroup->pitem != NULL)
+			kfree(pgroup->pitem);
+		kfree(pgroup);
+	}
+}
+EXPORT_SYMBOL(__write_item_deinit);
+
+/**
+ * __compare_regs_ex - dump a range of registers' value, copy to buf.
+ * @pgroup: addresses of registers.
+ * @buf: store the dump info.
+ *
+ * return bytes written to buf, <= 0 indicate err.
+ */
+ssize_t __compare_regs_ex(struct compare_group *pgroup, char *buf,
+				 ssize_t len)
+{
+#define CMP_DATAO_FMT PRINT_ADDR_FMT"  0x%08x  0x%08x  0x%08x  OK\n"
+#define CMP_DATAE_FMT PRINT_ADDR_FMT"  0x%08x  0x%08x  0x%08x  ERR\n"
+
+	int i;
+	ssize_t cnt = 0;
+	unsigned long reg;
+	u32 expect, actual, mask;
+	u8 actualb[16];
+	struct dump_addr dump_addr;
+
+	if (!pgroup) {
+		pr_err("%s,%d err, pgroup is NULL!\n", __func__, __LINE__);
+		goto end;
+	}
+
+	cnt += snprintf(buf, len - cnt, CMP_PRINT_FMT);
+	if (cnt > len) {
+		cnt = -EINVAL;
+		goto end;
+	}
+
+	for (i = 0; i < pgroup->num; i++) {
+		reg = pgroup->pitem[i].reg_addr;
+		expect = pgroup->pitem[i].val_expect;
+		dump_addr.uaddr_start = reg;
+		dump_addr.uaddr_end = reg;
+		if (__dump_regs_ex(&dump_addr, actualb, sizeof(actualb)) < 0)
+			return -EINVAL;
+
+		if (kstrtou32(actualb, 16, &actual))
+			return -EINVAL;
+
+		mask = pgroup->pitem[i].val_mask;
+		if ((actual & mask) == (expect & mask))
+			cnt +=
+			    snprintf(buf + cnt, len - cnt, CMP_DATAO_FMT, reg,
+				     expect, actual, mask);
+		else
+			cnt +=
+			    snprintf(buf + cnt, len - cnt, CMP_DATAE_FMT, reg,
+				     expect, actual, mask);
+		if (cnt > len) {
+			cnt = -EINVAL;
+			goto end;
+		}
+	}
+
+end:
+	return cnt;
+}
+EXPORT_SYMBOL(__compare_regs_ex);
+
+/**
+ * __parse_compare_str - parse the input string for compare attri.
+ * @str: string to be parsed, eg: "0x01c20000 0x80000011 0x00000011".
+ * @reg_addr: store the reg address. eg: 0x01c20000.
+ * @val_expect: store the expect value. eg: 0x80000011.
+ * @val_mask: store the mask value. eg: 0x00000011.
+ *
+ * return 0 if success, otherwise failed.
+ */
+static int __parse_compare_str(char *str, unsigned long *reg_addr,
+			       u32 *val_expect, u32 *val_mask)
+{
+	unsigned long result_addr[3] = { 0 };
+	char *ptr = str;
+	char *ptr2 = NULL;
+	int i, ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(result_addr); i++) {
+		ptr = skip_spaces(ptr);
+		ptr2 = strchr(ptr, ' ');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		ret = kstrtoul(ptr, 16, &result_addr[i]);
+		if (!ptr2)
+			break;
+
+		*ptr2 = ' ';
+
+		if (ret)
+			break;
+
+		ptr = ptr2 + 1;
+	}
+
+	*reg_addr = result_addr[0];
+	*val_expect = (u32) result_addr[1];
+	*val_mask = (u32) result_addr[2];
+
+	return ret;
+}
+
+/**
+ * __compare_item_init - init for compare attri. parse input string,
+ *                       and construct compare struct.
+ * @ppgroup: store the struct allocated, the struct contains items parsed from
+ *           input buf.
+ * @buf: input string,
+ *  eg: "0x01c20000 0x80000011 0x00000011,0x01c20004 0x0000c0a4 0x0000c0a0,...".
+ * @size: buf size.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __compare_item_init(struct compare_group **ppgroup,
+			       const char *buf, size_t size)
+{
+	char *ptr, *ptr2;
+	unsigned long addr = 0;
+	u32 val_expect = 0, val_mask = 0;
+	struct compare_group *pgroup = NULL;
+
+	/* alloc item buffer */
+	pgroup = kmalloc(sizeof(struct compare_group), GFP_KERNEL);
+	if (pgroup == NULL)
+		return -EINVAL;
+
+	pgroup->pitem = kmalloc(sizeof(struct compare_item) * MAX_COMPARE_ITEM,
+				GFP_KERNEL);
+	if (pgroup->pitem == NULL) {
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	pgroup->num = 0;
+
+	/* get item from buf */
+	ptr = (char *)buf;
+	do {
+		ptr2 = strchr(ptr, ',');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		if (!__parse_compare_str(ptr, &addr, &val_expect, &val_mask)) {
+			pgroup->pitem[pgroup->num].reg_addr = addr;
+			pgroup->pitem[pgroup->num].val_expect = val_expect;
+			pgroup->pitem[pgroup->num].val_mask = val_mask;
+			pgroup->num++;
+		} else
+			pr_err("%s: Failed to parse string: %s\n", __func__,
+			       ptr);
+
+		if (!ptr2)
+			break;
+
+		*ptr2 = ',';
+		ptr = ptr2 + 1;
+
+	} while (pgroup->num <= MAX_COMPARE_ITEM);
+
+	/* free buffer if no valid item */
+	if (pgroup->num == 0) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+		return -EINVAL;
+	}
+	*ppgroup = pgroup;
+
+	return 0;
+}
+EXPORT_SYMBOL(__compare_item_init);
+
+/**
+ * __compare_item_deinit - reled_addrse memory that cred_addrted by
+ *                         __compare_item_init.
+ * @pgroup: the compare struct allocated in __compare_item_init.
+ */
+void __compare_item_deinit(struct compare_group *pgroup)
+{
+	if (pgroup) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+	}
+}
+EXPORT_SYMBOL(__compare_item_deinit);
+
+static int __write_store(struct write_group *group)
+{
+	int i;
+	int index;
+	unsigned long reg;
+	u32 val;
+	const struct dump_struct *dump;
+	struct dump_addr dump_addr;
+
+
+	if (!group)
+		return -1;
+	/**
+	 * write reg
+	 * it is better if the regs been remaped and unmaped only once,
+	 * but we map everytime for the range between min and max address
+	 * maybe too large.
+	 */
+	for (i = 0; i < group->num; i++) {
+		reg = group->pitem[i].reg_addr;
+		dump_addr.uaddr_start = reg;
+		val = group->pitem[i].val;
+		index = __addr_valid(reg);
+		dump = &dump_table[index];
+		if (dump->remap)
+			dump_addr.vaddr_start = dump->remap(reg, 4);
+		else
+			dump_addr.vaddr_start = (void __iomem *)reg;
+		dump->write(val, dump->get_vaddr(&dump_addr, reg));
+		if (dump->unmap)
+			dump->unmap(dump_addr.vaddr_start);
+	}
+
+	return 0;
+}
+
+static ssize_t standby_dump_ctrl_show(struct class *class, struct class_attribute *attr,
+		char *buf)
+{
+	ssize_t size = 0;
+
+	size = sprintf(buf, "0x%08x\n", standby_dump_ctrl);
+
+	return size;
+}
+
+static ssize_t standby_dump_ctrl_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	u32 value = 0;
+	int ret;
+
+	ret = kstrtou32(buf, 16, &value);
+	if (ret) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	standby_dump_ctrl = value;
+
+	pr_info("standby_dump_ctrl change to 0x%08x\n", standby_dump_ctrl);
+
+	return count;
+}
+
+static int standby_dump_printk(void)
+{
+	ssize_t  cnt = 0;
+
+	if (!standby_dump_buff)
+		return 0;
+
+	cnt = __dump_regs_ex(&dump_para, standby_dump_buff, PAGE_SIZE);
+
+	if (cnt < 0)
+		return -1;
+
+	pr_alert("%s\n", standby_dump_buff);
+
+	return 0;
+}
+
+static int standby_dump_dev_prepare(struct device *dev)
+{
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_DEV_PREPARE)))
+		return 0;
+
+	return standby_dump_printk();
+}
+
+static void standby_dump_dev_complete(struct device *dev)
+{
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_DEV_COMPLETE)))
+		return;
+
+	standby_dump_printk();
+}
+
+
+static int standby_dump_dev_suspend(struct device *dev)
+{
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_DEV_SUSPEND)))
+		return 0;
+
+	return standby_dump_printk();
+}
+
+static int standby_dump_dev_resume(struct device *dev)
+{
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_DEV_RESUME)))
+		return 0;
+
+	return standby_dump_printk();
+}
+
+static int standby_dump_dev_suspend_late(struct device *dev)
+{
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_DEV_SUSPEND_LATE)))
+		return 0;
+
+	return standby_dump_printk();
+}
+
+static int standby_dump_dev_resume_early(struct device *dev)
+{
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_DEV_RESUME_EARLY)))
+		return 0;
+
+	return standby_dump_printk();
+}
+
+static int standby_dump_dev_suspend_noirq(struct device *dev)
+{
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_DEV_SUSPEND_NOIRQ)))
+		return 0;
+
+	return standby_dump_printk();
+}
+
+static int standby_dump_dev_resume_noirq(struct device *dev)
+{
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_DEV_RESUME_NOIRQ)))
+		return 0;
+
+	return standby_dump_printk();
+}
+
+static int standby_dump_syscore_suspend(void)
+{
+	int ret  = 0;
+
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_SYSCORE_SUSPEND)))
+		return 0;
+
+	ret = standby_dump_printk();
+	if (ret)
+		return ret;
+
+	if (standby_dump_ctrl & (0x1<<DUMP_CTRL_SUSPEND_WRITE)) {
+		/* flush to reg */
+		__write_store(wt_group);
+
+		__write_show(wt_group, standby_dump_buff, PAGE_SIZE);
+		pr_alert("%s\n", standby_dump_buff);
+	}
+
+	return ret;
+}
+
+static void standby_dump_syscore_resume(void)
+{
+	int ret = 0;
+
+	if (!(standby_dump_ctrl & (0x1<<DUMP_CTRL_SYSCORE_RESUME)))
+		return;
+
+	ret = standby_dump_printk();
+	if (ret)
+		return;
+
+	if (standby_dump_ctrl & (0x1<<DUMP_CTRL_RESUME_WRITE)) {
+		/* flush to reg */
+		__write_store(wt_group);
+
+		__write_show(wt_group, standby_dump_buff, PAGE_SIZE);
+		pr_alert("%s\n", standby_dump_buff);
+	}
+}
+
+static struct dev_pm_ops standby_dump_ops = {
+	.prepare = standby_dump_dev_prepare,
+	.complete = standby_dump_dev_complete,
+	.suspend = standby_dump_dev_suspend,
+	.resume = standby_dump_dev_resume,
+	.suspend_late = standby_dump_dev_suspend_late,
+	.resume_early = standby_dump_dev_resume_early,
+	.suspend_noirq = standby_dump_dev_suspend_noirq,
+	.resume_noirq = standby_dump_dev_resume_noirq,
+};
+
+static struct syscore_ops standby_dump_syscore = {
+	.suspend = standby_dump_syscore_suspend,
+	.resume  = standby_dump_syscore_resume,
+};
+
+/**
+ * dump_show - show func of dump attribute.
+ * @dev: class ptr.
+ * @attr: attribute ptr.
+ * @buf: the input buf which contain the start and end reg.
+ *       eg: "0x01c20000,0x01c20100\n".
+ *
+ * return size written to the buf, otherwise failed.
+ */
+static ssize_t
+dump_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return __dump_regs_ex(&dump_para, buf, PAGE_SIZE);
+}
+
+static ssize_t
+dump_store(struct class *class, struct class_attribute *attr,
+	   const char *buf, size_t count)
+{
+	int index;
+	unsigned long start_reg = 0;
+	unsigned long end_reg = 0;
+
+	if (__parse_dump_str(buf, count, &start_reg, &end_reg)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	index = __addr_valid(start_reg);
+	if ((index < 0) || (index != __addr_valid(end_reg))) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	dump_para.uaddr_start = start_reg;
+	dump_para.uaddr_end = end_reg;
+	pr_debug("%s,%d, start_reg:" PRINT_ADDR_FMT ", end_reg:" PRINT_ADDR_FMT
+		 "\n", __func__, __LINE__, start_reg, end_reg);
+
+	return count;
+
+err:
+	dump_para.uaddr_start = 0;
+	dump_para.uaddr_end = 0;
+
+	return -EINVAL;
+}
+
+static ssize_t
+write_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	/* display write result */
+	return __write_show(wt_group, buf, PAGE_SIZE);
+}
+
+
+static ssize_t
+write_store(struct class *class, struct class_attribute *attr,
+	    const char *buf, size_t count)
+{
+
+	/* free if not NULL */
+	if (wt_group) {
+		__write_item_deinit(wt_group);
+		wt_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__write_item_init(&wt_group, buf, count) < 0)
+		return -EINVAL;
+
+	if (!(standby_dump_ctrl & \
+		((0x1<<DUMP_CTRL_SUSPEND_WRITE) | (0x1<<DUMP_CTRL_RESUME_WRITE)))) {
+		/* flush to reg */
+		__write_store(wt_group);
+	} else {
+		pr_alert("Will write it actually when suspend.\n");
+	}
+
+	return count;
+}
+
+static ssize_t
+compare_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	/* dump the items */
+	return __compare_regs_ex(cmp_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+compare_store(struct class *class, struct class_attribute *attr,
+	      const char *buf, size_t count)
+{
+	/* free if struct not null */
+	if (cmp_group) {
+		__compare_item_deinit(cmp_group);
+		cmp_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__compare_item_init(&cmp_group, buf, count) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t
+rw_byte_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "read/write mode: %u(%s)\n", rw_byte_mode,
+		       rw_byte_mode ? "byte" : "word");
+}
+
+static ssize_t
+rw_byte_store(struct class *class, struct class_attribute *attr,
+	      const char *buf, size_t count)
+{
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (!ret && (value > 1)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto out;
+	}
+	rw_byte_mode = value;
+out:
+	return count;
+}
+
+static ssize_t
+test_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "addr:0x%08x\nsize:0x%08x\n", test_addr, test_size);
+}
+
+static ssize_t
+help_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	const char *info =
+		"dump single register:          echo {addr} > dump; cat dump\n"
+		"dump multi  registers:         echo {start-addr},{end-addr} > dump; cat dump\n"
+		"write single register:         echo {addr} {val} > write; cat write\n"
+		"write multi  registers:        echo {addr1} {val1},{addr2} {val2},... > write; cat write\n"
+		"compare single register:       echo {addr} {expect-val} {mask} > compare; cat compare\n"
+		"compare multi  registers:      echo {addr1} {expect-val1} {mask1},{addr2} {expect-val2} {mask2},... > compare; cat compare\n"
+		"byte-access mode:              echo 1 > rw_byte\n"
+		"word-access mode (default):    echo 0 > rw_byte\n"
+		"show test address info:        cat test\n"
+		"abort standby_dump_ctrl, \n"
+		"	If you don't know it, please keep at zero.\n"
+		"	If you want to use it, please read the source code or the wiki first.\n";
+
+	return sprintf(buf, info);
+}
+
+static struct class_attribute dump_class_attrs[] = {
+	__ATTR(dump,     S_IWUSR | S_IRUGO, dump_show,     dump_store),
+	__ATTR(write,    S_IWUSR | S_IRUGO, write_show,    write_store),
+	__ATTR(compare,  S_IWUSR | S_IRUGO, compare_show,  compare_store),
+	__ATTR(rw_byte,  S_IWUSR | S_IRUGO, rw_byte_show,  rw_byte_store),
+	__ATTR(test,     S_IRUGO,           test_show, NULL),
+	__ATTR(help,     S_IRUGO,           help_show, NULL),
+	__ATTR(standby_dump_ctrl, S_IWUSR | S_IRUGO, standby_dump_ctrl_show, standby_dump_ctrl_store),
+};
+
+static const struct of_device_id sunxi_dump_reg_match[] = {
+	{.compatible = "allwinner,sunxi-dump-reg", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_dump_reg_match);
+
+static int sunxi_dump_reg_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+
+	int err;
+	int i;
+
+	/* sys/class/sunxi_dump */
+	dump_class = class_create(THIS_MODULE, "sunxi_dump");
+	if (IS_ERR(dump_class)) {
+		pr_err("%s:%u class_create() failed\n", __func__, __LINE__);
+		return PTR_ERR(dump_class);
+	}
+
+	/* sys/class/sunxi_dump/xxx */
+	for (i = 0; i < ARRAY_SIZE(dump_class_attrs); i++) {
+		err = class_create_file(dump_class, &dump_class_attrs[i]);
+		if (err) {
+			pr_err("%s:%u class_create_file() failed. err=%d\n", __func__, __LINE__, err);
+			while (i--) {
+				class_remove_file(dump_class, &dump_class_attrs[i]);
+			}
+			class_destroy(dump_class);
+			dump_class = NULL;
+			return err;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM \n");
+		goto error;
+	}
+
+	test_addr = res->start;
+	test_size = resource_size(res);
+
+	standby_dump_buff = devm_kmalloc(dev, PAGE_SIZE, GFP_KERNEL);
+	if (!standby_dump_buff)
+		dev_err(dev, "malloc memory failed.\n");
+
+	register_syscore_ops(&standby_dump_syscore);
+
+	return 0;
+error:
+	dev_err(dev, "sunxi_dump_reg probe error\n");
+	return -1;
+}
+
+static int sunxi_dump_reg_remove(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dump_class_attrs); i++) {
+		class_remove_file(dump_class, &dump_class_attrs[i]);
+	}
+
+	class_destroy(dump_class);
+	return 0;
+}
+
+static struct platform_driver sunxi_dump_reg_driver = {
+	.probe  = sunxi_dump_reg_probe,
+	.remove = sunxi_dump_reg_remove,
+	.driver = {
+		.name   = "dump_reg",
+		.owner  = THIS_MODULE,
+		.of_match_table = sunxi_dump_reg_match,
+		.pm     = &standby_dump_ops,
+	},
+};
+
+module_platform_driver(sunxi_dump_reg_driver);
+
+MODULE_ALIAS("dump reg driver");
+MODULE_ALIAS("platform:dump reg");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.3");
+MODULE_AUTHOR("xiafeng <xiafeng@allwinnertech.com>");
+MODULE_AUTHOR("Martin <wuyan@allwinnertech.com>");
+MODULE_AUTHOR("liuyu <SWCliuyus@allwinnertech.com>");
+MODULE_DESCRIPTION("dump registers driver");
diff --git a/drivers/char/dump_reg/dump_reg.h b/drivers/char/dump_reg/dump_reg.h
new file mode 100644
index 000000000..decfba6cb
--- /dev/null
+++ b/drivers/char/dump_reg/dump_reg.h
@@ -0,0 +1,132 @@
+/*
+ * dump registers head file
+ *
+ * (C) Copyright 2015-2018
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * Liugang <liugang@reuuimllatech.com>
+ * Xiafeng <xiafeng@allwinnertech.com>
+ * Martin  <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _DUMP_REG_H_
+#define _DUMP_REG_H_
+
+/* BROM/SRAM/peripheral-registers space */
+#define SUNXI_IO_PHYS_START		(0x00000000UL)
+#define SUNXI_IO_PHYS_END		(0x09020FFFUL)
+
+/* DRAM space (Only map the first 1GB) */
+#define SUNXI_PLAT_PHYS_START		(0x40000000UL)
+#define SUNXI_PLAT_PHYS_END		(SUNXI_PLAT_PHYS_START + SZ_1G - 1)
+
+#if IS_ENABLED(CONFIG_ARM64) || IS_ENABLED(CONFIG_RISCV)
+/* Virtual address space 1 */
+#define SUNXI_IOMEM_START		(0xffffff8000000000UL)
+#define SUNXI_IOMEM_END			(SUNXI_IOMEM_START + SZ_2G - 1)
+/* Virtual address space 2 */
+#define SUNXI_MEM_PHYS_START		(0xffffffc000000000UL)
+#define SUNXI_MEM_PHYS_END		(SUNXI_MEM_PHYS_START + SZ_2G - 1)
+/* Print format */
+#define PRINT_ADDR_FMT			"0x%016lx"
+#define CMP_PRINT_FMT                   "reg                 expect      actual      mask        result\n"
+#define WR_PRINT_FMT                    "reg                 to_write    after_write\n"
+#else
+/* Virtual address space 2 */
+#define SUNXI_MEM_PHYS_START		PAGE_OFFSET
+#define SUNXI_MEM_PHYS_END		(SUNXI_MEM_PHYS_START + SZ_1G - 1)
+/* Print format */
+#define PRINT_ADDR_FMT			"0x%08lx"
+#define CMP_PRINT_FMT                   "reg         expect      actual      mask        result\n"
+#define WR_PRINT_FMT                    "reg         to_write    after_write\n"
+#endif
+
+/* Item count */
+#define MAX_COMPARE_ITEM		64
+#define MAX_WRITE_ITEM			64
+
+struct dump_addr {
+	/* User specified address. Maybe physical or virtual address */
+	unsigned long uaddr_start;
+	unsigned long uaddr_end;
+	/* Virtual address */
+	void __iomem *vaddr_start;
+};
+
+struct dump_struct {
+	unsigned long addr_start;
+	unsigned long addr_end;
+	/* some registers' operate method maybe different */
+	void __iomem *(*remap)(unsigned long paddr, size_t size);
+	void (*unmap)(void __iomem *vaddr);
+	void __iomem *(*get_vaddr)(struct dump_addr *dump_addr, unsigned long uaddr);
+	 u32 (*read)(void __iomem *vaddr);
+	void (*write)(u32 val, void __iomem *vaddr);
+};
+
+/**
+ * compare_item - reg compare item struct
+ * @reg_addr:	reg address.
+ * @val_expect: expected value, provided by caller.
+ * @val_mask:   mask value, provided by caller. only mask bits will be compared.
+ */
+struct compare_item {
+	unsigned long reg_addr;
+	u32	val_expect;
+	u32	val_mask;
+};
+
+/**
+ * compare_group - reg compare group struct
+ * @num:	pitem element count. cannot exceed MAX_COMPARE_ITEM.
+ * @pitem:	items that will be compared, provided by caller.
+ */
+struct compare_group {
+	u32	num;
+	u32	reserve;
+	struct compare_item *pitem;
+};
+
+/**
+ * write_item - reg write item struct
+ * @reg_addr:	reg address.
+ * @val:	value to write
+ */
+struct write_item {
+	unsigned long reg_addr;
+	u32	val;
+	u32	reserve;
+};
+
+/**
+ * write_group - reg write group struct
+ * @num:	pitem element count. cannot exceed MAX_WRITE_ITEM.
+ * @pitem:	items that will be write, provided by caller.
+ */
+struct write_group {
+	u32	num;
+	u32	reserve;
+	struct write_item *pitem;
+};
+
+extern const struct dump_struct dump_table[4];
+
+int __addr_valid(unsigned long addr);
+ssize_t __dump_regs_ex(struct dump_addr *reg, char *buf, ssize_t len);
+int __parse_dump_str(const char *buf, size_t size,
+						unsigned long *start, unsigned long *end);
+ssize_t __write_show(struct write_group *pgroup, char *buf, ssize_t len);
+int  __write_item_init(struct write_group **ppgroup, const char *buf,
+						size_t size);
+void __write_item_deinit(struct write_group *pgroup);
+ssize_t __compare_regs_ex(struct compare_group *pgroup, char *buf,
+							ssize_t len);
+int  __compare_item_init(struct compare_group **ppgroup,
+						const char *buf, size_t size);
+void __compare_item_deinit(struct compare_group *pgroup);
+
+#endif /* _DUMP_REG_H_ */
diff --git a/drivers/char/dump_reg/dump_reg_misc.c b/drivers/char/dump_reg/dump_reg_misc.c
new file mode 100644
index 000000000..238ddd147
--- /dev/null
+++ b/drivers/char/dump_reg/dump_reg_misc.c
@@ -0,0 +1,209 @@
+/*
+ * misc dump registers driver -
+ * User space application could use dump-reg functions through file operations
+ * (open/read/write/close) to the sysfs node created by this driver.
+ *
+ * Copyright(c) 2015-2018 Allwinnertech Co., Ltd.
+ *      http://www.allwinnertech.com
+ *
+ * Author: Liugang <liugang@allwinnertech.com>
+ *         Xiafeng <xiafeng@allwinnertech.com>
+ *         Martin  <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/seq_file.h>
+#include "dump_reg.h"
+
+/* for dump_reg misc driver */
+static struct dump_addr misc_dump_para;
+static struct write_group *misc_wt_group;
+static struct compare_group *misc_cmp_group;
+
+static ssize_t
+misc_dump_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return __dump_regs_ex(&misc_dump_para, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_dump_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	int index;
+	unsigned long start_reg = 0;
+	unsigned long end_reg = 0;
+
+	if (__parse_dump_str(buf, size, &start_reg, &end_reg)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	index = __addr_valid(start_reg);
+	if ((index < 0) || (index != __addr_valid(end_reg))) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	misc_dump_para.uaddr_start = start_reg;
+	misc_dump_para.uaddr_end = end_reg;
+	pr_debug("%s,%d, start_reg:" PRINT_ADDR_FMT ", end_reg:" PRINT_ADDR_FMT
+		 "\n", __func__, __LINE__, start_reg, end_reg);
+
+	return size;
+
+err:
+	misc_dump_para.uaddr_start = 0;
+	misc_dump_para.uaddr_end = 0;
+
+	return -EINVAL;
+}
+
+static ssize_t
+misc_write_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/* display write result */
+	return __write_show(misc_wt_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_write_store(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t size)
+{
+	int i;
+	int index;
+	unsigned long reg;
+	u32 val;
+	const struct dump_struct *dump;
+	struct dump_addr dump_addr;
+
+	/* free if not NULL */
+	if (misc_wt_group) {
+		__write_item_deinit(misc_wt_group);
+		misc_wt_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__write_item_init(&misc_wt_group, buf, size) < 0)
+		return -EINVAL;
+
+	/**
+	 * write reg
+	 * it is better if the regs been remaped and unmaped only once,
+	 * but we map everytime for the range between min and max address
+	 * maybe too large.
+	 */
+	for (i = 0; i < misc_wt_group->num; i++) {
+		reg = misc_wt_group->pitem[i].reg_addr;
+		dump_addr.uaddr_start = reg;
+		val = misc_wt_group->pitem[i].val;
+		index = __addr_valid(reg);
+		dump = &dump_table[index];
+		if (dump->remap)
+			dump_addr.vaddr_start = dump->remap(reg, 4);
+		else
+			dump_addr.vaddr_start = (void __iomem *)reg;
+		dump->write(val, dump->get_vaddr(&dump_addr, reg));
+		if (dump->unmap)
+			dump->unmap(dump_addr.vaddr_start);
+	}
+
+	return size;
+}
+
+static ssize_t
+misc_compare_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/* dump the items */
+	return __compare_regs_ex(misc_cmp_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_compare_store(struct device *dev, struct device_attribute *attr,
+		   const char *buf, size_t size)
+{
+	/* free if struct not null */
+	if (misc_cmp_group) {
+		__compare_item_deinit(misc_cmp_group);
+		misc_cmp_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__compare_item_init(&misc_cmp_group, buf, size) < 0)
+		return -EINVAL;
+
+	return size;
+}
+
+static DEVICE_ATTR(dump, S_IWUSR | S_IRUGO, misc_dump_show, misc_dump_store);
+static DEVICE_ATTR(write, S_IWUSR | S_IRUGO, misc_write_show, misc_write_store);
+static DEVICE_ATTR(compare, S_IWUSR | S_IRUGO, misc_compare_show,
+		   misc_compare_store);
+
+static struct attribute *misc_attributes[] = {  /* files under '/sys/devices/virtual/misc/sunxi-reg/rw/' */
+	&dev_attr_dump.attr,
+	&dev_attr_write.attr,
+	&dev_attr_compare.attr,
+	NULL,
+};
+
+static struct attribute_group misc_attribute_group = {
+	.name = "rw",  /* directory: '/sys/devices/virtual/misc/sunxi-reg/rw/' */
+	.attrs = misc_attributes,
+};
+
+static struct miscdevice dump_reg_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "sunxi-reg",  /* device node: '/dev/sunxi-reg' */
+};
+
+static int __init misc_dump_reg_init(void)
+{
+	int err;
+
+	pr_info("misc dump reg init\n");
+	err = misc_register(&dump_reg_dev);
+	if (err) {
+		pr_err("dump register driver as misc device error!\n");
+		goto exit;
+	}
+
+	err = sysfs_create_group(&dump_reg_dev.this_device->kobj,
+				 &misc_attribute_group);
+	if (err)
+		pr_err("dump register sysfs create group failed!\n");
+
+exit:
+	return err;
+}
+
+static void __exit misc_dump_reg_exit(void)
+{
+	pr_info("misc dump reg exit\n");
+
+	sysfs_remove_group(&(dump_reg_dev.this_device->kobj),
+			   &misc_attribute_group);
+	misc_deregister(&dump_reg_dev);
+}
+
+module_init(misc_dump_reg_init);
+module_exit(misc_dump_reg_exit);
+
+MODULE_ALIAS("misc dump reg driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.1");
+MODULE_AUTHOR("xiafeng <xiafeng@allwinnertech.com>");
+MODULE_DESCRIPTION("misc dump registers driver");
diff --git a/drivers/char/misc.c b/drivers/char/misc.c
index f6a147427..ca5141ed5 100644
--- a/drivers/char/misc.c
+++ b/drivers/char/misc.c
@@ -60,7 +60,7 @@ static DEFINE_MUTEX(misc_mtx);
 /*
  * Assigned numbers, used for dynamic minors
  */
-#define DYNAMIC_MINORS 64 /* like dynamic majors */
+#define DYNAMIC_MINORS 128 /* like dynamic majors */
 static DECLARE_BITMAP(misc_minors, DYNAMIC_MINORS);
 
 #ifdef CONFIG_PROC_FS
diff --git a/drivers/char/random.c b/drivers/char/random.c
index e877c20e0..249d9100a 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -307,6 +307,8 @@
  * Eastlake, Steve Crocker, and Jeff Schiller.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/utsname.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -354,7 +356,6 @@
 #define INPUT_POOL_WORDS	(1 << (INPUT_POOL_SHIFT-5))
 #define OUTPUT_POOL_SHIFT	10
 #define OUTPUT_POOL_WORDS	(1 << (OUTPUT_POOL_SHIFT-5))
-#define SEC_XFER_SIZE		512
 #define EXTRACT_SIZE		10
 
 
@@ -370,12 +371,6 @@
 #define ENTROPY_SHIFT 3
 #define ENTROPY_BITS(r) ((r)->entropy_count >> ENTROPY_SHIFT)
 
-/*
- * The minimum number of bits of entropy before we wake up a read on
- * /dev/random.  Should be enough to do a significant reseed.
- */
-static int random_read_wakeup_bits = 64;
-
 /*
  * If the entropy count falls under this number of bits, then we
  * should wake up processes which are selecting or polling on write
@@ -436,42 +431,11 @@ static const struct poolinfo {
 	/* was: x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 */
 	/* x^128 + x^104 + x^76 + x^51 +x^25 + x + 1 */
 	{ S(128),	104,	76,	51,	25,	1 },
-	/* was: x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 */
-	/* x^32 + x^26 + x^19 + x^14 + x^7 + x + 1 */
-	{ S(32),	26,	19,	14,	7,	1 },
-#if 0
-	/* x^2048 + x^1638 + x^1231 + x^819 + x^411 + x + 1  -- 115 */
-	{ S(2048),	1638,	1231,	819,	411,	1 },
-
-	/* x^1024 + x^817 + x^615 + x^412 + x^204 + x + 1 -- 290 */
-	{ S(1024),	817,	615,	412,	204,	1 },
-
-	/* x^1024 + x^819 + x^616 + x^410 + x^207 + x^2 + 1 -- 115 */
-	{ S(1024),	819,	616,	410,	207,	2 },
-
-	/* x^512 + x^411 + x^308 + x^208 + x^104 + x + 1 -- 225 */
-	{ S(512),	411,	308,	208,	104,	1 },
-
-	/* x^512 + x^409 + x^307 + x^206 + x^102 + x^2 + 1 -- 95 */
-	{ S(512),	409,	307,	206,	102,	2 },
-	/* x^512 + x^409 + x^309 + x^205 + x^103 + x^2 + 1 -- 95 */
-	{ S(512),	409,	309,	205,	103,	2 },
-
-	/* x^256 + x^205 + x^155 + x^101 + x^52 + x + 1 -- 125 */
-	{ S(256),	205,	155,	101,	52,	1 },
-
-	/* x^128 + x^103 + x^78 + x^51 + x^27 + x^2 + 1 -- 70 */
-	{ S(128),	103,	78,	51,	27,	2 },
-
-	/* x^64 + x^52 + x^39 + x^26 + x^14 + x + 1 -- 15 */
-	{ S(64),	52,	39,	26,	14,	1 },
-#endif
 };
 
 /*
  * Static global variables
  */
-static DECLARE_WAIT_QUEUE_HEAD(random_read_wait);
 static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);
 static struct fasync_struct *fasync;
 
@@ -530,11 +494,8 @@ struct entropy_store {
 	const struct poolinfo *poolinfo;
 	__u32 *pool;
 	const char *name;
-	struct entropy_store *pull;
-	struct work_struct push_work;
 
 	/* read-write data: */
-	unsigned long last_pulled;
 	spinlock_t lock;
 	unsigned short add_ptr;
 	unsigned short input_rotate;
@@ -550,9 +511,7 @@ static ssize_t _extract_entropy(struct entropy_store *r, void *buf,
 				size_t nbytes, int fips);
 
 static void crng_reseed(struct crng_state *crng, struct entropy_store *r);
-static void push_to_pool(struct work_struct *work);
 static __u32 input_pool_data[INPUT_POOL_WORDS] __latent_entropy;
-static __u32 blocking_pool_data[OUTPUT_POOL_WORDS] __latent_entropy;
 
 static struct entropy_store input_pool = {
 	.poolinfo = &poolinfo_table[0],
@@ -561,16 +520,6 @@ static struct entropy_store input_pool = {
 	.pool = input_pool_data
 };
 
-static struct entropy_store blocking_pool = {
-	.poolinfo = &poolinfo_table[1],
-	.name = "blocking",
-	.pull = &input_pool,
-	.lock = __SPIN_LOCK_UNLOCKED(blocking_pool.lock),
-	.pool = blocking_pool_data,
-	.push_work = __WORK_INITIALIZER(blocking_pool.push_work,
-					push_to_pool),
-};
-
 static __u32 const twist_table[8] = {
 	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
 	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
@@ -759,22 +708,17 @@ static void credit_entropy_bits(struct entropy_store *r, int nbits)
 		} while (unlikely(entropy_count < pool_size-2 && pnfrac));
 	}
 
-	if (unlikely(entropy_count < 0)) {
-		pr_warn("random: negative entropy/overflow: pool %s count %d\n",
+	if (WARN_ON(entropy_count < 0)) {
+		pr_warn("negative entropy/overflow: pool %s count %d\n",
 			r->name, entropy_count);
-		WARN_ON(1);
 		entropy_count = 0;
 	} else if (entropy_count > pool_size)
 		entropy_count = pool_size;
-	if ((r == &blocking_pool) && !r->initialized &&
-	    (entropy_count >> ENTROPY_SHIFT) > 128)
-		has_initialized = 1;
 	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
 		goto retry;
 
 	if (has_initialized) {
 		r->initialized = 1;
-		wake_up_interruptible(&random_read_wait);
 		kill_fasync(&fasync, SIGIO, POLL_IN);
 	}
 
@@ -783,36 +727,13 @@ static void credit_entropy_bits(struct entropy_store *r, int nbits)
 
 	if (r == &input_pool) {
 		int entropy_bits = entropy_count >> ENTROPY_SHIFT;
-		struct entropy_store *other = &blocking_pool;
 
 		if (crng_init < 2) {
 			if (entropy_bits < 128)
 				return;
 			crng_reseed(&primary_crng, r);
-			entropy_bits = r->entropy_count >> ENTROPY_SHIFT;
-		}
-
-		/* initialize the blocking pool if necessary */
-		if (entropy_bits >= random_read_wakeup_bits &&
-		    !other->initialized) {
-			schedule_work(&other->push_work);
-			return;
-		}
-
-		/* should we wake readers? */
-		if (entropy_bits >= random_read_wakeup_bits &&
-		    wq_has_sleeper(&random_read_wait)) {
-			wake_up_interruptible(&random_read_wait);
-			kill_fasync(&fasync, SIGIO, POLL_IN);
+			entropy_bits = ENTROPY_BITS(r);
 		}
-		/* If the input pool is getting full, and the blocking
-		 * pool has room, send some entropy to the blocking
-		 * pool.
-		 */
-		if (!work_pending(&other->push_work) &&
-		    (ENTROPY_BITS(r) > 6 * r->poolinfo->poolbytes) &&
-		    (ENTROPY_BITS(other) <= 6 * other->poolinfo->poolbytes))
-			schedule_work(&other->push_work);
 	}
 }
 
@@ -884,7 +805,7 @@ static void crng_initialize(struct crng_state *crng)
 		invalidate_batched_entropy();
 		numa_crng_init();
 		crng_init = 2;
-		pr_notice("random: crng done (trusting CPU's manufacturer)\n");
+		pr_notice("crng done (trusting CPU's manufacturer)\n");
 	}
 	crng->init_time = jiffies - CRNG_RESEED_INTERVAL - 1;
 }
@@ -946,8 +867,7 @@ static int crng_fast_load(const char *cp, size_t len)
 	if (crng_init_cnt >= CRNG_INIT_CNT_THRESH) {
 		invalidate_batched_entropy();
 		crng_init = 1;
-		wake_up_interruptible(&crng_init_wait);
-		pr_notice("random: fast init done\n");
+		pr_notice("fast init done\n");
 	}
 	return 1;
 }
@@ -1032,16 +952,15 @@ static void crng_reseed(struct crng_state *crng, struct entropy_store *r)
 		crng_init = 2;
 		process_random_ready_list();
 		wake_up_interruptible(&crng_init_wait);
-		pr_notice("random: crng init done\n");
+		kill_fasync(&fasync, SIGIO, POLL_IN);
+		pr_notice("crng init done\n");
 		if (unseeded_warning.missed) {
-			pr_notice("random: %d get_random_xx warning(s) missed "
-				  "due to ratelimiting\n",
+			pr_notice("%d get_random_xx warning(s) missed due to ratelimiting\n",
 				  unseeded_warning.missed);
 			unseeded_warning.missed = 0;
 		}
 		if (urandom_warning.missed) {
-			pr_notice("random: %d urandom warning(s) missed "
-				  "due to ratelimiting\n",
+			pr_notice("%d urandom warning(s) missed due to ratelimiting\n",
 				  urandom_warning.missed);
 			urandom_warning.missed = 0;
 		}
@@ -1246,7 +1165,7 @@ static void add_timer_randomness(struct timer_rand_state *state, unsigned num)
 	/*
 	 * delta is now minimum absolute delta.
 	 * Round down by 1 bit on general principles,
-	 * and limit entropy entimate to 12 bits.
+	 * and limit entropy estimate to 12 bits.
 	 */
 	credit_entropy_bits(r, min_t(int, fls(delta>>1), 11));
 }
@@ -1390,57 +1309,6 @@ EXPORT_SYMBOL_GPL(add_disk_randomness);
  *
  *********************************************************************/
 
-/*
- * This utility inline function is responsible for transferring entropy
- * from the primary pool to the secondary extraction pool. We make
- * sure we pull enough for a 'catastrophic reseed'.
- */
-static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes);
-static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
-{
-	if (!r->pull ||
-	    r->entropy_count >= (nbytes << (ENTROPY_SHIFT + 3)) ||
-	    r->entropy_count > r->poolinfo->poolfracbits)
-		return;
-
-	_xfer_secondary_pool(r, nbytes);
-}
-
-static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
-{
-	__u32	tmp[OUTPUT_POOL_WORDS];
-
-	int bytes = nbytes;
-
-	/* pull at least as much as a wakeup */
-	bytes = max_t(int, bytes, random_read_wakeup_bits / 8);
-	/* but never more than the buffer size */
-	bytes = min_t(int, bytes, sizeof(tmp));
-
-	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
-				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));
-	bytes = extract_entropy(r->pull, tmp, bytes,
-				random_read_wakeup_bits / 8, 0);
-	mix_pool_bytes(r, tmp, bytes);
-	credit_entropy_bits(r, bytes*8);
-}
-
-/*
- * Used as a workqueue function so that when the input pool is getting
- * full, we can "spill over" some entropy to the output pools.  That
- * way the output pools can store some of the excess entropy instead
- * of letting it go to waste.
- */
-static void push_to_pool(struct work_struct *work)
-{
-	struct entropy_store *r = container_of(work, struct entropy_store,
-					      push_work);
-	BUG_ON(!r);
-	_xfer_secondary_pool(r, random_read_wakeup_bits/8);
-	trace_push_to_pool(r->name, r->entropy_count >> ENTROPY_SHIFT,
-			   r->pull->entropy_count >> ENTROPY_SHIFT);
-}
-
 /*
  * This function decides how many bytes to actually take from the
  * given pool, and also debits the entropy count accordingly.
@@ -1466,10 +1334,9 @@ static size_t account(struct entropy_store *r, size_t nbytes, int min,
 	if (ibytes < min)
 		ibytes = 0;
 
-	if (unlikely(entropy_count < 0)) {
-		pr_warn("random: negative entropy count: pool %s count %d\n",
+	if (WARN_ON(entropy_count < 0)) {
+		pr_warn("negative entropy count: pool %s count %d\n",
 			r->name, entropy_count);
-		WARN_ON(1);
 		entropy_count = 0;
 	}
 	nfrac = ibytes << (ENTROPY_SHIFT + 3);
@@ -1482,8 +1349,7 @@ static size_t account(struct entropy_store *r, size_t nbytes, int min,
 		goto retry;
 
 	trace_debit_entropy(r->name, 8 * ibytes);
-	if (ibytes &&
-	    (r->entropy_count >> ENTROPY_SHIFT) < random_write_wakeup_bits) {
+	if (ibytes && ENTROPY_BITS(r) < random_write_wakeup_bits) {
 		wake_up_interruptible(&random_write_wait);
 		kill_fasync(&fasync, SIGIO, POLL_OUT);
 	}
@@ -1604,7 +1470,6 @@ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
 			spin_unlock_irqrestore(&r->lock, flags);
 			trace_extract_entropy(r->name, EXTRACT_SIZE,
 					      ENTROPY_BITS(r), _RET_IP_);
-			xfer_secondary_pool(r, EXTRACT_SIZE);
 			extract_buf(r, tmp);
 			spin_lock_irqsave(&r->lock, flags);
 			memcpy(r->last_data, tmp, EXTRACT_SIZE);
@@ -1613,60 +1478,11 @@ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
 	}
 
 	trace_extract_entropy(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
-	xfer_secondary_pool(r, nbytes);
 	nbytes = account(r, nbytes, min, reserved);
 
 	return _extract_entropy(r, buf, nbytes, fips_enabled);
 }
 
-/*
- * This function extracts randomness from the "entropy pool", and
- * returns it in a userspace buffer.
- */
-static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
-				    size_t nbytes)
-{
-	ssize_t ret = 0, i;
-	__u8 tmp[EXTRACT_SIZE];
-	int large_request = (nbytes > 256);
-
-	trace_extract_entropy_user(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
-	if (!r->initialized && r->pull) {
-		xfer_secondary_pool(r, ENTROPY_BITS(r->pull)/8);
-		if (!r->initialized)
-			return 0;
-	}
-	xfer_secondary_pool(r, nbytes);
-	nbytes = account(r, nbytes, 0, 0);
-
-	while (nbytes) {
-		if (large_request && need_resched()) {
-			if (signal_pending(current)) {
-				if (ret == 0)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			schedule();
-		}
-
-		extract_buf(r, tmp);
-		i = min_t(int, nbytes, EXTRACT_SIZE);
-		if (copy_to_user(buf, tmp, i)) {
-			ret = -EFAULT;
-			break;
-		}
-
-		nbytes -= i;
-		buf += i;
-		ret += i;
-	}
-
-	/* Wipe data just returned from memory */
-	memzero_explicit(tmp, sizeof(tmp));
-
-	return ret;
-}
-
 #define warn_unseeded_randomness(previous) \
 	_warn_unseeded_randomness(__func__, (void *) _RET_IP_, (previous))
 
@@ -1933,7 +1749,6 @@ static void __init init_std_data(struct entropy_store *r)
 	ktime_t now = ktime_get_real();
 	unsigned long rv;
 
-	r->last_pulled = jiffies;
 	mix_pool_bytes(r, &now, sizeof(now));
 	for (i = r->poolinfo->poolbytes; i > 0; i -= sizeof(rv)) {
 		if (!arch_get_random_seed_long(&rv) &&
@@ -1957,7 +1772,6 @@ static void __init init_std_data(struct entropy_store *r)
 int __init rand_initialize(void)
 {
 	init_std_data(&input_pool);
-	init_std_data(&blocking_pool);
 	crng_initialize(&primary_crng);
 	crng_global_init_time = jiffies;
 	if (ratelimit_disable) {
@@ -1985,40 +1799,15 @@ void rand_initialize_disk(struct gendisk *disk)
 #endif
 
 static ssize_t
-_random_read(int nonblock, char __user *buf, size_t nbytes)
+urandom_read_nowarn(struct file *file, char __user *buf, size_t nbytes,
+		    loff_t *ppos)
 {
-	ssize_t n;
-
-	if (nbytes == 0)
-		return 0;
-
-	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
-	while (1) {
-		n = extract_entropy_user(&blocking_pool, buf, nbytes);
-		if (n < 0)
-			return n;
-		trace_random_read(n*8, (nbytes-n)*8,
-				  ENTROPY_BITS(&blocking_pool),
-				  ENTROPY_BITS(&input_pool));
-		if (n > 0)
-			return n;
-
-		/* Pool is (near) empty.  Maybe wait and retry. */
-		if (nonblock)
-			return -EAGAIN;
-
-		wait_event_interruptible(random_read_wait,
-		    blocking_pool.initialized &&
-		    (ENTROPY_BITS(&input_pool) >= random_read_wakeup_bits));
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-	}
-}
+	int ret;
 
-static ssize_t
-random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
-{
-	return _random_read(file->f_flags & O_NONBLOCK, buf, nbytes);
+	nbytes = min_t(size_t, nbytes, INT_MAX >> (ENTROPY_SHIFT + 3));
+	ret = extract_crng_user(buf, nbytes);
+	trace_urandom_read(8 * nbytes, 0, ENTROPY_BITS(&input_pool));
+	return ret;
 }
 
 static ssize_t
@@ -2026,22 +1815,29 @@ urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
 	unsigned long flags;
 	static int maxwarn = 10;
-	int ret;
 
 	if (!crng_ready() && maxwarn > 0) {
 		maxwarn--;
 		if (__ratelimit(&urandom_warning))
-			printk(KERN_NOTICE "random: %s: uninitialized "
-			       "urandom read (%zd bytes read)\n",
-			       current->comm, nbytes);
+			pr_notice("%s: uninitialized urandom read (%zd bytes read)\n",
+				  current->comm, nbytes);
 		spin_lock_irqsave(&primary_crng.lock, flags);
 		crng_init_cnt = 0;
 		spin_unlock_irqrestore(&primary_crng.lock, flags);
 	}
-	nbytes = min_t(size_t, nbytes, INT_MAX >> (ENTROPY_SHIFT + 3));
-	ret = extract_crng_user(buf, nbytes);
-	trace_urandom_read(8 * nbytes, 0, ENTROPY_BITS(&input_pool));
-	return ret;
+
+	return urandom_read_nowarn(file, buf, nbytes, ppos);
+}
+
+static ssize_t
+random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+{
+	int ret;
+
+	ret = wait_for_random_bytes();
+	if (ret != 0)
+		return ret;
+	return urandom_read_nowarn(file, buf, nbytes, ppos);
 }
 
 static __poll_t
@@ -2049,10 +1845,10 @@ random_poll(struct file *file, poll_table * wait)
 {
 	__poll_t mask;
 
-	poll_wait(file, &random_read_wait, wait);
+	poll_wait(file, &crng_init_wait, wait);
 	poll_wait(file, &random_write_wait, wait);
 	mask = 0;
-	if (ENTROPY_BITS(&input_pool) >= random_read_wakeup_bits)
+	if (crng_ready())
 		mask |= EPOLLIN | EPOLLRDNORM;
 	if (ENTROPY_BITS(&input_pool) < random_write_wakeup_bits)
 		mask |= EPOLLOUT | EPOLLWRNORM;
@@ -2143,7 +1939,6 @@ static long random_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
 		input_pool.entropy_count = 0;
-		blocking_pool.entropy_count = 0;
 		return 0;
 	case RNDRESEEDCRNG:
 		if (!capable(CAP_SYS_ADMIN))
@@ -2185,23 +1980,27 @@ SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count,
 {
 	int ret;
 
-	if (flags & ~(GRND_NONBLOCK|GRND_RANDOM))
+	if (flags & ~(GRND_NONBLOCK|GRND_RANDOM|GRND_INSECURE))
+		return -EINVAL;
+
+	/*
+	 * Requesting insecure and blocking randomness at the same time makes
+	 * no sense.
+	 */
+	if ((flags & (GRND_INSECURE|GRND_RANDOM)) == (GRND_INSECURE|GRND_RANDOM))
 		return -EINVAL;
 
 	if (count > INT_MAX)
 		count = INT_MAX;
 
-	if (flags & GRND_RANDOM)
-		return _random_read(flags & GRND_NONBLOCK, buf, count);
-
-	if (!crng_ready()) {
+	if (!(flags & GRND_INSECURE) && !crng_ready()) {
 		if (flags & GRND_NONBLOCK)
 			return -EAGAIN;
 		ret = wait_for_random_bytes();
 		if (unlikely(ret))
 			return ret;
 	}
-	return urandom_read(NULL, buf, count, NULL);
+	return urandom_read_nowarn(NULL, buf, count, NULL);
 }
 
 /********************************************************************
@@ -2214,8 +2013,7 @@ SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count,
 
 #include <linux/sysctl.h>
 
-static int min_read_thresh = 8, min_write_thresh;
-static int max_read_thresh = OUTPUT_POOL_WORDS * 32;
+static int min_write_thresh;
 static int max_write_thresh = INPUT_POOL_WORDS * 32;
 static int random_min_urandom_seed = 60;
 static char sysctl_bootid[16];
@@ -2290,15 +2088,6 @@ struct ctl_table random_table[] = {
 		.proc_handler	= proc_do_entropy,
 		.data		= &input_pool.entropy_count,
 	},
-	{
-		.procname	= "read_wakeup_threshold",
-		.data		= &random_read_wakeup_bits,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= &min_read_thresh,
-		.extra2		= &max_read_thresh,
-	},
 	{
 		.procname	= "write_wakeup_threshold",
 		.data		= &random_write_wakeup_bits,
diff --git a/drivers/char/sunxi-bs83b16c.c b/drivers/char/sunxi-bs83b16c.c
new file mode 100644
index 000000000..e631fdeec
--- /dev/null
+++ b/drivers/char/sunxi-bs83b16c.c
@@ -0,0 +1,504 @@
+/*
+ * drivers/char/sunxi-bs83b16c.c - Allwinner bs83b16c key & led driver
+ *
+ * Copyright (C) 2021 Allwinner Technology Limited. All rights reserved.
+ *       http://www.allwinnertech.com
+ * Author : OuJiayu <OuJiayu@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/pinctrl/pinctrl-sunxi.h>
+#include <linux/input/matrix_keypad.h>
+#include <linux/leds.h>
+#include <linux/err.h>
+#include "sunxi-bs83b16c.h"
+
+static int i2c_write(struct i2c_client *client, unsigned int reg,
+		unsigned int val)
+{
+	return i2c_smbus_write_byte_data(client, reg, val);
+}
+
+static int i2c_read(struct i2c_client *client, unsigned int reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+
+static inline struct led_data *
+		cdev_to_leddata(struct led_classdev *led_cdev)
+{
+	return container_of(led_cdev, struct led_data, cdev);
+}
+
+static inline struct sunxi_bs83b16c_pdata *
+		flag_to_pdata(u8 *flag)
+{
+	return container_of(flag, struct sunxi_bs83b16c_pdata, flag);
+}
+
+static void sunxi_bs83b16c_work_func(struct work_struct *work)
+{
+	struct sunxi_bs83b16c_pdata *pdata = container_of(work,
+				struct sunxi_bs83b16c_pdata, work);
+	struct input_dev *input_dev = pdata->input_dev;
+	struct i2c_client *client = pdata->client;
+	unsigned int new_state[KEY_MAX_COLS];
+	uint32_t bits_changed;
+	int i, j, num, code;
+
+	udelay(pdata->key_scan_udelay * 20);
+	memset(new_state, 0, sizeof(new_state));
+
+	/* save new key state */
+	for (i = 0; i < pdata->key_row_num; i++) {
+		new_state[i] = i2c_read(client, DATA_START + i);
+		udelay(pdata->key_scan_udelay);
+	}
+
+	/* find the change and input report */
+	for (i = 0; i < pdata->key_row_num; i++) {
+		bits_changed = pdata->last_key_state[i] ^ new_state[i];
+		if (bits_changed == 0)
+			continue;
+
+		for (j = 0; j < pdata->key_col_num; j++) {
+			if ((bits_changed & (1 << j)) == 0)
+				continue;
+
+			num = i * pdata->key_row_num + j;
+			code = MATRIX_SCAN_CODE(i, j, pdata->row_shift);
+			input_event(input_dev, EV_MSC, MSC_SCAN, code);
+			input_report_key(input_dev,
+					pdata->keycode[num],
+					new_state[i] & (1 << j));
+		}
+
+	}
+	input_sync(input_dev);
+	memcpy(pdata->last_key_state, new_state, sizeof(new_state));
+
+	spin_lock_irq(&pdata->slock);
+	enable_irq(pdata->int_irq);
+	spin_unlock_irq(&pdata->slock);
+}
+
+static irqreturn_t sunxi_bs83b16c_handler(int irq, void *data)
+{
+	struct sunxi_bs83b16c_pdata *pdata = data;
+
+	disable_irq_nosync(pdata->int_irq);
+
+	schedule_work(&pdata->work);
+
+	return IRQ_HANDLED;
+}
+
+static void sunxi_bs83b16c_led_set(struct led_classdev *led_cdev,
+			enum led_brightness value)
+{
+	struct led_data *leds = cdev_to_leddata(led_cdev);
+	struct sunxi_bs83b16c_pdata *pdata =
+		flag_to_pdata(leds->flag);
+	int ret;
+	unsigned int data;
+
+	data = i2c_read(pdata->client, DATA_END - leds->row);
+	udelay(5*100);
+
+	if (value == LED_OFF) {
+		data &= ~(1 << leds->col);
+	} else {
+		data |= 1 << leds->col;
+	}
+
+	ret = i2c_write(pdata->client, DATA_END - leds->row, data);
+	if (ret < 0)
+		dev_err(&pdata->client->dev, "i2c write led data failed\n");
+}
+
+static int sunxi_bs83b16c_led_set_blocking(struct led_classdev *led_cdev,
+			enum led_brightness value)
+{
+	sunxi_bs83b16c_led_set(led_cdev, value);
+	return 0;
+}
+
+static int sunxi_bs83b16c_set_keypin(struct i2c_client *client,
+			struct device_node *np,
+			struct sunxi_bs83b16c_pdata *pdata)
+{
+	struct device *dev = &client->dev;
+	int gpio, irq, ret;
+
+	gpio = of_get_named_gpio(np, "int-gpio", 0);
+	if (gpio < 0) {
+		dev_err(dev, "get int-gpio failed\n");
+		return -1;
+	}
+
+	ret = pinctrl_pm_select_default_state(dev);
+	if (ret) {
+		dev_err(dev, "set int gpio pin function failed\n");
+		return -1;
+	}
+
+	irq = gpio_to_irq(gpio);
+
+	pdata->int_irq = irq;
+
+	ret = request_irq(irq, sunxi_bs83b16c_handler,
+			IRQF_TRIGGER_FALLING | IRQF_SHARED,
+			dev_name(dev), pdata);
+	if (ret) {
+		dev_err(dev, "request_irq for int-gpio failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sunxi_bs83b16c_led_register(struct sunxi_bs83b16c_pdata *pdata,
+			struct i2c_client *client, int i)
+{
+	struct device *dev = &client->dev;
+	struct led_classdev *cdev;
+	int ret;
+
+	pdata->leds[i].row = i / pdata->led_row_num;
+	pdata->leds[i].col = i % pdata->led_row_num;
+	pdata->leds[i].flag = &pdata->flag;
+	cdev = &pdata->leds[i].cdev;
+
+	cdev->brightness_set = sunxi_bs83b16c_led_set;
+	cdev->brightness_set_blocking = sunxi_bs83b16c_led_set_blocking;
+	cdev->name = kzalloc(8, GFP_KERNEL);
+	sprintf((char *)cdev->name, "mled%d", i);
+	cdev->dev = dev;
+
+	ret = devm_led_classdev_register(dev, cdev);
+	if (ret < 0) {
+		dev_err(dev, "class register failed %s\n", cdev->name);
+		return ret;
+	}
+	udelay(1*1000);
+	return 0;
+}
+
+static int sunxi_bs83b16c_led_unregister(struct sunxi_bs83b16c_pdata *pdata)
+{
+	int i, led_cnt;
+	led_cnt = pdata->led_row_num * pdata->led_col_num;
+
+	for (i = 0; i < led_cnt; i++) {
+		kfree(pdata->leds[i].cdev.name);
+		led_classdev_unregister(&pdata->leds[i].cdev);
+		udelay(5*100);
+	}
+	return 0;
+}
+
+static int sunxi_bs83b16c_set_func(struct i2c_client *client,
+			struct sunxi_bs83b16c_pdata *pdata)
+{
+	int ret;
+	unsigned int num;
+
+	if ((unsigned int)(pdata->func >> KEY_FUNC) & 1) {
+		num = (pdata->key_row_num << 4) | pdata->key_col_num;
+		ret = i2c_write(client, KEY_HV_INIT, num);
+		if (ret)
+			return -1;
+	}
+
+	if ((unsigned int)(pdata->func >> LED_FUNC) & 1) {
+		num = (pdata->led_row_num << 4) | pdata->led_col_num;
+		ret = i2c_write(client, LED_HV_INIT, num);
+		if (ret)
+			return -1;
+	}
+
+	return 0;
+}
+
+static int sunxi_bs83b16c_enable_func(struct i2c_client *client,
+			struct sunxi_bs83b16c_pdata *pdata)
+{
+	unsigned int tmp;
+	int ret;
+
+	if ((unsigned int)(pdata->func >> KEY_FUNC) & 1) {
+		tmp = i2c_read(client, KEY_HV_INIT);
+		if (tmp) {
+			ret = i2c_write(client, KEY_EN_REG, 1);
+			if (ret)
+				return -1;
+		}
+	}
+
+	if ((unsigned int)(pdata->func >> LED_FUNC) & 1) {
+		tmp = i2c_read(client, LED_HV_INIT);
+		if (tmp) {
+			ret = i2c_write(client, LED_EN_REG, 1);
+			if (ret)
+				return -1;
+		}
+	}
+
+	return 0;
+}
+
+static void sunxi_bs83b16c_set_input_code(struct sunxi_bs83b16c_pdata *pdata)
+{
+	int i = 0;
+	int keysize = pdata->key_row_num * pdata->key_col_num;
+
+	for (i = 0; i < keysize; i++) {
+		input_set_capability(pdata->input_dev,
+				EV_KEY, pdata->keycode[i]);
+	}
+}
+
+struct sunxi_bs83b16c_pdata *of_get_bs83b16c_pdata(struct i2c_client *client,
+			struct device_node *np)
+{
+	struct sunxi_bs83b16c_pdata *pdata;
+	struct device *dev = &client->dev;
+	int keysize, i;
+	unsigned int *keycode;
+
+	pdata = devm_kzalloc(dev, sizeof(pdata), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(pdata)) {
+		dev_err(dev, "could not allocate memory for platform data\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	if (of_property_read_u32(np, "func", &pdata->func)) {
+		dev_err(dev, "could not read func from dts, please check\n");
+		goto free_pdata;
+	}
+
+	if (pdata->func == 0) {
+		dev_warn(dev, "func = 0, driver does not need to be load\n");
+		goto free_pdata;
+	}
+
+	if ((unsigned int)(pdata->func >> KEY_FUNC) & 1) {
+		if (of_property_read_u32(np, "key_scan_udelay", &pdata->key_scan_udelay))
+			pdata->key_scan_udelay = 0;
+		of_property_read_u32(np, "key_row_num", &pdata->key_row_num);
+		of_property_read_u32(np, "key_col_num", &pdata->key_col_num);
+		if (pdata->key_row_num == 0 || pdata->key_col_num == 0) {
+			dev_err(dev, "could not read key num from dts\n");
+			goto free_pdata;
+		}
+
+		keysize = pdata->key_row_num * pdata->key_col_num;
+		keycode = devm_kzalloc(dev, sizeof(unsigned int) * keysize,
+				GFP_KERNEL);
+		if (IS_ERR_OR_NULL(pdata)) {
+			dev_err(dev, "could not allocate memory for keycode\n");
+			goto free_pdata;
+		}
+
+		of_property_read_u32_array(np, "keymap", keycode, keysize);
+		if (!keycode) {
+			dev_err(dev, "could not read keymap form dts\n");
+			goto free_pdata;
+		}
+
+		for (i = 0; i < keysize; i++) {
+			keycode[i] = keycode[i] & 0x0000ffff;
+		}
+
+		pdata->keycode = keycode;
+	}
+
+	if ((unsigned int)(pdata->func >> LED_FUNC) & 1) {
+		of_property_read_u32(np, "led_row_num", &pdata->led_row_num);
+		of_property_read_u32(np, "led_col_num", &pdata->led_col_num);
+		if (pdata->led_row_num == 0 || pdata->led_col_num == 0) {
+			dev_err(dev, "could not read led num from dts\n");
+			goto free_pdata;
+		}
+	}
+
+	return pdata;
+
+free_pdata:
+	kfree(pdata);
+	return ERR_PTR(-1);
+}
+
+static int sunxi_bs83b16c_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct sunxi_bs83b16c_pdata *pdata;
+	struct device_node *np = dev->of_node;
+	struct input_dev *input_dev;
+	int ret, led_cnt, i;
+	ssize_t size;
+
+	if (!np) {
+		dev_err(dev, "device lacks DT data\n");
+		return -ENODEV;
+	}
+
+	pdata = of_get_bs83b16c_pdata(client, np);
+	if (IS_ERR(pdata)) {
+		dev_err(dev, "get bs83b16c platform data failed\n");
+		return -1;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		ret = -ENOMEM;
+		goto pdata_err;
+	}
+	pdata->input_dev = input_dev;
+	pdata->client = client;
+	pdata->flag = 1;
+
+	input_dev->name = client->name;
+	input_dev->id.bustype   = BUS_HOST;
+	input_dev->dev.parent   = dev;
+
+	/* check i2c dev */
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(dev, "SMBUS Byte Data not Supported\n");
+		ret = -EIO;
+		goto pdata_err;
+	}
+
+	INIT_WORK(&pdata->work, sunxi_bs83b16c_work_func);
+	spin_lock_init(&pdata->slock);
+
+	if ((unsigned int)(pdata->func >> KEY_FUNC) & 1) {
+		pdata->row_shift = get_count_order(pdata->key_col_num);
+		for (i = 0; i < pdata->key_row_num; i++)
+			pdata->last_key_state[i] = 0;
+
+		ret = sunxi_bs83b16c_set_keypin(client, np, pdata);
+		if (ret < 0) {
+			dev_err(dev, "sunxi_bs83b16c_set_keypin failed\n");
+			goto pdata_err;
+		}
+	}
+
+	if ((unsigned int)(pdata->func >> LED_FUNC) & 1) {
+		led_cnt = pdata->led_row_num * pdata->led_col_num;
+		size = sizeof(struct led_data) * led_cnt;
+		pdata->leds = devm_kzalloc(dev, size, GFP_KERNEL);
+		if (!pdata->leds) {
+			dev_err(dev, "could not allocate for leds data\n");
+			ret = -ENOMEM;
+			goto pdata_err;
+		}
+
+		for (i = 0; i < led_cnt; i++) {
+			ret = sunxi_bs83b16c_led_register(pdata, client, i);
+			if (ret < 0) {
+				dev_err(dev,
+					"sunxi_bs83b16c_led_register failed\n");
+				goto pdata_err;
+			}
+		}
+	}
+
+	ret = sunxi_bs83b16c_set_func(client, pdata);
+	if (ret < 0) {
+		dev_err(dev, "i2c set mcu func failed\n");
+		goto led_err;
+	}
+
+	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
+	input_set_drvdata(input_dev, pdata);
+	sunxi_bs83b16c_set_input_code(pdata);
+
+	ret = input_register_device(pdata->input_dev);
+	if (ret) {
+		dev_err(dev, "input_register_device failed\n");
+		goto input_err;
+	}
+
+	ret = sunxi_bs83b16c_enable_func(client, pdata);
+	if (ret < 0) {
+		dev_err(dev, "i2c enable func failed\n");
+		goto input_err;
+	}
+
+	i2c_set_clientdata(client, pdata);
+
+	return 0;
+
+input_err:
+	input_free_device(input_dev);
+led_err:
+	sunxi_bs83b16c_led_unregister(pdata);
+pdata_err:
+	kfree(pdata);
+	return ret;
+}
+
+static int sunxi_bs83b16c_remove(struct i2c_client *client)
+{
+	struct sunxi_bs83b16c_pdata *pdata = i2c_get_clientdata(client);
+
+	if ((unsigned int)(pdata->func >> KEY_FUNC) & 1)
+		input_unregister_device(pdata->input_dev);
+	if ((unsigned int)(pdata->func >> LED_FUNC) & 1)
+		sunxi_bs83b16c_led_unregister(pdata);
+
+	kfree(pdata);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_bs83b16c_dt_ids[] = {
+	{.compatible = "allwinner,sunxi-bs83b16c"},
+	{},
+};
+
+static struct i2c_driver sunxi_bs83b16c_driver = {
+	.driver = {
+		.name = "sunxi_bs83b16c",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_bs83b16c_dt_ids,
+	},
+	.probe = sunxi_bs83b16c_probe,
+	.remove = sunxi_bs83b16c_remove,
+};
+
+static int __init sunxi_bs83b16c_init(void)
+{
+	return i2c_add_driver(&sunxi_bs83b16c_driver);
+}
+late_initcall(sunxi_bs83b16c_init);
+
+static void __exit sunxi_bs83b16c_exit(void)
+{
+	i2c_del_driver(&sunxi_bs83b16c_driver);
+}
+module_exit(sunxi_bs83b16c_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
+MODULE_DESCRIPTION("BS83B16C MCU driver for matrix key and matrix led");
+MODULE_AUTHOR("OuJiayu@allwinnertech.com");
diff --git a/drivers/char/sunxi-bs83b16c.h b/drivers/char/sunxi-bs83b16c.h
new file mode 100644
index 000000000..1cd1f8877
--- /dev/null
+++ b/drivers/char/sunxi-bs83b16c.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2021 Allwinner Technology Limited. All rights reserved.
+ * OuJiayu <OuJiayu@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __LINUX_SUNXI_BS83B16C_H
+#define __LINUX_SUNXI_BS83B16C_H
+
+#define KEY_FUNC	0
+#define LED_FUNC	1
+
+#define DATA_START	0x00
+#define DATA_END	0x07
+
+#define	KEY_EN_REG	0x08
+#define KEY_HV_INIT	0x09
+#define KEY_STATE	0x0a
+#define KEY_HV		0x0b
+
+#define LED_EN_REG	0x0c
+#define LED_HV_INIT	0x0d
+#define LED_STATE	0x0e
+#define LED_HV		0x0f
+
+#define DELAY_REG	0x10
+#define FILTER_REG	0x11
+
+#define PIN_PB0		8
+#define PIN_PC0		16
+
+#define KEY_MAX_COLS	16
+#define LED_MAX_CNT	64
+
+struct led_data {
+	struct led_classdev cdev;
+	unsigned int row;
+	unsigned int col;
+	u8 *flag;
+};
+
+struct sunxi_bs83b16c_pdata {
+	struct i2c_client	*client;
+	struct input_dev	*input_dev;
+	struct work_struct	work;
+	spinlock_t		slock;
+	struct led_classdev	cdev;
+	struct led_data		*leds;
+
+	unsigned int		*keycode;
+	unsigned int		func;
+	unsigned int		key_row_num;
+	unsigned int		key_col_num;
+	unsigned int		led_row_num;
+	unsigned int		led_col_num;
+	int			row_shift;
+	int			int_irq;
+	u8			flag;
+	unsigned int		key_scan_udelay;
+	unsigned int		last_key_state[KEY_MAX_COLS];
+};
+
+#endif
diff --git a/drivers/char/sunxi-di/Kconfig b/drivers/char/sunxi-di/Kconfig
new file mode 100644
index 000000000..3e65e4f2c
--- /dev/null
+++ b/drivers/char/sunxi-di/Kconfig
@@ -0,0 +1,32 @@
+menuconfig SUNXI_DI
+	tristate "Allwinnertech DE-Interlace Driver"
+	default n
+	help
+	  This is an option for de-interlace.
+
+config SUNXI_DI_V1XX
+  bool "Support DI V110/120"
+  depends on (SUNXI_DI)
+  default n
+  ---help---
+  Say Y here if you want to use DI110/120.
+  Say N here if you do NOT want to use DI110/120.
+  If unsure, say N.
+
+config SUNXI_DI_V2X
+  bool "Support DI V200"
+  depends on (SUNXI_DI)
+  default n
+  ---help---
+  Say Y here if you want to use DI200.
+  Say N here if you do NOT want to use DI200.
+  If unsure, say N.
+
+config SUNXI_DI_V3X
+  bool "Support DI V300"
+  depends on (SUNXI_DI)
+  default n
+  ---help---
+  Say Y here if you want to use DI300.
+  Say N here if you do NOT want to use DI300.
+  If unsure, say N.
diff --git a/drivers/char/sunxi-di/Makefile b/drivers/char/sunxi-di/Makefile
new file mode 100644
index 000000000..225fe5ab1
--- /dev/null
+++ b/drivers/char/sunxi-di/Makefile
@@ -0,0 +1,22 @@
+obj-$(CONFIG_SUNXI_DI) += deinterlace.o
+
+ifeq ($(CONFIG_SUNXI_DI_V1XX),y)
+sub_dir = drv_div1xx
+endif
+
+ifeq ($(CONFIG_SUNXI_DI_V2X),y)
+sub_dir = drv_div2x
+endif
+
+ifeq ($(CONFIG_SUNXI_DI_V3X),y)
+sub_dir = drv_div3x
+endif
+
+ifneq ($(sub_dir),)
+-include $(obj)/$(sub_dir)/Makefile
+
+deinterlace-y += common/di_utils.o
+deinterlace-y += $(sunxi_di)
+
+endif
+
diff --git a/drivers/char/sunxi-di/common/di_debug.h b/drivers/char/sunxi-di/common/di_debug.h
new file mode 100644
index 000000000..39fe93dd6
--- /dev/null
+++ b/drivers/char/sunxi-di/common/di_debug.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_DEBUG_H_
+#define _DI_DEBUG_H_
+
+#include <linux/printk.h>
+
+#if defined(CONFIG_FPGA_V4_PLATFORM) || defined(CONFIG_FPGA_V7_PLATFORM)
+#define DI_FPGA_TEST
+#endif
+
+/*
+ * debug control, you can switch on (delete 'x' suffix)
+ * to enable log output and assert mechanism.
+ */
+#define CONFIG_ENABLE_DEBUG
+
+#define PRINT printk
+
+/*
+ * debug level,
+ * if is DEBUG_LEVEL_DISABLE, no log is allowed output,
+ * if is DEBUG_LEVEL_ERR, only ERR is allowed output,
+ * if is DEBUG_LEVEL_INFO, ERR and INFO are allowed output,
+ * if is DEBUG_LEVEL_DEBUG, all log are allowed output,
+ */
+enum debug_level {
+	DEBUG_LEVEL_DISABLE = 0,
+	DEBUG_LEVEL_ERR,
+	DEBUG_LEVEL_INFO,
+	DEBUG_LEVEL_DEBUG,
+	DEBUG_LEVEL_TEST,
+	DEBUG_LEVEL_FMD,
+	DEBUG_LEVEL_MAX,
+};
+
+extern int debug_mask;
+
+#define DI_ERR(...)                      \
+do {                                     \
+	if (debug_mask >= DEBUG_LEVEL_ERR \
+		&& debug_mask < DEBUG_LEVEL_TEST) { \
+		PRINT(__VA_ARGS__);              \
+	}                                    \
+} while (0)
+
+#define DI_INFO(...)                      \
+do {                                      \
+	if (debug_mask >= DEBUG_LEVEL_INFO \
+		&& debug_mask < DEBUG_LEVEL_TEST) { \
+		PRINT(__VA_ARGS__);               \
+	}                                     \
+} while (0)
+
+#define DI_DEBUG(...)                      \
+do {                                       \
+	if (debug_mask >= DEBUG_LEVEL_DEBUG \
+		&& debug_mask < DEBUG_LEVEL_TEST) { \
+		PRINT(__VA_ARGS__);                \
+	}                                      \
+} while (0)
+
+#define DI_TEST(...)                      \
+do {                                       \
+	if (debug_mask == DEBUG_LEVEL_TEST) { \
+		PRINT(__VA_ARGS__);                \
+	}                                      \
+} while (0)
+
+#define DI_FMD(...)                      \
+do {                                       \
+	if (debug_mask == DEBUG_LEVEL_FMD \
+		|| debug_mask == DEBUG_LEVEL_DEBUG) { \
+		PRINT(__VA_ARGS__);                \
+	}                                      \
+} while (0)
+#endif /* _DI_DEBUG_H_ */
diff --git a/drivers/char/sunxi-di/common/di_utils.c b/drivers/char/sunxi-di/common/di_utils.c
new file mode 100644
index 000000000..875ff14a3
--- /dev/null
+++ b/drivers/char/sunxi-di/common/di_utils.c
@@ -0,0 +1,373 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "di_utils.h"
+#include "di_debug.h"
+
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <drm/drm_fourcc.h>
+
+static struct device *dma_dev;
+
+void di_utils_set_dma_dev(struct device *dev)
+{
+	dma_dev = dev;
+}
+
+
+static struct info_mem di_mem[MAX_DI_MEM_INDEX];
+void *di_malloc(__u32 bytes_num, uintptr_t *phy_addr)
+{
+	void *address = NULL;
+
+#if defined(CONFIG_ION_SUNXI)
+	u32 actual_bytes;
+
+	if (bytes_num != 0) {
+		actual_bytes = PAGE_ALIGN(bytes_num);
+
+		address = dma_alloc_coherent(dma_dev, actual_bytes,
+					     (dma_addr_t *) phy_addr,
+					     GFP_KERNEL);
+		if (address) {
+			DI_INFO("dma_alloc_coherent ok, address=0x%p, size=0x%x\n",
+			    (void *)(*(unsigned long *)phy_addr), bytes_num);
+			return address;
+		}
+
+		DI_ERR("dma_alloc_coherent fail, size=0x%x\n", bytes_num);
+		return NULL;
+	}
+	DI_ERR("%s size is zero\n", __func__);
+#else
+	unsigned map_size = 0;
+	struct page *page;
+
+	if (bytes_num != 0) {
+		map_size = PAGE_ALIGN(bytes_num);
+		page = alloc_pages(GFP_KERNEL, get_order(map_size));
+		if (page != NULL) {
+			address = page_address(page);
+			if (address == NULL) {
+				free_pages((unsigned long)(page),
+					   get_order(map_size));
+				DI_ERR("page_address fail!\n");
+				return NULL;
+			}
+			*phy_addr = virt_to_phys(address);
+			return address;
+		}
+		DI_ERR("alloc_pages fail!\n");
+		return NULL;
+	}
+	DI_ERR("%s size is zero\n", __func__);
+#endif
+
+	return NULL;
+}
+
+void di_free(void *virt_addr, void *phy_addr, unsigned int size)
+{
+#if defined(CONFIG_ION_SUNXI)
+	u32 actual_bytes;
+
+	actual_bytes = PAGE_ALIGN(size);
+	if (phy_addr && virt_addr)
+		dma_free_coherent(dma_dev, actual_bytes, virt_addr,
+				  (dma_addr_t) phy_addr);
+#else
+	unsigned map_size = PAGE_ALIGN(size);
+	unsigned page_size = map_size;
+
+	if (virt_addr == NULL)
+		return;
+
+	free_pages((unsigned long)virt_addr, get_order(page_size));
+#endif
+}
+
+__s32 di_get_free_mem_index(void)
+{
+	__u32 i = 0;
+
+	for (i = 0; i < MAX_DI_MEM_INDEX; i++) {
+		if (di_mem[i].b_used == 0)
+			return i;
+	}
+	return -1;
+}
+
+int di_mem_request(__u32 size, u64 *phyaddr)
+{
+	__s32 sel;
+	unsigned long ret = 0;
+	uintptr_t phy_addr;
+
+	sel = di_get_free_mem_index();
+	if (sel < 0) {
+		DI_ERR("di_get_free_mem_index fail!\n");
+		return -EINVAL;
+	}
+
+	ret = (unsigned long)di_malloc(size, &phy_addr);
+	if (ret != 0) {
+		di_mem[sel].virt_addr = (void *)ret;
+		memset(di_mem[sel].virt_addr, 0, size);
+		di_mem[sel].phy_addr = phy_addr;
+		di_mem[sel].mem_len = size;
+		di_mem[sel].b_used = 1;
+		*phyaddr = phy_addr;
+
+		DI_INFO("map_di_memory[%d]: pa=%08lx va=%p size:%x\n", sel,
+		     di_mem[sel].phy_addr, di_mem[sel].virt_addr, size);
+		return sel;
+	}
+	DI_ERR("fail to alloc reserved memory!\n");
+	return -ENOMEM;
+}
+
+int di_mem_release(__u32 sel)
+{
+	if (di_mem[sel].b_used == 0) {
+		DI_ERR("mem not used in di_mem_release,%d\n", sel);
+		return -EINVAL;
+	}
+
+	di_free((void *)di_mem[sel].virt_addr, (void *)di_mem[sel].phy_addr,
+		 di_mem[sel].mem_len);
+	memset(&di_mem[sel], 0, sizeof(struct info_mem));
+
+	return 0;
+}
+
+static struct di_dma_item *di_dma_item_create(
+	struct dma_buf *dmabuf,
+	struct dma_buf_attachment *attach,
+	struct sg_table *sgt,
+	enum dma_data_direction dir)
+{
+	struct di_dma_item *item;
+	struct sg_table *sgt_bak;
+	struct scatterlist *sgl, *sgl_bak;
+	s32 sg_count = 0;
+	int i;
+
+	/*DEFINE_DMA_ATTRS(attrs);
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);*/
+
+	item = kzalloc(sizeof(*item), GFP_KERNEL);
+	if (item == NULL) {
+		DI_ERR(TAG"alloc mem for dma_item fail\n");
+		return NULL;
+	}
+
+	sgt_bak = kzalloc(sizeof(*sgt_bak), GFP_KERNEL);
+	if (sgt_bak == NULL) {
+		DI_ERR(TAG"alloc mem for sgt_bak fail\n");
+		goto err_item_kfree;
+	}
+	if (sg_alloc_table(sgt_bak, sgt->nents, GFP_KERNEL)) {
+		DI_ERR(TAG"alloc sgt fail\n");
+		goto err_sgt_kfree;
+	}
+
+	sgl_bak = sgt_bak->sgl;
+	for_each_sg(sgt->sgl, sgl, sgt->nents, i)  {
+		sg_set_page(sgl_bak, sg_page(sgl), sgl->length, sgl->offset);
+		sgl_bak = sg_next(sgl_bak);
+	}
+	sg_count = dma_map_sg_attrs(dma_dev,
+		sgt_bak->sgl, sgt_bak->nents, dir, DMA_ATTR_SKIP_CPU_SYNC);
+	if (sg_count != 1) {
+		DI_ERR(TAG"dma_map_sg_attrs failed:%d\n", sg_count);
+		goto err_free_sgt;
+	}
+
+	item->buf = dmabuf;
+	item->attach = attach;
+	item->sgt_org = sgt;
+	item->sgt_bak = sgt_bak;
+	item->dir = dir;
+	item->dma_addr = sg_dma_address(sgt_bak->sgl);
+
+	return item;
+
+err_free_sgt:
+	sg_free_table(sgt_bak);
+
+err_sgt_kfree:
+	kfree(sgt_bak);
+
+err_item_kfree:
+	kfree(item);
+
+	return NULL;
+}
+
+struct di_dma_item *di_dma_buf_self_map(
+	int fd, enum dma_data_direction dir)
+{
+	struct di_dma_item *dma_item = NULL;
+
+	struct dma_buf *dmabuf = NULL;
+	struct dma_buf_attachment *attach = NULL;
+	struct sg_table *sgt = NULL;
+
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		DI_ERR(TAG"dma buf get fail. fd=%d\n", fd);
+		return NULL;
+	}
+
+	attach = dma_buf_attach(dmabuf, dma_dev);
+	if (IS_ERR(attach)) {
+		DI_ERR(TAG"dma buf attach fail\n");
+		goto out_buf_put;
+	}
+
+	sgt = dma_buf_map_attachment(attach, dir);
+	if (IS_ERR_OR_NULL(sgt)) {
+		DI_ERR(TAG"dma_buf_map_attachment fail\n");
+		goto out_buf_detach;
+	}
+
+	dma_item = di_dma_item_create(dmabuf, attach, sgt, dir);
+	if (dma_item != NULL)
+		return dma_item;
+
+/* out_buf_unmap: */
+	dma_buf_unmap_attachment(attach, sgt, dir);
+
+out_buf_detach:
+	dma_buf_detach(dmabuf, attach);
+
+out_buf_put:
+	dma_buf_put(dmabuf);
+
+	return dma_item;
+}
+
+void di_dma_buf_self_unmap(struct di_dma_item *item)
+{
+	/*DEFINE_DMA_ATTRS(attrs);
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);*/
+
+	dma_unmap_sg_attrs(dma_dev, item->sgt_bak->sgl,
+		item->sgt_bak->nents, item->dir, DMA_ATTR_SKIP_CPU_SYNC);
+	dma_buf_unmap_attachment(item->attach,
+		item->sgt_bak, item->dir);
+	sg_free_table(item->sgt_bak);
+	kfree(item->sgt_bak);
+	dma_buf_detach(item->buf, item->attach);
+	dma_buf_put(item->buf);
+
+	kfree(item);
+}
+
+struct di_mapped_buf *di_dma_buf_alloc_map(u32 size)
+{
+	struct di_mapped_buf *mbuf =
+		kzalloc(sizeof(*mbuf), GFP_KERNEL);
+
+	if (mbuf == NULL) {
+		DI_ERR(TAG"kzalloc for mapped buf fail, size=%d\n",
+			(u32)sizeof(*mbuf));
+		return NULL;
+	}
+
+	mbuf->size_request = size;
+	mbuf->size_alloced = DI_ALIGN(size, 2);
+	mbuf->vir_addr = dma_alloc_coherent(dma_dev,
+		mbuf->size_alloced, &mbuf->dma_addr, GFP_KERNEL);
+	if (mbuf->vir_addr == NULL) {
+		DI_ERR(TAG"dma_alloc_coherent fail, size=0x%x->0x%x\n",
+			mbuf->size_request, mbuf->size_alloced);
+		kfree(mbuf);
+		return NULL;
+	}
+
+	DI_DEBUG(TAG"%s: addr[%p,%x], size=0x%x\n", __func__,
+		mbuf->vir_addr, (unsigned int)mbuf->dma_addr, mbuf->size_alloced);
+
+	return mbuf;
+}
+
+void di_dma_buf_unmap_free(struct di_mapped_buf *mbuf)
+{
+	DI_DEBUG(TAG"%s: addr[%p,%x], size=0x%x\n", __func__,
+		mbuf->vir_addr, (unsigned int)mbuf->dma_addr, mbuf->size_alloced);
+	dma_free_coherent(dma_dev, mbuf->size_alloced,
+		mbuf->vir_addr, mbuf->dma_addr);
+	kfree(mbuf);
+}
+
+const char *di_format_to_string(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_YUV420:
+		return "YU12";
+	case DRM_FORMAT_YVU420:
+		return "YV12";
+	case DRM_FORMAT_YUV422:
+		return "YU16";
+	case DRM_FORMAT_YVU422:
+		return "YV16";
+	case DRM_FORMAT_NV12:
+		return "NV12";
+	case DRM_FORMAT_NV21:
+		return "NV21";
+	case DRM_FORMAT_NV16:
+		return "NV16";
+	case DRM_FORMAT_NV61:
+		return "NV61";
+	default:
+		DI_INFO(TAG"%s format(0x%x)\n", __func__, format);
+		return "unknown format";
+	}
+}
+
+u32 di_format_get_planar_num(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		return 3;
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+		return 2;
+	default:
+		DI_INFO(TAG"%s:%s\n", __func__,
+			di_format_to_string(format));
+		return 1;
+	}
+}
+
+u32 di_format_get_uvseq(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV61:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_YVU422:
+		/* TODO: add more format to support */
+		return DI_UVSEQ_VU;
+	default:
+		return DI_UVSEQ_UV;
+	}
+}
diff --git a/drivers/char/sunxi-di/common/di_utils.h b/drivers/char/sunxi-di/common/di_utils.h
new file mode 100644
index 000000000..b85f03a3e
--- /dev/null
+++ b/drivers/char/sunxi-di/common/di_utils.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_UTILS_H_
+#define _DI_UTILS_H_
+
+#include <linux/types.h>
+#include <linux/dma-buf.h>
+
+#define TAG "[DI_UTILS]"
+#define DI_ALIGN(value, align) ((align == 0) ? \
+				value : \
+				(((value) + ((align) - 1)) & ~((align) - 1)))
+
+#define MAX_DI_MEM_INDEX       100
+
+#define DI_TASK_CNT_MAX DI_CLIENT_CNT_MAX
+
+struct info_mem {
+	unsigned long phy_addr;
+	void *virt_addr;
+	__u32 b_used;
+	__u32 mem_len;
+};
+
+struct di_dma_item {
+	struct dma_buf *buf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt_org;
+	struct sg_table *sgt_bak;
+	enum dma_data_direction dir;
+	dma_addr_t dma_addr;
+};
+
+struct di_mapped_buf {
+	u32 size_request;
+	u32 size_alloced;
+	void *vir_addr;
+	dma_addr_t dma_addr;
+};
+
+void di_utils_set_dma_dev(struct device *dev);
+
+int di_mem_release(__u32 sel);
+int di_mem_request(__u32 size, u64 *phyaddr);
+
+struct di_dma_item *di_dma_buf_self_map(
+	int fd, enum dma_data_direction dir);
+void di_dma_buf_self_unmap(struct di_dma_item *item);
+
+struct di_mapped_buf *di_dma_buf_alloc_map(u32 size);
+void di_dma_buf_unmap_free(struct di_mapped_buf *mbuf);
+
+
+enum {
+	DI_UVSEQ_UV = 0, /* uv-combined: LSB U0V0U1V1 MSB */
+	DI_UVSEQ_VU = 1, /* uv-combined: LSB V0U0V1U1 MSB */
+};
+
+const char *di_format_to_string(u32 format);
+u32 di_format_get_planar_num(u32 format);
+u32 di_format_get_uvseq(u32 format);
+
+#endif /* #ifndef _DI_UTILS_H_ */
diff --git a/drivers/char/sunxi-di/drv_div1xx/Makefile b/drivers/char/sunxi-di/drv_div1xx/Makefile
new file mode 100644
index 000000000..ece22398f
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/Makefile
@@ -0,0 +1,5 @@
+sunxi_di_dir := drv_div1xx
+sunxi_di := $(sunxi_di_dir)/di_driver.o  \
+			$(sunxi_di_dir)/di_client.o \
+			$(sunxi_di_dir)/di_fops.o \
+			$(sunxi_di_dir)/di110.o
diff --git a/drivers/char/sunxi-di/drv_div1xx/di110.c b/drivers/char/sunxi-di/drv_div1xx/di110.c
new file mode 100644
index 000000000..6ee36a7b7
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di110.c
@@ -0,0 +1,382 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/delay.h>
+
+#include "../common/di_utils.h"
+#include "../common/di_debug.h"
+#include "di_client.h"
+#include "di110_reg.h"
+#include "di110.h"
+
+static struct di_reg *di_reg_base;
+static struct di_process_fb_arg current_fb_arg;
+
+static struct di_reg *di_dev_get_reg_base(void)
+{
+	return di_reg_base;
+}
+
+void di_dev_set_reg_base(void __iomem *reg_base)
+{
+	di_reg_base = (struct di_reg *)reg_base;
+}
+
+void di_dev_exit(void)
+{
+	di_reg_base = 0;
+}
+
+static void di_dev_dump_reg_value(void)
+{
+	unsigned int *addr;
+	unsigned long i;
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	addr = (unsigned int *)reg;
+
+	DI_INFO("GENERAL TOP REG(0x00~0x18):\n");
+	for (i = 0x0; i <= 0x18; i += 4) {
+		DI_INFO("0x%02lx:0x%08x ", i, *((unsigned int *)((unsigned long)addr + i)));
+	}
+	DI_INFO("\n");
+
+	DI_INFO("PITCH REG(0x1c~0x34):\n");
+	for (i = 0x1c; i <= 0x34; i += 4) {
+		DI_INFO("0x%02lx:0x%08x ", i, *((unsigned int *)((unsigned long)addr + i)));
+	}
+	DI_INFO("\n");
+
+	DI_INFO("ADDRESS REG:(0x38~0x7c)\n");
+	for (i = 0x38; i <= 0x7c; i += 4) {
+		DI_INFO("0x%02lx:0x%08x ", i, *((unsigned int *)((unsigned long)addr + i)));
+	}
+	DI_INFO("\n");
+
+	DI_INFO("OTHER REGS(0x80~0xa0):\n");
+	for (i = 0x80; i <= 0xa0; i += 4) {
+		DI_INFO("0x%02lx:0x%08x ", i, *((unsigned int *)((unsigned long)addr + i)));
+	}
+	DI_INFO("\n");
+}
+
+static bool di_dev_work_mode_is_change(struct di_process_fb_arg *fb_arg)
+{
+	if ((fb_arg->is_interlace != current_fb_arg.is_interlace)
+		|| (fb_arg->field_order != current_fb_arg.field_order)
+		|| (fb_arg->pixel_format != current_fb_arg.pixel_format)
+		|| (fb_arg->size.width != current_fb_arg.size.width)
+		|| (fb_arg->size.height != current_fb_arg.size.height)) {
+		DI_INFO("DI device work mode changes!\n ");
+		return true;
+	}
+
+	return false;
+}
+
+/*
+* convert format to the format that indecated in DI HW
+*/
+static u32 di_dev_convert_fmt(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+		return YUV420_PLANNER;
+
+	case DRM_FORMAT_NV12:
+		return YUV420_NV12;
+
+	case DRM_FORMAT_NV21:
+		return YUV420_NV21;
+
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		return YUV422_PLANNER;
+
+	case DRM_FORMAT_NV16:
+		return YUV422_NV16;
+
+	case DRM_FORMAT_NV61:
+		return YUV422_NV61;
+	default:
+		DI_ERR(TAG"unknown format=%s(0x%x)\n",
+			di_format_to_string(format), format);
+		return 0;
+	}
+}
+
+static u8 di_get_format_type(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+		return PLANNER_FORMAT;
+
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV21:
+		return UVCOMBINE_FORMAT;
+
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		return PLANNER_FORMAT;
+
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+		return UVCOMBINE_FORMAT;
+	default:
+		DI_ERR(TAG"unknown format=%s(0x%x)\n",
+			di_format_to_string(format), format);
+		return 0;
+	}
+
+	return 0;
+}
+
+/*set output address
+* set out put fb y/cb/cr address
+*/
+static void di_dev_set_addr(struct di_reg *reg,
+		struct di_process_fb_arg *fb_arg)
+{
+//set in_fb0
+	reg->in_frame0_addr0.dwval = fb_arg->in_fb0.buf.addr.y_addr & 0xffffffff;
+	reg->in_frame0_addr1.dwval = fb_arg->in_fb0.buf.addr.cb_addr & 0xffffffff;
+	reg->in_frame0_addr2.dwval = fb_arg->in_fb0.buf.addr.cr_addr & 0xffffffff;
+	reg->in_frame0_add_ext.bits.plane0_h
+				= fb_arg->in_fb0.buf.addr.y_addr >> 32 & 0xff;
+	reg->in_frame0_add_ext.bits.plane1_h
+				= fb_arg->in_fb0.buf.addr.cb_addr >> 32 & 0xff;
+	reg->in_frame0_add_ext.bits.plane2_h
+				= fb_arg->in_fb0.buf.addr.cr_addr >> 32 & 0xff;
+//set in_fb1
+	reg->in_frame1_addr0.dwval = fb_arg->in_fb1.buf.addr.y_addr & 0xffffffff;
+	reg->in_frame1_addr1.dwval = fb_arg->in_fb1.buf.addr.cb_addr & 0xffffffff;
+	reg->in_frame1_addr2.dwval = fb_arg->in_fb1.buf.addr.cr_addr & 0xffffffff;
+	reg->in_frame1_add_ext.bits.plane0_h
+				= fb_arg->in_fb1.buf.addr.y_addr >> 32 & 0xff;
+	reg->in_frame1_add_ext.bits.plane1_h
+				= fb_arg->in_fb1.buf.addr.cb_addr >> 32 & 0xff;
+	reg->in_frame1_add_ext.bits.plane2_h
+				= fb_arg->in_fb1.buf.addr.cr_addr >> 32 & 0xff;
+
+//set out_fb0
+	reg->out_frame0_addr0.dwval = fb_arg->out_fb0.buf.addr.y_addr & 0xffffffff;
+	reg->out_frame0_addr1.dwval = fb_arg->out_fb0.buf.addr.cb_addr & 0xffffffff;
+	reg->out_frame0_addr2.dwval = fb_arg->out_fb0.buf.addr.cr_addr & 0xffffffff;
+	reg->out_frame0_add_ext.bits.plane0_h
+				= fb_arg->out_fb0.buf.addr.y_addr >> 32 & 0xff;
+	reg->out_frame0_add_ext.bits.plane1_h
+				= fb_arg->out_fb0.buf.addr.cb_addr >> 32 & 0xff;
+	reg->out_frame0_add_ext.bits.plane2_h
+				= fb_arg->out_fb0.buf.addr.cr_addr >> 32 & 0xff;
+
+//set out_fb1
+	reg->out_frame1_addr0.dwval = fb_arg->out_fb1.buf.addr.y_addr & 0xffffffff;
+	reg->out_frame1_addr1.dwval = fb_arg->out_fb1.buf.addr.cb_addr & 0xffffffff;
+	reg->out_frame1_addr2.dwval = fb_arg->out_fb1.buf.addr.cr_addr & 0xffffffff;
+	reg->out_frame1_add_ext.bits.plane0_h
+				= fb_arg->out_fb1.buf.addr.y_addr >> 32 & 0xff;
+	reg->out_frame1_add_ext.bits.plane1_h
+				= fb_arg->out_fb1.buf.addr.cb_addr >> 32 & 0xff;
+	reg->out_frame1_add_ext.bits.plane2_h
+				= fb_arg->out_fb1.buf.addr.cr_addr >> 32 & 0xff;
+}
+
+static void di_dev_set_pitches(struct di_reg *reg,
+		struct di_process_fb_arg *fb_arg)
+{
+//in plane0(Y)
+	//reg->in_pitch0.bits.fb0_plane0 = DI_ALIGN(fb_arg->in_fb0.size.width, 2);
+	//reg->in_pitch0.bits.fb1_plane0 = DI_ALIGN(fb_arg->in_fb1.size.width, 2);
+	reg->in_pitch0.dwval = (DI_ALIGN(fb_arg->in_fb1.size.width, 2) << 16)
+				| DI_ALIGN(fb_arg->in_fb0.size.width, 2);
+//out plane0(Y)
+	reg->out_pitch0.bits.plane0 = DI_ALIGN(fb_arg->out_fb0.size.width, 2);
+
+	if (di_get_format_type(fb_arg->pixel_format) == PLANNER_FORMAT) {
+//in plane1(U or V)
+		reg->in_pitch1.dwval = (DI_ALIGN(fb_arg->in_fb1.size.width / 2, 2) << 16)
+				| DI_ALIGN(fb_arg->in_fb0.size.width / 2, 2);
+
+//in plane2(V or U)
+		reg->in_pitch2.dwval = (DI_ALIGN(fb_arg->in_fb1.size.width / 2, 2) << 16)
+				| DI_ALIGN(fb_arg->in_fb0.size.width / 2, 2);
+
+//out plane1(U or V)
+		reg->out_pitch1.dwval
+				= DI_ALIGN(fb_arg->out_fb0.size.width / 2, 2);
+//out plane2(V or U)
+		reg->out_pitch2.dwval
+				= DI_ALIGN(fb_arg->out_fb0.size.width / 2, 2);
+
+	} else if (di_get_format_type(fb_arg->pixel_format) == UVCOMBINE_FORMAT) {
+//in plane1(U or V)
+		reg->in_pitch1.dwval = (DI_ALIGN(fb_arg->in_fb1.size.width, 2) << 16)
+					| DI_ALIGN(fb_arg->in_fb0.size.width, 2);
+
+//in plane2(V or U)
+		reg->in_pitch2.dwval = 0;
+
+//out plane1(U or V)
+		reg->out_pitch1.dwval = DI_ALIGN(fb_arg->out_fb0.size.width, 2);
+//out plane2(V or U)
+		reg->out_pitch2.dwval = 0;
+	}
+}
+
+/*set fb
+* 1.set pitch,phy address of in/out_fb to reg
+*/
+static void di_dev_set_fb(struct di_process_fb_arg *fb_arg)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	di_dev_set_pitches(reg, fb_arg);
+	di_dev_set_addr(reg, fb_arg);
+}
+
+static bool di_dev_is_busy(void)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	return reg->status.bits.busy ? true : false;
+}
+
+static void di_dev_reset(void)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	reg->ctrl.bits.reset = 1;
+	udelay(1);
+	reg->ctrl.bits.reset = 0;
+}
+
+static void di_dev_start(void)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	reg->ctrl.bits.start = 1;
+}
+
+static void di_dev_apply_fixed_para(void)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	reg->ctrl.bits.auto_clk_gate_en = 1;
+
+	//reg->model_para.bits.feather_detection_en = 1;
+	reg->model_para.dwval = reg->model_para.dwval | (1  << 8);
+
+	//reg->luma_para.bits.min_luma_th = 0x4;
+	//reg->luma_para.bits.max_luma_th = 0xc;
+	//reg->luma_para.bits.luma_th_shifter = 0x1;
+	//reg->luma_para.bits.avg_luma_shifter = 0x6;
+	//reg->luma_para.bits.angle_const_th = 0x5;
+	//reg->luma_para.bits.max_angle = 0x6;
+	//reg->luma_para.bits.slow_motion_fac = 0x2;
+	reg->luma_para.dwval = 0x026561c4;
+
+	reg->chroma_para.bits.chroma_diff_th = 0x4;
+	reg->chroma_para.bits.chroma_spatial_th = 0x5;
+	reg->chroma_para.dwval = 0x00000054;
+}
+
+u32 di_dev_get_ip_version(void)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	return reg->version.dwval;
+}
+
+static void di_dev_enable_irq(u32 en)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	reg->int_ctrl.bits.finish_int_en = en;
+}
+
+u32 di_dev_query_state_with_clear(void)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	u32 val = reg->status.bits.finish_flag;
+	reg->status.bits.finish_flag = 1;
+
+	return val;
+}
+
+static void di_dev_apply_top_para(struct di_process_fb_arg *fb_arg)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	//reg->size.bits.width = DI_ALIGN(fb_arg->size.width, 2) - 1;
+	//reg->size.bits.height = DI_ALIGN(fb_arg->size.height, 4) - 1;
+
+	reg->size.dwval = ((DI_ALIGN(fb_arg->size.height, 4) - 1) << 16)
+			| (DI_ALIGN(fb_arg->size.width, 2) - 1);
+
+	reg->format.bits.in_format = di_dev_convert_fmt(fb_arg->pixel_format);
+	reg->format.bits.field_order = fb_arg->field_order;
+
+	//reg->model_para.bits.di_mode = fb_arg->di_mode;
+	//reg->model_para.bits.output_mode = fb_arg->output_mode;
+	//reg->model_para.dwval = reg->model_para.dwval | (1  << 8);
+	reg->model_para.dwval = (1 << 8) | (fb_arg->output_mode << 4)
+					| fb_arg->di_mode;
+}
+
+static void di_dev_set_mdflag(struct di_client *client)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	struct di_mapped_buf *md_buf = client->md_buf;
+	struct di_process_fb_arg *fb_arg = &client->fb_arg;
+
+	if (md_buf) {
+		reg->mdflag_add.dwval = (u32)md_buf->dma_addr;
+		reg->mdflag_pitch.dwval = DI_ALIGN(fb_arg->size.width, 1);
+	} else {
+		reg->mdflag_add.dwval = 0;
+		reg->mdflag_pitch.dwval = 0;
+	}
+
+	reg->mdflag_add_ext.dwval = 0;
+}
+
+/* invoked in every di process. */
+s32 di_dev_apply(void *client)
+{
+	struct di_client *c = (struct di_client *)client;
+
+	DI_DEBUG(TAG"%s: client:%s  seqno:%llu\n",
+		__func__, c->name, c->proc_fb_seqno);
+
+	/*other client may be using di device and we need to wait*/
+	while (di_dev_is_busy())
+		msleep(1);
+
+	if (di_dev_work_mode_is_change(&c->fb_arg))
+		di_dev_reset();
+
+	memcpy(&current_fb_arg, &c->fb_arg, sizeof(struct di_process_fb_arg));
+	di_dev_apply_fixed_para();
+	di_dev_apply_top_para(&c->fb_arg);
+	di_dev_set_fb(&c->fb_arg);
+	di_dev_set_mdflag(client);
+
+	di_dev_enable_irq(1);
+
+	di_dev_dump_reg_value();
+	di_dev_start();
+
+	return 0;
+}
diff --git a/drivers/char/sunxi-di/drv_div1xx/di110.h b/drivers/char/sunxi-di/drv_div1xx/di110.h
new file mode 100644
index 000000000..90b48bec9
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di110.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef _DI_110_H_
+#define _DI_110_H_
+
+enum di_pixel_format {
+	YUV420_PLANNER = 0,
+	YUV420_NV12,
+	YUV420_NV21,
+	YUV422_PLANNER,
+	YUV422_NV16,
+	YUV422_NV61,
+};
+
+enum di_format_type {
+	PLANNER_FORMAT = 0,
+	UVCOMBINE_FORMAT = 1,
+};
+#endif
diff --git a/drivers/char/sunxi-di/drv_div1xx/di110_reg.h b/drivers/char/sunxi-di/drv_div1xx/di110_reg.h
new file mode 100644
index 000000000..30cd831fc
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di110_reg.h
@@ -0,0 +1,412 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef _DI110_REG_H_
+#define _DI110_REG_H_
+
+#include <linux/types.h>
+
+union di_ctrl_reg {
+	u32 dwval;
+	struct {
+		u32 start:1;
+		u32 reserve0:3;
+		u32 auto_clk_gate_en:1;
+		u32 reserve1:26;
+		u32 reset:1;
+	} bits;
+};
+
+union di_int_ctrl_reg {
+	u32 dwval;
+	struct {
+		u32 finish_int_en:1;
+		u32 reserve0:31;
+	} bits;
+};
+
+union di_status_reg {
+	u32 dwval;
+	struct {
+		u32 finish_flag:1;
+		u32 reserve0:3;
+		u32 busy:1;
+		u32 reserve1:7;
+		u32 cut_blk:4;
+		u32 cur_line:10;
+		u32 reserve2:2;
+		u32 cur_chl:2;
+		u32 reserve3:2;
+	} bits;
+};
+
+union di_version_reg {
+	u32 dwval;
+	struct {
+		u32 ip_version:12;
+		u32 reserve0:20;
+	} bits;
+};
+
+union di_size_reg {
+	u32 dwval;
+	struct {
+		u32 width:11;
+		u32 reserve0:5;
+		u32 height:11;
+		u32 reserve1:5;
+	} bits;
+};
+
+union di_format_reg {
+	u32 dwval;
+	struct {
+		u32 in_format:3;
+		u32 reserve0:1;
+		u32 field_order:1;
+		u32 reserve1:27;
+	} bits;
+};
+
+union di_model_para_reg {
+	u32 dwval;
+	struct {
+		u32 di_mode:1;
+		u32 reserve0:3;
+		u32 output_mode:1;
+		u32 reserve1:3;
+		u32 feather_detection_en:1;
+		u32 reserve2:23;
+	} bits;
+};
+
+/* for pitch of plane0(Y Component)
+ * plane0 of in_fb0
+ * plane0 of in_fb1
+ */
+union di_in_pitch0_reg {
+	u32 dwval;
+	struct {
+		u32 fb0_plane0:12;
+		u32 reserve0:4;
+		u32 fb1_plane0:12;
+		u32 reserve1:4;
+	} bits;
+};
+
+/* for pitch of plane1(U(or V) Component)
+ * plane1 of in_fb0
+ * plane1 of in_fb1
+ */
+union di_in_pitch1_reg {
+	u32 dwval;
+	struct {
+		u32 fb0_plane1:12;
+		u32 reserve0:4;
+		u32 fb1_plane1:12;
+		u32 reserve1:4;
+	} bits;
+};
+
+/* for pitch of plane2(V(or U) Component)
+ * plane2 of in_fb0
+ * plane2 of in_fb1
+ */
+union di_in_pitch2_reg {
+	u32 dwval;
+	struct {
+		u32 fb0_plane2:12;
+		u32 reserve0:4;
+		u32 fb1_plane2:12;
+		u32 reserve1:4;
+	} bits;
+};
+
+/* for pitch of plane0(Y Component)
+ * plane0 of out_fb
+ */
+union di_out_pitch0_reg {
+	u32 dwval;
+	struct {
+		u32 plane0:12;
+		u32 reserve0:20;
+	} bits;
+};
+
+/* for pitch of plane1(U(or V) Component)
+ * plane1 of out_fb
+ */
+union di_out_pitch1_reg {
+	u32 dwval;
+	struct {
+		u32 plane1:12;
+		u32 reserve0:20;
+	} bits;
+};
+
+/* for pitch of plane2(V(or U) Component)
+ * plane2 of out_fb
+ */
+union di_out_pitch2_reg {
+	u32 dwval;
+	struct {
+		u32 plane2:12;
+		u32 reserve0:20;
+	} bits;
+};
+
+/* for pitch of motion flag*/
+union di_mdflag_pitch_reg {
+	u32 dwval;
+	struct {
+		u32 flag_pitch:12;
+		u32 reserve0:20;
+	} bits;
+};
+
+/* plane0(Y Component) address of in_fb0*/
+union di_in_frame0_add0_reg {
+	u32 dwval;
+	struct {
+		u32 plane0:32;
+	} bits;
+};
+
+/* plane1(U(or V) Component) address of in_fb0*/
+union di_in_frame0_add1_reg {
+	u32 dwval;
+	struct {
+		u32 plane1:32;
+	} bits;
+};
+
+/* plane2(V(or U) Component) address of in_fb0*/
+union di_in_frame0_add2_reg {
+	u32 dwval;
+	struct {
+		u32 plane2:32;
+	} bits;
+};
+
+/*extension address of in_fb0*/
+union di_in_frame0_add_ext_reg {
+	u32 dwval;
+	struct {
+		u32 plane0_h:8;
+		u32 plane1_h:8;
+		u32 plane2_h:8;
+		u32 reserve0:8;
+	} bits;
+};
+
+/* plane0(Y Component) address of in_fb1*/
+union di_in_frame1_add0_reg {
+	u32 dwval;
+	struct {
+		u32 plane0:32;
+	} bits;
+};
+
+/* plane1(U(or V) Component) address of in_fb1*/
+union di_in_frame1_add1_reg {
+	u32 dwval;
+	struct {
+		u32 plane1:32;
+	} bits;
+};
+
+/* plane2(V(or U) Component) address of in_fb1*/
+union di_in_frame1_add2_reg {
+	u32 dwval;
+	struct {
+		u32 plane2:32;
+	} bits;
+};
+
+/*extension address of in_fb1*/
+union di_in_frame1_add_ext_reg {
+	u32 dwval;
+	struct {
+		u32 plane0_h:8;
+		u32 plane1_h:8;
+		u32 plane2_h:8;
+		u32 reserve0:8;
+	} bits;
+};
+
+/* plane0(Y Component) address of out_fb0*/
+union di_out_frame0_add0_reg {
+	u32 dwval;
+	struct {
+		u32 plane0:32;
+	} bits;
+};
+
+/* plane1(U(or V) Component) address of out_fb0*/
+union di_out_frame0_add1_reg {
+	u32 dwval;
+	struct {
+		u32 plane1:32;
+	} bits;
+};
+
+/* plane2(V(or U) Component) address of out_fb0*/
+union di_out_frame0_add2_reg {
+	u32 dwval;
+	struct {
+		u32 plane2:32;
+	} bits;
+};
+
+/*extension address of out_fb0*/
+union di_out_frame0_add_ext_reg {
+	u32 dwval;
+	struct {
+		u32 plane0_h:8;
+		u32 plane1_h:8;
+		u32 plane2_h:8;
+		u32 reserve0:8;
+	} bits;
+};
+
+/* plane0(Y Component) address of out_fb1*/
+union di_out_frame1_add0_reg {
+	u32 dwval;
+	struct {
+		u32 plane0:32;
+	} bits;
+};
+
+/* plane1(U(or V) Component) address of out_fb1*/
+union di_out_frame1_add1_reg {
+	u32 dwval;
+	struct {
+		u32 plane1:32;
+	} bits;
+};
+
+/* plane2(V(or U) Component) address of out_fb1*/
+union di_out_frame1_add2_reg {
+	u32 dwval;
+	struct {
+		u32 plane2:32;
+	} bits;
+};
+
+/*extension address of out_fb1*/
+union di_out_frame1_add_ext_reg {
+	u32 dwval;
+	struct {
+		u32 plane0_h:8;
+		u32 plane1_h:8;
+		u32 plane2_h:8;
+		u32 reserve0:8;
+	} bits;
+};
+
+union di_mdflag_add_reg {
+	u32 dwval;
+	struct {
+		u32 flag_add:32;
+	} bits;
+};
+
+union di_mdflag_add_ext_reg {
+	u32 dwval;
+	struct {
+		u32 flag_add_h:32;
+	} bits;
+};
+
+union di_luma_para_reg {
+	u32 dwval;
+	struct {
+		u32 min_luma_th:4;
+		u32 max_luma_th:4;
+		u32 luma_th_shifter:4;
+		u32 avg_luma_shifter:4;
+		u32 angle_const_th:4;
+		u32 max_angle:4;
+		u32 slow_motion_fac:4;
+		u32 reserve0:4;
+	} bits;
+};
+
+union di_chroma_para_reg {
+	u32 dwval;
+	struct {
+		u32 chroma_diff_th:4;
+		u32 chroma_spatial_th:4;
+		u32 reserve0:24;
+	} bits;
+};
+
+union di_process_time_reg {
+	u32 dwval;
+	struct {
+		u32 time:32;
+	} bits;
+};
+
+/*register of di110*/
+struct di_reg {
+	union di_ctrl_reg ctrl;					//0x000
+	union di_int_ctrl_reg int_ctrl;				//0x004
+	union di_status_reg status;				//0x008
+	union di_version_reg version;				//0x00c
+	union di_size_reg size;					//0x010
+	union di_format_reg format;				//0x014
+	union di_model_para_reg model_para;			//0x018
+
+//pitch
+	union di_in_pitch0_reg in_pitch0;			//0x01c
+	union di_in_pitch1_reg in_pitch1;			//0x020
+	union di_in_pitch2_reg in_pitch2;			//0x024
+
+	union di_out_pitch0_reg out_pitch0;			//0x028
+	union di_out_pitch1_reg out_pitch1;			//0x02c
+	union di_out_pitch2_reg out_pitch2;			//0x030
+
+	union di_mdflag_pitch_reg mdflag_pitch;			//0x034
+
+//address
+	union di_in_frame0_add0_reg in_frame0_addr0;		//0x038
+	union di_in_frame0_add1_reg in_frame0_addr1;		//0x03c
+	union di_in_frame0_add2_reg in_frame0_addr2;		//0x040
+	union di_in_frame0_add_ext_reg in_frame0_add_ext;	//0x044
+
+	union di_in_frame1_add0_reg in_frame1_addr0;		//0x048
+	union di_in_frame1_add1_reg in_frame1_addr1;		//0x04c
+	union di_in_frame1_add2_reg in_frame1_addr2;		//0x050
+	union di_in_frame1_add_ext_reg in_frame1_add_ext;	//0x054
+
+	union di_out_frame0_add0_reg out_frame0_addr0;		//0x058
+	union di_out_frame0_add1_reg out_frame0_addr1;		//0x05c
+	union di_out_frame0_add2_reg out_frame0_addr2;		//0x060
+	union di_out_frame0_add_ext_reg out_frame0_add_ext;	//0x064
+
+	union di_out_frame1_add0_reg out_frame1_addr0;		//0x068
+	union di_out_frame1_add1_reg out_frame1_addr1;		//0x06c
+	union di_out_frame1_add2_reg out_frame1_addr2;		//0x070
+	union di_out_frame1_add_ext_reg out_frame1_add_ext;	//0x074
+
+	union di_mdflag_add_reg mdflag_add;			//0x078
+	union di_mdflag_add_ext_reg mdflag_add_ext;		//0x7c
+
+	union di_luma_para_reg luma_para;			//0x80
+	union di_chroma_para_reg chroma_para;			//0x84
+
+	u32 res[6];						//0x88~0x9c
+
+	union di_process_time_reg process_time;			//0x0a0
+};
+#endif
diff --git a/drivers/char/sunxi-di/drv_div1xx/di_client.c b/drivers/char/sunxi-di/drv_div1xx/di_client.c
new file mode 100644
index 000000000..0103e5682
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di_client.c
@@ -0,0 +1,473 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "di_client.h"
+#include "../common/di_utils.h"
+#include "../common/di_debug.h"
+#include "sunxi_di.h"
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#define DI_TNR_BUF_ALIGN_LEN 16
+#define DI_MD_BUF_ALIGN_LEN 32
+
+extern int di_drv_get_version(struct di_version *version);
+extern int di_drv_client_inc(struct di_client *c);
+extern int di_drv_client_dec(struct di_client *c);
+extern int di_drv_is_valid_client(struct di_client *c);
+extern int di_drv_process_fb(struct di_client *c);
+
+static int di_client_alloc_mbuf(struct di_mapped_buf **mbuf, u32 size)
+{
+	struct di_mapped_buf *p = *mbuf;
+
+	if (p != NULL) {
+		u32 size_alloced = PAGE_ALIGN(size);
+
+		if (p->size_alloced != size_alloced) {
+			di_dma_buf_unmap_free(p);
+			p = NULL;
+			*mbuf = NULL;
+		} else {
+			p->size_request = size;
+		}
+	}
+	if (p == NULL) {
+		p = di_dma_buf_alloc_map(size);
+		if (p == NULL)
+			return -ENOMEM;
+	}
+	memset((void *)p->vir_addr, 0, p->size_alloced);
+	*mbuf = p;
+
+	return 0;
+}
+
+static void di_client_free_mbuf(struct di_mapped_buf **mbuf)
+{
+	if ((*mbuf)->size_alloced) {
+		di_dma_buf_unmap_free(*mbuf);
+		*mbuf = NULL;
+	}
+}
+
+static int di_client_setup_md_buf(struct di_client *c)
+{
+	return di_client_alloc_mbuf(&c->md_buf,
+		DI_ALIGN(c->fb_arg.size.width, 2)
+		* DI_ALIGN(c->fb_arg.size.height, 4));
+}
+
+static int di_client_init(struct di_client *c)
+{
+	DI_DEBUG("%s: %s\n", c->name, __func__);
+
+	c->proc_fb_seqno = 0;
+	atomic_set(&c->wait_con, DI_PROC_STATE_IDLE);
+
+	return 0;
+}
+
+/*checking and correcting di_client para before running proccess_fb*/
+int di_client_check_para(struct di_client *c, void *data)
+{
+	DI_DEBUG("%s: %s\n", c->name, __func__);
+
+	if ((c->fb_arg.size.height == 0)
+		|| ((c->fb_arg.size.height & 0x1) != 0)
+		|| (c->fb_arg.size.width == 0)
+		|| ((c->fb_arg.size.width & 0x1) != 0)) {
+		DI_ERR("%s: invalid size W(%d)xH(%d)\n",
+			c->name, c->fb_arg.size.height,
+			c->fb_arg.size.width);
+		goto err_out;
+	}
+
+	atomic_set(&c->wait_con, DI_PROC_STATE_IDLE);
+
+	return 0;
+
+err_out:
+	return -EINVAL;
+}
+
+static bool di_client_check_fb_arg(struct di_client *c,
+	struct di_process_fb_arg *fb_arg)
+{
+	DI_DEBUG("%s topFieldFirst[%s]\n",
+		fb_arg->is_interlace ? "Interlace" : "P",
+		fb_arg->field_order ? "Y" : "N");
+
+	/* TODO: add more check ? */
+	return true;
+}
+
+static int di_client_get_fb(struct di_client *c,
+	struct di_dma_item **dma_fb_item, struct di_fb *fb,
+	enum dma_data_direction dir)
+{
+	struct di_dma_item *dma_fb = *dma_fb_item;
+
+	if ((fb->dma_buf_fd <= 0) && (fb->buf.addr.y_addr == 0))
+		return 0;
+
+	DI_DEBUG("%s: buf_offset[0x%llx,0x%llx,0x%llx],"
+		"fd=%d,size[%d,%d]\n",
+		c->name,
+		fb->buf.offset.y_offset, fb->buf.offset.cb_offset,
+		fb->buf.offset.cr_offset,
+		fb->dma_buf_fd,
+		fb->size.width, fb->size.height);
+
+	if (dma_fb != NULL) {
+		di_dma_buf_self_unmap(dma_fb);
+		dma_fb = NULL;
+	}
+
+	if (fb->dma_buf_fd > 0) {
+		dma_fb = di_dma_buf_self_map(fb->dma_buf_fd, dir);
+		if (dma_fb == NULL) {
+			DI_ERR("%s: %s,%d\n", c->name, __func__, __LINE__);
+			return -EINVAL;
+		}
+		fb->buf.addr.y_addr = (u64)(dma_fb->dma_addr)
+					+ fb->buf.offset.y_offset;
+		fb->buf.addr.cb_addr = (u64)(dma_fb->dma_addr)
+					+ fb->buf.offset.cb_offset;
+		if (fb->buf.offset.cr_offset)
+			fb->buf.addr.cr_addr = (u64)(dma_fb->dma_addr)
+					+ fb->buf.offset.cr_offset;
+		DI_DEBUG("%s:dma_addr=0x%llx,yuv[0x%llx,0x%llx,0x%llx]\n",
+			c->name, (u64)(dma_fb->dma_addr),
+			fb->buf.addr.y_addr,
+			fb->buf.addr.cb_addr,
+			fb->buf.addr.cr_addr);
+	} else if (fb->buf.addr.y_addr && fb->buf.addr.cb_addr) {
+		DI_DEBUG("%s: On phy_addr_buf method\n", c->name);
+	}
+
+	*dma_fb_item = dma_fb;
+	DI_DEBUG("\n");
+
+	return 0;
+}
+
+static int di_client_get_fbs(struct di_client *c)
+{
+	struct di_process_fb_arg *fb_arg = &c->fb_arg;
+
+	if (di_client_get_fb(c, &c->in_fb0,
+			&fb_arg->in_fb0, DMA_TO_DEVICE)) {
+		DI_ERR("di_client_get_fb:in_fb0 failed\n");
+		return -EINVAL;
+	}
+	if (di_client_get_fb(c, &c->in_fb1,
+			&fb_arg->in_fb1, DMA_TO_DEVICE)) {
+		DI_ERR("di_client_get_fb:in_fb1 failed\n");
+		return -EINVAL;
+	}
+	if (di_client_get_fb(c, &c->in_fb2,
+			&fb_arg->in_fb2, DMA_TO_DEVICE)) {
+		DI_ERR("di_client_get_fb:in_fb2 failed\n");
+		return -EINVAL;
+	}
+	if (di_client_get_fb(c, &c->out_fb0,
+			&fb_arg->out_fb0, DMA_FROM_DEVICE)) {
+		DI_ERR("di_client_get_fb:out_fb0 failed\n");
+		return -EINVAL;
+	}
+	if (di_client_get_fb(c, &c->out_fb1,
+			&fb_arg->out_fb1, DMA_FROM_DEVICE)) {
+		DI_ERR("di_client_get_fb:out_fb1 failed\n");
+		return -EINVAL;
+	}
+
+	if (fb_arg->tnr_mode.mode > 0) {
+		if (di_client_get_fb(c, &c->out_tnr_fb,
+				&fb_arg->out_tnr_fb, DMA_FROM_DEVICE)) {
+			DI_ERR("di_client_get_fb:out_tnr_fb failed\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int di_client_put_fbs(struct di_client *c)
+{
+	if (c->in_fb0 != NULL) {
+		di_dma_buf_self_unmap(c->in_fb0);
+		c->in_fb0 = NULL;
+	}
+
+	if (c->in_fb1 != NULL) {
+		di_dma_buf_self_unmap(c->in_fb1);
+		c->in_fb1 = NULL;
+	}
+	if (c->in_fb2 != NULL) {
+		di_dma_buf_self_unmap(c->in_fb2);
+		c->in_fb2 = NULL;
+	}
+
+	if (c->out_fb0 != NULL) {
+		di_dma_buf_self_unmap(c->out_fb0);
+		c->out_fb0 = NULL;
+	}
+
+	if (c->out_fb1 != NULL) {
+		di_dma_buf_self_unmap(c->out_fb1);
+		c->out_fb1 = NULL;
+	}
+
+	if (c->out_tnr_fb != NULL) {
+		di_dma_buf_self_unmap(c->out_tnr_fb);
+		c->out_tnr_fb = NULL;
+	}
+
+	return 0;
+}
+
+static bool di_client_workmode_is_change(struct di_client *c,
+			struct di_process_fb_arg *fb_arg)
+{
+	struct di_process_fb_arg *current_fb_arg = &c->fb_arg;
+
+	if ((fb_arg->is_interlace != current_fb_arg->is_interlace)
+		|| (fb_arg->field_order != current_fb_arg->field_order)
+		|| (fb_arg->pixel_format != current_fb_arg->pixel_format)
+		|| (fb_arg->size.width != current_fb_arg->size.width)
+		|| (fb_arg->size.height != current_fb_arg->size.height))
+		return true;
+
+	return false;
+}
+
+
+static void di_dump_fb_arg(struct di_process_fb_arg *arg)
+{
+	DI_INFO("is_interlace:%u field_prder:%u\n", arg->is_interlace, arg->field_order);
+	DI_INFO("SIZE:(%ux%u) format:%u\n", arg->size.width, arg->size.height, arg->pixel_format);
+	DI_INFO("DIMODE:%u output_mode:%u\n", arg->di_mode, arg->output_mode);
+	DI_INFO("tnr:mode:%u level:%u\n", arg->tnr_mode.mode, arg->tnr_mode.level);
+
+	DI_INFO("\ninFB0:\n");
+	if (arg->in_fb0.dma_buf_fd > 0) {
+		DI_INFO("dmafd:%d offset[%llu, %llu, %llu]\n",
+			arg->in_fb0.dma_buf_fd,
+			arg->in_fb0.buf.offset.y_offset,
+			arg->in_fb0.buf.offset.cb_offset,
+			arg->in_fb0.buf.offset.cr_offset);
+	} else {
+		DI_INFO("addr[%llu, %llu, %llu]\n",
+			arg->in_fb0.buf.addr.y_addr,
+			arg->in_fb0.buf.addr.cb_addr,
+			arg->in_fb0.buf.addr.cr_addr);
+	}
+
+	DI_INFO("\ninFB1:\n");
+	if (arg->in_fb1.dma_buf_fd > 0) {
+		DI_INFO("dmafd:%d offset[%llu, %llu, %llu]\n",
+			arg->in_fb1.dma_buf_fd,
+			arg->in_fb1.buf.offset.y_offset,
+			arg->in_fb1.buf.offset.cb_offset,
+			arg->in_fb1.buf.offset.cr_offset);
+	} else {
+		DI_INFO("addr[%llu, %llu, %llu]\n",
+			arg->in_fb1.buf.addr.y_addr,
+			arg->in_fb1.buf.addr.cb_addr,
+			arg->in_fb1.buf.addr.cr_addr);
+	}
+
+	DI_INFO("\noutFB0:\n");
+	if (arg->out_fb0.dma_buf_fd > 0) {
+		DI_INFO("dmafd:%d offset[%llu, %llu, %llu]\n",
+			arg->out_fb0.dma_buf_fd,
+			arg->out_fb0.buf.offset.y_offset,
+			arg->out_fb0.buf.offset.cb_offset,
+			arg->out_fb0.buf.offset.cr_offset);
+	} else {
+		DI_INFO("addr[%llu, %llu, %llu]\n",
+			arg->out_fb0.buf.addr.y_addr,
+			arg->out_fb0.buf.addr.cb_addr,
+			arg->out_fb0.buf.addr.cr_addr);
+	}
+
+	DI_INFO("\noutFB1:\n");
+	if (arg->out_fb1.dma_buf_fd > 0) {
+		DI_INFO("dmafd:%d offset[%llu, %llu, %llu]\n",
+			arg->out_fb1.dma_buf_fd,
+			arg->out_fb1.buf.offset.y_offset,
+			arg->out_fb1.buf.offset.cb_offset,
+			arg->out_fb1.buf.offset.cr_offset);
+	} else {
+		DI_INFO("addr[%llu, %llu, %llu]\n",
+			arg->out_fb1.buf.addr.y_addr,
+			arg->out_fb1.buf.addr.cb_addr,
+			arg->out_fb1.buf.addr.cr_addr);
+	}
+}
+
+int di_client_process_fb(struct di_client *c,
+	struct di_process_fb_arg *fb_arg)
+{
+	int ret = 0;
+	bool is_change = false;
+	ktime_t time;
+	unsigned long long t0 = 0, t1 = 0, t2 = 0, t3 = 0;
+
+	di_dump_fb_arg(fb_arg);
+
+	time = ktime_get();
+	t0 = ktime_to_us(time);
+
+	if (!di_client_check_fb_arg(c, fb_arg)) {
+		DI_ERR("%s: check_fb_arg fail\n", c->name);
+		return -EINVAL;
+	}
+
+	is_change = di_client_workmode_is_change(c, fb_arg);
+	if (is_change) {
+		DI_INFO("di workmode changes, init client\n");
+		di_client_init(c);
+	}
+
+	memcpy((void *)&c->fb_arg, fb_arg, sizeof(c->fb_arg));
+
+	if (is_change && (fb_arg->di_mode == DI_INTP_MODE_MOTION)) {
+		DI_INFO("di workmode changes, creat and setup md flag buf\n");
+		di_client_setup_md_buf(c);
+	}
+
+	ret = di_client_get_fbs(c);
+	if (ret < 0) {
+		DI_ERR("di_client_get_fbs failed!\n");
+		return ret;
+	}
+
+	time = ktime_get();
+	t1 = ktime_to_us(time);
+
+	ret = di_drv_process_fb(c);
+
+	time = ktime_get();
+	t2 = ktime_to_us(time);
+
+	di_client_put_fbs(c);
+
+	time = ktime_get();
+	t3 = ktime_to_us(time);
+
+	DI_TEST("total:%lluus     t0~t1:%lluus  t1~t2:%lluus  t2~t3:%lluus\n",
+		(t3 - t0),
+		(t1 - t0),
+		(t2 - t1),
+		(t3 - t2));
+	return ret;
+}
+
+int di_client_get_version(struct di_client *c,
+	struct di_version *version)
+{
+	return di_drv_get_version(version);
+}
+
+int di_client_set_timeout(struct di_client *c,
+	struct di_timeout_ns *timeout)
+{
+	DI_DEBUG("%s:wait4start=%llu,wait4finish=%llu\n",
+		c->name, timeout->wait4start, timeout->wait4finish);
+	if (timeout->wait4start > 0)
+		c->timeout.wait4start = timeout->wait4start;
+	if (timeout->wait4finish > 0)
+		c->timeout.wait4finish = timeout->wait4finish;
+
+	return 0;
+}
+
+void *di_client_create(const char *name)
+{
+	struct di_client *client;
+
+	if (!name) {
+		DI_ERR("%s: Name cannot be null\n", __func__);
+		return NULL;
+	}
+
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
+	if (client == NULL) {
+		DI_ERR("kzalloc for client%s fail\n", name);
+		return NULL;
+	}
+
+	client->name = kstrdup(name, GFP_KERNEL);
+	if (client->name == NULL) {
+		kfree(client);
+		DI_ERR("kstrdup for name(%s) fail\n", name);
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&client->node);
+
+	client->timeout.wait4start = 3 * 1000000000UL;
+	client->timeout.wait4finish = 3 * 1000000000UL;
+
+	init_waitqueue_head(&client->wait);
+	atomic_set(&client->wait_con, DI_PROC_STATE_IDLE);
+
+	if (di_drv_client_inc(client)) {
+		kfree(client);
+		return NULL;
+	}
+
+	return client;
+}
+EXPORT_SYMBOL_GPL(di_client_create);
+
+void di_client_destroy(void *client)
+{
+	struct di_client *c = (struct di_client *)client;
+
+	if (!di_drv_is_valid_client(c)) {
+		DI_ERR("%s, invalid client(%p)\n", __func__, c);
+		return;
+	}
+	di_drv_client_dec(c);
+
+	if (c->md_buf)
+		di_client_free_mbuf(&c->md_buf);
+
+	kfree(c->name);
+	kfree(c);
+}
+EXPORT_SYMBOL_GPL(di_client_destroy);
+
+int di_client_mem_request(struct di_client *c, void *data)
+{
+	struct di_mem_arg *mem = (struct di_mem_arg *)data;
+
+	mem->handle = di_mem_request(mem->size, &mem->phys_addr);
+
+	if (mem->handle < 0)
+		return -1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(di_client_mem_request);
+
+int di_client_mem_release(struct di_client *c, void *data)
+{
+	struct di_mem_arg *mem = (struct di_mem_arg *)data;
+
+	return mem->handle = di_mem_release(mem->handle);
+}
+EXPORT_SYMBOL_GPL(di_client_mem_release);
diff --git a/drivers/char/sunxi-di/drv_div1xx/di_client.h b/drivers/char/sunxi-di/drv_div1xx/di_client.h
new file mode 100644
index 000000000..010438c4a
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di_client.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_CLIENT_H_
+#define _DI_CLIENT_H_
+
+#include "sunxi_di.h"
+#include "../common/di_utils.h"
+
+#include <linux/types.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+
+#define DI_CLIENT_CNT_MAX 32
+
+#define DI_IN_FB_NUM_MAX 3
+#define DI_OUT_FB_NUM_MAX 3
+#define DI_FB_NUM_MAX (DI_IN_FB_NUM_MAX + DI_OUT_FB_NUM_MAX)
+
+enum di_mode {
+	DI_MODE_INVALID = 0,
+	DI_MODE_60HZ,
+	DI_MODE_30HZ,
+	DI_MODE_BOB,
+	DI_MODE_WEAVE,
+	DI_MODE_TNR, /* only tnr */
+};
+
+enum {
+	DI_PROC_STATE_IDLE = 0,
+	DI_PROC_STATE_FINISH = DI_PROC_STATE_IDLE,
+	DI_PROC_STATE_WAIT2START,
+	DI_PROC_STATE_2START,
+	DI_PROC_STATE_WAIT4FINISH,
+	DI_PROC_STATE_FINISH_ERR,
+};
+
+/* for process fb */
+struct di_dma_fb {
+	struct di_fb *fb;
+	struct di_dma_item *dma_item;
+};
+
+struct di_client {
+	struct list_head node;
+	const char *name;
+
+	/* user setting para */
+	struct di_timeout_ns timeout;
+	struct di_process_fb_arg fb_arg;
+
+	struct di_dma_item *in_fb0;
+	struct di_dma_item *in_fb1;
+	struct di_dma_item *in_fb2;
+	struct di_dma_item *out_fb0;
+	struct di_dma_item *out_fb1;
+	struct di_dma_item *out_tnr_fb;
+
+	struct di_mapped_buf *md_buf;
+
+	/* runtime context */
+	wait_queue_head_t wait;
+	atomic_t wait_con;
+	u64 proc_fb_seqno;
+
+	/* dev_cdata must be at last */
+	uintptr_t dev_cdata;
+};
+
+void *di_client_create(const char *name);
+void di_client_destroy(void *c);
+
+int di_client_mem_request(struct di_client *c, void *data);
+int di_client_mem_release(struct di_client *c, void *data);
+
+int di_client_get_version(struct di_client *c, struct di_version *version);
+int di_client_set_timeout(struct di_client *c, struct di_timeout_ns *timeout);
+int di_client_process_fb(struct di_client *c, struct di_process_fb_arg *fb_arg);
+
+#endif /* ifndef _DI_CLIENT_H_ */
diff --git a/drivers/char/sunxi-di/drv_div1xx/di_dev.h b/drivers/char/sunxi-di/drv_div1xx/di_dev.h
new file mode 100644
index 000000000..b4d2baa12
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di_dev.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_DEV_H_
+#define _DI_DEV_H_
+u32 di_dev_get_ip_version(void);
+void di_dev_set_reg_base(void __iomem *reg_base);
+void di_dev_exit(void);
+u32 di_dev_query_state_with_clear(void);
+s32 di_dev_apply(void *client);
+#endif
diff --git a/drivers/char/sunxi-di/drv_div1xx/di_driver.c b/drivers/char/sunxi-di/drv_div1xx/di_driver.c
new file mode 100644
index 000000000..f32e85492
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di_driver.c
@@ -0,0 +1,902 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/reset.h>
+
+#include "../common/di_utils.h"
+#include "../common/di_debug.h"
+#include "di_driver.h"
+#include "di_fops.h"
+#include "di_dev.h"
+
+#define DI_MODULE_NAME "deinterlace"
+
+#define DI_VERSION_MAJOR 1
+#define DI_VERSION_MINOR 0
+#define DI_VERSION_PATCHLEVEL 0
+
+static struct di_driver_data *di_drvdata;
+static unsigned int di_debug_mode;
+
+unsigned int di_device_get_debug_mode(void)
+{
+	return di_debug_mode;
+}
+
+int di_drv_get_version(struct di_version *version)
+{
+	if (version) {
+		version->version_major = DI_VERSION_MAJOR;
+		version->version_minor = DI_VERSION_MINOR;
+		version->version_patchlevel = DI_VERSION_PATCHLEVEL;
+		version->ip_version = di_dev_get_ip_version();
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static ssize_t di_device_debug_mode_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t n = 0;
+
+	n += sprintf(buf + n, "1:enable debug mode   0:disable debug mode\n");
+	n += sprintf(buf + n, "current debug_mode:%d\n", di_debug_mode);
+
+	return n;
+}
+
+static ssize_t di_device_debug_mode_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	char *end;
+
+	di_debug_mode = (unsigned int)simple_strtoull(buf, &end, 0);
+
+	return count;
+}
+
+static DEVICE_ATTR(debug_mode, S_IWUSR | S_IRUGO,
+	di_device_debug_mode_show, di_device_debug_mode_store);
+
+static ssize_t
+di_device_debug_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+
+	n += sprintf(buf + n,
+	"echo [level] > /sys/class/deinterlace/deinterlace/debug\n");
+
+	n += sprintf(buf + n, "level 0: disable all kinds of di logs\n");
+	n += sprintf(buf + n, "level 1: enable error di logs\n");
+	n += sprintf(buf + n, "level 2: enable info di logs\n");
+	n += sprintf(buf + n, "level 3: enable debug di logs\n");
+	n += sprintf(buf + n, "level 4: enable debug di time detect logs\n");
+	n += sprintf(buf + n, "level 5: enable film mode detect logs\n");
+
+	n += sprintf(buf + n, "\nNow the debug level is:%d\n", debug_mask);
+
+	return n;
+}
+
+static ssize_t
+di_device_debug_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int val;
+	char *end;
+
+	retval = count;
+	val = simple_strtoull(buf, &end, 0);
+
+	if (val < DEBUG_LEVEL_MAX) {
+		debug_mask = val;
+	} else {
+		pr_err("ERROR: invalid input log level:%u\n", val);
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static DEVICE_ATTR(debug, S_IWUSR | S_IRUGO,
+	di_device_debug_show, di_device_debug_store);
+
+static ssize_t
+di_device_info_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct di_driver_data *data = di_drvdata;
+	ssize_t n = 0;
+
+	n += sprintf(buf + n, "DI Current Info:\n");
+	n += sprintf(buf + n, "irq_no:%u\n", data->irq_no);
+	n += sprintf(buf + n, "dev enable:%u pm_state:%s\n",
+		data->dev_enable, data->pm_state ? "suspend" : "resume");
+	n += sprintf(buf + n, "driver state:%s\n",
+		data->state ? "busy" : "idle");
+	return n;
+}
+
+static DEVICE_ATTR(info, S_IWUSR | S_IRUGO,
+	di_device_info_show, NULL);
+
+static char debug_client_name[30];
+static ssize_t di_device_client_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+
+	n += sprintf(buf + n, "All of the di clients name:\n");
+	list_for_each_entry(client, &drvdata->clients, node)
+		n += sprintf(buf + n, "%s\n", client->name);
+	n += sprintf(buf + n, "\n\n");
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(client->name, debug_client_name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		n += sprintf(buf + n, "Wrong debug_client_name:%s, please ",
+			debug_client_name);
+		n += sprintf(buf + n,
+		 "echo [client_name] > /sys/class/deinterlace/deinterlace/client\n");
+		return n;
+	}
+
+	n += sprintf(buf + n, "debug_client_name:%s\n",
+			debug_client_name);
+
+	return n;
+}
+
+static ssize_t
+di_device_client_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+	char name[30] = { 0 };
+
+	memcpy(name, buf, count);
+
+	name[count - 1] = '\0';
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(name, client->name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		DI_ERR("ERROR client name input:%s\n", buf);
+		return count;
+	}
+
+	strcpy(debug_client_name, client->name);
+
+	pr_info("set the debug client name:%s\n", debug_client_name);
+
+	return count;
+}
+
+static DEVICE_ATTR(client, S_IWUSR | S_IRUGO,
+	di_device_client_show, di_device_client_store);
+
+static ssize_t di_device_timeout_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+
+
+	n += sprintf(buf + n, "debug_client_name:%s\n", debug_client_name);
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(client->name, debug_client_name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		n += sprintf(buf + n, "Wrong debug_client_name:%s, please ",
+				debug_client_name);
+		n += sprintf(buf + n,
+		 "echo [client_name] > /sys/class/deinterlace/deinterlace/client\n");
+		return n;
+	}
+
+	n += sprintf(buf + n, "wait4start:%lld  wait4finish:%lld\n",
+		client->timeout.wait4start, client->timeout.wait4finish);
+
+	return n;
+}
+
+static ssize_t
+di_device_timeout_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t n = 0;
+	unsigned long long start, finish;
+	char *end;
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+
+
+	pr_info("debug_client_name:%s\n", debug_client_name);
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(client->name, debug_client_name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		pr_info("Wrong debug_client_name:%s, please ", debug_client_name);
+		pr_info("echo [client_name] > /sys/class/deinterlace/deinterlace/client\n");
+		return n;
+	}
+
+	start = simple_strtoull(buf, &end, 0);
+	pr_info("set timeout, wait2start:%lld\n", start);
+
+	if ((*end != ' ') && (*end != ',')) {
+		pr_err("error separator:%c\n", *end);
+		return count;
+	}
+
+	finish = simple_strtoull(end + 1, &end, 0);
+	pr_info("set timeout, wait2finish:%lld\n", finish);
+
+	client->timeout.wait4start = start;
+	client->timeout.wait4finish = finish;
+
+	pr_info("set timeout wait4start:%lld  wait4finish:%lld\n",
+		client->timeout.wait4start, client->timeout.wait4finish);
+
+	return count;
+}
+
+static DEVICE_ATTR(timeout, S_IWUSR | S_IRUGO,
+	di_device_timeout_show, di_device_timeout_store);
+
+static struct attribute *di_device_attrs[] = {
+	 &dev_attr_debug_mode.attr,
+	&dev_attr_debug.attr,
+	&dev_attr_info.attr,
+	&dev_attr_client.attr,
+	&dev_attr_timeout.attr,
+	NULL
+};
+
+static struct attribute_group di_device_attr_group = {
+	.attrs	= di_device_attrs,
+};
+
+static const struct attribute_group *di_device_attr_groups[] = {
+	&di_device_attr_group,
+	NULL
+};
+
+static int di_init_hw(struct di_driver_data *drvdata)
+{
+	di_dev_set_reg_base(drvdata->reg_base);
+	return 0;
+}
+
+static int di_clk_enable(struct di_driver_data *drvdata)
+{
+	if (!IS_ERR_OR_NULL(drvdata->iclk)) {
+		int ret = clk_prepare_enable(drvdata->iclk);
+
+		if (ret) {
+			DI_ERR(TAG"try to enable di clk failed!\n");
+			return ret;
+		}
+
+		if (!IS_ERR_OR_NULL(drvdata->clk_bus))
+			clk_prepare_enable(drvdata->clk_bus);
+
+		if (!IS_ERR_OR_NULL(drvdata->rst_bus_di))
+			reset_control_deassert(drvdata->rst_bus_di);
+	} else {
+		DI_INFO(TAG"di clk handle is invalid for enable\n");
+	}
+	return 0;
+}
+
+static int di_clk_disable(struct di_driver_data *drvdata)
+{
+	if (!IS_ERR_OR_NULL(drvdata->iclk)) {
+		clk_disable_unprepare(drvdata->iclk);
+		if (!IS_ERR_OR_NULL(drvdata->rst_bus_di))
+			reset_control_assert(drvdata->rst_bus_di);
+
+	} else
+		DI_INFO(TAG"di clk handle is invalid!\n");
+	return 0;
+}
+
+static int di_check_enable_device_locked(
+	struct di_driver_data *drvdata)
+{
+	int ret = 0;
+
+	DI_DEBUG(TAG"client_cnt=%d, pm_state=%d, dev_en=%d\n",
+		drvdata->client_cnt, drvdata->pm_state, drvdata->dev_enable);
+
+	if (drvdata->pm_state == DI_PM_STATE_SUSPEND)
+		return 0;
+
+	if ((drvdata->client_cnt > 0)
+		&& (drvdata->dev_enable == false)) {
+		ret = di_clk_enable(drvdata);
+		if (ret)
+			return ret;
+		drvdata->dev_enable = true;
+	} else if ((drvdata->client_cnt == 0)
+		&& (drvdata->dev_enable == true)) {
+		ret = di_clk_disable(drvdata);
+		if (ret)
+			return ret;
+		drvdata->dev_enable = false;
+	} else if (drvdata->client_cnt < 0) {
+		DI_ERR(TAG"err client_cnt=%d\n", drvdata->client_cnt);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+bool di_drv_is_valid_client(struct di_client *c)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+	struct di_client *client;
+	bool valid = false;
+
+	if (c) {
+		mutex_lock(&drvdata->mlock);
+		list_for_each_entry(client, &drvdata->clients, node) {
+			if (client == c) {
+				valid = true;
+				break;
+			}
+		}
+		mutex_unlock(&drvdata->mlock);
+	}
+
+	if (!valid)
+		DI_ERR("invalid client[0x%p]\n", c);
+
+	return valid;
+}
+
+int di_drv_client_inc(struct di_client *c)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+	int client_cnt;
+
+	mutex_lock(&drvdata->mlock);
+	client_cnt = drvdata->client_cnt + 1;
+	if (client_cnt > DI_CLIENT_CNT_MAX) {
+		mutex_unlock(&drvdata->mlock);
+		DI_ERR(TAG"%s: %d > max_clients[%d]\n",
+			__func__, client_cnt, DI_CLIENT_CNT_MAX);
+		return -EINVAL;
+	}
+	drvdata->client_cnt = client_cnt;
+	list_add_tail(&c->node, &drvdata->clients);
+	di_check_enable_device_locked(drvdata);
+	mutex_unlock(&drvdata->mlock);
+
+	return 0;
+}
+
+int di_drv_client_dec(struct di_client *c)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+	int client_cnt;
+
+	mutex_lock(&drvdata->mlock);
+	list_del(&c->node);
+
+	client_cnt = drvdata->client_cnt;
+	if (client_cnt > 0) {
+		drvdata->client_cnt--;
+		di_check_enable_device_locked(drvdata);
+	} else {
+		mutex_unlock(&drvdata->mlock);
+		DI_INFO(TAG"%s:client_cnt=%d\n", __func__, client_cnt);
+		return -EINVAL;
+	}
+	mutex_unlock(&drvdata->mlock);
+
+	return 0;
+}
+
+static int di_drv_wait2start(
+	struct di_driver_data *drvdata, struct di_client *c)
+{
+	const u64 wait2start = c->timeout.wait4start;
+	long ret = 0;
+	unsigned long flags;
+	u32 id;
+	u32 wait_con;
+
+	spin_lock_irqsave(&drvdata->queue_lock, flags);
+
+	if (drvdata->task_cnt >= DI_TASK_CNT_MAX) {
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+		DI_ERR(TAG"too many tasks %d\n", drvdata->task_cnt);
+		return -EBUSY;
+	}
+
+	id = (drvdata->front + drvdata->task_cnt) % DI_TASK_CNT_MAX;
+	drvdata->queue[id] = c;
+	drvdata->task_cnt++;
+	if (drvdata->state == DI_DRV_STATE_IDLE) {
+		drvdata->state = DI_DRV_STATE_BUSY;
+		atomic_set(&c->wait_con, DI_PROC_STATE_2START);
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+		return 0;
+	}
+
+	if (wait2start == 0) {
+		drvdata->queue[id] = NULL;
+		drvdata->task_cnt--;
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+		DI_ERR(TAG"wait4start=%lluns too short to wait\n",
+			wait2start);
+		return -ETIMEDOUT;
+	}
+	atomic_set(&c->wait_con, DI_PROC_STATE_WAIT2START);
+
+	spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+
+	ret = wait_event_interruptible_hrtimeout(c->wait,
+		atomic_read(&c->wait_con) == DI_PROC_STATE_2START,
+		ns_to_ktime(wait2start));
+
+	if (atomic_read(&c->wait_con) != DI_PROC_STATE_2START) {
+		spin_lock_irqsave(&drvdata->queue_lock, flags);
+		wait_con = atomic_read(&c->wait_con); /* check-again */
+		if (wait_con != DI_PROC_STATE_2START) {
+			drvdata->queue[id] = NULL;
+			drvdata->task_cnt--;
+			spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+			DI_ERR(TAG"wait2start(%lluns) fail, con=%u, ret(%ld)\n",
+				wait2start, wait_con, ret);
+			return -ETIMEDOUT;
+		}
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+	}
+
+	return 0;
+}
+
+static int di_drv_wait4finish(
+	struct di_driver_data *drvdata, struct di_client *c)
+{
+	long ret = 0;
+	unsigned long flags;
+	int wait_con;
+	const u64 wait4finish = c->timeout.wait4finish;
+
+	ret = wait_event_interruptible_hrtimeout(c->wait,
+		atomic_read(&c->wait_con) != DI_PROC_STATE_WAIT4FINISH,
+		ns_to_ktime(wait4finish));
+
+	if (atomic_read(&c->wait_con) != DI_PROC_STATE_FINISH) {
+		spin_lock_irqsave(&drvdata->queue_lock, flags);
+		wait_con = atomic_read(&c->wait_con); /* check-again */
+		if (wait_con == DI_PROC_STATE_WAIT4FINISH) {
+			di_dev_query_state_with_clear();
+			drvdata->queue[drvdata->front] = NULL;
+			drvdata->front = (drvdata->front + 1) % DI_TASK_CNT_MAX;
+			drvdata->task_cnt--;
+			drvdata->state = DI_DRV_STATE_IDLE;
+		}
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+
+		if (wait_con == DI_PROC_STATE_WAIT4FINISH) {
+			DI_ERR(TAG"wait4finish(%lluns) timeout, ret=%ld\n",
+				wait4finish, ret);
+			return ret ? ret : -ETIME;
+		} else if (wait_con != DI_PROC_STATE_FINISH) {
+			DI_ERR(TAG"wait4finish(%lluns) err, ret=%ld, con=%u\n",
+				wait4finish, ret, wait_con);
+			return ret ? ret : -wait_con;
+		}
+	}
+
+	DI_DEBUG("Processing frame %llu\n", c->proc_fb_seqno);
+	c->proc_fb_seqno++;
+	return 0;
+}
+
+/* caller must make sure c is valid */
+int di_drv_process_fb(struct di_client *c)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+	int ret = 0;
+	unsigned long flags;
+
+	ret = di_drv_wait2start(drvdata, c);
+	if (ret)
+		return ret;
+
+	ret = di_dev_apply(c);
+
+	spin_lock_irqsave(&drvdata->queue_lock, flags);
+	atomic_set(&c->wait_con, DI_PROC_STATE_WAIT4FINISH);
+	spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+
+	ret |= di_drv_wait4finish(drvdata, c);
+
+	return ret;
+}
+
+static irqreturn_t di_irq_handler(int irq, void *dev_id)
+{
+	struct di_driver_data *drvdata = dev_id;
+	unsigned long flags;
+	struct di_client *c;
+	int wait_con;
+	u32 hw_state;
+
+	if (irq != drvdata->irq_no) {
+		DI_ERR("invalid irq no:%d %d\n", irq, drvdata->irq_no);
+		return IRQ_NONE;
+	}
+
+	spin_lock_irqsave(&drvdata->queue_lock, flags);
+
+	hw_state = di_dev_query_state_with_clear();
+
+	if (drvdata->task_cnt == 0) {
+		DI_ERR("NO task count\n");
+		goto irq_out;
+	}
+
+	c = drvdata->queue[drvdata->front];
+	wait_con = atomic_read(&c->wait_con);
+	if (wait_con == DI_PROC_STATE_WAIT4FINISH) {
+		if (hw_state)
+			atomic_set(&c->wait_con, DI_PROC_STATE_FINISH);
+		else
+			atomic_set(&c->wait_con, DI_PROC_STATE_FINISH_ERR);
+
+		wake_up_interruptible(&c->wait);
+
+		drvdata->queue[drvdata->front] = NULL;
+		drvdata->task_cnt--;
+		drvdata->state = DI_DRV_STATE_IDLE;
+
+		if (drvdata->task_cnt == 0)
+			goto irq_out;
+
+		drvdata->front = (drvdata->front + 1) % DI_TASK_CNT_MAX;
+		c = drvdata->queue[drvdata->front];
+		wait_con = atomic_read(&c->wait_con);
+	}
+
+	if (wait_con == DI_PROC_STATE_WAIT2START) {
+		atomic_set(&c->wait_con, DI_PROC_STATE_2START);
+		drvdata->state = DI_DRV_STATE_BUSY;
+		wake_up_interruptible(&c->wait);
+	}
+
+irq_out:
+	spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/* unload resources of di device */
+static void di_unload_resource(struct di_driver_data *drvdata)
+{
+	if (drvdata->reg_base)
+		iounmap(drvdata->reg_base);
+
+	if (drvdata->irq_no != 0)
+		DI_INFO(TAG"maybe should ummap irq[%d]...\n", drvdata->irq_no);
+
+	if (!IS_ERR_OR_NULL(drvdata->clk_source))
+		clk_put(drvdata->clk_source);
+	if (!IS_ERR_OR_NULL(drvdata->iclk))
+		clk_put(drvdata->iclk);
+}
+
+/* parse and load resources of di device */
+static int di_parse_dt(struct platform_device *pdev,
+	struct di_driver_data *drvdata)
+{
+	int ret = 0;
+	struct device_node *node = pdev->dev.of_node;
+
+	/* clk */
+	drvdata->iclk = of_clk_get(node, 0);
+	if (IS_ERR_OR_NULL(drvdata->iclk)) {
+		DI_ERR(TAG"get di clock failed!\n");
+		ret = PTR_ERR(drvdata->iclk);
+		goto err_out;
+	}
+
+	drvdata->rst_bus_di = devm_reset_control_get(&pdev->dev, "rst_bus_di");
+	if (IS_ERR(drvdata->rst_bus_di)) {
+		DI_ERR(TAG"get di bus reset control  failed!\n");
+		ret = PTR_ERR(drvdata->rst_bus_di);
+		goto err_out;
+	}
+
+	drvdata->clk_bus = of_clk_get(node, 1);
+	if (IS_ERR_OR_NULL(drvdata->clk_bus)) {
+		DI_ERR(TAG"get clk_source clock failed!\n");
+		ret = PTR_ERR(drvdata->clk_bus);
+		goto err_out;
+	}
+	/* fixme: set iclk's parent as clk_source */
+
+	/* irq */
+	drvdata->irq_no = irq_of_parse_and_map(node, 0);
+	if (drvdata->irq_no == 0) {
+		DI_ERR(TAG"platform_get_irq failed!\n");
+		ret = -EINVAL;
+		goto err_out;
+	}
+	ret = devm_request_irq(&pdev->dev, drvdata->irq_no,
+		di_irq_handler, 0, dev_name(&pdev->dev), drvdata);
+	if (ret) {
+		DI_ERR(TAG"devm_request_irq failed\n");
+		goto err_out;
+	}
+	DI_DEBUG(TAG"di irq_no=%u\n", drvdata->irq_no);
+
+	/* reg */
+	drvdata->reg_base = of_iomap(node, 0);
+	if (!drvdata->reg_base) {
+		DI_ERR(TAG"of_iomap failed\n");
+		ret =  -ENOMEM;
+		goto err_out;
+	}
+	DI_DEBUG(TAG"di reg_base=0x%p\n", drvdata->reg_base);
+
+err_out:
+	return ret;
+}
+
+static int di_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device_node *node = pdev->dev.of_node;
+	struct di_driver_data *drvdata = NULL;
+
+	if (!of_device_is_available(node)) {
+		DI_ERR(TAG"DEINTERLACE device is not configed\n");
+		return -ENODEV;
+	}
+
+	drvdata = kzalloc(sizeof(*drvdata), GFP_KERNEL);
+	if (drvdata == NULL) {
+		DI_ERR(TAG"kzalloc for drvdata failed\n");
+		return -ENOMEM;
+	}
+
+	ret = di_parse_dt(pdev, drvdata);
+	if (ret)
+		goto probe_done;
+
+	reset_control_deassert(drvdata->rst_bus_di);
+	clk_prepare_enable(drvdata->iclk);
+
+	if (!IS_ERR_OR_NULL(drvdata->clk_bus))
+		clk_prepare_enable(drvdata->clk_bus);
+
+	di_utils_set_dma_dev(&pdev->dev);
+
+	ret = di_init_hw(drvdata);
+	if (ret)
+		goto probe_done;
+
+	mutex_init(&drvdata->mlock);
+	INIT_LIST_HEAD(&drvdata->clients);
+	spin_lock_init(&drvdata->queue_lock);
+
+	alloc_chrdev_region(&drvdata->devt, 0, 1, DI_MODULE_NAME);
+	drvdata->pcdev = cdev_alloc();
+	cdev_init(drvdata->pcdev, &di_fops);
+	drvdata->pcdev->owner = THIS_MODULE;
+	ret = cdev_add(drvdata->pcdev, drvdata->devt, 1);
+	if (ret) {
+		DI_ERR(TAG"cdev add major(%d).\n", MAJOR(drvdata->devt));
+		goto probe_done;
+	}
+	drvdata->pclass = class_create(THIS_MODULE, DI_MODULE_NAME);
+	if (IS_ERR(drvdata->pclass)) {
+		DI_ERR(TAG"create class error\n");
+		ret = PTR_ERR(drvdata->pclass);
+		goto probe_done;
+	}
+
+	drvdata->pdev = device_create_with_groups(
+			drvdata->pclass,  NULL, drvdata->devt,
+			NULL, di_device_attr_groups,
+			DI_MODULE_NAME);
+	if (IS_ERR(drvdata->pdev)) {
+		DI_ERR(TAG"device_create error\n");
+		ret = PTR_ERR(drvdata->pdev);
+		goto probe_done;
+	}
+
+	di_drvdata = drvdata;
+	platform_set_drvdata(pdev, (void *)drvdata);
+
+	do {
+		struct di_version version;
+
+		di_drv_get_version(&version);
+		dev_info(&pdev->dev, "version[%d.%d.%d], ip=0x%x\n",
+			version.version_major,
+			version.version_minor,
+			version.version_patchlevel,
+			version.ip_version);
+	} while (0);
+
+	return 0;
+
+probe_done:
+	if (ret) {
+		di_dev_exit();
+		di_unload_resource(drvdata);
+		kfree(drvdata);
+		dev_err(&pdev->dev, "probe failed, errno %d!\n", ret);
+	}
+
+	return ret;
+
+}
+
+static int di_remove(struct platform_device *pdev)
+{
+	struct di_driver_data *drvdata;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	drvdata = platform_get_drvdata(pdev);
+	if (drvdata != NULL) {
+		platform_set_drvdata(pdev, NULL);
+		di_drvdata = NULL;
+
+		if (drvdata->client_cnt > 0)
+			DI_ERR(TAG"still has client_cnt=%d\n",
+				drvdata->client_cnt);
+
+		device_destroy(drvdata->pclass, drvdata->devt);
+		class_destroy(drvdata->pclass);
+		cdev_del(drvdata->pcdev);
+		unregister_chrdev_region(drvdata->devt, 1);
+
+		di_dev_exit();
+		di_unload_resource(drvdata);
+
+		kfree(drvdata);
+	}
+
+	return 0;
+}
+
+static int di_suspend(struct device *dev)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+
+	if (drvdata->state == DI_DRV_STATE_BUSY)
+		DI_INFO(TAG"drv busy on suspend !\n");
+
+	mutex_lock(&drvdata->mlock);
+	drvdata->pm_state = DI_PM_STATE_SUSPEND;
+	if (drvdata->dev_enable == true) {
+		if (di_clk_disable(drvdata))
+			drvdata->dev_enable = false;
+	}
+	mutex_unlock(&drvdata->mlock);
+	return 0;
+}
+
+static int di_resume(struct device *dev)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+
+	mutex_lock(&drvdata->mlock);
+	if (drvdata->client_cnt > 0) {
+		if (di_clk_enable(drvdata))
+			drvdata->dev_enable = true;
+	}
+	drvdata->pm_state = DI_PM_STATE_RESUME;
+	mutex_unlock(&drvdata->mlock);
+	return 0;
+}
+
+static const struct dev_pm_ops di_pm_ops = {
+	.suspend = di_suspend,
+	.resume = di_resume,
+};
+
+static const struct of_device_id di_dt_match[] = {
+	{.compatible = "allwinner,sunxi-deinterlace"},
+	{},
+};
+
+static struct platform_driver di_driver = {
+	.probe = di_probe,
+	.remove = di_remove,
+	.driver = {
+		.name = DI_MODULE_NAME,
+		.owner = THIS_MODULE,
+		.pm = &di_pm_ops,
+		.of_match_table = di_dt_match,
+	},
+};
+
+#ifdef CONFIG_VIDEO_SUNXI_CAR_REVERSE
+static int __init sunxi_di_init(void)
+{
+		pr_info("Deinterlace Module initialized.\n");
+			return platform_driver_register(&di_driver);
+}
+
+static void __exit sunxi_di_exit(void)
+{
+		platform_driver_unregister(&di_driver);
+}
+
+subsys_initcall(sunxi_di_init);
+module_exit(sunxi_di_exit);
+#else
+module_platform_driver(di_driver);
+#endif
+
+int debug_mask = DEBUG_LEVEL_ERR;
+module_param_named(debug_mask, debug_mask, int, 0644);
+
+MODULE_DEVICE_TABLE(of, di_dt_match);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("zhengwanyu@allwinnertech.com");
+MODULE_DESCRIPTION("Sunxi De-Interlace");
+MODULE_VERSION("DI1xx");
diff --git a/drivers/char/sunxi-di/drv_div1xx/di_driver.h b/drivers/char/sunxi-di/drv_div1xx/di_driver.h
new file mode 100644
index 000000000..2a4a13886
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di_driver.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_DRIVER_H_
+#define _DI_DRIVER_H_
+
+#include "di_client.h"
+
+#include <linux/types.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+
+enum di_drv_state {
+	DI_DRV_STATE_IDLE = 0,
+	DI_DRV_STATE_BUSY,
+};
+
+enum di_pm_state {
+	DI_PM_STATE_RESUME = 0,
+	DI_PM_STATE_SUSPEND,
+	DI_PM_STATE_UNKNOWN,
+};
+
+struct di_driver_data {
+	dev_t devt;
+	struct cdev *pcdev;
+	struct class *pclass;
+	struct device *pdev;
+
+	void __iomem *reg_base;
+	u32  irq_no;
+	struct clk *clk_source;
+	struct clk *clk_bus;
+	struct clk *iclk;
+	struct reset_control *rst_bus_di;
+
+	struct mutex mlock;
+	struct list_head clients;
+	int client_cnt;
+	bool dev_enable;
+	enum di_pm_state pm_state;
+
+	spinlock_t queue_lock;
+	u32 front;
+	u32 task_cnt; /* client task count in queue */
+	struct di_client *queue[DI_TASK_CNT_MAX];
+	enum di_drv_state state;
+
+};
+#endif /* #ifndef _DI_DRIVER_H_ */
diff --git a/drivers/char/sunxi-di/drv_div1xx/di_fops.c b/drivers/char/sunxi-di/drv_div1xx/di_fops.c
new file mode 100644
index 000000000..a5d8837d6
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di_fops.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "sunxi_di.h"
+#include "di_client.h"
+
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+
+typedef int di_ioctl_t(struct di_client *c, void *data);
+
+struct di_ioctl_desc {
+	unsigned int cmd;
+	di_ioctl_t *func;
+	const char *name;
+};
+
+#define DI_IOCTL_DEF(ioctl, _func)	\
+	[DI_IOCTL_NR(ioctl)] = {		\
+		.cmd = ioctl,			\
+		.func = (di_ioctl_t *)_func,	\
+		.name = #ioctl			\
+	}
+
+/* Ioctl table */
+static const struct di_ioctl_desc di_ioctls[] = {
+	DI_IOCTL_DEF(DI_IOC_GET_VERSION, di_client_get_version),
+	DI_IOCTL_DEF(DI_IOC_SET_TIMEOUT, di_client_set_timeout),
+	DI_IOCTL_DEF(DI_IOC_PROCESS_FB, di_client_process_fb),
+
+	DI_IOCTL_DEF(DI_IOC_MEM_REQUEST, di_client_mem_request),
+	DI_IOCTL_DEF(DI_IOC_MEM_RELEASE, di_client_mem_release),
+};
+
+#define DI_IOCTL_COUNT	ARRAY_SIZE(di_ioctls)
+
+static long di_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = -EINVAL;
+	struct di_client *c = file->private_data;
+	const struct di_ioctl_desc *ioctl = NULL;
+	unsigned int nr = DI_IOCTL_NR(cmd);
+	char stack_kdata[128];
+	char *kdata = NULL;
+	unsigned int in_size, out_size, ksize;
+
+	if ((c == NULL)
+		|| (nr >= DI_IOCTL_COUNT)) {
+		return -EINVAL;
+	}
+
+	in_size = out_size = ksize = _IOC_SIZE(cmd);
+	if ((cmd & IOC_IN) == 0)
+		in_size = 0;
+	if ((cmd & IOC_OUT) == 0)
+		out_size = 0;
+
+	if (ksize <= sizeof(stack_kdata)) {
+		kdata = stack_kdata;
+	} else {
+		kdata = kmalloc(ksize, GFP_KERNEL);
+		if (!kdata) {
+			ret = -ENOMEM;
+			goto err;
+		}
+	}
+
+	ioctl = &di_ioctls[nr];
+	if (!ioctl->func) {
+		ret = -EINVAL;
+		goto err;
+	}
+	if (in_size > 0) {
+		if (copy_from_user(kdata, (void __user *)arg, in_size) != 0) {
+			ret = -EFAULT;
+			goto err;
+		}
+	}
+	ret = ioctl->func(c, (void *)kdata);
+	if (!ret && out_size > 0)
+		if (copy_to_user((void __user *)arg, kdata, out_size) != 0)
+			ret = -EFAULT;
+
+err:
+	if (kdata != stack_kdata)
+		kfree(kdata);
+
+	return ret;
+}
+
+static int di_open(struct inode *inode, struct file *file)
+{
+	void *client;
+	char debug_name[64];
+
+	snprintf(debug_name, 64, "client_%u",
+		task_pid_nr(current->group_leader));
+	client = di_client_create(debug_name);
+	if (client == NULL)
+		return -EINVAL;
+	file->private_data = client;
+	return 0;
+}
+
+static int di_release(struct inode *inode, struct file *file)
+{
+	di_client_destroy(file->private_data);
+	return 0;
+}
+
+int di_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long mypfn = vma->vm_pgoff;
+	unsigned long vmsize = vma->vm_end - vma->vm_start;
+
+	vma->vm_pgoff = 0;
+
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	if (remap_pfn_range(vma, vma->vm_start, mypfn,
+			    vmsize, vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+const struct file_operations di_fops = {
+	.owner = THIS_MODULE,
+	.open = di_open,
+	.release = di_release,
+	.unlocked_ioctl = di_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = di_ioctl,
+#endif
+	.mmap = di_mmap,
+};
diff --git a/drivers/char/sunxi-di/drv_div1xx/di_fops.h b/drivers/char/sunxi-di/drv_div1xx/di_fops.h
new file mode 100644
index 000000000..3520ba91b
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/di_fops.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_FOPS_H_
+#define _DI_FOPS_H_
+
+#include <linux/fs.h>
+
+extern const struct file_operations di_fops;
+
+#endif /* #ifndef _DI_FOPS_H_ */
diff --git a/drivers/char/sunxi-di/drv_div1xx/sunxi_di.h b/drivers/char/sunxi-di/drv_div1xx/sunxi_di.h
new file mode 100644
index 000000000..22d0028b8
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div1xx/sunxi_di.h
@@ -0,0 +1,179 @@
+/*
+ * Copyright (c) 2020-2031 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_SUNXI_DI_H_
+#define _UAPI_SUNXI_DI_H_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <drm/drm_fourcc.h>
+
+#ifndef __KERNEL__
+typedef __u8 u8;
+typedef __s32 s32;
+typedef __u32 u32;
+typedef __u64 u64;
+#endif /* #ifdef __KERNEL__ */
+
+
+enum {
+	DI_INTP_MODE_INVALID = 0x0,
+	DI_INTP_MODE_BOB,
+	DI_INTP_MODE_MOTION,
+};
+
+enum {
+	DI_OUT_0FRAME = 0x0,
+	DI_OUT_1FRAME,
+	DI_OUT_2FRAME,
+};
+
+enum {
+	DI_TNR_MODE_INVALID = 0,
+	DI_TNR_MODE_ADAPTIVE,
+	DI_TNR_MODE_FIX,
+};
+
+enum {
+	DI_TNR_LEVEL_HIGH = 0,
+	DI_TNR_LEVEL_MIDDLE,
+	DI_TNR_LEVEL_LOW,
+};
+
+enum {
+	DI_BOTTOM_FIELD_FIRST = 0,
+	DI_TOP_FIELD_FIRST = 1,
+};
+
+struct di_version {
+	u32 version_major;
+	u32 version_minor;
+	u32 version_patchlevel;
+
+	u32 ip_version;
+};
+
+struct di_timeout_ns {
+	u64 wait4start;
+	u64 wait4finish;
+};
+
+/*
+ * @mode:
+ * @level:
+ */
+struct di_tnr_mode {
+	u32 mode;
+	u32 level;
+};
+
+struct di_size {
+	u32 width;
+	u32 height;
+};
+
+struct di_rect {
+	u32 left;
+	u32 top;
+	u32 right;
+	u32 bottom;
+};
+
+struct di_addr {
+	u64 y_addr;
+	u64 cb_addr;
+	u64 cr_addr;
+};
+
+struct di_offset {
+	u64 y_offset;
+	u64 cb_offset;
+	u64 cr_offset;
+};
+
+/*
+ * support dma_buf method or phy_addr_buf method.
+ * 1.On dma_buf method: use di_offset
+ * 2.On phy_addr_buf method: use di_addr
+ */
+union di_buf {
+	struct di_addr addr;
+	struct di_offset offset;
+};
+
+/*
+ * @format: see DRM_FORMAT_XXX in drm_fourcc.h.
+ * @dma_buf_fd: dma buf fd that from userspace.
+ *    @dma_buf_fd must be invalid(<0) on phy_addr_buf method.
+ * @size.width,@size.height: size of pixel datas of image. unit: pixel.
+ */
+struct di_fb {
+	s32 dma_buf_fd;
+	union di_buf buf;
+	struct di_size size;
+};
+
+struct di_process_fb_arg {
+	u8 is_interlace;
+	u8 field_order; /*1:top field first 0:bottom field first*/
+	u32 pixel_format;
+	struct di_size size; /*size of source interlace picture*/
+
+	u8 output_mode; /*0: 1-frame 1: 2-frame*/
+	u8 di_mode; /*0:motion adaptive mode  1:inter field interpolation mode*/
+
+	struct di_tnr_mode tnr_mode;
+
+	struct di_fb in_fb0;
+	struct di_fb in_fb1;
+	struct di_fb in_fb2;
+
+	struct di_fb out_fb0;
+	struct di_fb out_fb1;
+	struct di_fb out_tnr_fb;
+
+};
+
+struct di_mem_arg {
+	unsigned int size;
+	unsigned int handle;
+	u64 phys_addr;
+};
+
+#define DI_IOC_MAGIC 'D'
+#define DI_IO(nr)          _IO(DI_IOC_MAGIC, nr)
+#define DI_IOR(nr, size)   _IOR(DI_IOC_MAGIC, nr, size)
+#define DI_IOW(nr, size)   _IOW(DI_IOC_MAGIC, nr, size)
+#define DI_IOWR(nr, size)  _IOWR(DI_IOC_MAGIC, nr, size)
+#define DI_IOCTL_NR(n)     _IOC_NR(n)
+
+#define DI_IOC_GET_VERSION    DI_IOR(0x0, struct di_version)
+/*
+#define DI_IOC_RESET          DI_IO(0x1)
+#define DI_IOC_CHECK_PARA     DI_IO(0x2)
+*/
+#define DI_IOC_SET_TIMEOUT    DI_IOW(0x3, struct di_timeout_ns)
+/*
+#define DI_IOC_SET_VIDEO_SIZE DI_IOW(0x4, struct di_size)
+#define DI_IOC_SET_DIT_MODE   DI_IOW(0x5, struct di_dit_mode)
+#define DI_IOC_SET_TNR_MODE   DI_IOW(0x6, struct di_tnr_mode)
+#define DI_IOC_SET_FMD_ENABLE DI_IOW(0x7, struct di_fmd_enable)
+*/
+#define DI_IOC_PROCESS_FB     DI_IOW(0x8, struct di_process_fb_arg)
+//#define DI_IOC_SET_VIDEO_CROP DI_IOW(0x9, struct di_rect)
+#define DI_IOC_MEM_REQUEST    DI_IOWR(0x10, struct di_mem_arg)
+#define DI_IOC_MEM_RELEASE    DI_IOWR(0x11, struct di_mem_arg)
+//#define DI_IOC_SET_DEMO_CROP  DI_IOW(0x12, struct di_demo_crop_arg)
+
+extern unsigned int di_device_get_debug_mode(void);
+#endif /* #ifndef _UAPI_SUNXI_DI_H_ */
diff --git a/drivers/char/sunxi-di/drv_div2x/Makefile b/drivers/char/sunxi-di/drv_div2x/Makefile
new file mode 100644
index 000000000..454742e1b
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/Makefile
@@ -0,0 +1,44 @@
+sunxi_di_dir := drv_div2x
+sunxi_di := $(sunxi_di_dir)/sunxi-di.o
+
+ifeq ($(CONFIG_ARCH_SUN50IW6P1),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v2x/di_v2x.o
+endif
+
+ifeq ($(CONFIG_ARCH_SUN8IW12P1),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v2x/di_v2x.o
+endif
+
+ifeq ($(CONFIG_ARCH_SUN8IW17P1),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v2x/di_v2x.o
+endif
+
+ifeq ($(CONFIG_ARCH_SUN50IW2),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v1x/di_ebios.o \
+			$(sunxi_di_dir)/lowlevel_v1x/di.o
+endif
+
+ifeq ($(CONFIG_ARCH_SUN8IW10),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v1x/di_ebios.o \
+			$(sunxi_di_dir)/lowlevel_v1x/di.o
+endif
+
+ifeq ($(CONFIG_ARCH_SUN8IW11),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v1x/di_ebios.o \
+			$(sunxi_di_dir)/lowlevel_v1x/di.o
+endif
+
+ifeq ($(CONFIG_ARCH_SUN3IW1),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v1x/di_ebios_sun3i.o.o \
+			$(sunxi_di_dir)/lowlevel_v1x/di.o
+endif
+
+ifeq ($(CONFIG_ARCH_SUN50IW1),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v1x/di_ebios.o \
+			$(sunxi_di_dir)/lowlevel_v1x/di.o
+endif
+
+ifeq ($(CONFIG_ARCH_SUN8IW7P1),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v1x/di_ebios.o \
+			$(sunxi_di_dir)/lowlevel_v1x/di.o
+endif
\ No newline at end of file
diff --git a/drivers/char/sunxi-di/drv_div2x/di.h b/drivers/char/sunxi-di/drv_div2x/di.h
new file mode 100644
index 000000000..8bf01bb5d
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/di.h
@@ -0,0 +1,149 @@
+/*
+ * Allwinner SoCs de-interlace driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __DI_H__
+#define __DI_H__
+
+#include <linux/types.h>
+
+enum __di_pixel_fmt_t {
+	DI_FORMAT_NV12 = 0x00, /* 2-plane */
+	DI_FORMAT_NV21 = 0x01, /* 2-plane */
+	DI_FORMAT_MB32_12 = 0x02, /* NOT SUPPORTED, UV mapping like NV12 */
+	DI_FORMAT_MB32_21 = 0x03, /* NOT SUPPORTED, UV mapping like NV21 */
+	DI_FORMAT_YV12 = 0x04, /* 3-plane */
+	DI_FORMAT_YUV422_SP_UVUV = 0x08, /* 2-plane, New in DI_V2.2 */
+	DI_FORMAT_YUV422_SP_VUVU = 0x09, /* 2-plane, New in DI_V2.2 */
+	DI_FORMAT_YUV422P = 0x0c, /* 3-plane, New in DI_V2.2 */
+	DI_FORMAT_MAX,
+};
+
+enum __di_intp_mode_t {
+	DI_MODE_WEAVE = 0x0, /* Copy source to destination */
+	DI_MODE_INTP = 0x1, /* Use current field to interpolate another field */
+	DI_MODE_MOTION = 0x2, /* Use 4-field to interpolate another field */
+};
+
+enum __di_updmode_t {
+	DI_UPDMODE_FIELD = 0x0, /* Output 2 frames when updated 1 input frame */
+	DI_UPDMODE_FRAME = 0x1, /* Output 1 frame when updated 1 input frame */
+};
+
+struct __di_rectsz_t {
+	unsigned int width;
+	unsigned int height;
+};
+
+struct __di_fb_t {
+	void	*addr[2];              /* frame buffer address */
+	struct	__di_rectsz_t		size;           /* size pixel */
+	enum	__di_pixel_fmt_t	format;
+};
+
+struct __di_para_t {
+	struct __di_fb_t       input_fb;          /* current frame fb */
+	struct __di_fb_t       pre_fb;            /* previous frame fb */
+	struct __di_rectsz_t   source_regn;    /* current frame and
+						* previous frame process region
+						*/
+	struct __di_fb_t       output_fb;	  /* output frame fb */
+	struct __di_rectsz_t   out_regn;          /* output frame region */
+	__u32           field;                  /* process field <0-top field ;
+						 * 1-bottom field>
+						 */
+	__u32          top_field_first;        /* video information <0-is not
+						* top_field_first; 1-is top_
+						* field_first>
+						*/
+};
+
+/* di_format_attr - display format attribute
+ *
+ * @format: pixel format
+ * @bits: bits of each component
+ * @hor_rsample_u: reciprocal of horizontal sample rate
+ * @hor_rsample_v: reciprocal of horizontal sample rate
+ * @ver_rsample_u: reciprocal of vertical sample rate
+ * @hor_rsample_v: reciprocal of vertical sample rate
+ * @uvc: 1: u & v component combined
+ * @interleave: 0: progressive, 1: interleave
+ * @factor & div: bytes of pixel = factor / div (bytes)
+ *
+ * @addr[out]: address for each plane
+ * @trd_addr[out]: address for each plane of right eye buffer
+ */
+struct di_format_attr {
+	enum __di_pixel_fmt_t format;
+	unsigned int bits;
+	unsigned int hor_rsample_u;
+	unsigned int hor_rsample_v;
+	unsigned int ver_rsample_u;
+	unsigned int ver_rsample_v;
+	unsigned int uvc;
+	unsigned int interleave;
+	unsigned int factor;
+	unsigned int div;
+};
+
+struct __di_fb_t2 {
+	int fd;
+	unsigned long long addr[3]; /* frame buffer address */
+	struct __di_rectsz_t size; /* size (in pixel) */
+	enum __di_pixel_fmt_t format;
+};
+
+struct __di_para_t2 {
+	struct __di_fb_t2 input_fb; /* current frame fb */
+	struct __di_fb_t2 pre_fb; /* previous frame fb */
+	struct __di_fb_t2 next_fb; /* next frame fb */
+	struct __di_rectsz_t source_regn; /* current frame /previous frame and
+					   * next frame process region
+					   */
+	struct __di_fb_t2 output_fb; /* output frame fb */
+	struct __di_rectsz_t out_regn; /* output frame region */
+	unsigned int field; /* process field <0-first field ; 1-second field> */
+	unsigned int top_field_first; /* video information <0-is not
+				       *top_field_first; 1-is top_field_first>
+				       */
+	/* unsigned int update_mode; */
+			/* update buffer mode <0-update 1 frame,
+			output 2 frames; 1-update 1 frame, output 1 frame> */
+	int id;
+	int dma_if;
+};
+
+/* New in DI_2.X */
+struct __di_mode_t {
+	enum __di_intp_mode_t di_mode;
+	enum __di_updmode_t update_mode;
+};
+
+struct __di_mem_t {
+	unsigned int size;
+	void *v_addr;
+	unsigned long p_addr;
+};
+
+s32 di_set_reg_base(void *base);
+void *di_get_reg_base(void);
+s32 di_set_init(void);
+s32 di_reset(void);
+s32 di_start(void);
+s32 di_irq_enable(u32 enable);
+s32 di_get_status(void);
+s32 di_irq_clear(void);
+s32 di_set_para(struct __di_para_t2 *para, void *in_flag_add,
+		void *out_flag_add,  u32 field);
+void di_set_mode(struct __di_mode_t *di_mode);
+s32 di_sw_para_to_reg(u8 type, u8 format);
+s32 di_internal_clk_enable(void);
+s32 di_internal_clk_disable(void);
+
+#endif
diff --git a/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di.c b/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di.c
new file mode 100644
index 000000000..ec89be03e
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di.c
@@ -0,0 +1,292 @@
+/*
+ * Allwinner SoCs de-interlace driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+
+#include "../di.h"
+#include "di_ebios.h"
+#include <linux/slab.h>
+
+volatile __di_dev_t *di_dev;
+
+/* function: di_set_reg_base(u32 base)
+ * description: set di module register base
+ * parameters: base <di module AHB memory mapping >
+ * return   :
+ */
+s32 di_set_reg_base(void *base)
+{
+	di_dev = (__di_dev_t *)base;
+
+	return 0;
+}
+
+/* function: di_get_reg_base(void)
+ * description: get di module register base
+ * parameters:
+ * return   : di module AHB memory mapping
+ */
+void *di_get_reg_base(void)
+{
+	void *ret = NULL;
+
+	ret = (void *)(di_dev);
+
+	return ret;
+}
+
+/* function: di_set_init(void)
+ * description: set di module default register to ready de-interlace
+ * parameters:
+ * return   :
+ */
+s32 di_set_init(void)
+{
+	DI_Init();
+
+	return 0;
+}
+
+/* function: di_reset(void)
+ * description: stop di module
+ * parameters:
+ * return   :
+ */
+s32 di_reset(void)
+{
+	DI_Set_Reset();
+
+	return 0;
+}
+
+/* function: di_start(void)
+ * description: start a de-interlace function
+ * parameters:
+ * return   :
+ */
+s32 di_start(void)
+{
+	DI_Set_Writeback_Start();
+
+	return 0;
+}
+
+/* function: di_irq_enable(u32 enable)
+ * description: enable/disable di irq
+ * parameters: enable <0-disable; 1-enable>
+ * return   :
+ */
+s32 di_irq_enable(u32 enable)
+{
+	DI_Set_Irq_Enable(enable);
+
+	return 0;
+}
+
+/*
+* function: di_get_status(void)
+* description: get status of di module
+* parameters:
+* return  :  <0-Writeback finish; 1-Writeback no start;
+*			 2-Writeback-ing; (-1)-Undefined
+*/
+s32 di_get_status(void)
+{
+	s32 ret;
+
+	ret = DI_Get_Irq_Status();
+	return ret;
+}
+
+/* function: di_irq_clear()
+ * description: clear irq status
+ * parameters:
+ * return   :
+ */
+s32 di_irq_clear(void)
+{
+	DI_Clear_irq();
+
+	return 0;
+}
+
+/* function: di_set_para(__disp_scaler_para_t *para)
+ * description: set parameters to ready a de-interlace function
+ * parameters: para <parameters which set from ioctrl>
+ * in_flag_add/out_flag_add <flag address malloc in driver>
+ * field <0 - select even line for source line;
+ * 1 - select odd line for source line>
+ * return  :   <0 - set OK; 1 - para NULL>
+ */
+s32 di_set_para(struct __di_para_t2 *para, void *in_flag_add,
+		void *out_flag_add, u32 field)
+{
+	__di_buf_addr_t in_addr;
+	__di_buf_addr_t out_addr;
+	__di_src_size_t in_size;
+	__di_out_size_t out_size;
+	__di_src_type_t in_type;
+	__di_out_type_t out_type;
+	__di_buf_addr_t pre_addr;
+	unsigned long in_address = 0;
+	unsigned long out_address = 0;
+	unsigned long ch0_addr = 0;
+	unsigned long ch1_addr = 0;
+
+	if (para == NULL) {
+		/* DE_WRN("input parameter can't be null!\n"); */
+		return -1;
+	}
+
+	in_type.fmt = di_sw_para_to_reg(0, para->input_fb.format);
+	in_type.mod = di_sw_para_to_reg(1, para->input_fb.format);
+	in_type.ps = di_sw_para_to_reg(2, para->input_fb.format);
+
+	out_type.fmt = di_sw_para_to_reg(3, para->output_fb.format);
+	out_type.ps = di_sw_para_to_reg(4, para->output_fb.format);
+	out_type.alpha_en = 0;
+
+	out_size.width  = para->out_regn.width;
+	out_size.height = para->out_regn.height;
+	out_size.fb_width = para->output_fb.size.width;
+	out_size.fb_height = para->output_fb.size.height;
+
+	ch0_addr = (unsigned long)(para->input_fb.addr[0]);
+	ch1_addr = (unsigned long)(para->input_fb.addr[1]);
+	in_addr.ch0_addr = (u32)(ch0_addr);
+	in_addr.ch1_addr = (u32)(ch1_addr);
+	in_addr.ch0_addr = (u32)DI_VAtoPA(in_addr.ch0_addr);
+	in_addr.ch1_addr = (u32)DI_VAtoPA(in_addr.ch1_addr);
+
+	in_size.src_width = para->input_fb.size.width;
+	in_size.src_height = para->input_fb.size.height;
+	in_size.scal_width = para->source_regn.width;
+	in_size.scal_height = para->source_regn.height;
+
+	ch0_addr = (unsigned long)(para->output_fb.addr[0]);
+	ch1_addr = (unsigned long)(para->output_fb.addr[1]);
+	out_addr.ch0_addr = (u32)(ch0_addr);
+	out_addr.ch1_addr = (u32)(ch1_addr);
+
+	ch0_addr = (unsigned long)(para->pre_fb.addr[0]);
+	ch1_addr = (unsigned long)(para->pre_fb.addr[1]);
+	pre_addr.ch0_addr = (u32)(ch0_addr);
+	pre_addr.ch1_addr = (u32)(ch1_addr);
+
+	out_addr.ch0_addr = DI_VAtoPA(out_addr.ch0_addr);
+	out_addr.ch1_addr = DI_VAtoPA(out_addr.ch1_addr);
+
+	pre_addr.ch0_addr = DI_VAtoPA(pre_addr.ch0_addr);
+	pre_addr.ch1_addr = DI_VAtoPA(pre_addr.ch1_addr);
+
+	DI_Module_Enable();
+
+	DI_Config_Src(&in_addr, &in_size, &in_type);
+	DI_Set_Scaling_Factor(&in_size, &out_size);
+	DI_Set_Scaling_Coef(&in_size, &out_size, &in_type, &out_type);
+	DI_Set_Out_Format(&out_type);
+	DI_Set_Out_Size(&out_size);
+	DI_Set_Writeback_Addr_ex(&out_addr, &out_size, &out_type);
+
+	DI_Set_Di_PreFrame_Addr(pre_addr.ch0_addr, pre_addr.ch1_addr);
+	in_address = (unsigned long)(in_flag_add);
+	out_address = (unsigned long)(out_flag_add);
+	in_address = DI_VAtoPA(in_address);
+	out_address = DI_VAtoPA(out_address);
+	DI_Set_Di_MafFlag_Src((u32)(in_address), (u32)(out_address), 0x200);
+	DI_Set_Di_Field(field);
+
+	DI_Enable();
+	DI_Set_Reg_Rdy();
+
+	return 0;
+}
+
+/* 0:deinterlace input pixel format
+ * 1:deinterlace input yuv mode
+ * 2:deinterlace input pixel sequence
+ * 3:deinterlace output format
+ * 4:deinterlace output pixel sequence
+ */
+s32 di_sw_para_to_reg(u8 type, u8 format)
+{
+	/* deinterlace input  pixel format */
+	if (type == 0)	{
+		if (format <= DI_FORMAT_MB32_21)
+			return DI_INYUV420;
+		else {
+			/* DE_INF("not supported de-interlace input pixel
+			 * format:%d in di_sw_para_to_reg\n",format);
+			 */
+		}
+	}
+	/* deinterlace input mode */
+	else if (type == 1) {
+		if ((format == DI_FORMAT_MB32_21) ||
+				(format == DI_FORMAT_MB32_12))
+			return DI_UVCOMBINEDMB;
+		else if ((format == DI_FORMAT_NV21) ||
+				(format == DI_FORMAT_NV12))
+			return DI_UVCOMBINED;
+		else {
+			/* DE_INF("not supported de-interlace input mode:%d
+			 * in di_sw_para_to_reg\n", format);
+			 */
+		}
+	}
+	/* deinterlace input pixel sequence */
+	else if (type == 2) {
+		if ((format == DI_FORMAT_MB32_12) ||
+				(format == DI_FORMAT_NV12))
+			return DI_UVUV;
+		else if ((format == DI_FORMAT_MB32_21) ||
+				(format == DI_FORMAT_NV21))
+			return DI_VUVU;
+		else {
+			/* DE_INF("not supported de-interlace input
+			 * pixel sequence:%d in di_sw_para_to_reg\n",format);
+			 */
+		}
+	}
+	/* deinterlace output format */
+	else if (type == 3) {
+		if ((format == DI_FORMAT_NV12) || (format == DI_FORMAT_NV21))
+			return DI_OUTUVCYUV420;
+		else {
+			/* DE_INF("not supported de-interlace output format :%d
+			 * in di_sw_para_to_reg\n", format);
+			 */
+		}
+	}
+	/*deinterlace output pixel sequence*/
+	else if (type == 4) {
+		if (format == DI_FORMAT_NV12)
+			return DI_UVUV;
+		else if (format == DI_FORMAT_NV21)
+			return DI_VUVU;
+		else {
+			/* DE_INF("not supported de-interlace output pixel
+			 * sequence:%d in di_sw_para_to_reg\n", format);
+			 */
+		}
+	}
+	/* DE_INF("not supported type:%d in di_sw_para_to_reg\n", type); */
+	return -1;
+}
+
+
+s32 di_internal_clk_enable(void)
+{
+	return DI_Internal_Set_Clk(1);
+}
+
+s32 di_internal_clk_disable(void)
+{
+	return DI_Internal_Set_Clk(0);
+}
diff --git a/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios.c b/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios.c
new file mode 100644
index 000000000..258b35f8e
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios.c
@@ -0,0 +1,533 @@
+/*
+ * Allwinner SoCs de-interlace driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include "di_ebios.h"
+#include "di_ebios_data.h"
+#include <linux/slab.h>
+#include <asm/io.h>
+
+extern volatile __di_dev_t *di_dev;
+
+__u32 DI_VAtoPA(__u32 va)
+{
+	if ((va) > 0x40000000)
+		return (va) - 0x40000000;
+	return va;
+}
+
+/* should initial some registers for memory-to-memory de-interlace used */
+__s32 DI_Init(void)
+{
+#if defined CONFIG_ARCH_SUN9IW1
+	di_dev->trd_ctrl.dwval = 0;
+	di_dev->ch0_horzphase.bits.phase = 0;
+	di_dev->ch1_horzphase.bits.phase = 0;
+	di_dev->ch0_vertphase0.bits.phase = 0;
+	di_dev->ch0_vertphase1.bits.phase = 0;
+	di_dev->ch1_vertphase0.bits.phase = 0;
+	di_dev->ch1_vertphase1.bits.phase = 0;
+	di_dev->output_fmt.bits.byte_seq = 0;
+	di_dev->input_fmt.bits.byte_seq = 0;
+
+#endif
+
+	di_dev->bypass.bits.csc_bypass_en = 1; /* bypass CSC */
+	di_dev->wb_linestrd_en.dwval = 0x1;
+	di_dev->frm_ctrl.bits.out_ctrl = 1;
+	di_dev->output_fmt.bits.alpha_en = 0x0;
+	di_dev->bypass.bits.sram_map_sel = 0; /* normal mode */
+	di_dev->agth_sel.bits.linebuf_agth = 1;
+
+	DI_Set_Di_Ctrl(1, 3, 1, 1);
+
+	return 0;
+}
+
+__s32 DI_Config_Src(__di_buf_addr_t *addr, __di_src_size_t *size,
+			__di_src_type_t *type)
+{
+/* __u8 w_shift, h_shift; */
+	__u32 image_w0, image_w1;
+/* __u32 x_off0, y_off0, x_off1, y_off1; */
+	__u32 in_w0, in_h0, in_w1, in_h1;
+/* __u8 rgb16mode = 0; */
+
+	image_w0 = size->src_width;
+	in_w0 = size->scal_width;
+	in_h0 = size->scal_height;
+
+	image_w1 = (image_w0 + 0x1)>>1;
+	in_w1 = (in_w0 + 0x1)>>1;
+	in_h1 = (in_h0 + 0x1)>>1;
+
+	/* added no-zero limited */
+	in_h0 = (in_h0 != 0) ? in_h0 : 1;
+	in_h1 = (in_h1 != 0) ? in_h1 : 1;
+	in_w0 = (in_w0 != 0) ? in_w0 : 1;
+	in_w1 = (in_w1 != 0) ? in_w1 : 1;
+
+	if (type->mod == DI_UVCOMBINED) {
+		di_dev->linestrd0.dwval = image_w0;
+		di_dev->linestrd1.dwval = image_w1<<1;
+		di_dev->linestrd2.dwval = 0x0;
+
+		di_dev->buf_addr0.dwval = addr->ch0_addr;
+		di_dev->buf_addr1.dwval = addr->ch1_addr;
+		di_dev->buf_addr2.dwval = 0x0;
+	} else if (type->mod == DI_UVCOMBINEDMB) {
+		image_w0 = (image_w0 + 0x1f)&0xffffffe0;
+		image_w1 = (image_w1 + 0x0f)&0xfffffff0;
+		/* block offset */
+		di_dev->tb_off0.bits.x_offset0 = 0;
+		di_dev->tb_off0.bits.y_offset0 = 0;
+		di_dev->tb_off0.bits.x_offset1 = (in_w0 + 0x1f) & 0x1f;
+		di_dev->tb_off1.bits.x_offset0 = 0;
+		di_dev->tb_off1.bits.y_offset0 = 0;
+		di_dev->tb_off1.bits.x_offset1 = (((in_w1)<<1) + 0x1f) & 0x1f;
+
+		di_dev->linestrd0.dwval =
+			(((image_w0 + 0x1f)&0xffe0) - 0x1f)<<0x05;
+		di_dev->linestrd1.dwval =
+			(((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
+		di_dev->linestrd2.dwval = 0x00;
+
+		di_dev->buf_addr0.dwval = addr->ch0_addr;
+		di_dev->buf_addr1.dwval = addr->ch1_addr;
+		di_dev->buf_addr2.dwval = 0x0;
+	}
+
+	di_dev->input_fmt.bits.data_mod = type->mod;
+	di_dev->input_fmt.bits.data_fmt = type->fmt;
+	di_dev->input_fmt.bits.data_ps = type->ps;
+
+	di_dev->ch0_insize.bits.in_width = in_w0 - 1;
+	di_dev->ch0_insize.bits.in_height = in_h0 - 1;
+	di_dev->ch1_insize.bits.in_width = in_w1 - 1;
+	di_dev->ch1_insize.bits.in_height = in_h1 - 1;
+
+	return 0;
+}
+
+__s32 DI_Set_Scaling_Factor(__di_src_size_t *in_size,
+				__di_out_size_t *out_size)
+{
+	__s32 in_w0, in_h0, out_w0, out_h0;
+	__s32 ch0_hstep, ch0_vstep;
+
+	in_w0 = in_size->scal_width;
+	in_h0 = in_size->scal_height;
+
+	out_w0 = out_size->width;
+	out_h0 = out_size->height;
+
+	/* added no-zero limited */
+	in_h0 = (in_h0 != 0) ? in_h0 : 1;
+	in_w0 = (in_w0 != 0) ? in_w0 : 1;
+	out_h0 = (out_h0 != 0) ? out_h0 : 1;
+	out_w0 = (out_w0 != 0) ? out_w0 : 1;
+
+	/* step factor */
+	ch0_hstep = (in_w0<<16)/out_w0;
+	ch0_vstep = (in_h0<<16)/out_h0;
+
+		di_dev->ch0_horzfact.dwval = ch0_hstep;
+	di_dev->ch0_vertfact.dwval = ch0_vstep;
+	di_dev->ch1_horzfact.dwval = ch0_hstep;
+	di_dev->ch1_vertfact.dwval = ch0_vstep;
+
+	return 0;
+}
+
+__s32 DI_Set_Scaling_Coef(__di_src_size_t *in_size, __di_out_size_t *out_size,
+			__di_src_type_t *in_type,  __di_out_type_t *out_type)
+{
+	__s32 in_w0, in_h0, out_w0, out_h0;
+	__u32 int_part, float_part;
+	__u32 zoom0_size, zoom1_size, zoom2_size, zoom3_size, zoom4_size;
+	__u32 zoom5_size, al1_size;
+	__u32 ch0h_sc, ch0v_sc;
+	__u32 ch0v_fir_coef_addr, ch0h_fir_coef_addr;
+	__u32 ch1v_fir_coef_addr, ch1h_fir_coef_addr;
+	__u32 ch0v_fir_coef_ofst, ch0h_fir_coef_ofst;
+#if defined CONFIG_ARCH_SUN9IW1
+	__u32 ch3h_fir_coef_addr, ch3v_fir_coef_addr;
+#else
+	__u32 loop_count = 0;
+#endif
+#if defined SCALE_NO_SUPPORT
+	__s32 i;
+#endif
+	in_w0 = in_size->scal_width;
+	in_h0 = in_size->scal_height;
+	out_w0 = out_size->width;
+	out_h0 = out_size->height;
+
+	zoom0_size = 1;
+	zoom1_size = 2;
+	zoom2_size = 2;
+	zoom3_size = 1;
+	zoom4_size = 1;
+	zoom5_size = 1;
+	al1_size = zoom0_size + zoom1_size + zoom2_size + zoom3_size
+		+ zoom4_size + zoom5_size;
+
+	/* added no-zero limited */
+	in_h0 = (in_h0 != 0) ? in_h0 : 1;
+	in_w0 = (in_w0 != 0) ? in_w0 : 1;
+	out_h0 = (out_h0 != 0) ? out_h0 : 1;
+	out_w0 = (out_w0 != 0) ? out_w0 : 1;
+
+	ch0h_sc = (in_w0<<1)/out_w0;
+	ch0v_sc = (in_h0<<1)/out_h0;
+
+	/* comput the fir coefficient offset in coefficient table */
+	int_part = ch0h_sc>>1;
+	float_part = ch0h_sc & 0x1;
+
+	ch0h_fir_coef_ofst = (int_part == 0)  ? zoom0_size :
+		 (int_part == 1)  ? zoom0_size + float_part :
+		(int_part == 2)  ? zoom0_size + zoom1_size + float_part :
+		(int_part == 3)  ? zoom0_size + zoom1_size + zoom2_size :
+	(int_part == 4)  ? zoom0_size + zoom1_size + zoom2_size + zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+
+	int_part = ch0v_sc>>1;
+	float_part = ch0v_sc & 0x1;
+	ch0v_fir_coef_ofst = (int_part == 0)  ? zoom0_size :
+		(int_part == 1)  ? zoom0_size + float_part :
+		(int_part == 2)  ? zoom0_size + zoom1_size + float_part :
+		(int_part == 3)  ? zoom0_size + zoom1_size + zoom2_size :
+	(int_part == 4)  ? zoom0_size + zoom1_size + zoom2_size + zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+
+#if defined CONFIG_ARCH_SUN9IW1
+	/* compute the fir coeficient address for each channel in horizontal
+	 * and vertical direction
+	 */
+	ch0h_fir_coef_addr = ch0h_fir_coef_ofst<<5;
+	ch0v_fir_coef_addr = ch0v_fir_coef_ofst<<5;
+	ch1h_fir_coef_addr = ch0h_fir_coef_ofst<<5;
+	ch1v_fir_coef_addr = ch0v_fir_coef_ofst<<5;
+	ch3h_fir_coef_addr = ch0h_fir_coef_addr<<5;
+	ch3v_fir_coef_addr = ch0v_fir_coef_addr<<5;
+
+	memcpy(&di_dev->ch0_horzcoef0,
+			lan3coefftab32_left + ch0h_fir_coef_addr, 256);
+	memcpy(&di_dev->ch0_horzcoef1,
+			lan3coefftab32_right + ch0h_fir_coef_addr, 256);
+	memcpy(&di_dev->ch0_vertcoef,
+			lan2coefftab32 + ch0v_fir_coef_addr, 256);
+
+	if ((out_type->fmt == DI_OUTUVCYUV420) ||
+			(in_type->fmt == DI_INYUV420)) {
+		memcpy(&di_dev->ch1_horzcoef0,
+			bicubic8coefftab32_left + ch1h_fir_coef_addr, 256);
+		memcpy(&di_dev->ch1_horzcoef1,
+			bicubic8coefftab32_right + ch1h_fir_coef_addr, 256);
+		memcpy(&di_dev->ch1_vertcoef,
+			bicubic4coefftab32 + ch1v_fir_coef_addr, 256);
+	} else {
+		memcpy(&di_dev->ch1_horzcoef0,
+			lan3coefftab32_left + ch1h_fir_coef_addr, 256);
+		memcpy(&di_dev->ch1_horzcoef1,
+			lan3coefftab32_right + ch1h_fir_coef_addr, 256);
+		memcpy(&di_dev->ch1_vertcoef,
+			lan2coefftab32 + ch1v_fir_coef_addr, 256);
+	}
+
+	if (out_type->alpha_en && (in_type->mod == DI_INTERLEAVED)) {
+		memcpy(&di_dev->ch3_horzcoef0,
+			bicubic8coefftab32_left + ch3h_fir_coef_addr, 256);
+		memcpy(&di_dev->ch3_horzcoef1,
+			bicubic8coefftab32_right + ch3h_fir_coef_addr, 256);
+		memcpy(&di_dev->ch3_vertcoef,
+			bicubic4coefftab32 + ch3v_fir_coef_addr, 256);
+	}
+
+	di_dev->frm_ctrl.bits.coef_rdy_en = 0x1;
+#else
+	/* for  single buffer */
+	ch0h_fir_coef_addr = (ch0h_fir_coef_ofst<<5);
+	ch0v_fir_coef_addr = (ch0v_fir_coef_ofst<<5);
+	ch1h_fir_coef_addr = (ch0h_fir_coef_ofst<<5);
+	ch1v_fir_coef_addr = (ch0v_fir_coef_ofst<<5);
+
+	di_dev->frm_ctrl.bits.coef_access_ctrl = 1;
+	while ((di_dev->status.bits.coef_access_status == 0) &&
+			(loop_count < 40)) {
+		loop_count++;
+	}
+
+#if defined SCALE_NO_SUPPORT
+	for (i = 0; i < 32; i++) {
+		di_dev->ch0_horzcoef0[i].dwval = 0x00004000;
+		di_dev->ch0_vertcoef[i].dwval  = 0x00004000;
+		di_dev->ch1_horzcoef0[i].dwval = 0x00004000;
+		di_dev->ch1_vertcoef[i].dwval  = 0x00004000;
+	}
+#else
+	memcpy(&di_dev->ch0_horzcoef0,
+		lan2coefftab32 + ch0h_fir_coef_addr, 128);
+	memcpy(&di_dev->ch0_vertcoef,
+		lan2coefftab32 + ch0v_fir_coef_addr, 128);
+
+	if ((out_type->fmt == DI_OUTUVCYUV420) ||
+		(in_type->fmt == DI_INYUV420)) {
+		memcpy(&di_dev->ch1_horzcoef0,
+			bicubic4coefftab32 + ch1h_fir_coef_addr, 128);
+		memcpy(&di_dev->ch1_vertcoef,
+			bicubic4coefftab32 + ch1v_fir_coef_addr, 128);
+
+		if (di_dev->ch1_horzcoef0[0].dwval != 0xfd0d290d) {
+			pr_warn("DIDIDIDIDIDI wrong! di_dev->ch1_horzcoef0[0] = 0x%x.\n  bicubic4coefftab32[64] = 0x%x, ch1h_fir_coef_addr = %d.\n",
+				di_dev->ch1_horzcoef0[0].dwval,
+				bicubic4coefftab32[64], ch1h_fir_coef_addr);
+		}
+	} else {
+		memcpy(&di_dev->ch1_horzcoef0,
+				lan2coefftab32 + ch1h_fir_coef_addr, 128);
+		memcpy(&di_dev->ch1_vertcoef,
+				lan2coefftab32 + ch1v_fir_coef_addr, 128);
+	}
+
+#endif
+	di_dev->frm_ctrl.bits.coef_access_ctrl = 0x0;
+#endif
+	return 0;
+}
+
+__s32 DI_Set_Out_Format(__di_out_type_t *out_type)
+{
+	di_dev->output_fmt.bits.data_fmt = out_type->fmt;
+	di_dev->output_fmt.bits.data_ps  = out_type->ps;
+
+	return 0;
+}
+
+__s32 DI_Set_Out_Size(__di_out_size_t *out_size)
+{
+	__u32 out_w1, out_h1, out_w0, out_h0;
+
+	out_h0 = out_size->height;
+	out_w0 = out_size->width;
+	out_w1 = (out_size->width + 0x1) >> 1;
+	out_h1 = (out_size->height + 0x1) >> 1;
+
+	/* added no-zero limited */
+	out_h0 = (out_h0 != 0) ? out_h0 : 1;
+	out_h1 = (out_h1 != 0) ? out_h1 : 1;
+	out_w0 = (out_w0 != 0) ? out_w0 : 1;
+	out_w1 = (out_w1 != 0) ? out_w1 : 1;
+
+	di_dev->ch0_outsize.bits.out_height = out_h0 - 1;
+	di_dev->ch0_outsize.bits.out_width = out_w0 - 1;
+	di_dev->ch1_outsize.bits.out_height = out_h1 - 1;
+	di_dev->ch1_outsize.bits.out_width = out_w1 - 1;
+	return 0;
+}
+
+__s32 DI_Set_Writeback_Addr(__di_buf_addr_t *addr)
+{
+	di_dev->wb_addr0.dwval = addr->ch0_addr;
+	di_dev->wb_addr1.dwval = addr->ch1_addr;
+	di_dev->wb_addr2.dwval = addr->ch2_addr;
+
+	return 0;
+}
+
+__s32 DI_Set_Writeback_Addr_ex(__di_buf_addr_t *addr, __di_out_size_t *size,
+				__di_out_type_t *type)
+{
+	__u32 image_w0, image_w1;
+
+	image_w0 = size->fb_width;
+	image_w1 = (image_w0 + 0x1)>>1;
+
+	if (type->fmt == DI_OUTUVCYUV420) {
+		di_dev->wb_linestrd0.dwval = image_w0;
+		di_dev->wb_linestrd1.dwval = (image_w1<<1);
+		di_dev->wb_linestrd2.dwval = 0;
+
+		/*addr->ch0_addr = addr->ch0_addr;
+		addr->ch1_addr = addr->ch1_addr;*/
+		addr->ch2_addr = 0x0;
+
+		DI_Set_Writeback_Addr(addr);
+	}
+	return 0;
+}
+
+
+__s32 DI_Set_Di_Ctrl(__u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
+{
+	di_dev->di_ctrl.bits.en = en;
+	di_dev->di_ctrl.bits.flag_out_en = (mode == 3)?0:1;
+	di_dev->di_ctrl.bits.mod = mode;
+	di_dev->di_ctrl.bits.diagintp_en = diagintp_en;
+	di_dev->di_ctrl.bits.tempdiff_en = tempdiff_en;
+#if defined CONFIG_ARCH_SUN9IW1
+	di_dev->di_spatcomp.bits.th2 = 0;
+	di_dev->di_lumath.bits.avglumashifter = 8;
+#else
+	di_dev->di_lumath.bits.minlumath = 4;
+	di_dev->di_spatcomp.bits.th2 = 5;
+	di_dev->di_tempdiff.bits.ambiguity_th = 5;
+	di_dev->di_diagintp.bits.th0 = 60;
+	di_dev->di_diagintp.bits.th1 = 0;
+	di_dev->di_diagintp.bits.th3 = 30;
+	di_dev->di_chromadiff.bits.chroma_diff_th = 31;
+#endif
+
+	return 0;
+}
+
+
+__s32 DI_Set_Di_PreFrame_Addr(__u32 luma_addr, __u32 chroma_addr)
+{
+	di_dev->di_preluma.dwval = luma_addr;
+	di_dev->di_prechroma.dwval = chroma_addr;
+
+	return 0;
+}
+
+
+__s32 DI_Set_Di_MafFlag_Src(__u32 cur_addr, __u32 pre_addr, __u32 stride)
+{
+	di_dev->di_tileflag0.dwval = pre_addr;
+	di_dev->di_tileflag1.dwval = cur_addr;
+	di_dev->di_flaglinestrd.dwval = stride;
+
+	return 0;
+}
+
+__s32 DI_Set_Di_Field(u32 field)
+{
+	di_dev->field_ctrl.bits.field_cnt = (field & 0x1);
+
+	return 0;
+}
+__s32 DI_Set_Reg_Rdy(void)
+{
+	di_dev->frm_ctrl.bits.reg_rdy_en = 0x1;
+
+	return 0;
+}
+
+__s32 DI_Enable(void)
+{
+	/* di_dev->modl_en.bits.en = 0x1; */
+	di_dev->frm_ctrl.bits.frm_start = 0x1;
+
+	return 0;
+}
+
+__s32 DI_Module_Enable(void)
+{
+	di_dev->modl_en.bits.en = 0x1;
+
+	return 0;
+}
+
+__s32 DI_Set_Reset(void)
+{
+	di_dev->frm_ctrl.bits.frm_start = 0x0;
+	di_dev->modl_en.bits.en = 0x0;
+
+	return 0;
+}
+
+
+__s32 DI_Set_Irq_Enable(__u32 enable)
+{
+	di_dev->int_en.bits.wb_en = (enable & 0x1);
+	return 0;
+}
+
+__s32 DI_Clear_irq(void)
+{
+	di_dev->int_status.bits.wb_status = 0x1;
+
+	return 0;
+}
+
+__s32 DI_Get_Irq_Status(void)
+{
+	__u32 wb_finish;
+	__u32 wb_processing;
+
+	wb_finish = di_dev->int_status.bits.wb_status;
+	wb_processing = di_dev->status.bits.wb_status;
+
+	if (wb_processing)
+		return 2;
+	else if (wb_finish == 0 && wb_processing == 0)
+		return 1;
+	else if (wb_finish)
+		return 0;
+	else
+		return 3;
+}
+
+__s32 DI_Set_Writeback_Start(void)
+{
+	di_dev->frm_ctrl.bits.wb_en = 0x1;
+
+	return 0;
+}
+
+#if defined CONFIG_ARCH_SUN9IW1
+__s32 DI_Internal_Set_Clk(__u32 enable)
+{
+	__u32 reg_val, base;
+
+	base = 0xf3000000; /* FIXME */
+
+	if (enable) {
+		reg_val = readl(base + 0x0);
+		reg_val |= 0x1;
+		writel(reg_val, base + 0x0);
+
+		reg_val = readl(base + 0x4);
+		reg_val |= 0x1;
+		writel(reg_val, base + 0x4);
+
+		reg_val = readl(base + 0x8);
+		reg_val |= 0x1;
+		writel(reg_val, base + 0x8);
+
+		reg_val = readl(base + 0xc);
+		reg_val |= 0x1;
+		writel(reg_val, base + 0xc);
+	} else {
+		reg_val = readl(base + 0x0);
+		reg_val &= 0xfffffffe;
+		writel(reg_val, base + 0x0);
+
+		reg_val = readl(base + 0x4);
+		reg_val &= 0xfffffffe;
+		writel(reg_val, base + 0x4);
+
+		reg_val = readl(base + 0x8);
+		reg_val &= 0xfffffffe;
+		writel(reg_val, base + 0x8);
+
+		reg_val = readl(base + 0xc);
+		reg_val &= 0xfffffffe;
+		writel(reg_val, base + 0xc);
+	}
+	return 0;
+}
+#else
+__s32 DI_Internal_Set_Clk(__u32 enable)
+{
+	return 0;
+}
+#endif
+
diff --git a/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios.h b/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios.h
new file mode 100644
index 000000000..79d18619f
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios.h
@@ -0,0 +1,1055 @@
+/*
+ * Allwinner SoCs de-interlace driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __DI_EBIOS_H__
+#define __DI_EBIOS_H__
+#include <linux/types.h>
+
+typedef struct __SCAL_SRC_TYPE {
+	/* 0:plannar; 1: interleaved; 2: plannar uv combined;
+	 * 4: plannar mb; 6: uv combined mb
+	 */
+	__u8    mod;
+	/* 0:yuv444; 1: yuv422; 2: yuv420; 3:yuv411; 4: csi rgb; 5:rgb888 */
+	__u8    fmt;
+	__u8    ps;        /*  */
+} __di_src_type_t;
+
+typedef struct __SCAL_OUT_TYPE {
+	/* 0:plannar rgb; 1: argb(byte0,byte1, byte2, byte3); 2:bgra;
+	 * 4:yuv444; 5:yuv420; 6:yuv422; 7:yuv411
+	 */
+	__u8    fmt;
+	__u8    ps;        /*  */
+	/* output alpha channel enable, valid when rgb888fmt */
+	__u8    alpha_en;
+} __di_out_type_t;
+
+typedef struct __SCAL_SRC_SIZE {
+	__u32   src_width;
+	__u32   src_height;
+	__u32   scal_width;
+	__u32   scal_height;
+} __di_src_size_t;
+
+typedef struct __SCAL_OUT_SIZE {
+	__u32   width;
+	__u32   height;
+	__u32   fb_width;
+	__u32   fb_height;
+} __di_out_size_t;
+
+typedef struct _SCAL_BUF_ADDR {
+	__u32   ch0_addr;
+	__u32   ch1_addr;
+	__u32   ch2_addr;
+} __di_buf_addr_t;
+
+
+typedef enum {
+	DI_BGRA = 0,
+	DI_ARGB = 1,
+	DI_AYUV = 0,
+	DI_VUYA = 1,
+	DI_UVUV = 0,
+	DI_VUVU = 1,
+	DI_UYVY = 0,
+	DI_YUYV = 1,
+	DI_VYUY = 2,
+	DI_YVYU = 3,
+	DI_RGB565 = 0,
+	DI_BGR565 = 1,
+	DI_ARGB4444 = 0,
+	DI_BGRA4444 = 1,
+	DI_ARGB1555 = 0,
+	DI_BGRA5551 = 1
+} __di_ps_t;
+
+typedef enum {
+	DI_PLANNAR = 0,
+	DI_INTERLEAVED,
+	DI_UVCOMBINED,
+	DI_PLANNARMB = 4,
+	DI_UVCOMBINEDMB = 6
+} __di_inmode_t;
+
+
+typedef enum {
+	DI_INYUV444 = 0,
+	DI_INYUV422,
+	DI_INYUV420,
+	DI_INYUV411,
+	DI_INRGB565,
+	DI_INRGB888,
+	DI_INRGB4444,
+	DI_INRGB1555
+} __di_infmt_t;
+
+typedef enum {
+	DI_OUTPRGB888 = 0,
+	DI_OUTI0RGB888,
+	DI_OUTI1RGB888,
+	DI_OUTPYUV444 = 4,
+	DI_OUTPYUV420,
+	DI_OUTPYUV422,
+	DI_OUTPYUV411,
+	DI_OUTUVCYUV420 = 13
+} __di_outfmt_t;
+
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 en                 :  1;    /* Default: 0x0; */
+		u32 res0               : 31;    /* Default:; */
+	} bits;
+} DI_EN_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 reg_rdy_en         :  1;    /* Default: 0x0; */
+		u32 coef_rdy_en        :  1;    /* Default: 0x0; */
+		u32 wb_en              :  1;    /* Default: 0x0; */
+		u32 res0               :  5;    /* Default:; */
+		u32 out_port_sel       :  2;    /* Default: 0x0; */
+		u32 res1               :  1;    /* Default:; */
+		u32 out_ctrl           :  1;    /* Default: 0x0; */
+		u32 in_ctrl            :  3;    /* Default: 0x0; */
+		u32 res2               :  1;    /* Default:; */
+		u32 frm_start          :  1;    /* Default: 0x0; */
+		u32 res3               :  6;    /* Default:; */
+		/* fir coef ram access control, for  single buffer */
+		u32 coef_access_ctrl   :  1;
+		u32 res4               :  8;    /* Default:; */
+	} bits;
+} DI_FRM_CTRL_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0               :  1;    /* Default:; */
+		u32 csc_bypass_en      :  1;    /* Default: 0x0; */
+		u32 res1               : 28;    /* Default:; */
+		u32 sram_map_sel       :  2;    /* Default: 0x0; */
+	} bits;
+} DI_BYPASS_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0               :  8;    /* Default:; */
+		u32 linebuf_agth       :  1;    /* Default: 0x0; */
+		u32 res1               : 23;    /* Default:; */
+	} bits;
+} DI_AGTH_SEL_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 trig_line          : 13;    /* Default: 0x0; */
+		u32 res0               :  2;    /* Default:; */
+		u32 field_sel          :  1;    /* Default: 0x0; */
+		u32 current_line       : 12;    /* Default: 0x0; */
+		u32 res1               :  4;    /* Default:; */
+	} bits;
+} DI_LINT_CTRL_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 prefrm_addr;    /* Default: 0x0; */
+	} bits;
+} DI_3D_PRELUMA_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 buf_addr;    /* Default: 0x0; */
+	} bits;
+} DI_BUF_ADDR0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 buf_addr;    /* Default: 0x0; */
+	} bits;
+} DI_BUF_ADDR1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 buf_addr;    /* Default: 0x0; */
+	} bits;
+} DI_BUF_ADDR2_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 field_cnt          :  8;    /* Default: 0x0; */
+		u32 valid_field_cnt    :  3;    /* Default: 0x0; */
+		u32 res0               :  1;    /* Default:; */
+		u32 field_loop_mod     :  1;    /* Default: 0x0; */
+		u32 res1               : 11;    /* Default:; */
+		u32 fir_offset         :  6;    /* Default: 0x20; */
+		u32 res2               :  2;    /* Default:; */
+	} bits;
+} DI_FIELD_CTRL_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 x_offset0          :  5;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 y_offset0          :  5;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+		u32 x_offset1          :  5;    /* Default: 0x0; */
+		u32 res2               : 11;    /* Default:; */
+	} bits;
+} DI_TB_OFF0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 x_offset0          :  5;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 y_offset0          :  5;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+		u32 x_offset1          :  5;    /* Default: 0x0; */
+		u32 res2               : 11;    /* Default:; */
+	} bits;
+} DI_TB_OFF1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 x_offset0          :  5;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 y_offset0          :  5;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+		u32 x_offset1          :  5;    /* Default: 0x0; */
+		u32 res2               : 11;    /* Default:; */
+	} bits;
+} DI_TB_OFF2_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 prefrm_addr;    /* Default: 0x0; */
+	} bits;
+} DI_3D_PRECHROMA_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 line_stride;    /* Default: 0x0; */
+	} bits;
+} DI_LINESTRD0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 line_stride;    /* Default: 0x0; */
+	} bits;
+} DI_LINESTRD1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 line_stride;    /* Default: 0x0; */
+	} bits;
+} DI_LINESTRD2_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 data_ps            :  2;    /* Default: 0x0; */
+		u32 res0               :  2;    /* Default:; */
+		u32 data_fmt           :  3;    /* Default: 0x0; */
+		u32 res1               :  1;    /* Default:; */
+		u32 data_mod           :  3;    /* Default: 0x0; */
+		u32 res2               :  1;    /* Default:; */
+		u32 scan_mod           :  1;    /* Default: 0x0; */
+		u32 res3               :  1;    /* Default:; */
+		u32 a_coef_sel         :  1;    /* Default: 0x0; */
+		u32 res4               :  1;    /* Default:; */
+		u32 byte_seq           :  1;    /* Default: 0x0; */
+		u32 res5               : 15;    /* Default:; */
+	} bits;
+} DI_INPUT_FMT_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 wb_addr;    /* Default: 0x0; */
+	} bits;
+} DI_WB_ADDR0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 wb_addr;    /* Default: 0x0; */
+	} bits;
+} DI_WB_ADDR1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 wb_addr;    /* Default: 0x0; */
+	} bits;
+} DI_WB_ADDR2_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 data_fmt           :  4;    /* Default: 0x0; */
+		u32 scan_mod           :  1;    /* Default: 0x0; */
+		u32 data_ps            :  2;    /* Default:; */
+		u32 alpha_en           :  1;    /* Default: 0x0; */
+		u32 byte_seq           :  1;    /* Default: 0x0; */
+		u32 res2               : 23;    /* Default:; */
+	} bits;
+} DI_OUTPUT_FMT_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0               :  7;    /* Default:; */
+		u32 wb_en              :  1;    /* Default: 0x0; */
+		u32 res1               :  1;    /* Default:; */
+		u32 line_en            :  1;    /* Default: 0x0; */
+		u32 reg_load_en        :  1;    /* Default: 0x0; */
+		u32 res2               : 21;    /* Default:; */
+	} bits;
+} DI_INT_EN_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0               :  7;    /* Default:; */
+		u32 wb_status          :  1;    /* Default: 0x0; */
+		u32 res1               :  1;    /* Default:; */
+		u32 line_status        :  1;    /* Default: 0x0; */
+		u32 reg_load_status    :  1;    /* Default: 0x0; */
+		u32 res2               : 21;    /* Default:; */
+	} bits;
+} DI_INT_STATUS_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 frm_busy           :  1;    /* Default: 0x0; */
+		u32 wb_status          :  1;    /* Default: 0x0; */
+		u32 cfg_pending        :  1;    /* Default: 0x0; */
+		u32 res0               :  1;    /* Default:; */
+		u32 dram_status        :  1;    /* Default: 0x0; */
+		u32 lcd_field          :  1;    /* Default: 0x0; */
+		u32 res1               :  5;    /* Default:; */
+		/* fir coef access status, for single buffer */
+		u32 coef_access_status :  1;
+		u32 wb_err_status      :  1;    /* Default: 0x0; */
+		u32 res2               :  1;    /* Default:; */
+		u32 wb_err_losedata    :  1;    /* Default: 0x0; */
+		u32 wb_err_sync        :  1;    /* Default: 0x0; */
+		u32 line_on_sync       : 13;    /* Default: 0x0; */
+		u32 res3               :  3;    /* Default:; */
+	} bits;
+} DI_STATUS_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF00_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF01_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF02_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 cont               : 14;    /* Default: 0x0; */
+		u32 res0               : 18;    /* Default:; */
+	} bits;
+} DI_CSC_COEF03_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF10_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF11_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF12_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 cont               : 14;    /* Default: 0x0; */
+		u32 res0               : 18;    /* Default:; */
+	} bits;
+} DI_CSC_COEF13_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF20_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF21_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 coef               : 13;    /* Default: 0x0; */
+		u32 res0               : 19;    /* Default:; */
+	} bits;
+} DI_CSC_COEF22_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 cont               : 14;    /* Default: 0x0; */
+		u32 res0               : 18;    /* Default:; */
+	} bits;
+} DI_CSC_COEF23_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 en                 :  1;    /* Default: 0x0; */
+		u32 res0               :  7;    /* Default:; */
+		u32 flag_out_en        :  1;    /* Default: 0x0; */
+		u32 res1               :  7;    /* Default:; */
+		u32 mod                :  2;    /* Default: 0x0; */
+		u32 res2               :  6;    /* Default:; */
+		u32 diagintp_en        :  1;    /* Default: 0x0; */
+		u32 tempdiff_en        :  1;    /* Default: 0x0; */
+		u32 res3               :  6;    /* Default:; */
+	} bits;
+} DI_DI_CTRL_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 th0                :  7;    /* Default: 0x28; */
+		u32 res0               :  1;    /* Default:; */
+		u32 th1                :  7;    /* Default: 0x5; */
+		u32 res1               :  9;    /* Default:; */
+		u32 th3                :  8;    /* Default: 0x8; */
+	} bits;
+} DI_DI_DIAGINTP_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 sad_central_th     :  7;    /* Default: 0xA; */
+		u32 res0               :  1;    /* Default:; */
+		u32 ambiguity_th       :  7;    /* Default: 0xA; */
+		u32 res1               :  1;    /* Default:; */
+		u32 direct_dither_th   : 11;    /* Default: 0xF; */
+		u32 res2               :  5;    /* Default:; */
+	} bits;
+} DI_DI_TEMPDIFF_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 minlumath          :  8;    /* Default: 0x9; */
+		u32 maxlumath          :  8;    /* Default: 0x10; */
+		u32 avglumashifter     :  8;    /* Default: 0x6; */
+		u32 pixel_static_th    :  2;    /* Default: 0x3; */
+		u32 res0               :  6;    /* Default:; */
+	} bits;
+} DI_DI_LUMA_TH_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 th2                :  8;    /* Default: 0xA; */
+		u32 res0               :  8;    /* Default:; */
+		u32 th3                :  8;    /* Default: 0x14; */
+		u32 res1               :  8;    /* Default:; */
+	} bits;
+} DI_DI_SPATCOMP_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 chroma_diff_th     :  8;    /* Default: 0x5; */
+		u32 res0               :  8;    /* Default:; */
+		u32 luma               :  6;    /* Default: 0x1F; */
+		u32 res1               :  2;    /* Default:; */
+		u32 chroma             :  6;    /* Default: 0x1F; */
+		u32 res2               :  2;    /* Default:; */
+	} bits;
+} DI_DI_CHROMADIFF_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 prefrm_addr;    /* Default: 0x0; */
+	} bits;
+} DI_DI_PRELUMA_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 prefrm_addr;    /* Default: 0x0; */
+	} bits;
+} DI_DI_PRECHROMA_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tile_flag_addr0;    /* Default: 0x0; */
+	} bits;
+} DI_DI_TILEFLAG0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tile_flag_addr1;    /* Default: 0x0; */
+	} bits;
+} DI_DI_TILEFLAG1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tile_flag_linestrd;    /* Default: 0x200; */
+	} bits;
+} DI_DI_FLAGLINESTRD_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 field_cnt          :  8;    /* Default: 0x0; */
+		u32 valid_field_cnt    :  3;    /* Default: 0x0; */
+		u32 res0               :  1;
+		u32 field_loop_mod     :  1;    /* Default: 0x0; */
+		u32 res1               :  19;
+	} bits;
+} DI_DI_FLAG_SEQ_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 en                 :  1;    /* Default: 0x0; */
+		u32 res0               : 31;    /* Default:; */
+	} bits;
+} DI_WB_LINESTRD_EN_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 line_strd;    /* Default: 0x0; */
+	} bits;
+} DI_WB_LINESTRD0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 line_strd;    /* Default: 0x0; */
+	} bits;
+} DI_WB_LINESTRD1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 line_strd;    /* Default: 0x0; */
+	} bits;
+} DI_WB_LINESTRD2_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 mod_sel            :  2;    /* Default: 0x0; */
+		u32 res0               :  6;    /* Default:; */
+		u32 ci_out_en          :  1;    /* Default: 0x0; */
+		u32 res1               :  1;    /* Default:; */
+		u32 ss_out_en          :  1;    /* Default: 0x0; */
+		u32 li_in_en           :  1;    /* Default: 0x0; */
+		u32 tb_out_scan_mod    :  1;    /* Default: 0x0; */
+		u32 res2               :  3;    /* Default:; */
+		u32 ci_out_mod         :  3;    /* Default: 0x0; */
+		u32 res3               :  5;    /* Default:; */
+		u32 tb_out_mod_field   :  2;    /* Default: 0x0; */
+		u32 res4               :  6;    /* Default:; */
+	} bits;
+} DI_3D_CTRL_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 right_ch0_addr;    /* Default: 0x0; */
+	} bits;
+} DI_3D_BUF_ADDR0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 right_ch1_addr;    /* Default: 0x0; */
+	} bits;
+} DI_3D_BUF_ADDR1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 right_ch2_addr;    /* Default: 0x0; */
+	} bits;
+} DI_3D_BUF_ADDR2_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 x_offset0          :  5;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 y_offset0          :  5;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+		u32 x_offset1          :  5;    /* Default: 0x0; */
+		u32 res2               : 11;    /* Default:; */
+	} bits;
+} DI_3D_TB_OFF0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 x_offset0          :  5;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 y_offset0          :  5;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+		u32 x_offset1          :  5;    /* Default: 0x0; */
+		u32 res2               : 11;    /* Default:; */
+	} bits;
+} DI_3D_TB_OFF1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 x_offset0          :  5;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 y_offset0          :  5;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+		u32 x_offset1          :  5;    /* Default: 0x0; */
+		u32 res2               : 11;    /* Default:; */
+	} bits;
+} DI_3D_TB_OFF2_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 wb_stride          :  5;    /* Default: 0x0; */
+	} bits;
+} DI_3D_WB_STRD_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 in_width           : 13;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 in_height          : 13;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+	} bits;
+} DI_CH0_INSIZE_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 out_width          : 13;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 out_height         : 13;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+	} bits;
+} DI_CH0_OUTSIZE_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 factor_frac        : 16;    /* Default: 0x0; */
+		u32 factor_int         :  8;    /* Default: 0x0; */
+		u32 res0               :  8;    /* Default:; */
+	} bits;
+} DI_CH0_HORZFACT_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 factor_frac        : 16;    /* Default: 0x0; */
+		u32 factor_int         :  8;    /* Default: 0x0; */
+		u32 res0               :  8;    /* Default:; */
+	} bits;
+} DI_CH0_VERTFACT_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 phase              : 20;    /* Default: 0x0; */
+		u32 res0               : 12;    /* Default:; */
+	} bits;
+} DI_CH0_HORZPHASE_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 phase              : 20;    /* Default: 0x0; */
+		u32 res0               : 12;    /* Default:; */
+	} bits;
+} DI_CH0_VERTPHASE0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 phase              : 20;    /* Default: 0x0; */
+		u32 res0               : 12;    /* Default:; */
+	} bits;
+} DI_CH0_VERTPHASE1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap0               :  7;    /* Default: 0x7D; */
+		u32 res0               :  1;    /* Default:; */
+		u32 tap1               :  7;    /* Default: 0x1; */
+		u32 res1               :  1;    /* Default:; */
+		u32 tap2               :  7;    /* Default: 0x1; */
+		u32 res2               :  1;    /* Default:; */
+		u32 tap3               :  7;    /* Default: 0x1; */
+		u32 res3               :  1;    /* Default:; */
+	} bits;
+} DI_CH0_HORZTAP0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap4               :  7;    /* Default: 0x1; */
+		u32 res0               :  1;    /* Default:; */
+		u32 tap5               :  7;    /* Default: 0x1; */
+		u32 res1               :  1;    /* Default:; */
+		u32 tap6               :  7;    /* Default: 0x1; */
+		u32 res2               :  1;    /* Default:; */
+		u32 tap7               :  7;    /* Default: 0x1; */
+		u32 res3               :  1;    /* Default:; */
+	} bits;
+} DI_CH0_HORZTAP1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap0               :  7;    /* Default: 0x7F; */
+		u32 res0               :  1;    /* Default:; */
+		u32 tap1               :  7;    /* Default: 0x1; */
+		u32 res1               :  1;    /* Default:; */
+		u32 tap2               :  7;    /* Default: 0x1; */
+		u32 res2               :  1;    /* Default:; */
+		u32 tap3               :  7;    /* Default: 0x1; */
+		u32 res3               :  1;    /* Default:; */
+	} bits;
+} DI_CH0_VERTTAP_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 in_width           : 13;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 in_height          : 13;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+	} bits;
+} DI_CH1_INSIZE_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 out_width          : 13;    /* Default: 0x0; */
+		u32 res0               :  3;    /* Default:; */
+		u32 out_height         : 13;    /* Default: 0x0; */
+		u32 res1               :  3;    /* Default:; */
+	} bits;
+} DI_CH1_OUTSIZE_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 factor_frac        : 16;    /* Default: 0x0; */
+		u32 factor_int         :  8;    /* Default: 0x0; */
+		u32 res0               :  8;    /* Default:; */
+	} bits;
+} DI_CH1_HORZFACT_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 factor_frac        : 16;    /* Default: 0x0; */
+		u32 factor_int         :  8;    /* Default: 0x0; */
+		u32 res0               :  8;    /* Default:; */
+	} bits;
+} DI_CH1_VERTFACT_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 phase              : 20;    /* Default: 0x0; */
+		u32 res0               : 12;    /* Default:; */
+	} bits;
+} DI_CH1_HORZPHASE_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 phase              : 20;    /* Default: 0x0; */
+		u32 res0               : 12;    /* Default:; */
+	} bits;
+} DI_CH1_VERTPHASE0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 phase              : 20;    /* Default: 0x0; */
+		u32 res0               : 12;    /* Default:; */
+	} bits;
+} DI_CH1_VERTPHASE1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap0               :  7;    /* Default: 0x7D; */
+		u32 res0               :  1;    /* Default:; */
+		u32 tap1               :  7;    /* Default: 0x1; */
+		u32 res1               :  1;    /* Default:; */
+		u32 tap2               :  7;    /* Default: 0x1; */
+		u32 res2               :  1;    /* Default:; */
+		u32 tap3               :  7;    /* Default: 0x1; */
+		u32 res3               :  1;    /* Default:; */
+	} bits;
+} DI_CH1_HORZTAP0_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap4               :  7;    /* Default: 0x1; */
+		u32 res0               :  1;    /* Default:; */
+		u32 tap5               :  7;    /* Default: 0x1; */
+		u32 res1               :  1;    /* Default:; */
+		u32 tap6               :  7;    /* Default: 0x1; */
+		u32 res2               :  1;    /* Default:; */
+		u32 tap7               :  7;    /* Default: 0x1; */
+		u32 res3               :  1;    /* Default:; */
+	} bits;
+} DI_CH1_HORZTAP1_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap0               :  7;    /* Default: 0x7F; */
+		u32 res0               :  1;    /* Default:; */
+		u32 tap1               :  7;    /* Default: 0x1; */
+		u32 res1               :  1;    /* Default:; */
+		u32 tap2               :  7;    /* Default: 0x1; */
+		u32 res2               :  1;    /* Default:; */
+		u32 tap3               :  7;    /* Default: 0x1; */
+		u32 res3               :  1;    /* Default:; */
+	} bits;
+} DI_CH1_VERTTAP_REG_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap0                         :  8;
+		u32 tap1                         :  8;
+		u32 tap2                         :  8;
+		u32 tap3                         :  8;
+	} bits;
+} DI_CH0_HORZCOEF0_REGN_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap4                         :  8;
+		u32 tap5                         :  8;
+		u32 tap6                         :  8;
+		u32 tap7                         :  8;
+	} bits;
+} DI_CH0_HORZCOEF1_REGN_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 tap0                         :  8;
+		u32 tap1                         :  8;
+		u32 tap2                         :  8;
+		u32 tap3                         :  8;
+	} bits;
+} DI_CH0_VERTCOEF_REGN_t;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0               :  32;    /*  */
+	} bits;
+} DI_RESEVED_REG_t;
+
+
+/* device define */
+typedef struct {
+	DI_EN_REG_t                     modl_en;/* 0x00 */
+	DI_FRM_CTRL_REG_t               frm_ctrl;/* 0x04 */
+	DI_BYPASS_REG_t                 bypass;/* 0x08 */
+	DI_AGTH_SEL_REG_t               agth_sel;/* 0x0c */
+	DI_LINT_CTRL_REG_t              lint_ctrl;/* 0x10 */
+	DI_RESEVED_REG_t		res0x14[2];/* 0x14~0x1b */
+	DI_3D_PRELUMA_REG_t		trd_preluma;/* 0x1c */
+	DI_BUF_ADDR0_REG_t              buf_addr0;/* 0x20 */
+	DI_BUF_ADDR1_REG_t              buf_addr1;/* 0x24 */
+	DI_BUF_ADDR2_REG_t              buf_addr2;/* 0x28 */
+	DI_FIELD_CTRL_REG_t             field_ctrl;/* 0x2c */
+	DI_TB_OFF0_REG_t                tb_off0;/* 0x30 */
+	DI_TB_OFF1_REG_t                tb_off1;/* 0x34 */
+	DI_TB_OFF2_REG_t                tb_off2;/* 0x38 */
+	DI_3D_PRECHROMA_REG_t		trd_prechroma;/* 0x3c */
+	DI_LINESTRD0_REG_t              linestrd0;/* 0x40 */
+	DI_LINESTRD1_REG_t              linestrd1;/* 0x44 */
+	DI_LINESTRD2_REG_t              linestrd2;/* 0x48 */
+	DI_INPUT_FMT_REG_t              input_fmt;/* 0x4c */
+	DI_WB_ADDR0_REG_t               wb_addr0;/* 0x50 */
+	DI_WB_ADDR1_REG_t               wb_addr1;/* 0x54 */
+	DI_WB_ADDR2_REG_t               wb_addr2;/* 0x58 */
+	DI_OUTPUT_FMT_REG_t             output_fmt;/* 0x5c */
+	DI_INT_EN_REG_t                 int_en;/* 0x60 */
+	DI_INT_STATUS_REG_t             int_status;/* 0x64 */
+	DI_STATUS_REG_t                 status;/* 0x68 */
+	DI_RESEVED_REG_t                res0x6c;/* 0x6c */
+	DI_CSC_COEF03_REG_t             csc_coef[12];/* 0x70~0x9f */
+	DI_DI_CTRL_REG_t                di_ctrl;/* 0xa0 */
+	DI_DI_DIAGINTP_REG_t            di_diagintp;/* 0xa4 */
+	DI_DI_TEMPDIFF_REG_t            di_tempdiff;/* 0xa8 */
+	DI_DI_LUMA_TH_REG_t             di_lumath;/* 0xac */
+	DI_DI_SPATCOMP_REG_t            di_spatcomp;/* 0xb0 */
+	DI_DI_CHROMADIFF_REG_t          di_chromadiff;/* 0xb4 */
+	DI_DI_PRELUMA_REG_t             di_preluma;/* 0xb8 */
+	DI_DI_PRECHROMA_REG_t           di_prechroma;/* 0xbc */
+	DI_DI_TILEFLAG0_REG_t	        di_tileflag0;/* 0xc0 */
+	DI_DI_TILEFLAG1_REG_t           di_tileflag1;/* 0xc4 */
+	DI_DI_FLAGLINESTRD_REG_t	di_flaglinestrd;/* 0xc8 */
+	DI_DI_FLAG_SEQ_REG_t		di_flagseq;/* 0xcc */
+	DI_WB_LINESTRD_EN_REG_t         wb_linestrd_en;/* 0xd0 */
+	DI_WB_LINESTRD0_REG_t           wb_linestrd0;/* 0xd4 */
+	DI_WB_LINESTRD1_REG_t           wb_linestrd1;/* 0xd8 */
+	DI_WB_LINESTRD2_REG_t           wb_linestrd2;/* 0xdc */
+	DI_3D_CTRL_REG_t                trd_ctrl;/* 0xe0 */
+	DI_3D_BUF_ADDR0_REG_t           trd_buf_addr0;/* 0xe4 */
+	DI_3D_BUF_ADDR1_REG_t           trd_buf_addr1;/* 0xe8 */
+	DI_3D_BUF_ADDR2_REG_t           trd_buf_addr2;/* 0xec */
+	DI_3D_TB_OFF0_REG_t             trd_tb_off0;/* 0xf0 */
+	DI_3D_TB_OFF1_REG_t             trd_tb_off1;/* 0xf4 */
+	DI_3D_TB_OFF2_REG_t             trd_tb_off2;/* 0xf8 */
+	DI_3D_WB_STRD_REG_t		trd_wb_strd;/* 0xfc */
+	DI_CH0_INSIZE_REG_t             ch0_insize;/* 0x100 */
+	DI_CH0_OUTSIZE_REG_t            ch0_outsize;/* 0x104 */
+	DI_CH0_HORZFACT_REG_t           ch0_horzfact;/* 0x108 */
+	DI_CH0_VERTFACT_REG_t           ch0_vertfact;/* 0x10c */
+	DI_CH0_HORZPHASE_REG_t          ch0_horzphase;/* 0x110 */
+	DI_CH0_VERTPHASE0_REG_t         ch0_vertphase0;/* 0x114 */
+	DI_CH0_VERTPHASE1_REG_t         ch0_vertphase1;/* 0x118 */
+	DI_RESEVED_REG_t		res0x11c;/* 0x11c */
+	DI_CH0_HORZTAP0_REG_t           ch0_horztap0;/* 0x120 */
+	DI_CH0_HORZTAP1_REG_t           ch0_horztap1;/* 0x124 */
+	DI_CH0_VERTTAP_REG_t            ch0_verttap;/* 0x128 */
+	DI_RESEVED_REG_t		res0x12c[53];/* 0x12c~0x1FF */
+	DI_CH1_INSIZE_REG_t             ch1_insize;/* 0x200 */
+	DI_CH1_OUTSIZE_REG_t            ch1_outsize;/* 0x204 */
+	DI_CH1_HORZFACT_REG_t           ch1_horzfact;/* 0x208 */
+	DI_CH1_VERTFACT_REG_t           ch1_vertfact;/* 0x20c */
+	DI_CH1_HORZPHASE_REG_t          ch1_horzphase;/* 0x210 */
+	DI_CH1_VERTPHASE0_REG_t         ch1_vertphase0;/* 0x214 */
+	DI_CH1_VERTPHASE1_REG_t         ch1_vertphase1;/* 0x218 */
+	DI_RESEVED_REG_t		res0x21c;/* 0x21c */
+	DI_CH1_HORZTAP0_REG_t           ch1_horztap0;/* 0x220 */
+	DI_CH1_HORZTAP1_REG_t           ch1_horztap1;/* 0x224 */
+	DI_CH1_VERTTAP_REG_t            ch1_verttap;/* 0x228 */
+	DI_RESEVED_REG_t		res0x22c[117];/* 0x22c~0x3FF */
+	DI_CH0_HORZCOEF0_REGN_t         ch0_horzcoef0[32];/* 0x400~0x47f */
+	DI_CH0_HORZCOEF1_REGN_t         ch0_horzcoef1[32];/* 0x480~0x4ff */
+	DI_CH0_VERTCOEF_REGN_t          ch0_vertcoef[32];/* 0x500~0x5ff */
+	DI_RESEVED_REG_t		res0x580[32];/* 0x580~0x57f */
+	DI_CH0_HORZCOEF0_REGN_t         ch1_horzcoef0[32];/* 0x600~0x67f */
+	DI_CH0_HORZCOEF1_REGN_t         ch1_horzcoef1[32];/* 0x680~6ff */
+	DI_CH0_VERTCOEF_REGN_t          ch1_vertcoef[32];/* 0x700~0x77f */
+	DI_RESEVED_REG_t		res0x780[32];/* 0x780~0x7ff */
+	DI_CH0_HORZCOEF0_REGN_t         ch3_horzcoef0[32];/* 0x800~0x87f */
+	DI_CH0_HORZCOEF1_REGN_t         ch3_horzcoef1[32];/* 0x880~8ff */
+	DI_CH0_VERTCOEF_REGN_t          ch3_vertcoef[32];/* 0x900~0x97f */
+	DI_RESEVED_REG_t		res0xA80[32];/* 0xa80~0xaff */
+} __di_dev_t;
+
+__s32 DI_Init(void);
+__s32 DI_Config_Src(__di_buf_addr_t *addr, __di_src_size_t *size,
+			__di_src_type_t *type);
+__s32 DI_Set_Scaling_Factor(__di_src_size_t *in_size,
+			__di_out_size_t *out_size);
+__s32 DI_Set_Scaling_Coef(__di_src_size_t *in_size, __di_out_size_t *out_size,
+			__di_src_type_t *in_type,  __di_out_type_t *out_type);
+__s32 DI_Set_Out_Format(__di_out_type_t *out_type);
+__s32 DI_Set_Out_Size(__di_out_size_t *out_size);
+__s32 DI_Set_Writeback_Addr(__di_buf_addr_t *addr);
+__s32 DI_Set_Writeback_Addr_ex(__di_buf_addr_t *addr, __di_out_size_t *size,
+			__di_out_type_t *type);
+__s32 DI_Set_Di_Ctrl(__u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en);
+__s32 DI_Set_Di_PreFrame_Addr(__u32 luma_addr, __u32 chroma_addr);
+__s32 DI_Set_Di_MafFlag_Src(__u32 cur_addr, __u32 pre_addr, __u32 stride);
+__s32 DI_Set_Di_Field(u32 field);
+__s32 DI_Set_Reg_Rdy(void);
+__s32 DI_Enable(void);
+__s32 DI_Module_Enable(void);
+__s32 DI_Set_Reset(void);
+__s32 DI_Set_Irq_Enable(__u32 enable);
+__s32 DI_Clear_irq(void);
+__s32 DI_Get_Irq_Status(void);
+__s32 DI_Set_Writeback_Start(void);
+__s32 DI_Internal_Set_Clk(__u32 enable);
+__u32 DI_VAtoPA(__u32 va);
+
+#endif
diff --git a/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios_data.h b/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios_data.h
new file mode 100644
index 000000000..e3eae8e52
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/lowlevel_v1x/di_ebios_data.h
@@ -0,0 +1,444 @@
+/*
+ * Allwinner SoCs de-interlace driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __DI_EBIOS_DATA_H__
+#define __DI_EBIOS_DATA_H__
+
+#ifndef CONFIG_ARCH_SUN9IW1
+#define SCALE_NO_SUPPORT
+#endif
+#if (defined CONFIG_ARCH_SUN9IW1)
+
+static u32 lan3coefftab32_left[256] = {
+	0x40000000, 0x40fe0000, 0x3ffd0100, 0x3efc0100,
+	0x3efb0100, 0x3dfa0200, 0x3cf90200, 0x3bf80200,
+	0x39f70200, 0x37f70200, 0x35f70200, 0x33f70200,
+	0x31f70200, 0x2ef70200, 0x2cf70200, 0x2af70200,
+	0x27f70200, 0x24f80100, 0x22f80100, 0x1ef90100,
+	0x1cf90100, 0x19fa0100, 0x17fa0100, 0x14fb0100,
+	0x11fc0000, 0x0ffc0000, 0x0cfd0000, 0x0afd0000,
+	0x08fe0000, 0x05ff0000, 0x03ff0000, 0x02000000,
+
+	0x40000000, 0x40fe0000, 0x3ffd0100, 0x3efc0100,
+	0x3efb0100, 0x3dfa0200, 0x3cf90200, 0x3bf80200,
+	0x39f70200, 0x37f70200, 0x35f70200, 0x33f70200,
+	0x31f70200, 0x2ef70200, 0x2cf70200, 0x2af70200,
+	0x27f70200, 0x24f80100, 0x22f80100, 0x1ef90100,
+	0x1cf90100, 0x19fa0100, 0x17fa0100, 0x14fb0100,
+	0x11fc0000, 0x0ffc0000, 0x0cfd0000, 0x0afd0000,
+	0x08fe0000, 0x05ff0000, 0x03ff0000, 0x02000000,
+
+	0x2b10fa00, 0x2b0ffa00, 0x2b0efa00, 0x2b0cfa00,
+	0x2b0bfa00, 0x2a0afb01, 0x2a09fb01, 0x2908fb01,
+	0x2807fb01, 0x2806fb01, 0x2805fb01, 0x2604fc01,
+	0x2503fc01, 0x2502fc01, 0x2401fc01, 0x2301fc01,
+	0x2100fd01, 0x21fffd01, 0x21fffd01, 0x20fefd01,
+	0x1dfefe01, 0x1cfdfe01, 0x1cfdfe00, 0x1bfcfe00,
+	0x19fcff00, 0x19fbff00, 0x17fbff00, 0x16fbff00,
+	0x15fbff00, 0x14fb0000, 0x13fa0000, 0x11fa0000,
+
+	0x201200fe, 0x201100fe, 0x1f11fffe, 0x2010fffe,
+	0x1f0ffffe, 0x1e0ffffe, 0x1f0efeff, 0x1f0dfeff,
+	0x1f0dfeff, 0x1e0cfeff, 0x1e0bfeff, 0x1d0bfeff,
+	0x1d0afeff, 0x1d09fdff, 0x1d09fdff, 0x1c08fdff,
+	0x1c07fdff, 0x1b07fd00, 0x1b06fd00, 0x1a06fd00,
+	0x1a05fd00, 0x1805fd00, 0x1904fd00, 0x1804fd00,
+	0x1703fd00, 0x1703fd00, 0x1602fe00, 0x1502fe00,
+	0x1501fe00, 0x1401fe00, 0x1301fe00, 0x1300fe00,
+
+	0x181104ff, 0x191103ff, 0x191003ff, 0x181003ff,
+	0x180f03ff, 0x190f02ff, 0x190e02ff, 0x180e02ff,
+	0x180d02ff, 0x180d01ff, 0x180d01ff, 0x180c01ff,
+	0x180c01ff, 0x180b00ff, 0x170b00ff, 0x170a00ff,
+	0x170a00ff, 0x170900ff, 0x160900ff, 0x160900ff,
+	0x1608ffff, 0x1508ffff, 0x1507ff00, 0x1507ff00,
+	0x1407ff00, 0x1306ff00, 0x1306ff00, 0x1305ff00,
+	0x1205ff00, 0x1105ff00, 0x1204ff00, 0x1104ff00,
+
+	0x14100600, 0x15100500, 0x150f0500, 0x150f0500,
+	0x140f0500, 0x150e0400, 0x140e0400, 0x130e0400,
+	0x140d0400, 0x150d0300, 0x130d0300, 0x140c0300,
+	0x140c0300, 0x140c0200, 0x140b0200, 0x130b0200,
+	0x120b0200, 0x130a0200, 0x130a0200, 0x130a0100,
+	0x13090100, 0x12090100, 0x11090100, 0x12080100,
+	0x11080100, 0x10080100, 0x11070100, 0x11070000,
+	0x10070000, 0x11060000, 0x10060000, 0x10060000,
+
+	0x140f0600, 0x140f0600, 0x130f0600, 0x140f0500,
+	0x140e0500, 0x130e0500, 0x130e0500, 0x140d0400,
+	0x140d0400, 0x130d0400, 0x120d0400, 0x130c0400,
+	0x130c0300, 0x130c0300, 0x130b0300, 0x130b0300,
+	0x110b0300, 0x130a0200, 0x120a0200, 0x120a0200,
+	0x120a0200, 0x12090200, 0x10090200, 0x11090100,
+	0x11080100, 0x11080100, 0x10080100, 0x10080100,
+	0x10070100, 0x10070100, 0x0f070100, 0x10060100,
+
+	0x120f0701, 0x130f0601, 0x130e0601, 0x130e0601,
+	0x120e0601, 0x130e0501, 0x130e0500, 0x130d0500,
+	0x120d0500, 0x120d0500, 0x130c0400, 0x130c0400,
+	0x120c0400, 0x110c0400, 0x120b0400, 0x120b0300,
+	0x120b0300, 0x120b0300, 0x120a0300, 0x110a0300,
+	0x110a0200, 0x11090200, 0x11090200, 0x10090200,
+	0x10090200, 0x10080200, 0x10080200, 0x10080100,
+	0x0f080100, 0x10070100, 0x0f070100, 0x0f070100
+
+};
+
+static u32 lan3coefftab32_right[256] = {
+
+	0x00000000, 0x00000002, 0x0000ff04, 0x0000ff06,
+	0x0000fe08, 0x0000fd0a, 0x0000fd0c, 0x0000fc0f,
+	0x0000fc12, 0x0001fb14, 0x0001fa17, 0x0001fa19,
+	0x0001f91c, 0x0001f91f, 0x0001f822, 0x0001f824,
+	0x0002f727, 0x0002f72a, 0x0002f72c, 0x0002f72f,
+	0x0002f731, 0x0002f733, 0x0002f735, 0x0002f737,
+	0x0002f73a, 0x0002f83b, 0x0002f93c, 0x0002fa3d,
+	0x0001fb3e, 0x0001fc3f, 0x0001fd40, 0x0000fe40,
+
+	0x00000000, 0x00000002, 0x0000ff04, 0x0000ff06,
+	0x0000fe08, 0x0000fd0a, 0x0000fd0c, 0x0000fc0f,
+	0x0000fc12, 0x0001fb14, 0x0001fa17, 0x0001fa19,
+	0x0001f91c, 0x0001f91f, 0x0001f822, 0x0001f824,
+	0x0002f727, 0x0002f72a, 0x0002f72c, 0x0002f72f,
+	0x0002f731, 0x0002f733, 0x0002f735, 0x0002f737,
+	0x0002f73a, 0x0002f83b, 0x0002f93c, 0x0002fa3d,
+	0x0001fb3e, 0x0001fc3f, 0x0001fd40, 0x0000fe40,
+
+	0x0000fa11, 0x0000fa12, 0x0000fa13, 0x0000fb14,
+	0x00fffb16, 0x00fffb16, 0x00fffb17, 0x00fffb19,
+	0x00fffc1a, 0x00fefc1c, 0x00fefd1c, 0x01fefd1d,
+	0x01fefe1e, 0x01fdfe20, 0x01fdff21, 0x01fdff22,
+	0x01fd0023, 0x01fc0124, 0x01fc0124, 0x01fc0225,
+	0x01fc0326, 0x01fc0427, 0x01fb0528, 0x01fb0629,
+	0x01fb0729, 0x01fb0829, 0x01fb092a, 0x01fb0a2a,
+	0x00fa0b2c, 0x00fa0c2b, 0x00fa0e2b, 0x00fa0f2c,
+
+	0x00fe0012, 0x00fe0013, 0x00fe0114, 0x00fe0114,
+	0x00fe0116, 0x00fe0216, 0x00fe0216, 0x00fd0317,
+	0x00fd0317, 0x00fd0418, 0x00fd0419, 0x00fd0519,
+	0x00fd051a, 0x00fd061b, 0x00fd061b, 0x00fd071c,
+	0xfffd071e, 0xfffd081d, 0xfffd091d, 0xfffd091e,
+	0xfffe0a1d, 0xfffe0b1e, 0xfffe0b1e, 0xfffe0c1e,
+	0xfffe0d1f, 0xfffe0d1f, 0xfffe0e1f, 0xfeff0f1f,
+	0xfeff0f20, 0xfeff1020, 0xfeff1120, 0xfe001120,
+
+	0x00ff0411, 0x00ff0411, 0x00ff0412, 0x00ff0512,
+	0x00ff0513, 0x00ff0513, 0x00ff0613, 0x00ff0614,
+	0x00ff0714, 0x00ff0715, 0x00ff0715, 0xffff0816,
+	0xffff0816, 0xff000916, 0xff000917, 0xff000918,
+	0xff000a17, 0xff000a18, 0xff000b18, 0xff000b18,
+	0xff010c18, 0xff010c19, 0xff010d18, 0xff010d18,
+	0xff020d18, 0xff020e19, 0xff020e19, 0xff020f19,
+	0xff030f19, 0xff031019, 0xff031019, 0xff031119,
+
+	0x00000610, 0x00000610, 0x00000611, 0x00000611,
+	0x00000711, 0x00000712, 0x00010712, 0x00010812,
+	0x00010812, 0x00010812, 0x00010913, 0x00010913,
+	0x00010913, 0x00010a13, 0x00020a13, 0x00020a14,
+	0x00020b14, 0x00020b14, 0x00020b14, 0x00020c14,
+	0x00030c14, 0x00030c15, 0x00030d15, 0x00030d15,
+	0x00040d15, 0x00040e15, 0x00040e15, 0x00040e16,
+	0x00050f15, 0x00050f15, 0x00050f16, 0x00051015,
+
+	0x00000611, 0x00010610, 0x00010710, 0x00010710,
+	0x00010711, 0x00010811, 0x00010811, 0x00010812,
+	0x00010812, 0x00010912, 0x00020912, 0x00020912,
+	0x00020a12, 0x00020a12, 0x00020a13, 0x00020a13,
+	0x00030b13, 0x00030b13, 0x00030b14, 0x00030c13,
+	0x00030c13, 0x00040c13, 0x00040d14, 0x00040d14,
+	0x00040d15, 0x00040d15, 0x00050e14, 0x00050e14,
+	0x00050e15, 0x00050f14, 0x00060f14, 0x00060f14,
+
+	0x0001070f, 0x0001070f, 0x00010710, 0x00010710,
+	0x00010810, 0x00010810, 0x00020810, 0x00020811,
+	0x00020911, 0x00020911, 0x00020912, 0x00020912,
+	0x00020a12, 0x00030a12, 0x00030a12, 0x00030b12,
+	0x00030b12, 0x00030b12, 0x00040b12, 0x00040c12,
+	0x00040c13, 0x00040c14, 0x00040c14, 0x00050d13,
+	0x00050d13, 0x00050d14, 0x00050e13, 0x01050e13,
+	0x01060e13, 0x01060e13, 0x01060e14, 0x01060f13
+};
+#endif /*if defined CONFIG_ARCH_SUN9IW1 */
+
+#ifndef SCALE_NO_SUPPORT
+static u32 lan2coefftab32[256] = {
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc,
+	0x000a3bfb, 0xff0d39fb, 0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb,
+	0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc, 0xfc2424fc, 0xfc2721fc,
+	0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,
+	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400,
+	0xfe3f0300, 0xff400100,
+
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc,
+	0x000a3bfb, 0xff0d39fb, 0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb,
+	0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc, 0xfc2424fc, 0xfc2721fc,
+	0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,
+	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400,
+	0xfe3f0300, 0xff400100,
+
+	0xff0c2a0b, 0xff0d2a0a, 0xff0e2a09, 0xff0f2a08, 0xff102a07, 0xff112a06,
+	0xff132905, 0xff142904, 0xff162803, 0xff172703, 0xff182702, 0xff1a2601,
+	0xff1b2501, 0xff1c2401, 0xff1e2300, 0xff1f2200, 0x00202000, 0x00211f00,
+	0x01221d00, 0x01231c00, 0x01251bff, 0x02251aff, 0x032618ff, 0x032717ff,
+	0x042815ff, 0x052814ff, 0x052913ff, 0x06291100, 0x072a10ff, 0x082a0e00,
+	0x092a0d00, 0x0a2a0c00,
+
+	0x000e240e, 0x000f240d, 0x0010240c, 0x0011240b, 0x0013230a, 0x0013230a,
+	0x00142309, 0x00152308, 0x00162208, 0x00172207, 0x01182106, 0x01192105,
+	0x011a2005, 0x021b1f04, 0x021b1f04, 0x021d1e03, 0x031d1d03, 0x031e1d02,
+	0x041e1c02, 0x041f1b02, 0x05201a01, 0x05211901, 0x06211801, 0x07221700,
+	0x07221601, 0x08231500, 0x09231400, 0x0a231300, 0x0a231300, 0x0b231200,
+	0x0c231100, 0x0d231000,
+
+	0x0010210f, 0x0011210e, 0x0011210e, 0x0012210d, 0x0013210c, 0x0014200c,
+	0x0114200b, 0x0115200a, 0x01161f0a, 0x01171f09, 0x02171f08, 0x02181e08,
+	0x03181e07, 0x031a1d06, 0x031a1d06, 0x041b1c05, 0x041c1c04, 0x051c1b04,
+	0x051d1a04, 0x061d1a03, 0x071d1903, 0x071e1803, 0x081e1802, 0x081f1702,
+	0x091f1602, 0x0a201501, 0x0b1f1501, 0x0b201401, 0x0c211300, 0x0d211200,
+	0x0e201200, 0x0e211100,
+
+	0x00102010, 0x0011200f, 0x00121f0f, 0x00131f0e, 0x00141f0d, 0x01141f0c,
+	0x01141f0c, 0x01151e0c, 0x02161e0a, 0x02171e09, 0x03171d09, 0x03181d08,
+	0x03181d08, 0x04191c07, 0x041a1c06, 0x051a1b06, 0x051b1b05, 0x061b1a05,
+	0x061c1a04, 0x071c1904, 0x081c1903, 0x081d1803, 0x091d1703, 0x091e1702,
+	0x0a1e1602, 0x0b1e1502, 0x0c1e1501, 0x0c1f1401, 0x0d1f1400, 0x0e1f1300,
+	0x0e1f1201, 0x0f1f1200,
+
+	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141d0e,
+	0x02151d0c, 0x02151d0c, 0x02161d0b, 0x03161c0b, 0x03171c0a, 0x04171c09,
+	0x04181b09, 0x05181b08, 0x05191b07, 0x06191a07, 0x061a1a06, 0x071a1906,
+	0x071b1905, 0x081b1805, 0x091b1804, 0x091c1704, 0x0a1c1703, 0x0a1c1604,
+	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301,
+	0x0f1e1300, 0x101e1200,
+
+	0x00111e11, 0x00121e10, 0x00131d10, 0x01131d0f, 0x01141d0e, 0x01141d0e,
+	0x02151c0d, 0x02151c0d, 0x03161c0b, 0x03161c0b, 0x04171b0a, 0x04171b0a,
+	0x05171b09, 0x05181a09, 0x06181a08, 0x06191a07, 0x07191907, 0x071a1906,
+	0x081a1806, 0x081a1806, 0x091a1805, 0x0a1b1704, 0x0a1b1704, 0x0b1c1603,
+	0x0b1c1603, 0x0c1c1503, 0x0d1c1502, 0x0d1d1402, 0x0e1d1401, 0x0f1d1301,
+	0x0f1d1301, 0x101e1200,
+
+};
+#endif
+
+#if (defined CONFIG_ARCH_SUN9IW1)
+static u32 bicubic8coefftab32_left[256] = {
+
+	0x40000000, 0x40ff0000, 0x3ffe0000, 0x3efe0000,
+	0x3dfd0000, 0x3cfc0000, 0x3bfc0000, 0x39fc0000,
+	0x36fc0000, 0x35fb0000, 0x33fb0000, 0x31fb0000,
+	0x2ffb0000, 0x2cfb0000, 0x29fc0000, 0x27fc0000,
+	0x24fc0000, 0x21fc0000, 0x1efd0000, 0x1cfd0000,
+	0x19fd0000, 0x16fe0000, 0x14fe0000, 0x11fe0000,
+	0x0dff0000, 0x0cff0000, 0x0aff0000, 0x08ff0000,
+	0x05000000, 0x03000000, 0x02000000, 0x01000000,
+
+	0x40000000, 0x40ff0000, 0x3ffe0000, 0x3efe0000,
+	0x3dfd0000, 0x3cfc0000, 0x3bfc0000, 0x39fc0000,
+	0x36fc0000, 0x35fb0000, 0x33fb0000, 0x31fb0000,
+	0x2ffb0000, 0x2cfb0000, 0x29fc0000, 0x27fc0000,
+	0x24fc0000, 0x21fc0000, 0x1efd0000, 0x1cfd0000,
+	0x19fd0000, 0x16fe0000, 0x14fe0000, 0x11fe0000,
+	0x0dff0000, 0x0cff0000, 0x0aff0000, 0x08ff0000,
+	0x05000000, 0x03000000, 0x02000000, 0x01000000,
+
+	0x2a0efd00, 0x2a0dfd00, 0x2a0cfd00, 0x290bfd00,
+	0x290afd00, 0x2909fd00, 0x2908fd00, 0x2807fd00,
+	0x2706fd00, 0x2705fd00, 0x2604fe00, 0x2603fe00,
+	0x2502fe00, 0x2402fe00, 0x2401fe00, 0x2200fe00,
+	0x2200fe00, 0x2000ff00, 0x1fffff00, 0x1effff00,
+	0x1dfeff00, 0x1cfeff00, 0x1afeff00, 0x19feff00,
+	0x17fe0000, 0x16fd0000, 0x15fd0000, 0x14fd0000,
+	0x12fd0000, 0x11fd0000, 0x10fd0000, 0x0ffd0000,
+
+	0x201200fe, 0x201100fe, 0x1f1100fe, 0x2010fffe,
+	0x200ffffe, 0x1f0ffffe, 0x1f0efffe, 0x1e0dffff,
+	0x1f0cfeff, 0x1e0cfeff, 0x1e0bfeff, 0x1e0afeff,
+	0x1d0afeff, 0x1d09feff, 0x1c08feff, 0x1b08feff,
+	0x1b07feff, 0x1a07feff, 0x1a06feff, 0x1a05feff,
+	0x1805fe00, 0x1904fe00, 0x1704fe00, 0x1703fe00,
+	0x1603fe00, 0x1602fe00, 0x1402fe00, 0x1402fe00,
+	0x1401fe00, 0x1301fe00, 0x1201fe00, 0x1200fe00,
+
+	0x191104fe, 0x191104fe, 0x191003fe, 0x191003fe,
+	0x171003fe, 0x180f03fe, 0x180f02fe, 0x180e02fe,
+	0x180e02fe, 0x180d01fe, 0x180d01fe, 0x180d01fe,
+	0x170c01fe, 0x160c01fe, 0x170b00fe, 0x170b00fe,
+	0x160a00fe, 0x160a00fe, 0x160a00fe, 0x150900fe,
+	0x1509fffe, 0x1508fffe, 0x1508fffe, 0x1408fffe,
+	0x1407fffe, 0x1307ffff, 0x1306ffff, 0x1206ffff,
+	0x1206ffff, 0x1205ffff, 0x1205ffff, 0x1104feff,
+
+	0x140f0700, 0x140f0600, 0x140f0600, 0x140f0600,
+	0x140e0600, 0x130e0500, 0x140e05ff, 0x130e05ff,
+	0x140d05ff, 0x130d04ff, 0x130d04ff, 0x120d04ff,
+	0x130c04ff, 0x130c03ff, 0x130c03ff, 0x120c03ff,
+	0x120b03ff, 0x120b02ff, 0x120b02ff, 0x120a02ff,
+	0x120a02ff, 0x110a02ff, 0x110a01ff, 0x120901ff,
+	0x100901ff, 0x100901ff, 0x110801ff, 0x110801ff,
+	0x100800ff, 0x100800ff, 0x100700ff, 0x100700fe,
+
+	0x120f0701, 0x120e0701, 0x120e0701, 0x120e0701,
+	0x120e0600, 0x110e0600, 0x120d0600, 0x120d0600,
+	0x120d0500, 0x120d0500, 0x110d0500, 0x110c0500,
+	0x110c0500, 0x110c0400, 0x110c0400, 0x110b04ff,
+	0x110b04ff, 0x110b04ff, 0x110b03ff, 0x110b03ff,
+	0x110a03ff, 0x110a03ff, 0x100a03ff, 0x110a02ff,
+	0x100902ff, 0x100902ff, 0x100902ff, 0x0f0902ff,
+	0x0e0902ff, 0x100801ff, 0x0f0801ff, 0x0f0801ff,
+
+	0x100e0802, 0x100e0802, 0x110e0702, 0x110d0701,
+	0x110d0701, 0x100d0701, 0x100d0701, 0x110d0601,
+	0x110d0601, 0x110c0601, 0x110c0601, 0x100c0600,
+	0x100c0500, 0x100c0500, 0x100c0500, 0x100b0500,
+	0x100b0500, 0x100b0400, 0x100b0400, 0x0f0b0400,
+	0x100a0400, 0x0f0a0400, 0x0f0a0400, 0x0f0a0300,
+	0x0f0a03ff, 0x0f0903ff, 0x0f0903ff, 0x0f0903ff,
+	0x0f0903ff, 0x0f0902ff, 0x0f0902ff, 0x0f0802ff
+
+};
+static u32 bicubic8coefftab32_right[256] = {
+
+	0x00000000, 0x00000001, 0x00000003, 0x00000004,
+	0x00000006, 0x0000ff09, 0x0000ff0a, 0x0000ff0c,
+	0x0000ff0f, 0x0000fe12, 0x0000fe14, 0x0000fe16,
+	0x0000fd19, 0x0000fd1c, 0x0000fd1e, 0x0000fc21,
+	0x0000fc24, 0x0000fc27, 0x0000fc29, 0x0000fb2c,
+	0x0000fb2f, 0x0000fb31, 0x0000fb33, 0x0000fb36,
+	0x0000fc38, 0x0000fc39, 0x0000fc3b, 0x0000fc3d,
+	0x0000fd3e, 0x0000fe3f, 0x0000fe40, 0x0000ff40,
+
+	0x00000000, 0x00000001, 0x00000003, 0x00000004,
+	0x00000006, 0x0000ff09, 0x0000ff0a, 0x0000ff0c,
+	0x0000ff0f, 0x0000fe12, 0x0000fe14, 0x0000fe16,
+	0x0000fd19, 0x0000fd1c, 0x0000fd1e, 0x0000fc21,
+	0x0000fc24, 0x0000fc27, 0x0000fc29, 0x0000fb2c,
+	0x0000fb2f, 0x0000fb31, 0x0000fb33, 0x0000fb36,
+	0x0000fc38, 0x0000fc39, 0x0000fc3b, 0x0000fc3d,
+	0x0000fd3e, 0x0000fe3f, 0x0000fe40, 0x0000ff40,
+
+	0x0000fd0e, 0x0000fd0f, 0x0000fd10, 0x0000fd12,
+	0x0000fd13, 0x0000fd14, 0x0000fd15, 0x0000fd17,
+	0x0000fe18, 0x00fffe1a, 0x00fffe1b, 0x00fffe1c,
+	0x00fffe1e, 0x00ffff1e, 0x00ffff1f, 0x00ff0021,
+	0x00fe0022, 0x00fe0023, 0x00fe0124, 0x00fe0224,
+	0x00fe0226, 0x00fe0326, 0x00fe0427, 0x00fd0528,
+	0x00fd0628, 0x00fd0729, 0x00fd0829, 0x00fd0929,
+	0x00fd0a2a, 0x00fd0b2a, 0x00fd0c2a, 0x00fd0d2a,
+
+	0x00fe0012, 0x00fe0013, 0x00fe0113, 0x00fe0114,
+	0x00fe0115, 0x00fe0215, 0x00fe0216, 0x00fe0217,
+	0x00fe0317, 0x00fe0318, 0x00fe0418, 0x00fe0419,
+	0x00fe0519, 0x00fe051a, 0x00fe061b, 0x00fe071b,
+	0x00fe071c, 0x00fe081c, 0x00fe081d, 0x00fe091d,
+	0x00fe0a1d, 0x00fe0a1d, 0x00fe0b1e, 0x00fe0c1e,
+	0x00ff0c1e, 0x00ff0d1e, 0x00ff0e1f, 0x00ff0e1f,
+	0x00ff0f1f, 0x00ff0f20, 0x0000101f, 0x0000111f,
+
+	0x00fe0412, 0x00fe0412, 0x00ff0512, 0x00ff0512,
+	0x00ff0613, 0x00ff0613, 0x00ff0614, 0x00ff0714,
+	0x00ff0714, 0x00ff0815, 0x00ff0815, 0x00ff0815,
+	0x00ff0916, 0x00000916, 0x00000a16, 0x00000a16,
+	0x00000a18, 0x00000b17, 0x00000b17, 0x00010c17,
+	0x00010c18, 0x00010d18, 0x00010d18, 0x00010d19,
+	0x00020e18, 0x00020e18, 0x00020f18, 0x00030f18,
+	0x00030f18, 0x00031018, 0x00031018, 0x00041119,
+
+	0x0000070f, 0x00000710, 0x00000710, 0x00000710,
+	0x00000810, 0x00010811, 0x00010811, 0x00010911,
+	0x00010911, 0x00010913, 0x00010913, 0x00020a12,
+	0x00020a12, 0x00020a13, 0x00020b12, 0x00020b13,
+	0x00030b13, 0x00030c13, 0x00030c13, 0x00030c14,
+	0x00040c13, 0x00040d13, 0x00040d14, 0x00040d14,
+	0x00050e14, 0x00050e14, 0x00050e14, 0x00050e14,
+	0x00060f14, 0x00060f14, 0x00060f15, 0x00061015,
+
+	0x0001070f, 0x0001080f, 0x0001080f, 0x0001080f,
+	0x00010811, 0x00020910, 0x00020910, 0x00020910,
+	0x00020911, 0x00020a10, 0x00030a10, 0x00030a11,
+	0x00030a11, 0x00030b11, 0x00030b11, 0x00040b12,
+	0x00040b12, 0x00040c11, 0x00040c12, 0x00040c12,
+	0x00050c12, 0x00050c12, 0x00050d12, 0x00050d12,
+	0x00060d13, 0x00060d13, 0x00060e12, 0x00060e13,
+	0x00070e13, 0x00070e13, 0x00070f13, 0x00070f13,
+
+	0x0002080e, 0x0002080e, 0x0002080e, 0x00020810,
+	0x0002090f, 0x0003090f, 0x0003090f, 0x0003090f,
+	0x0003090f, 0x00030a0f, 0x00030a0f, 0x00040a10,
+	0x00040a11, 0x00040b10, 0x00040b10, 0x00040b11,
+	0x00050b10, 0x00050b11, 0x00050c10, 0x00050c11,
+	0x00050c11, 0x00060c11, 0x00060c11, 0x00060d11,
+	0x00060d12, 0x00070d12, 0x00070d12, 0x00070e11,
+	0x00070e11, 0x00070e12, 0x00080e11, 0x00080e12
+
+};
+#endif /* if defined CONFIG_ARCH_SUN9IW1 */
+
+#ifndef SCALE_NO_SUPPORT
+static u32 bicubic4coefftab32[256] = {
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063dfd, 0xff083dfc,
+	0xff0a3bfc, 0xff0c39fc, 0xff0e37fc, 0xfe1136fb, 0xfe1433fb, 0xfe1631fb,
+	0xfd192ffb, 0xfd1c2cfb, 0xfd1e29fc, 0xfc2127fc, 0xfc2424fc, 0xfc2721fc,
+	0xfc291efd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfb3611fe,
+	0xfc370eff, 0xfc390cff, 0xfc3b0aff, 0xfc3d08ff, 0xfd3d0600, 0xfd3f0400,
+	0xfe3f0300, 0xff400100,
+
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063dfd, 0xff083dfc,
+	0xff0a3bfc, 0xff0c39fc, 0xff0e37fc, 0xfe1136fb, 0xfe1433fb, 0xfe1631fb,
+	0xfd192ffb, 0xfd1c2cfb, 0xfd1e29fc, 0xfc2127fc, 0xfc2424fc, 0xfc2721fc,
+	0xfc291efd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfb3611fe,
+	0xfc370eff, 0xfc390cff, 0xfc3b0aff, 0xfc3d08ff, 0xfd3d0600, 0xfd3f0400,
+	0xfe3f0300, 0xff400100,
+
+	0xfd0d290d, 0xfd0e290c, 0xfd0f290b, 0xfd11280a, 0xfd122809, 0xfd132808,
+	0xfd142807, 0xfd162706, 0xfd172705, 0xfd192604, 0xfe1a2503, 0xfe1b2502,
+	0xfe1c2402, 0xfe1d2302, 0xff1e2201, 0xff1f2101, 0x00202000, 0x00211f00,
+	0x01221eff, 0x02221dff, 0x02241cfe, 0x03241bfe, 0x042519fe, 0x042618fe,
+	0x052617fe, 0x062716fd, 0x072714fe, 0x082713fe, 0x092812fd, 0x0a2811fd,
+	0x0b2810fd, 0x0c280ffd,
+
+	0x00111f10, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141e0d,
+	0x01151d0d, 0x02151d0c, 0x02161d0b, 0x03161d0a, 0x03171c0a, 0x04171c09,
+	0x04181c08, 0x05181b08, 0x05191b07, 0x06191a07, 0x061a1a06, 0x071a1906,
+	0x071b1905, 0x081b1805, 0x081c1804, 0x091c1704, 0x0a1c1703, 0x0a1d1603,
+	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1e1401, 0x0e1d1401, 0x0e1e1301,
+	0x0f1e1300, 0x101e1200,
+
+	0x04111a11, 0x04121911, 0x04131910, 0x0513190f, 0x0513190f, 0x0513190f,
+	0x0613190e, 0x0614180e, 0x0714180d, 0x0714180d, 0x0715180c, 0x0814180c,
+	0x0815170c, 0x0816170b, 0x0916170a, 0x0916170a, 0x0a16160a, 0x0a171609,
+	0x0a171609, 0x0b171608, 0x0b171509, 0x0c171508, 0x0c181507, 0x0d171507,
+	0x0d181407, 0x0e181406, 0x0e181406, 0x0e191306, 0x0f191305, 0x0f191305,
+	0x10191304, 0x10191205,
+
+	0x07111711, 0x07121710, 0x07121611, 0x08121610, 0x08121610, 0x0813160f,
+	0x0912160f, 0x0913160e, 0x0913160e, 0x0913160e, 0x0a14150d, 0x0a14150d,
+	0x0a14150d, 0x0b14150c, 0x0b14150c, 0x0b14150c, 0x0c14140c, 0x0c15140b,
+	0x0c15140b, 0x0c15140b, 0x0d15140a, 0x0d15140a, 0x0d15140a, 0x0e161309,
+	0x0e161309, 0x0e161309, 0x0f151309, 0x0f161308, 0x0f161209, 0x10161208,
+	0x10161208, 0x10171207,
+
+	0x0a111411, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b12140f,
+	0x0b12140f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f,
+	0x0d12130e, 0x0d12130e, 0x0d12130e, 0x0d13130d, 0x0d13130d, 0x0d13130d,
+	0x0e12130d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0f13120c,
+	0x0f13120c, 0x0f13120c, 0x0f14120b, 0x0f14120b, 0x1013120b, 0x1013120b,
+	0x1013120b, 0x1014110b,
+
+	0x0c111310, 0x0c111310, 0x0c111310, 0x0d101310, 0x0d101310, 0x0d111210,
+	0x0d111210, 0x0d111210, 0x0d12120f, 0x0d12120f, 0x0d12120f, 0x0d12120f,
+	0x0e11120f, 0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0e12120e,
+	0x0e12120e, 0x0e12120e, 0x0f11120e, 0x0f12120d, 0x0f12120d, 0x0f12120d,
+	0x0f12120d, 0x0f12110e, 0x0f12110e, 0x0f12110e, 0x1012110d, 0x1012110d,
+	0x1013110c, 0x1013110c,
+
+};
+#endif
+#endif
diff --git a/drivers/char/sunxi-di/drv_div2x/lowlevel_v2x/di_type_v2x.h b/drivers/char/sunxi-di/drv_div2x/lowlevel_v2x/di_type_v2x.h
new file mode 100644
index 000000000..9383a8311
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/lowlevel_v2x/di_type_v2x.h
@@ -0,0 +1,414 @@
+/**
+ *  All Winner Tech, All Right Reserved. 2006-2016 Copyright (c)
+ *
+ *  File name   :       di_type_v23.h
+ *
+ *  Description :
+ *
+ *  History     :2016/01/12        zhengwj        initial version for DI_V2.0
+ *               2016/10/09        zhengwj        modify for DI_V2.3
+ *               2016/12/27        yulangheng     code of DI_V2.2 added
+ *
+ *  This file is licensed under the terms of the GNU General Public
+ *  License version 2.  This program is licensed "as is" without any
+ *  warranty of any kind, whether express or implied.
+ */
+
+#ifndef __DI_TYPE_V2X__H__
+#define __DI_TYPE_V2X__H__
+#include <linux/types.h>
+#include "../sunxi-di.h"
+
+struct __di_buf_size_t {
+	unsigned int width;
+	unsigned int height;
+	unsigned int fb_width;
+	unsigned int fb_height;
+};
+
+struct __di_buf_addr_t {
+	unsigned long long ch0_addr;
+	unsigned long long ch1_addr;
+	unsigned long long ch2_addr;
+};
+
+enum __di_fmt_t {
+	DI_FMT_PLANAR420 = 0x0,
+	DI_FMT_UVCOMB420 = 0x1,
+	DI_FMT_PLANAR422 = 0x2,
+	DI_FMT_UVCOMB422 = 0x3,
+};
+
+union DI_CTRL_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int start:1;
+		unsigned int res0:15;
+		unsigned int dma_rand_access_en:1; /* res in DI220 */
+		unsigned int res1:14;
+		unsigned int reset:1;
+	} bits;
+};
+
+union DI_INT_CTRL_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int int_en:1;
+		unsigned int res0:31;
+	} bits;
+};
+
+union DI_STATUS_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int finish_sts:1;
+		unsigned int res0:7;
+		unsigned int busy:1;
+		unsigned int res1:7;
+		unsigned int cur_line:11;
+		unsigned int res2:1;
+		unsigned int cur_plane:2;
+		unsigned int res3:2;
+	} bits;
+};
+
+union DI_SIZE_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int width:11;
+		unsigned int res0:5;
+		unsigned int height:11;
+		unsigned int res1:5;
+	} bits;
+};
+
+union DI_FORMAT_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int fmt:2;
+		unsigned int res0:30;
+	} bits;
+};
+
+union DI_POLAR_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int polar:1;
+		unsigned int res0:31;
+	} bits;
+};
+
+union DI_PITCH_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int pitch:16;
+		unsigned int res0:16;
+	} bits;
+};
+
+union DI_ADD_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int addr:32;
+	} bits;
+};
+
+union DI_ADDHB_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int addhb0:8;
+		unsigned int addhb1:8;
+		unsigned int addhb2:8;
+		unsigned int res0:8;
+	} bits;
+};
+
+union DI_MODE_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int di_mode_luma:1;
+		unsigned int res0:3;
+		unsigned int motion_detc_en:1;
+		unsigned int diag_intp_en:1;
+#if defined DI_V23
+		unsigned int res1:6;
+		unsigned int flag_auto_update_mode:2;
+		unsigned int res2:2;
+#elif defined DI_V22
+		unsigned int res1:2;
+		unsigned int flag_update_mode:1;
+		unsigned int res2:7;
+#endif
+		unsigned int di_mode_chroma:1;
+		unsigned int res3:14;
+		unsigned int in_field_mode:1;
+	} bits;
+};
+
+union DI_MD_PARA0_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int minlumath:8; /* Default: 0x4 */
+		unsigned int maxlumath:8; /* Default: 0xc */
+		unsigned int avglumashifter:4; /* Default: 0x6 */
+		unsigned int res0:4; /* Default: */
+		unsigned int th_shift:4; /* Default: 0x1 */
+		unsigned int res1:4; /* Default: */
+	} bits;
+};
+
+union DI_MD_PARA1_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int f_port_th:8;/* Default:0x80 res in DI_V23 */
+		unsigned int f_port_factor:3;/* Default:0x4 res in DI_V23 */
+		unsigned int res0:5;
+		unsigned int edge_th:8;/* Default:0x20 res in DI_V23 */
+		unsigned int mov_fac_edge:2;/* Default:0x3 res in DI_V23 */
+		unsigned int res1:2;
+		unsigned int mov_fac_nonedge:2; /* Default: 0x1 */
+		unsigned int res2:2; /* Default: */
+	} bits;
+};
+
+
+union DI_MD_PARA2_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int luma_spatial_th:8; /* Default:5 res in DI230 */
+		unsigned int chroma_spatical_th:8; /* Default: 0x80 */
+		unsigned int chroma_diff_th:8; /* Default: 0x5 */
+		unsigned int erosion_bob_th:4; /* Default: 0x7 res in DI230 */
+		unsigned int pix_static_th:2; /* Default: 0x3 */
+		unsigned int res2:2; /* Default: */
+	} bits;
+};
+
+union DI_INTP_PARA_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int angle_limit:5; /* Default: 0x14 */
+		unsigned int res0:3; /* Default: */
+		unsigned int angle_const_th:3; /* Default: 0x5 */
+		unsigned int res1:5; /* Default: */
+		unsigned int luma_cur_fac_mod:3; /* Default: 0x1 */
+		unsigned int res2:1; /* Default: */
+		unsigned int chroma_cur_fac_mod:3; /* Default: 0x1 */
+		unsigned int res3:9; /* Default: */
+	} bits;
+};
+
+union DI_MD_CH_PARA_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int blend_mode:4; /* Default: 0x0 */
+		unsigned int res0:4; /* Default: */
+		unsigned int font_pro_en:1; /* Default: 0x0 */
+		unsigned int res1:7; /* Default: */
+		unsigned int font_pro_th:8; /* Default: 0x30 */
+		unsigned int font_pro_fac:5;
+						 /* Default: 0x4
+					      * 4 bits width in DI230
+					      */
+		unsigned int res2:3; /* Default: */
+	} bits;
+};
+
+union DI_INTP_PARA1_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int a:3; /* Default: 0x4 */
+		unsigned int en:1; /* Default: 0x1 */
+		unsigned int c:4; /* Default: 0xa */
+		unsigned int cmax:8; /* Default: 0x40 */
+		unsigned int maxrat:2; /* Default: 0x2 */
+		unsigned int res0:14; /* Default: */
+	} bits;
+};
+
+union DI_OUTPUT_PATH_REG {
+	unsigned int dwval;
+	struct {
+		unsigned int output_path:1;
+		unsigned int res0:31;
+	} bits;
+};
+
+/*
+ * DI_V23 does not contain DNS-related regisgter
+ */
+union DNS_CTL {
+	unsigned int dwval;
+	struct {
+		unsigned int dns_en:1;
+		unsigned int winsz_sel:1;
+		unsigned int res0:29;
+		unsigned int win_en:1;
+	} bits;
+}; /* default: 0x0000_0000 */
+
+union DNS_SIZE {
+	unsigned int dwval;
+	struct {
+		unsigned int width:13;
+		unsigned int res0:3;
+		unsigned int height:13;
+		unsigned int res1:3;
+	} bits;
+}; /* default: 0x0000_0000 */
+
+union DNS_WIN0 {
+	unsigned int dwval;
+	struct {
+		unsigned int win_left:13;
+		unsigned int res0:3;
+		unsigned int win_top:13;
+		unsigned int res1:3;
+	} bits;
+}; /* default: 0x0000_0000 */
+
+union DNS_WIN1 {
+	unsigned int dwval;
+	struct {
+		unsigned int win_right:13;
+		unsigned int res0:3;
+		unsigned int win_bot:13;
+		unsigned int res1:3;
+	} bits;
+}; /* default: 0x0000_0000 */
+
+union DNS_LFT_PARA0 {
+	unsigned int dwval;
+	struct {
+		unsigned int lsig:3;
+		unsigned int res0:5;
+		unsigned int lsig2:8;
+		unsigned int lsig3:8;
+		unsigned int ldir_rsig_gain2:8;
+	} bits;
+}; /* default: 0x0000_0000 */
+
+union DNS_LFT_PARA1 {
+	unsigned int dwval;
+	struct {
+		unsigned int ldir_cen:8;
+		unsigned int ldir_rsig_gain:8;
+		unsigned int ldir_thrlow:8;
+		unsigned int ldir_thrhigh:8;
+	} bits;
+}; /* default: 0x0000_0000 */
+
+union DNS_LFT_PARA2 {
+	unsigned int dwval;
+	struct {
+		unsigned int lbben:1;
+		unsigned int res0:7;
+		unsigned int lbgain:8;
+		unsigned int lbyst:4;
+		unsigned int lbxst:4;
+		unsigned int lbw:4;
+		unsigned int lbh:4;
+	} bits;
+}; /* default:0x7700_0000 */
+
+union DNS_LFT_PARA3 {
+	unsigned int dwval;
+	struct {
+		unsigned int lsig_cen:8;
+		unsigned int res0:24;
+	} bits;
+}; /* default:0x0000_0000*/
+
+union IQA_CTL {
+	unsigned int dwval;
+	struct {
+		unsigned int no_name:1;
+		unsigned int res0:31;
+	} bits;
+}; /* default: 0x0000_0000 */
+
+union IQA_BLKDT_PARA0 {
+	unsigned int dwval;
+	struct {
+		unsigned int dt_thrlow:8;
+		unsigned int dt_thrhigh:8;
+		unsigned int res0:16;
+	} bits;
+}; /* default: 0x0000_c810*/
+
+struct __di_dev_t {
+	union DI_CTRL_REG ctrl; /* 0x0000 */
+	union DI_INT_CTRL_REG intr; /* 0x0004 */
+	union DI_STATUS_REG status;	/* 0x0008 */
+	unsigned int res0; /* 0x000c */
+	union DI_SIZE_REG size; /* 0x0010 */
+	union DI_FORMAT_REG fmt; /* 0x0014 */
+	union DI_POLAR_REG polar; /* 0x0018 */
+	unsigned int res1; /* 0x001c */
+	union DI_PITCH_REG inpicth0; /* 0x0020 */
+	union DI_PITCH_REG inpicth1; /* 0x0024 */
+	union DI_PITCH_REG inpicth2; /* 0x0028 */
+	unsigned int res2; /* 0x002C */
+	union DI_PITCH_REG outpicth0; /* 0x0030 */
+	union DI_PITCH_REG outpicth1; /* 0x0034 */
+	union DI_PITCH_REG outpicth2; /* 0x0038 */
+	unsigned int res3; /* 0x003C */
+	union DI_PITCH_REG flagpitch; /* 0x0040 */
+	unsigned int res4[3]; /* 0x0044-4c */
+	union DI_ADD_REG in0add0; /* 0x0050 */
+	union DI_ADD_REG in0add1; /* 0x0054 */
+	union DI_ADD_REG in0add2; /* 0x0058 */
+	union DI_ADDHB_REG in0addhb; /* 0x005c */
+	union DI_ADD_REG in1add0; /* 0x0060 */
+	union DI_ADD_REG in1add1; /* 0x0064 */
+	union DI_ADD_REG in1add2; /* 0x0068 */
+	union DI_ADDHB_REG in1addhb; /* 0x006c */
+	union DI_ADD_REG in2add0; /* 0x0070 */
+	union DI_ADD_REG in2add1; /* 0x0074 */
+	union DI_ADD_REG in2add2; /* 0x0078 */
+	union DI_ADDHB_REG in2addhb; /* 0x007c */
+	union DI_ADD_REG in3add0; /* 0x0080 */
+	union DI_ADD_REG in3add1; /* 0x0084 */
+	union DI_ADD_REG in3add2; /* 0x0088 */
+	union DI_ADDHB_REG in3addhb; /* 0x008c */
+	union DI_ADD_REG outadd0; /* 0x0090 */
+	union DI_ADD_REG outadd1; /* 0x0094 */
+	union DI_ADD_REG outadd2; /* 0x0098 */
+	union DI_ADDHB_REG outaddhb; /* 0x009c */
+	union DI_ADD_REG inflagadd; /* 0x00a0 */
+	union DI_ADD_REG outflagadd; /* 0x00a4 */
+	union DI_ADDHB_REG flagaddhb; /* 0x00a8 */
+	unsigned int res5; /* 0x00ac */
+	union DI_MODE_REG mode; /* 0x00b0 */
+	union DI_MD_PARA0_REG mdpara0; /* 0x00b4 */
+	union DI_MD_PARA1_REG mdpara1; /* 0x00b8 */
+	union DI_MD_PARA2_REG mdpara2; /* 0x00bc */
+	union DI_INTP_PARA_REG dipara0; /* 0x00c0 */
+	union DI_MD_CH_PARA_REG mdchpara; /* 0x00c4 */
+
+	union DI_INTP_PARA1_REG dipara1; /* 0x00c8 res in DI220 */
+	unsigned int res6[77]; /* 0x00cc-0x01fc */
+
+	union DI_OUTPUT_PATH_REG outpath; /* 0x0200 */
+};
+
+/*
+ * DI_V23 does not contain DNS module
+ */
+struct __dns_dev_t {
+	union DNS_CTL dns_ctl; /* 0x10000 */
+	union DNS_SIZE dns_size; /* 0x10004 */
+	union DNS_WIN0 dns_win0; /* 0x10008 */
+	union DNS_WIN1 dns_win1; /* 0x1000c */
+	union DNS_LFT_PARA0 dns_lft_para0; /* 0x10010 */
+	union DNS_LFT_PARA1 dns_lft_para1; /* 0x10014 */
+	union DNS_LFT_PARA2 dns_lft_para2; /* 0x10018 */
+	union DNS_LFT_PARA3 dns_lft_para3; /* 0x1001c */
+	unsigned int res8[56]; /* 0x10020-0x100fc */
+	union IQA_CTL iqa_ctl; /* 0x10100 */
+	unsigned int res9[14]; /* 0x10104-0x1c80c */
+	union IQA_BLKDT_PARA0 iqa_blkdt_para0; /* 0x1013c */
+
+};
+
+#endif
diff --git a/drivers/char/sunxi-di/drv_div2x/lowlevel_v2x/di_v2x.c b/drivers/char/sunxi-di/drv_div2x/lowlevel_v2x/di_v2x.c
new file mode 100644
index 000000000..36954ed43
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/lowlevel_v2x/di_v2x.c
@@ -0,0 +1,678 @@
+/**
+ *  All Winner Tech, All Right Reserved. 2006-2016 Copyright (c)
+ *
+ *  File name   :        di_v23.c
+ *
+ *  Description :
+ *
+ *  History     :2016/01/18        zhengwj        initial version for DI_V2.0
+ *               2016/10/09        zhengwj        modify for DI_V2.3
+ *               2016/12/27        yulangheng     code of DI_V2.2 added
+ *
+ *  This file is licensed under the terms of the GNU General Public
+ *  License version 2.  This program is licensed "as is" without any
+ *  warranty of any kind, whether express or implied.
+ */
+
+#include "../di.h"
+#include "../sunxi-di.h"
+#include "di_type_v2x.h"
+#include <linux/slab.h>
+#include <asm/io.h>
+
+volatile struct __di_dev_t *di_dev;
+#if defined SUPPORT_DNS
+volatile struct __dns_dev_t *dns_dev;
+#endif
+
+static struct __di_mode_t g_di_mode;
+
+#define SETMASK(width, shift) ((width ? ((-1U) >> (32-width)) : 0)  << (shift))
+#define CLRMASK(width, shift)   (~(SETMASK(width, shift)))
+#define SET_BITS(shift, width, reg, val) \
+		(((reg) & CLRMASK(width, shift)) | (val << (shift)))
+/**
+ * function: di_set_reg_base(void *base)
+ * description: set di module register base
+ * parameters: base <di module AHB memory mapping >
+ * return   :
+ */
+s32 di_set_reg_base(void *base)
+{
+	di_dev = (struct __di_dev_t *)base;
+
+#if defined SUPPORT_DNS
+	dns_dev = (struct __dns_dev_t *)(base + 0x10000);
+#endif
+
+	return 0;
+}
+
+/**
+ * function: di_get_reg_base(void)
+ * description: get di module register base
+ * parameters:
+ * return   : di module AHB memory mapping
+ */
+void *di_get_reg_base(void)
+{
+	void *ret = NULL;
+
+	ret = (void *)(di_dev);
+
+	return ret;
+}
+
+/**
+ * function: di_set_init(void)
+ * description: set di module default register to ready de-interlace
+ * parameters:
+ * return   :
+ */
+#if defined DI_V23
+#define IOMMU_ENABLE 1 /* DI_V2.3 : Enable IOMMU function */
+#endif
+
+s32 di_set_init(void)
+{
+#if defined DI_V23
+	/* di_dev->output_path.bits.output_path = 0; */
+	di_dev->outpath.dwval = 0x00000000;
+
+	/* default setting of di */
+
+	/* di_dev->ctrl.bits.dma_rand_access_en = 1 (iommu_enable) */
+	di_dev->ctrl.dwval = 0x00000000 | (IOMMU_ENABLE << 16);
+
+	/* int di_mode = 1;
+	 * int motion_detc_en = 1;
+	 * int diag_intp_en = 1;
+	 * int flag_update_mode = 0;
+	 * di_dev->mode.bits.di_mode_luma = di_mode;
+	 * di_dev->mode.bits.di_mode_chroma = di_mode;
+	 * di_dev->mode.bits.motion_detc_en = motion_detc_en;
+	 * di_dev->mode.bits.diag_intp_en = diag_intp_en;
+	 * di_dev->mode.bits.flag_update_mode = flag_update_mode;
+	 * di_dev->mode.bits.in_field_mode =
+	 *         (di_mode == DI_MODE_MOTION)? 0: 1;
+	 */
+	di_dev->mode.dwval = 0x00010031;
+
+	/* di_dev->mdpara0.bits.minlumath = 0x4;
+	 * di_dev->mdpara0.bits.maxlumath = 0xc;
+	 * di_dev->mdpara0.bits.avglumashifter = 0x6;
+	 * di_dev->mdpara0.bits.th_shift = 0x1;
+	 */
+	di_dev->mdpara0.dwval = 0x01060c04;
+
+	/* di_dev->mdpara1.bits.mov_fac_nonedge = 0x2;
+	 */
+	di_dev->mdpara1.dwval = 0x20000000;
+
+	/* di_dev->mdpara2.bits.chroma_spatical_th = 0x80;
+	 * di_dev->mdpara2.bits.chroma_diff_th = 0x5;
+	 * di_dev->mdpara2.bits.pix_static_th = 0x3;
+	 */
+	di_dev->mdpara2.dwval = 0x30058000;
+
+	/* di_dev->dipara.bits.angle_limit = 0x14;
+	 * di_dev->dipara.bits.angle_const_th = 0x5;
+	 * di_dev->dipara.bits.luma_cur_fac_mod = 0x1;
+	 * di_dev->dipara.bits.chroma_cur_fac_mod = 0x1;
+	 */
+	di_dev->dipara0.dwval = 0x00110514;
+
+	/* di_dev->mdchpara.bits.blend_mode = 0x1;
+	 * di_dev->mdchpara.bits.font_pro_en = 0x1;
+	 * di_dev->mdchpara.bits.font_pro_th = 0x30;
+	 * di_dev->mdchpara.bits.font_pro_fac = 0x4;
+	 */
+	di_dev->mdchpara.dwval = 0x04300101;
+
+	/* di_dev->dipara1.bits.a = 0x4;
+	 * di_dev->dipara1.bits.en = 0x1;
+	 * di_dev->dipara1.bits.c = 0xa;
+	 * di_dev->dipara1.bits.cmax = 0x40;
+	 * di_dev->dipara1.bits.maxrat = 0x2
+	 */
+	di_dev->dipara1.dwval = 0x000240ac;
+#elif defined DI_V22
+	/* di_dev->output_path.bits.output_path = 0; */
+	di_dev->outpath.dwval = 0x00000000;
+
+	/* default setting of di */
+	/* di_dev->ctrl.bits.dma_rand_access_en = 1 (iommu_enable) */
+	di_dev->ctrl.dwval = 0x00000000;
+
+	/* int di_mode = 1;
+	 * int motion_detc_en = 1;
+	 * int diag_intp_en = 1;
+	 * int flag_update_mode = 0;
+	 * di_dev->mode.bits.di_mode_luma = di_mode;
+	 * di_dev->mode.bits.di_mode_chroma = di_mode;
+	 * di_dev->mode.bits.motion_detc_en = motion_detc_en;
+	 * di_dev->mode.bits.diag_intp_en = diag_intp_en;
+	 * di_dev->mode.bits.flag_update_mode = flag_update_mode;
+	 * di_dev->mode.bits.in_field_mode =
+	 *         (di_mode == DI_MODE_MOTION)? 0: 1;
+	 */
+	di_dev->mode.dwval = 0x00010031;
+
+	/* di_dev->mdpara0.bits.minlumath = 0x4;
+	 * di_dev->mdpara0.bits.max_luma_th= 0x18;
+	 * di_dev->mdpara0.bits.avglumashifter = 0x6;
+	 * di_dev->mdpara0.bits.th_shift = 0x0;
+	 */
+	/*di_dev->mdpara0.dwval = 0x01060c04;*/
+	di_dev->mdpara0.dwval = 0x00061804;
+
+	/* di_dev->f_prot_th = 0x80
+	 * di_dev->f_prot_factor = 0x4
+	 * di_dev->edge_th = 0x20
+	 * di_dev->mov_fac_edge = 0x03
+	 * di_dev->mov_fac_nonedge = 0x01
+	 */
+	di_dev->mdpara1.dwval = 0x13200480;
+
+	/* di_dev->luma_spatial_th = 0x5
+	 * di_dev->chroma_spatical_th = 0x80
+	 * di_dev->chroma_diff_th = 0x5
+	 * di_dev->erosion_bob_th = 0x7
+	 * di_dev->pix_static_th = 0x3
+	 */
+	di_dev->mdpara2.dwval = 0x37058005;
+
+	/* di_dev->dipara.bits.angle_limit = 0x14;
+	 * di_dev->dipara.bits.angle_const_th = 0x5;
+	 * di_dev->dipara.bits.luma_cur_fac_mod = 0x1;
+	 * di_dev->dipara.bits.chroma_cur_fac_mod = 0x1;
+	 */
+	di_dev->dipara0.dwval = 0x00110514;
+
+	/* di_dev->mdchpara.bits.blend_mode = 0x0;
+	 * di_dev->mdchpara.bits.font_pro_en = 0x0;
+	 * di_dev->mdchpara.bits.font_pro_th = 0x30;
+	 * di_dev->mdchpara.bits.font_pro_fac = 0x4;
+	 */
+	di_dev->mdchpara.dwval = 0x04300000;
+#endif
+
+#if defined SUPPORT_DNS
+	dns_dev->dns_ctl.dwval = 0x00000001; /* Enable Denoising */
+	dns_dev->dns_lft_para0.dwval = 0x00ff9601;
+	dns_dev->dns_lft_para1.dwval = 0xb24e3c80;
+	dns_dev->dns_lft_para2.dwval = 0x77153a00;
+	dns_dev->dns_lft_para3.dwval = 0x000000ff;
+	dns_dev->iqa_blkdt_para0.dwval = 0x0000c810;
+
+#endif
+
+	g_di_mode.di_mode = DI_MODE_MOTION;
+	g_di_mode.update_mode = DI_UPDMODE_FIELD;
+
+	return 0;
+}
+
+#define di_writel(val, addr) writel(val, (void __iomem *)(addr))
+#define di_readl(addr) readl((void __iomem *)(addr))
+
+void DI_SET_BITS(unsigned int *reg_addr, unsigned int bits_val,
+			unsigned int shift, unsigned int width)
+{
+	unsigned int reg_val;
+
+	reg_val = di_readl(reg_addr);
+	reg_val = SET_BITS(shift, width, reg_val, bits_val);
+	di_writel(reg_val, reg_addr);
+}
+
+/**
+ * function: di_reset(void)
+ * description: stop di module
+ * parameters:
+ * return   :
+ */
+s32 di_reset(void)
+{
+	unsigned int reset = 0x1;
+
+	di_dev->ctrl.bits.reset = reset;
+	/* DI_SET_BITS(&di_dev->ctrl.dwval, reset, 0, 1); */
+	while (reset < 20)
+		reset++;
+	reset = 0;
+	di_dev->ctrl.bits.reset = reset;
+	/* DI_SET_BITS(&di_dev->ctrl.dwval, reset, 0, 1); */
+	return 0;
+}
+
+/**
+ * function: di_start(void)
+ * description: start a de-interlace function
+ * parameters:
+ * return   :
+ */
+s32 di_start(void)
+{
+	di_dev->ctrl.bits.start = 0x1;
+
+	return 0;
+}
+
+/**
+ * function: di_irq_enable(unsigned int enable)
+ * description: enable/disable di irq
+ * parameters: enable <0-disable; 1-enable>
+ * return   :
+ */
+s32 di_irq_enable(unsigned int enable)
+{
+	di_dev->intr.bits.int_en = (enable & 0x1);
+
+	return 0;
+}
+
+/**
+ * function: di_get_status(void)
+ * description: get status of di module
+ * parameters:
+ * return  :  <0-Writeback finish; 1-Writeback no start; 2-Writeback-ing;
+ *            (-1)-Undefined
+ */
+s32 di_get_status(void)
+{
+	int ret;
+	unsigned int busy;
+	unsigned int finish;
+
+	finish = di_dev->status.bits.finish_sts;
+	busy = di_dev->status.bits.busy;
+
+	if (busy)
+		ret = 2;
+	else if (finish == 0 && busy == 0)
+		ret = 1;
+	else if (finish)
+		ret = 0;
+	else
+		ret = -1;
+
+	return ret;
+}
+
+/**
+ * function: di_irq_clear()
+ * description: clear irq status
+ * parameters:
+ * return   :
+ */
+s32 di_irq_clear(void)
+{
+	di_dev->status.bits.finish_sts = 0x1;
+
+	return 0;
+}
+
+void DI_SET_FORMAT(unsigned char fmt)
+{
+	di_dev->fmt.bits.fmt = fmt;
+}
+
+void DI_SET_SIZE(unsigned int width, unsigned int height)
+{
+	di_dev->size.dwval = ((height - 1) & 0x7ff) << 16 |
+			     ((width - 1) & 0x7ff);
+#if defined SUPPORT_DNS
+	dns_dev->dns_size.dwval = ((height - 1) & 0x7ff) << 16 |
+			     ((width - 1) & 0x7ff);
+#endif
+
+}
+
+void DI_CALC_INADDR(struct __di_buf_addr_t *pre_addr,
+		    struct __di_buf_addr_t *cur_addr,
+		    struct __di_buf_addr_t *nxt_addr,
+		    struct __di_buf_size_t *size, unsigned int field,
+		    unsigned char fmt, unsigned int top_field_first,
+		    unsigned long long addr[4][3], unsigned int fieldpitch[3])
+{
+	unsigned int pitch[3];
+
+	pitch[0] = size->fb_width;
+
+	if (fmt == DI_FMT_PLANAR420 || fmt == DI_FMT_PLANAR422) {
+		pitch[1] = ((size->fb_width + 1) >> 1);
+		pitch[2] = pitch[1];
+	} else {
+		pitch[1] = (((size->fb_width + 1) >> 1) << 1);
+		pitch[2] = 0;
+	}
+
+	fieldpitch[0] = pitch[0] << 1;
+	fieldpitch[1] = pitch[1] << 1;
+	fieldpitch[2] = pitch[2] << 1;
+
+	if (top_field_first == 1) {
+		if (field == 0) {
+			addr[0][0] = pre_addr->ch0_addr;
+			addr[0][1] = pre_addr->ch1_addr;
+			addr[0][2] = pre_addr->ch2_addr;
+			addr[1][0] = pre_addr->ch0_addr + pitch[0];
+			addr[1][1] = pre_addr->ch1_addr + pitch[1];
+			addr[1][2] = pre_addr->ch2_addr + pitch[2];
+			addr[2][0] = cur_addr->ch0_addr;
+			addr[2][1] = cur_addr->ch1_addr;
+			addr[2][2] = cur_addr->ch2_addr;
+			addr[3][0] = cur_addr->ch0_addr + pitch[0];
+			addr[3][1] = cur_addr->ch1_addr + pitch[1];
+			addr[3][2] = cur_addr->ch2_addr + pitch[2];
+		} else {
+			addr[0][0] = pre_addr->ch0_addr + pitch[0];
+			addr[0][1] = pre_addr->ch1_addr + pitch[1];
+			addr[0][2] = pre_addr->ch2_addr + pitch[2];
+			addr[1][0] = cur_addr->ch0_addr;
+			addr[1][1] = cur_addr->ch1_addr;
+			addr[1][2] = cur_addr->ch2_addr;
+			addr[2][0] = cur_addr->ch0_addr + pitch[0];
+			addr[2][1] = cur_addr->ch1_addr + pitch[1];
+			addr[2][2] = cur_addr->ch2_addr + pitch[2];
+			addr[3][0] = nxt_addr->ch0_addr;
+			addr[3][1] = nxt_addr->ch1_addr;
+			addr[3][2] = nxt_addr->ch2_addr;
+		}
+	} else {
+		if (field == 0) {
+			addr[0][0] = pre_addr->ch0_addr;
+			addr[0][1] = pre_addr->ch1_addr;
+			addr[0][2] = pre_addr->ch2_addr;
+			addr[1][0] = cur_addr->ch0_addr + pitch[0];
+			addr[1][1] = cur_addr->ch1_addr + pitch[1];
+			addr[1][2] = cur_addr->ch2_addr + pitch[2];
+			addr[2][0] = cur_addr->ch0_addr;
+			addr[2][1] = cur_addr->ch1_addr;
+			addr[2][2] = cur_addr->ch2_addr;
+			addr[3][0] = nxt_addr->ch0_addr + pitch[0];
+			addr[3][1] = nxt_addr->ch1_addr + pitch[1];
+			addr[3][2] = nxt_addr->ch2_addr + pitch[2];
+		} else {
+			addr[0][0] = pre_addr->ch0_addr + pitch[0];
+			addr[0][1] = pre_addr->ch1_addr + pitch[1];
+			addr[0][2] = pre_addr->ch2_addr + pitch[2];
+			addr[1][0] = pre_addr->ch0_addr;
+			addr[1][1] = pre_addr->ch1_addr;
+			addr[1][2] = pre_addr->ch2_addr;
+			addr[2][0] = cur_addr->ch0_addr + pitch[0];
+			addr[2][1] = cur_addr->ch1_addr + pitch[1];
+			addr[2][2] = cur_addr->ch2_addr + pitch[2];
+			addr[3][0] = cur_addr->ch0_addr;
+			addr[3][1] = cur_addr->ch1_addr;
+			addr[3][2] = cur_addr->ch2_addr;
+		}
+	}
+}
+
+void DI_SET_INPUT(unsigned int pitch[3], unsigned long long addr[4][3])
+{
+	di_dev->inpicth0.dwval = pitch[0] & 0xffff;
+	di_dev->inpicth1.dwval = pitch[1] & 0xffff;
+	di_dev->inpicth2.dwval = pitch[2] & 0xffff;
+
+	di_dev->in0add0.dwval = (unsigned int)(addr[0][0] & 0xffffffffLL);
+	di_dev->in0add1.dwval = (unsigned int)(addr[0][1] & 0xffffffffLL);
+	di_dev->in0add2.dwval = (unsigned int)(addr[0][2] & 0xffffffffLL);
+	di_dev->in0addhb.dwval =
+		((unsigned int)((addr[0][0] & 0xff00000000LL)>>32) |
+		 (unsigned int)((addr[0][1] & 0xff00000000LL)>>24) |
+		 (unsigned int)((addr[0][2] & 0xff00000000LL)>>16));
+
+	di_dev->in1add0.dwval = (unsigned int)(addr[1][0] & 0xffffffffLL);
+	di_dev->in1add1.dwval = (unsigned int)(addr[1][1] & 0xffffffffLL);
+	di_dev->in1add2.dwval = (unsigned int)(addr[1][2] & 0xffffffffLL);
+	di_dev->in1addhb.dwval =
+		((unsigned int)((addr[1][0] & 0xff00000000LL)>>32) |
+		 (unsigned int)((addr[1][1] & 0xff00000000LL)>>24) |
+		 (unsigned int)((addr[1][2] & 0xff00000000LL)>>16));
+
+	di_dev->in2add0.dwval = (unsigned int)(addr[2][0] & 0xffffffffLL);
+	di_dev->in2add1.dwval = (unsigned int)(addr[2][1] & 0xffffffffLL);
+	di_dev->in2add2.dwval = (unsigned int)(addr[2][2] & 0xffffffffLL);
+	di_dev->in2addhb.dwval =
+		((unsigned int)((addr[2][0] & 0xff00000000LL)>>32) |
+		 (unsigned int)((addr[2][1] & 0xff00000000LL)>>24) |
+		 (unsigned int)((addr[2][2] & 0xff00000000LL)>>16));
+
+	di_dev->in3add0.dwval = (unsigned int)(addr[3][0] & 0xffffffffLL);
+	di_dev->in3add1.dwval = (unsigned int)(addr[3][1] & 0xffffffffLL);
+	di_dev->in3add2.dwval = (unsigned int)(addr[3][2] & 0xffffffffLL);
+	di_dev->in3addhb.dwval =
+		((unsigned int)((addr[3][0] & 0xff00000000LL)>>32) |
+		 (unsigned int)((addr[3][1] & 0xff00000000LL)>>24) |
+		 (unsigned int)((addr[3][2] & 0xff00000000LL)>>16));
+
+}
+
+void DI_SET_OUTPUT(struct __di_buf_size_t *size, unsigned char fmt,
+			unsigned long long addr[3])
+{
+	unsigned int pitch[3];
+
+	pitch[0] = size->fb_width;
+
+	if (fmt == DI_FMT_PLANAR420 || fmt == DI_FMT_PLANAR422) {
+		pitch[1] = ((size->fb_width + 1) >> 1);
+		pitch[2] = pitch[1];
+	} else {
+		pitch[1] = (((size->fb_width + 1) >> 1) << 1);
+		pitch[2] = 0;
+	}
+
+	di_dev->outpicth0.dwval = pitch[0] & 0xffff;
+	di_dev->outpicth1.dwval = pitch[1] & 0xffff;
+	di_dev->outpicth2.dwval = pitch[2] & 0xffff;
+
+	di_dev->outadd0.dwval = (unsigned int)(addr[0] & 0xffffffffLL);
+	di_dev->outadd1.dwval = (unsigned int)(addr[1] & 0xffffffffLL);
+	di_dev->outadd2.dwval = (unsigned int)(addr[2] & 0xffffffffLL);
+	di_dev->outaddhb.dwval =
+		((unsigned int)((addr[0] & 0xff00000000LL)>>32) |
+		 (unsigned int)((addr[1] & 0xff00000000LL)>>24) |
+		 (unsigned int)((addr[2] & 0xff00000000LL)>>16));
+
+}
+
+void DI_SET_FLAG(unsigned long long in_flag_add,
+		 unsigned long long out_flag_add, unsigned int pitch)
+{
+	di_dev->flagpitch.dwval = pitch & 0xffff;
+
+	di_dev->inflagadd.dwval = (unsigned int)(in_flag_add & 0xffffffffLL);
+	di_dev->outflagadd.dwval = (unsigned int)(out_flag_add & 0xffffffffLL);
+	di_dev->flagaddhb.dwval =
+		((unsigned int)((in_flag_add & 0xff00000000LL)>>32) |
+		 (unsigned int)((out_flag_add & 0xff00000000LL)>>24));
+
+}
+
+void DI_SET_CURFAC(unsigned int curfac)
+{
+	di_dev->dipara0.bits.luma_cur_fac_mod = curfac;
+	di_dev->dipara0.bits.chroma_cur_fac_mod = curfac;
+}
+
+void DI_SET_POLAR(unsigned int polar)
+{
+	di_dev->polar.dwval = polar & 0x1;
+}
+
+void DI_SET_FLAG_AUTO_UPD_MODE(unsigned int mode)
+{
+#if defined DI_V23
+	di_dev->mode.bits.flag_auto_update_mode = mode;
+#endif
+}
+
+int DI_SW_PARA_TO_REG(unsigned char format)
+{
+	/* deinterlace input pixel format */
+	if (format <= DI_FORMAT_NV21)
+		return DI_FMT_UVCOMB420;
+	else if (format == DI_FORMAT_YV12)
+		return DI_FMT_PLANAR420;
+	else if (format == DI_FORMAT_YUV422_SP_UVUV ||
+		   format == DI_FORMAT_YUV422_SP_VUVU)
+		return DI_FMT_UVCOMB422;
+	else if (format == DI_FORMAT_YUV422P)
+		return DI_FMT_PLANAR422;
+	/* DE_INF("not supported de-interlace input pixel format :%d
+	 *		in di_sw_para_to_reg\n",format);
+	 */
+	return -1;
+}
+
+/**
+ * function: di_set_para(__di_para_t *para)
+ * description: set parameters to ready a de-interlace function
+ * parameters: para <parameters which set from ioctrl>
+ *             in_flag_add/out_flag_add <flag address malloc in driver>
+ *             polar <0 - select even line for source line;
+ *                    1 - select odd line for source line>
+ *             di_mode <di mode set by app>
+ * return  :   <0 - set OK; -1 - para NULL>
+ */
+s32 di_set_para(struct __di_para_t2 *para, void *in_flag_add,
+		void *out_flag_add, u32 field)
+{
+	int fmt;
+	unsigned int width, height;
+	unsigned long long inaddr[4][3], outaddr[3];
+	unsigned int inpitch[3];
+	/* FIXME: flagpitch can be changed according to source */
+	unsigned int flagpitch = 0x200;
+	unsigned int curfac = 0;
+	unsigned int faum;
+
+	struct __di_buf_addr_t pre_addr;
+	struct __di_buf_addr_t cur_addr;
+	struct __di_buf_addr_t nxt_addr;
+	/*struct __di_buf_addr_t out_addr;*/
+	/*struct __di_buf_addr_t flg_addr;*/
+	struct __di_buf_size_t in_size;
+	struct __di_buf_size_t out_size;
+
+	if (para == NULL) {
+		/* DE_WRN("input parameter can't be null!\n"); */
+		return -1;
+	}
+
+	/* FORMAT and SIZE*/
+	fmt = DI_SW_PARA_TO_REG(para->input_fb.format);
+
+	if (fmt < 0) {
+		/* DE_WRN("para->input_fb.format=%d isnot supported!\n",
+		 * para->input_fb.format);
+		 */
+		return -1;
+	}
+
+	width = para->source_regn.width;
+	height = para->source_regn.height;
+	DI_SET_FORMAT(fmt);
+	DI_SET_SIZE(width, height);
+
+	/* INPUT FRAMEBUFFER ADDRESS and PITCH */
+	pre_addr.ch0_addr = para->pre_fb.addr[0];
+	pre_addr.ch1_addr = para->pre_fb.addr[1];
+	pre_addr.ch2_addr = para->pre_fb.addr[2];
+
+	cur_addr.ch0_addr = para->input_fb.addr[0];
+	cur_addr.ch1_addr = para->input_fb.addr[1];
+	cur_addr.ch2_addr = para->input_fb.addr[2];
+
+	nxt_addr.ch0_addr = para->next_fb.addr[0];
+	nxt_addr.ch1_addr = para->next_fb.addr[1];
+	nxt_addr.ch2_addr = para->next_fb.addr[2];
+
+	/* in_size.width = para->source_regn.width; */
+	/* in_size.height = para->source_regn.height; */
+	in_size.fb_width = para->input_fb.size.width;
+	in_size.fb_height = para->input_fb.size.height;
+
+	DI_CALC_INADDR(&pre_addr, &cur_addr, &nxt_addr, &in_size, field, fmt,
+			para->top_field_first, inaddr, inpitch);
+	DI_SET_INPUT(inpitch, inaddr);
+
+	/* OUTPUT FRAMEBUFFER ADDRESS and PITCH */
+	outaddr[0] = para->output_fb.addr[0];
+	outaddr[1] = para->output_fb.addr[1];
+	outaddr[2] = para->output_fb.addr[2];
+
+	/* out_size.width = para->out_regn.width; */
+	/* out_size.height = para->out_regn.height; */
+	out_size.fb_width = para->output_fb.size.width;
+	out_size.fb_height = para->output_fb.size.height;
+
+	DI_SET_OUTPUT(&out_size, fmt, outaddr);
+
+	/* MOTION INFORMATION ADDRESS and PITCH */
+	DI_SET_FLAG((unsigned long)in_flag_add,
+			(unsigned long)out_flag_add, flagpitch);
+
+	/* DI PARAMERTES */
+#if defined DI_V23
+	/* DI_V2.3 */
+	curfac = (para->top_field_first == 0) ? 5 : 4;
+#elif defined DI_V22
+	curfac = (g_di_mode.di_mode != DI_MODE_WEAVE) ? 1 :
+		 (para->top_field_first == 0) ? 5 : 4;
+#endif
+
+	DI_SET_CURFAC(curfac);
+	DI_SET_POLAR(field);
+
+	faum = (para->top_field_first == 0) ? 1 : 0;
+	DI_SET_FLAG_AUTO_UPD_MODE(faum);
+
+	return 0;
+}
+
+/**
+ * function: di_set_mode(struct __di_mode_t *di_mode)
+ * description: set DI mode
+ * parameters: di_mode <update_mode and di_mode set by app>
+ * return  :
+ */
+void di_set_mode(struct __di_mode_t *di_mode)
+{
+	unsigned char flag_update_mode;
+	unsigned char motion_detc_en;
+	unsigned char diag_intp_en;
+	unsigned char mode;
+	unsigned char in_field_mode;
+
+	g_di_mode.di_mode = di_mode->di_mode;
+	g_di_mode.update_mode = di_mode->update_mode;
+
+	flag_update_mode = di_mode->update_mode & 0x1;
+	motion_detc_en = (di_mode->di_mode < DI_MODE_MOTION) ? 0 : 1;
+	diag_intp_en = (di_mode->di_mode < DI_MODE_INTP) ? 0 : 1;
+	mode = (di_mode->di_mode < DI_MODE_INTP) ? 0 : 1;
+	in_field_mode = (di_mode->di_mode == DI_MODE_MOTION) ? 0 : 1;
+
+	di_dev->mode.dwval = mode |
+			    (motion_detc_en << 4) |
+			    (diag_intp_en << 5) |
+			    (flag_update_mode << 8) |
+			    (mode << 16) |
+			    (in_field_mode << 31);
+
+}
+
+s32 di_internal_clk_enable(void)
+{
+	return 0;
+}
+
+s32 di_internal_clk_disable(void)
+{
+	return 0;
+}
diff --git a/drivers/char/sunxi-di/drv_div2x/sunxi-di.c b/drivers/char/sunxi-di/drv_div2x/sunxi-di.c
new file mode 100644
index 000000000..892826756
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/sunxi-di.c
@@ -0,0 +1,1644 @@
+/*
+ * sunxi-di.c DE-Interlace driver
+ *
+ * Copyright (C) 2013-2015 allwinner.
+ *	Ming Li<liming@allwinnertech.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/major.h>
+#include <linux/poll.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <asm/irq.h>
+#include <linux/dma-buf.h>
+#include <linux/idr.h>
+#include "sunxi-di.h"
+
+#define DI_MAX_USERS 10
+
+static di_struct *di_data;
+static s32 sunxi_di_major = -1;
+static struct class *di_dev_class;
+static struct workqueue_struct *di_wq;
+static struct device *di_device;
+static struct clk *di_clk;
+static struct clk *di_clk_source;
+static struct device *iommu_dev;
+
+#ifdef DI_MULPLEX_SUPPORT
+struct sunxi_di {
+	int			id; /* chan id */
+	struct rb_node		node;
+	struct list_head	list;
+	bool			requested; /* indicate if have request */
+	bool			busy; /* at busy state when di proccessing */
+	unsigned long		start_time; /* the time when starting di */
+	di_struct	        data;
+	struct __di_para_t2	info;
+
+};
+
+struct sunxi_didev {
+	struct device		*dev;
+	spinlock_t		slock;
+	struct mutex		mlock;
+	struct mutex		dilock;
+	struct list_head	di_list;    /* di chan list */
+	unsigned int		count;	    /* di channel counter */
+	struct sunxi_di		*cur_di;    /* curent di channel processing */
+	bool			busy;
+	struct idr		idr;
+	struct rb_node		node;
+	struct rb_root		handles;
+};
+
+static struct sunxi_didev *gsunxi_dev;
+#endif
+
+struct dmabuf_item {
+	struct list_head list;
+	int fd;
+	struct dma_buf *buf;
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt;
+	dma_addr_t dma_addr;
+	unsigned long long id;
+};
+
+static u32 debug_mask;
+
+static ssize_t di_timeout_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+
+	error = kstrtoul(buf, 10, &data);
+
+	if (error) {
+		pr_err("%s kstrtoul error\n", __func__);
+		goto exit;
+	}
+
+	dprintk(DEBUG_DATA_INFO, "%s data = %ld\n", __func__, data);
+
+	if (data)
+		di_data->time_value = data;
+	else
+		di_data->time_value = DI_TIMEOUT;
+
+	return count;
+
+exit:
+	return error;
+}
+
+static DEVICE_ATTR(timeout, 0664,
+		NULL, di_timeout_store);
+
+static struct attribute *di_attributes[] = {
+	&dev_attr_timeout.attr,
+	NULL
+};
+
+static struct attribute_group di_attribute_group = {
+	.attrs = di_attributes
+};
+
+#ifdef DI_RESERVED_MEM
+/* alloc based on 4K byte */
+#define MY_BYTE_ALIGN(x) (((x + (4*1024-1)) >> 12) << 12)
+void *sunxi_di_alloc(u32 num_bytes, unsigned long *phys_addr)
+{
+	u32 actual_bytes;
+	void *address = NULL;
+
+	if (num_bytes != 0) {
+		actual_bytes = MY_BYTE_ALIGN(num_bytes);
+
+		address = dma_alloc_coherent(iommu_dev, actual_bytes,
+			    (dma_addr_t *)phys_addr, GFP_KERNEL);
+		if (address) {
+			dprintk(DEBUG_DATA_INFO,
+			"dma_alloc_coherent ok, address=0x%p, size=0x%x\n",
+			(void *)(*(unsigned long *)phys_addr), num_bytes);
+			return address;
+		} else {
+			pr_err("dma_alloc_coherent fail, size=0x%x\n",
+				num_bytes);
+			return NULL;
+		}
+	} else {
+		pr_err("%s size is zero\n", __func__);
+	}
+
+	return NULL;
+}
+
+void sunxi_di_free(void *virt_addr, unsigned long phys_addr, u32 num_bytes)
+{
+	u32 actual_bytes;
+
+	actual_bytes = MY_BYTE_ALIGN(num_bytes);
+	if (phys_addr && virt_addr)
+		dma_free_coherent(iommu_dev, actual_bytes,
+				virt_addr, (dma_addr_t)phys_addr);
+
+	return;
+}
+#endif
+
+static int di_mem_request(struct __di_mem_t *di_mem)
+{
+#ifndef DI_RESERVED_MEM
+	unsigned map_size = 0;
+	struct page *page;
+
+	map_size = PAGE_ALIGN(di_mem->size);
+
+	page = alloc_pages(GFP_KERNEL, get_order(map_size));
+	if (page != NULL) {
+		di_mem->v_addr = page_address(page);
+		if (di_mem->v_addr == NULL)	{
+			free_pages((unsigned long)(page), get_order(map_size));
+			pr_err("page_address fail!\n");
+			return -ENOMEM;
+		}
+		di_mem->p_addr = virt_to_phys(di_mem->v_addr);
+		memset(di_mem->v_addr, 0, di_mem->size);
+
+		dprintk(DEBUG_DATA_INFO, "pa=0x%p va=0x%p size:0x%x\n",
+			(void *)di_mem->p_addr, di_mem->v_addr, di_mem->size);
+		return 0;
+	}	else {
+		pr_err("alloc_pages fail!\n");
+		return -ENOMEM;
+	}
+#else
+	di_mem->v_addr = sunxi_di_alloc(di_mem->size,
+			(unsigned long *)&di_mem->p_addr);
+	if (di_mem->v_addr == NULL) {
+		pr_err("%s: failed!\n", __func__);
+		return -ENOMEM;
+	}
+	memset(di_mem->v_addr, 0, di_mem->size);
+#endif
+	return 0;
+}
+
+static int di_mem_release(struct __di_mem_t *di_mem)
+{
+#ifndef DI_RESERVED_MEM
+	unsigned map_size = PAGE_ALIGN(di_mem->size);
+	unsigned page_size = map_size;
+
+	if (di_mem->v_addr == NULL) {
+		pr_err("%s: failed!\n", __func__);
+		return -1;
+	}
+
+	free_pages((unsigned long)(di_mem->v_addr), get_order(page_size));
+	di_mem->v_addr = NULL;
+#else
+	if (di_mem->v_addr == NULL) {
+		pr_err("%s: failed!\n", __func__);
+		return -1;
+	}
+	sunxi_di_free(di_mem->v_addr, di_mem->p_addr, di_mem->size);
+	di_mem->v_addr = NULL;
+#endif
+	return 0;
+}
+
+static void di_complete_check_set(s32 data)
+{
+	atomic_set(&di_data->di_complete, data);
+
+	return;
+}
+
+static s32 di_complete_check_get(void)
+{
+	s32 data_temp = 0;
+
+	data_temp = atomic_read(&di_data->di_complete);
+
+	return data_temp;
+}
+
+#ifdef DI_MULPLEX_SUPPORT
+static struct sunxi_di *di_get_by_id(int id)
+{
+	 struct sunxi_di *di;
+
+	 mutex_lock(&gsunxi_dev->mlock);
+	 di = idr_find(&gsunxi_dev->idr, id);
+	 mutex_unlock(&gsunxi_dev->mlock);
+
+	 return di ? di : ERR_PTR(-EINVAL);
+}
+#endif
+
+int di_wait_cmd_finish(void)
+{
+	long timeout;
+	u32 flag_size = 0;
+#ifdef DI_MULPLEX_SUPPORT
+	unsigned long flags;
+#endif
+
+	timeout = wait_event_interruptible_timeout(di_data->wait,
+				     (di_complete_check_get() != 1),
+				     msecs_to_jiffies(di_data->time_value));
+	if (timeout <= 0) {
+		di_complete_check_set(DI_MODULE_TIMEOUT);
+		wake_up_interruptible(&di_data->wait);
+		flag_size = (FLAG_WIDTH*FLAG_HIGH)/4;
+		di_irq_enable(0);
+		di_irq_clear();
+		di_reset();
+#ifdef DI_MULPLEX_SUPPORT
+		spin_lock_irqsave(&gsunxi_dev->slock, flags);
+		if (gsunxi_dev->cur_di) {
+			if (gsunxi_dev->cur_di->data.mem_in_params.v_addr != NULL)
+				memset(gsunxi_dev->cur_di->data.mem_in_params.v_addr,
+						0, flag_size);
+			if (gsunxi_dev->cur_di->data.mem_out_params.v_addr != NULL)
+				memset(gsunxi_dev->cur_di->data.mem_out_params.v_addr,
+						0, flag_size);
+			gsunxi_dev->cur_di->busy = false;
+			gsunxi_dev->cur_di = NULL;
+			gsunxi_dev->busy = false;
+		}
+		spin_unlock_irqrestore(&gsunxi_dev->slock, flags);
+#else
+		if (di_data->mem_in_params.v_addr != NULL)
+			memset(di_data->mem_in_params.v_addr, 0, flag_size);
+		if (di_data->mem_out_params.v_addr != NULL)
+			memset(di_data->mem_out_params.v_addr, 0, flag_size);
+#endif
+		pr_err("di_timer_handle: timeout\n");
+		return -1;
+	}
+	return 0;
+}
+
+static irqreturn_t di_irq_service(int irqno, void *dev_id)
+{
+	s32 ret;
+#ifdef DI_MULPLEX_SUPPORT
+	unsigned long flags;
+#endif
+	dprintk(DEBUG_INT, "%s: enter\n", __func__);
+	di_irq_enable(0);
+	ret = di_get_status();
+	if (ret == 0) {
+		di_complete_check_set(0);
+		wake_up_interruptible(&di_data->wait);
+	} else {
+		di_complete_check_set(-ret);
+		wake_up_interruptible(&di_data->wait);
+	}
+
+#ifdef DI_MULPLEX_SUPPORT
+	spin_lock_irqsave(&gsunxi_dev->slock, flags);
+	if (gsunxi_dev->cur_di) {
+		gsunxi_dev->cur_di->busy = false;
+		gsunxi_dev->cur_di = NULL;
+		gsunxi_dev->busy = false;
+	}
+	spin_unlock_irqrestore(&gsunxi_dev->slock, flags);
+#endif
+	di_irq_clear();
+	di_reset();
+	return IRQ_HANDLED;
+}
+
+static s32 di_clk_cfg(struct device_node *node)
+{
+	unsigned long rate = 0;
+
+	di_clk = of_clk_get(node, 0);
+	if (!di_clk || IS_ERR(di_clk)) {
+		pr_err("try to get di clock failed!\n");
+		return -1;
+	}
+
+	di_clk_source = of_clk_get(node, 1);
+	if (!di_clk_source || IS_ERR(di_clk_source)) {
+		pr_err("try to get di_clk_source clock failed!\n");
+		return -1;
+	}
+
+	rate = clk_get_rate(di_clk_source);
+	dprintk(DEBUG_INIT, "%s: get di_clk_source rate %luHZ\n", __func__,
+		rate);
+
+	if (clk_set_parent(di_clk, di_clk_source)) {
+		pr_err(
+		"%s: set di_clk parent to di_clk_source failed!\n", __func__);
+		return -1;
+	}
+
+#if defined CONFIG_ARCH_SUN9IW1P1
+#else
+	rate = rate/2;
+	/* rate = rate / 4;*/
+	if (clk_set_rate(di_clk, rate)) {
+		pr_err("set di clock freq to PLL_PERIPH0/2 failed!\n");
+		return -1;
+	}
+	rate = clk_get_rate(di_clk);
+	dprintk(DEBUG_INIT,
+			"%s: get di_clk rate %dHZ\n", __func__, (__u32)rate);
+#endif
+	return 0;
+}
+
+static void di_clk_uncfg(void)
+{
+	if (di_clk == NULL || IS_ERR(di_clk)) {
+		pr_err("di_clk handle is invalid, just return!\n");
+		return;
+	} else {
+		clk_disable_unprepare(di_clk);
+		clk_put(di_clk);
+		di_clk = NULL;
+	}
+	if (NULL == di_clk_source || IS_ERR(di_clk_source)) {
+		pr_err("di_clk_source handle is invalid, just return!\n");
+		return;
+	} else {
+		clk_put(di_clk_source);
+		di_clk_source = NULL;
+	}
+	return;
+}
+
+static s32 di_clk_enable(void)
+{
+	if (di_clk == NULL || IS_ERR(di_clk)) {
+		pr_err("di_clk handle is invalid, just return!\n");
+		return -1;
+	} else {
+		clk_set_parent(di_clk, di_clk_source);
+		if (clk_prepare_enable(di_clk)) {
+			pr_err("try to enable di_clk failed!\n");
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static void di_clk_disable(void)
+{
+	if (di_clk == NULL || IS_ERR(di_clk)) {
+		pr_err("di_clk handle is invalid, just return!\n");
+		return;
+	} else {
+		clk_disable_unprepare(di_clk);
+	}
+	return;
+}
+
+static s32 sunxi_di_params_init(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct resource *mem_res = NULL;
+	s32 ret = 0;
+
+	ret = di_clk_cfg(node);
+	if (ret) {
+		pr_err("%s: clk cfg failed.\n", __func__);
+		goto clk_cfg_fail;
+	}
+
+	di_data->irq_number = platform_get_irq(pdev, 0);
+	if (di_data->irq_number < 0) {
+		pr_err("%s:get irq number failed!\n",  __func__);
+		return -EINVAL;
+	}
+	if (request_irq(di_data->irq_number, di_irq_service, 0, "DE-Interlace",
+			di_device)) {
+		ret = -EBUSY;
+		pr_err("%s: request irq failed.\n", __func__);
+		goto request_irq_err;
+	}
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (mem_res == NULL) {
+		pr_err("%s: failed to get MEM res\n", __func__);
+		ret = -ENXIO;
+		goto mem_io_err;
+	}
+
+	if (!request_mem_region(mem_res->start, resource_size(mem_res),
+			mem_res->name)) {
+		pr_err("%s: failed to request mem region\n", __func__);
+		ret = -EINVAL;
+		goto mem_io_err;
+	}
+
+	di_data->base_addr = ioremap(mem_res->start, resource_size(mem_res));
+	if (!di_data->base_addr) {
+		pr_err("%s: failed to io remap\n", __func__);
+		ret = -EIO;
+		goto mem_io_err;
+	}
+
+	di_set_reg_base(di_data->base_addr);
+	return 0;
+mem_io_err:
+	free_irq(di_data->irq_number, di_device);
+request_irq_err:
+	di_clk_uncfg();
+clk_cfg_fail:
+	return ret;
+}
+
+static void sunxi_di_params_exit(void)
+{
+	di_clk_uncfg();
+	free_irq(di_data->irq_number, di_device);
+	return;
+}
+
+
+#ifdef CONFIG_PM
+static s32 sunxi_di_suspend(struct device *dev)
+{
+	dprintk(DEBUG_SUSPEND, "enter: sunxi_di_suspend.\n");
+
+	if (atomic_read(&di_data->enable)) {
+		di_irq_enable(0);
+		di_reset();
+		di_internal_clk_disable();
+		di_clk_disable();
+	}
+
+	return 0;
+}
+
+static s32 sunxi_di_resume(struct device *dev)
+{
+	s32 ret = 0;
+	dprintk(DEBUG_SUSPEND, "enter: sunxi_di_resume.\n");
+
+	if (atomic_read(&di_data->enable)) {
+		ret = di_clk_enable();
+		if (ret) {
+			pr_err("%s: enable clk failed.\n", __func__);
+			return ret;
+		}
+		di_internal_clk_enable();
+		di_irq_enable(1);
+		di_set_init();
+	}
+	return 0;
+}
+#endif
+
+static void change_para(struct __di_para_t *di_para,
+				struct __di_para_t2 *di_para2)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		di_para2->input_fb.addr[i] =
+			(unsigned long)di_para->input_fb.addr[i];
+		di_para2->pre_fb.addr[i] =
+			(unsigned long)di_para->pre_fb.addr[i];
+		di_para2->output_fb.addr[i] =
+			(unsigned long)di_para->output_fb.addr[i];
+	}
+	di_para2->input_fb.size.width = di_para->input_fb.size.width;
+	di_para2->input_fb.size.height = di_para->input_fb.size.height;
+	di_para2->input_fb.format = di_para->input_fb.format;
+
+	di_para2->pre_fb.size.width = di_para->pre_fb.size.width;
+	di_para2->pre_fb.size.height = di_para->pre_fb.size.height;
+	di_para2->pre_fb.format = di_para->pre_fb.format;
+
+	di_para2->source_regn.width = di_para->source_regn.width;
+	di_para2->source_regn.height = di_para->source_regn.height;
+
+	di_para2->output_fb.size.width = di_para->output_fb.size.width;
+	di_para2->output_fb.size.height = di_para->output_fb.size.height;
+	di_para2->output_fb.format = di_para->output_fb.format;
+	di_para2->out_regn.width = di_para->out_regn.width;
+	di_para2->out_regn.height =  di_para->out_regn.height;
+
+	di_para2->field = di_para->field;
+	di_para2->top_field_first = di_para->top_field_first;
+}
+
+
+#ifdef USE_DMA_BUF
+static int di_dma_map(int fd, struct dmabuf_item *item)
+{
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt, *sgt_bak;
+	struct scatterlist *sgl, *sgl_bak;
+	s32 sg_count = 0;
+	int ret = -1;
+	int i;
+
+	unsigned long attrs = DMA_ATTR_SKIP_CPU_SYNC;
+
+	if (fd < 0) {
+		pr_err("dma_buf_id(%d) is invalid\n", fd);
+		goto exit;
+	}
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		pr_err("dma_buf_get failed\n");
+		goto exit;
+	}
+
+	attachment = dma_buf_attach(dmabuf, iommu_dev);
+	if (IS_ERR(attachment)) {
+		pr_err("dma_buf_attach failed\n");
+		goto err_buf_put;
+	}
+	sgt = dma_buf_map_attachment(attachment, DMA_FROM_DEVICE);
+	if (IS_ERR_OR_NULL(sgt)) {
+		pr_err("dma_buf_map_attachment failed\n");
+		goto err_buf_detach;
+	}
+
+	/* create a private sgtable base on the given dmabuf */
+	sgt_bak = kmalloc(sizeof(struct sg_table), GFP_KERNEL | __GFP_ZERO);
+	if (sgt_bak == NULL) {
+		pr_err("alloc sgt fail\n");
+		goto err_buf_unmap;
+	}
+	ret = sg_alloc_table(sgt_bak, sgt->nents, GFP_KERNEL);
+	if (ret != 0) {
+		pr_err("alloc sgt fail\n");
+		goto err_kfree;
+	}
+	sgl_bak = sgt_bak->sgl;
+	for_each_sg(sgt->sgl, sgl, sgt->nents, i)  {
+		sg_set_page(sgl_bak, sg_page(sgl), sgl->length, sgl->offset);
+		sgl_bak = sg_next(sgl_bak);
+	}
+
+	sg_count = dma_map_sg_attrs(iommu_dev, sgt_bak->sgl,
+			      sgt_bak->nents, DMA_FROM_DEVICE, attrs);
+
+	if (sg_count != 1) {
+		pr_err("dma_map_sg failed:%d\n", sg_count);
+		goto err_sgt_free;
+	}
+
+	item->fd = fd;
+	item->buf = dmabuf;
+	item->sgt = sgt_bak;
+	item->attachment = attachment;
+	item->dma_addr = sg_dma_address(sgt_bak->sgl);
+	ret = 0;
+
+	goto exit;
+
+err_sgt_free:
+	sg_free_table(sgt_bak);
+err_kfree:
+	kfree(sgt_bak);
+err_buf_unmap:
+	/* unmap attachment sgt, not sgt_bak, cause it's not alloc yet! */
+	dma_buf_unmap_attachment(attachment, sgt, DMA_FROM_DEVICE);
+err_buf_detach:
+	dma_buf_detach(dmabuf, attachment);
+err_buf_put:
+	dma_buf_put(dmabuf);
+exit:
+	return ret;
+}
+
+static void di_dma_unmap(struct dmabuf_item *item)
+{
+	unsigned long attrs = DMA_ATTR_SKIP_CPU_SYNC;
+
+	dma_unmap_sg_attrs(iommu_dev, item->sgt->sgl,
+			      item->sgt->nents, DMA_FROM_DEVICE, attrs);
+	dma_buf_unmap_attachment(item->attachment, item->sgt, DMA_FROM_DEVICE);
+	sg_free_table(item->sgt);
+	kfree(item->sgt);
+	dma_buf_detach(item->buf, item->attachment);
+	dma_buf_put(item->buf);
+}
+
+static struct di_format_attr fmt_attr_tbl[] = {
+	/*
+	      format                    bits
+					   hor_rsample(u,v)
+						  ver_rsample(u,v)
+							uvc
+							   interleave
+							       factor
+								  div
+	 */
+	{ DI_FORMAT_YUV422P,		8,  2, 2, 1, 1, 0, 0, 2, 1},
+	{ DI_FORMAT_YV12,		8,  2, 2, 2, 2, 0, 0, 3, 2},
+	{ DI_FORMAT_YUV422_SP_UVUV,	8,  2, 2, 1, 1, 1, 0, 2, 1},
+	{ DI_FORMAT_YUV422_SP_VUVU,	8,  2, 2, 1, 1, 1, 0, 2, 1},
+	{ DI_FORMAT_NV12,		8,  2, 2, 2, 2, 1, 0, 3, 2},
+	{ DI_FORMAT_NV21,		8,  2, 2, 2, 2, 1, 0, 3, 2},
+	{ DI_FORMAT_MB32_12,		8,  2, 2, 2, 2, 1, 0, 3, 2},
+	{ DI_FORMAT_MB32_21,		8,  2, 2, 2, 2, 1, 0, 3, 2},
+};
+
+s32 di_set_fb_info(struct __di_fb_t2 *di_para, struct dmabuf_item *item)
+{
+	s32 ret = -1;
+	u32 i = 0;
+	u32 len = ARRAY_SIZE(fmt_attr_tbl);
+	u32 y_width, y_height, u_width, u_height;
+	u32 y_pitch, u_pitch;
+	u32 y_size, u_size;
+
+	di_para->addr[0] = item->dma_addr;
+
+	if (di_para->format >= DI_FORMAT_MAX) {
+		pr_err("%s, format 0x%x is out of range\n", __func__,
+			di_para->format);
+		goto exit;
+	}
+
+	for (i = 0; i < len; ++i) {
+
+		if (fmt_attr_tbl[i].format == di_para->format) {
+			y_width = di_para->size.width;
+			y_height = di_para->size.height;
+			u_width = y_width/fmt_attr_tbl[i].hor_rsample_u;
+			u_height = y_height/fmt_attr_tbl[i].ver_rsample_u;
+
+			y_pitch = y_width;
+			u_pitch = u_width * (fmt_attr_tbl[i].uvc + 1);
+
+			y_size = y_pitch * y_height;
+			u_size = u_pitch * u_height;
+			di_para->addr[1] = di_para->addr[0] + y_size;
+			di_para->addr[2] = di_para->addr[0] + y_size + u_size;
+
+			ret = 0;
+			break;
+		}
+	}
+	if (ret != 0)
+		pr_err("%s, format 0x%x is invalid\n", __func__,
+			di_para->format);
+exit:
+	return ret;
+
+}
+#endif
+
+/*
+ * sunxi_di_request - request deinterlace channel
+ * On success, returns di handle.  On failure, returns 0.
+ */
+
+#ifdef DI_MULPLEX_SUPPORT
+unsigned int sunxi_di_request(void)
+{
+	struct sunxi_di *di_para = NULL;
+	unsigned long flags;
+	unsigned int count = 0;
+	struct rb_node **p = &gsunxi_dev->handles.rb_node;
+	struct rb_node *parent = NULL;
+	struct sunxi_di *entry;
+	int id;
+	int ret;
+
+	dprintk(DEBUG_DATA_INFO, "%s: request_enter!!\n", __func__);
+	if (gsunxi_dev->count > DI_MAX_USERS) {
+		pr_warn("%s(), user number have exceed max number %d\n",
+		    __func__, DI_MAX_USERS);
+		return 0;
+	}
+
+	di_para = kzalloc(sizeof(struct sunxi_di), GFP_KERNEL);
+	if (!di_para) {
+		pr_warn("alloc di_para fail\n");
+		return 0;
+	}
+
+	RB_CLEAR_NODE(&di_para->node);
+	di_para->requested = false;
+	di_para->busy = false;
+	di_para->start_time = jiffies;
+
+	id = idr_alloc(&gsunxi_dev->idr, di_para, 1, 0, GFP_KERNEL);
+	if (id < 0) {
+		pr_err("idr alloc failed!\n");
+		return 0;
+	}
+	di_para->id = id;
+
+	mutex_lock(&gsunxi_dev->mlock);
+	while (*p) {
+		parent = *p;
+		entry = rb_entry(parent, struct sunxi_di, node);
+
+		if (di_para < entry)
+			p = &(*p)->rb_left;
+
+		else if (di_para > entry)
+			p = &(*p)->rb_right;
+		else
+			pr_warn("%s: tr already found.\n", __func__);
+	}
+	rb_link_node(&di_para->node, parent, p);
+	rb_insert_color(&di_para->node, &gsunxi_dev->handles);
+	mutex_unlock(&gsunxi_dev->mlock);
+
+	spin_lock_irqsave(&gsunxi_dev->slock, flags);
+	list_add_tail(&di_para->list, &gsunxi_dev->di_list);
+	gsunxi_dev->count++;
+	count = gsunxi_dev->count;
+	spin_unlock_irqrestore(&gsunxi_dev->slock, flags);
+
+	mutex_lock(&gsunxi_dev->mlock);
+	if (1 == count) {
+		atomic_set(&di_data->enable, 1);
+		ret = di_clk_enable();
+		if (ret) {
+			pr_err("%s: enable clk failed.\n", __func__);
+			return ret;
+		}
+		di_internal_clk_enable();
+		di_set_init();
+	}
+
+	di_para->data.flag_size = (FLAG_WIDTH*FLAG_HIGH)/4;
+	di_para->data.mem_in_params.size = di_para->data.flag_size;
+
+	ret = di_mem_request(&(di_para->data.mem_in_params));
+	if (ret < 0) {
+		pr_err("%s: request in_flag mem failed\n", __func__);
+		return -1;
+	} else {
+		di_para->data.in_flag_phy =
+			(void *)di_para->data.mem_in_params.p_addr;
+	}
+
+	di_para->data.mem_out_params.size = di_para->data.flag_size;
+	ret = di_mem_request(&(di_para->data.mem_out_params));
+	if (ret < 0) {
+		pr_err("%s: request out_flag mem failed\n", __func__);
+		di_mem_release(&(di_para->data.mem_in_params));
+		return -1;
+	} else {
+		di_para->data.out_flag_phy =
+			(void *)di_para->data.mem_out_params.p_addr;
+	}
+	mutex_unlock(&gsunxi_dev->mlock);
+
+	dprintk(DEBUG_DATA_INFO, "%s: count = %d\n", __func__, count);
+
+	return id;
+}
+EXPORT_SYMBOL_GPL(sunxi_di_request);
+#endif
+
+void  sunxi_di_setmode(struct __di_mode_t *di_mode)
+{
+#ifdef DI_V2X_SUPPORT
+	di_set_mode(di_mode);
+#endif
+}
+EXPORT_SYMBOL_GPL(sunxi_di_setmode);
+
+#ifdef DI_MULPLEX_SUPPORT
+static int di_process(struct __di_para_t2 *di_para, di_struct *info,
+							struct file *filp)
+#else
+static int di_process(struct __di_para_t2 *di_para, struct file *filp)
+#endif
+{
+	int ret = 0;
+	__u32 field = 0;
+	__u32 count = 0;
+
+#ifdef USE_DMA_BUF
+	struct dmabuf_item *cur_item = NULL;
+	struct dmabuf_item *pre_item = NULL;
+	struct dmabuf_item *next_item = NULL;
+	struct dmabuf_item *out_item = NULL;
+#endif
+	if (di_para->dma_if == 0) {
+#ifdef USE_DMA_BUF
+		cur_item = kmalloc(sizeof(struct dmabuf_item),
+				      GFP_KERNEL | __GFP_ZERO);
+		if (cur_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       sizeof(struct dmabuf_item));
+			goto EXIT;
+		}
+		pre_item = kmalloc(sizeof(struct dmabuf_item),
+				      GFP_KERNEL | __GFP_ZERO);
+		if (pre_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       sizeof(struct dmabuf_item));
+			goto FREE_CUR;
+		}
+		next_item = kmalloc(sizeof(struct dmabuf_item),
+				      GFP_KERNEL | __GFP_ZERO);
+		if (next_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       sizeof(struct dmabuf_item));
+			goto FREE_PRE;
+		}
+		out_item = kmalloc(sizeof(struct dmabuf_item),
+				      GFP_KERNEL | __GFP_ZERO);
+		if (out_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       sizeof(struct dmabuf_item));
+			goto FREE_NEXT;
+		}
+
+		dprintk(DEBUG_DATA_INFO, "%s: input_fb.fd = 0x%x\n", __func__,
+							di_para->input_fb.fd);
+		dprintk(DEBUG_DATA_INFO, "%s: pre_fb.fd = 0x%x\n", __func__,
+							di_para->pre_fb.fd);
+		dprintk(DEBUG_DATA_INFO, "%s: next_fb.fd = 0x%x\n", __func__,
+							di_para->next_fb.fd);
+		dprintk(DEBUG_DATA_INFO, "%s: output_fb.fd = 0x%x\n", __func__,
+					di_para->output_fb.fd);
+
+		ret = di_dma_map(di_para->input_fb.fd, cur_item);
+		if (ret != 0) {
+			pr_err("map cur_item fail!\n");
+			goto FREE_OUT;
+		}
+		ret = di_dma_map(di_para->pre_fb.fd, pre_item);
+		if (ret != 0) {
+			pr_err("map pre_item fail!\n");
+			goto CUR_DMA_UNMAP;
+		}
+		ret = di_dma_map(di_para->next_fb.fd, next_item);
+		if (ret != 0) {
+			pr_err("map next_item fail!\n");
+			goto PRE_DMA_UNMAP;
+		}
+		ret = di_dma_map(di_para->output_fb.fd, out_item);
+		if (ret != 0) {
+			pr_err("map out_item fail!\n");
+			goto NEXT_DMA_UNMAP;
+		}
+
+		di_set_fb_info(&di_para->input_fb, cur_item);
+		di_set_fb_info(&di_para->pre_fb, pre_item);
+		di_set_fb_info(&di_para->next_fb, next_item);
+		di_set_fb_info(&di_para->output_fb, out_item);
+#endif
+	}
+
+	dprintk(DEBUG_DATA_INFO, "%s: input_fb.addr[0] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->input_fb.addr[0]));
+	dprintk(DEBUG_DATA_INFO, "%s: input_fb.addr[1] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->input_fb.addr[1]));
+	dprintk(DEBUG_DATA_INFO, "%s: input_fb.addr[2] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->input_fb.addr[2]));
+	dprintk(DEBUG_DATA_INFO, "%s: input_fb.size.width = %d\n", __func__,
+				di_para->input_fb.size.width);
+	dprintk(DEBUG_DATA_INFO, "%s: input_fb.size.height = %d\n", __func__,
+				di_para->input_fb.size.height);
+	dprintk(DEBUG_DATA_INFO, "%s: input_fb.format = %d\n", __func__,
+				di_para->input_fb.format);
+
+	dprintk(DEBUG_DATA_INFO, "%s: pre_fb.addr[0] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->pre_fb.addr[0]));
+	dprintk(DEBUG_DATA_INFO, "%s: pre_fb.addr[1] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->pre_fb.addr[1]));
+	dprintk(DEBUG_DATA_INFO, "%s: pre_fb.addr[2] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->pre_fb.addr[2]));
+	dprintk(DEBUG_DATA_INFO, "%s: pre_fb.size.width = %d\n", __func__,
+				di_para->pre_fb.size.width);
+	dprintk(DEBUG_DATA_INFO, "%s: pre_fb.size.height = %d\n", __func__,
+				di_para->pre_fb.size.height);
+	dprintk(DEBUG_DATA_INFO, "%s: pre_fb.format = %d\n", __func__,
+				di_para->pre_fb.format);
+
+	dprintk(DEBUG_DATA_INFO, "%s: next_fb.addr[0] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->next_fb.addr[0]));
+	dprintk(DEBUG_DATA_INFO, "%s: next_fb.addr[1] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->next_fb.addr[1]));
+	dprintk(DEBUG_DATA_INFO, "%s: next_fb.addr[2] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->next_fb.addr[2]));
+	dprintk(DEBUG_DATA_INFO, "%s: next_fb.size.width = %d\n", __func__,
+				di_para->next_fb.size.width);
+	dprintk(DEBUG_DATA_INFO, "%s: next_fb.size.height = %d\n", __func__,
+				di_para->next_fb.size.height);
+	dprintk(DEBUG_DATA_INFO, "%s: next_fb.format = %d\n", __func__,
+				di_para->next_fb.format);
+
+	dprintk(DEBUG_DATA_INFO, "%s: source_regn.width = %d\n", __func__,
+				di_para->source_regn.width);
+	dprintk(DEBUG_DATA_INFO, "%s: source_regn.height = %d\n", __func__,
+				di_para->source_regn.height);
+
+	dprintk(DEBUG_DATA_INFO, "%s: output_fb.addr[0] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->output_fb.addr[0]));
+	dprintk(DEBUG_DATA_INFO, "%s: output_fb.addr[1] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->output_fb.addr[1]));
+	dprintk(DEBUG_DATA_INFO, "%s: output_fb.addr[2] = 0x%lx\n", __func__,
+				(unsigned long)(di_para->output_fb.addr[2]));
+	dprintk(DEBUG_DATA_INFO, "%s: output_fb.size.width = %d\n", __func__,
+				di_para->output_fb.size.width);
+	dprintk(DEBUG_DATA_INFO, "%s: output_fb.size.height = %d\n", __func__,
+				di_para->output_fb.size.height);
+	dprintk(DEBUG_DATA_INFO, "%s: output_fb.format = %d\n", __func__,
+				di_para->output_fb.format);
+	dprintk(DEBUG_DATA_INFO, "%s: out_regn.width = %d\n", __func__,
+				di_para->out_regn.width);
+	dprintk(DEBUG_DATA_INFO, "%s: out_regn.height = %d\n", __func__,
+				di_para->out_regn.height);
+	dprintk(DEBUG_DATA_INFO, "%s: field = %d\n", __func__, di_para->field);
+	dprintk(DEBUG_DATA_INFO, "%s: top_field_first = %d\n", __func__,
+				di_para->top_field_first);
+
+	/* when di is in work, wait*/
+	ret = di_complete_check_get();
+	while (ret == 1 && count < 10) {
+		msleep(1);
+		ret = di_complete_check_get();
+		count++;
+	}
+	di_complete_check_set(1);
+	field = di_para->top_field_first ? di_para->field : (1-di_para->field);
+
+	dprintk(DEBUG_DATA_INFO, "%s: field = %d\n", __func__, field);
+#ifdef DI_MULPLEX_SUPPORT
+	dprintk(DEBUG_DATA_INFO, "%s: in_flag_phy = 0x%lx\n", __func__,
+				(unsigned long)(info->in_flag_phy));
+	dprintk(DEBUG_DATA_INFO, "%s: out_flag_phy = 0x%lx\n", __func__,
+				(unsigned long)(info->out_flag_phy));
+#else
+	dprintk(DEBUG_DATA_INFO, "%s: in_flag_phy = 0x%lx\n", __func__,
+				(unsigned long)(di_data->in_flag_phy));
+	dprintk(DEBUG_DATA_INFO, "%s: out_flag_phy = 0x%lx\n", __func__,
+				(unsigned long)(di_data->out_flag_phy));
+#endif
+	/* modify flag buffer update in DI_V2.X */
+#ifdef DI_MULPLEX_SUPPORT
+	ret = di_set_para(di_para, info->in_flag_phy,
+				   info->out_flag_phy, field);
+#else
+	ret = di_set_para(di_para, di_data->in_flag_phy,
+				di_data->out_flag_phy, field);
+#endif
+	if (ret) {
+		pr_err("%s: deinterlace work failed.\n", __func__);
+		return -1;
+	} else {
+		di_irq_enable(1);
+		di_start();
+	}
+
+	ret = di_wait_cmd_finish();
+	if (ret) {
+		pr_err("Deinterlace Failed!\n");
+		return ret;
+	}
+
+	ret = di_complete_check_get();
+	/* switch flag buffer for next time */
+	if (!ret) {/* if success, swap flag buffer */
+		void *tmp_ptr;
+#ifdef DI_MULPLEX_SUPPORT
+		tmp_ptr = info->in_flag_phy;
+		info->in_flag_phy = info->out_flag_phy;
+		info->out_flag_phy = tmp_ptr;
+#else
+		tmp_ptr = di_data->in_flag_phy;
+		di_data->in_flag_phy = di_data->out_flag_phy;
+		di_data->out_flag_phy = tmp_ptr;
+#endif
+	}
+
+
+	if (di_para->dma_if == 0) {
+#ifdef USE_DMA_BUF
+		di_dma_unmap(out_item);
+NEXT_DMA_UNMAP:
+		di_dma_unmap(next_item);
+PRE_DMA_UNMAP:
+		di_dma_unmap(pre_item);
+CUR_DMA_UNMAP:
+		di_dma_unmap(cur_item);
+FREE_OUT:
+		kfree(out_item);
+FREE_NEXT:
+		kfree(next_item);
+FREE_PRE:
+		kfree(pre_item);
+FREE_CUR:
+		kfree(cur_item);
+EXIT:
+		return ret;
+#endif
+	}
+	return ret;
+
+}
+
+#ifdef DI_MULPLEX_SUPPORT
+/* find a di which has request and a longest time to process */
+static struct sunxi_di *di_find_proper_task(void)
+{
+	struct sunxi_di *di = NULL, *proper_di = NULL;
+	unsigned long min_time = jiffies;
+
+	list_for_each_entry(di, &gsunxi_dev->di_list, list) {
+		bool condition1 = (true == di->requested);
+		bool condition2 = time_after_eq(min_time, di->start_time);
+
+		if (condition1 && condition2) {
+			min_time = di->start_time;
+			proper_di = di;
+		}
+		/*pr_warn("find_task: %d,%d, %ld,%ld\n", condition1,
+		 * condition2,min_time, di->start_time);
+		 */
+	}
+
+	return proper_di;
+}
+
+static int di_process_next_proper_task(u32 from, struct file *filp)
+{
+	unsigned long flags;
+	struct sunxi_di *di = NULL;
+	int ret = -1;
+
+	spin_lock_irqsave(&gsunxi_dev->slock, flags);
+	if (gsunxi_dev->busy) {
+		spin_unlock_irqrestore(&gsunxi_dev->slock, flags);
+		return -1;
+	}
+
+	/* find a di which has request */
+	di = di_find_proper_task();
+	if (NULL != di) {
+		/* process request */
+		gsunxi_dev->busy = true;
+		di->busy = true;
+		di->start_time = jiffies;
+		di->requested = false;
+
+		gsunxi_dev->cur_di = di;
+	}
+	spin_unlock_irqrestore(&gsunxi_dev->slock, flags);
+
+	if (NULL != di)
+		ret = di_process(&di->info, &di->data, filp);
+
+	return ret;
+}
+
+/*
+ * sunxi_di_commit - commit an deinterlace request
+ * @hdl: di handle which return by sunxi_di_request
+ * On success, returns 0. On failure, returns ERR_PTR(-errno).
+ */
+int sunxi_di_commit(struct __di_para_t2 *di_para, struct file *filp)
+{
+
+	int ret = 0;
+
+	struct sunxi_di *di = di_get_by_id(di_para->id);
+
+	if (IS_ERR_OR_NULL(di)) {
+		pr_warn("%s, hdl is invalid\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!di->requested && !di->busy) {
+		memcpy(&di->info, di_para, sizeof(struct __di_para_t2));
+		di->requested = true;
+
+		ret = di_process_next_proper_task(1, filp);
+	}
+
+	dprintk(DEBUG_DATA_INFO, "%s: count = %d\n", __func__, di_para->id);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sunxi_di_commit);
+
+/*
+ * sunxi_di_close - release di channel
+ * @hdl: di handle which return by sunxi_di_request
+ * On success, returns 0. On failure, returns ERR_PTR(-errno).
+ */
+int sunxi_di_close(unsigned int id)
+{
+	struct sunxi_di *di_para = di_get_by_id(id);
+	unsigned long flags;
+	unsigned int count = 0;
+
+	if (IS_ERR_OR_NULL(di_para)) {
+		pr_warn("%s, hdl is invalid!\n", __func__);
+		return -EINVAL;
+	}
+
+
+	mutex_lock(&gsunxi_dev->mlock);
+	idr_remove(&gsunxi_dev->idr, di_para->id);
+	if (!RB_EMPTY_NODE(&di_para->node))
+		rb_erase(&di_para->node, &gsunxi_dev->handles);
+	mutex_unlock(&gsunxi_dev->mlock);
+
+
+	if (di_para->data.mem_in_params.v_addr != NULL)
+		di_mem_release(&(di_para->data.mem_in_params));
+	if (di_para->data.mem_out_params.v_addr != NULL)
+		di_mem_release(&(di_para->data.mem_out_params));
+
+	spin_lock_irqsave(&gsunxi_dev->slock, flags);
+	list_del(&di_para->list);
+	gsunxi_dev->count--;
+	count = gsunxi_dev->count;
+	kfree((void *)di_para);
+	spin_unlock_irqrestore(&gsunxi_dev->slock, flags);
+
+	mutex_lock(&gsunxi_dev->mlock);
+	if (0 == count) {
+		atomic_set(&di_data->enable, 0);
+
+		di_irq_enable(0);
+		di_reset();
+		di_internal_clk_disable();
+		di_clk_disable();
+	}
+
+	mutex_unlock(&gsunxi_dev->mlock);
+
+	dprintk(DEBUG_DATA_INFO, "%s: count = %d\n", __func__, count);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(sunxi_di_close);
+#endif
+
+static long sunxi_di_ioctl(struct file *filp, unsigned int cmd,
+			unsigned long arg)
+{
+	struct __di_para_t di_paras;
+	struct __di_para_t *di_para = &di_paras;
+	struct __di_para_t2 di_paras2;
+	struct __di_para_t2 *di_para2 = &di_paras2;
+#ifdef DI_V2X_SUPPORT
+	struct __di_mode_t di_mode_paras;
+	struct __di_mode_t *di_mode = &di_mode_paras;
+#endif
+	__u32 ret = 0;
+
+	dprintk(DEBUG_TEST, "%s: enter!!\n", __func__);
+
+	switch (cmd) {
+
+#ifdef DI_MULPLEX_SUPPORT
+	case DI_REQUEST:
+	{
+		/* request a chan */
+		unsigned int id;
+
+		id = sunxi_di_request();
+		if (put_user(id, (unsigned int __user *)arg)) {
+			pr_err("%s, put di user failed.", __func__);
+			ret = -EFAULT;
+		} else {
+			ret = 0;
+		}
+
+		break;
+	}
+#endif
+	case DI_IOCSTART:
+	{
+#ifdef DI_MULPLEX_SUPPORT
+		mutex_lock(&gsunxi_dev->dilock);
+
+		if (copy_from_user((void *)di_para,
+			(void __user *)arg, sizeof(struct __di_para_t))) {
+			pr_warn("copy_from_user fail\n");
+			mutex_unlock(&gsunxi_dev->dilock);
+			return -EFAULT;
+		}
+
+		memset(di_para2, 0, sizeof(struct __di_para_t2));
+		change_para(di_para, di_para2);
+		ret = sunxi_di_commit(di_para2, filp);
+
+		mutex_unlock(&gsunxi_dev->dilock);
+#else
+		if (copy_from_user((void *)di_para,
+			(void __user *)arg, sizeof(struct __di_para_t))) {
+			pr_warn("copy_from_user fail\n");
+			return -EFAULT;
+		}
+
+		memset(di_para2, 0, sizeof(struct __di_para_t2));
+		change_para(di_para, di_para2);
+		ret = di_process(di_para2, filp);
+#endif
+	}
+	break;
+
+	case DI_IOCSTART2:
+	{
+#ifdef DI_MULPLEX_SUPPORT
+		mutex_lock(&gsunxi_dev->dilock);
+		memset(di_para2, 0, sizeof(struct __di_para_t2));
+
+		if (copy_from_user((void *)di_para2,
+			(void __user *)arg, sizeof(struct __di_para_t2))) {
+			pr_warn("copy_from_user fail\n");
+			mutex_unlock(&gsunxi_dev->dilock);
+			return -EFAULT;
+		}
+
+		ret = sunxi_di_commit(di_para2, filp);
+		mutex_unlock(&gsunxi_dev->dilock);
+#else
+		memset(di_para2, 0, sizeof(struct __di_para_t2));
+
+		if (copy_from_user((void *)di_para2,
+			(void __user *)arg, sizeof(struct __di_para_t2))) {
+			pr_warn("copy_from_user fail\n");
+			return -EFAULT;
+		}
+
+		ret = di_process(di_para2, filp);
+#endif
+	}
+	break;
+
+#ifdef DI_MULPLEX_SUPPORT
+	case DI_RELEASE:
+	{
+		/* release a chan */
+		unsigned int releaseId;
+		get_user(releaseId, (unsigned int __user *)arg);
+		ret = sunxi_di_close(releaseId);
+		break;
+	}
+#endif
+
+/* New IO for setting di_mode */
+#ifdef DI_V2X_SUPPORT
+	case DI_IOCSETMODE:
+	{
+		if (copy_from_user((void *)di_mode,
+			(void __user *)arg, sizeof(struct __di_mode_t))) {
+			pr_warn("copy_from_user fail\n");
+			return -EFAULT;
+		}
+		di_set_mode(di_mode);
+	}
+		break;
+#endif
+	default:
+		break;
+	}
+
+	dprintk(DEBUG_TEST, "%s: out!!\n", __func__);
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long sunxi_di_compat_ioctl(struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	unsigned long translated_arg = (unsigned long)compat_ptr(arg);
+
+	return sunxi_di_ioctl(filp, cmd, translated_arg);
+}
+#endif
+
+static int sunxi_di_open(struct inode *inode, struct file *file)
+{
+#ifndef DI_MULPLEX_SUPPORT
+	s32 ret = 0;
+
+	dprintk(DEBUG_DATA_INFO, "%s: enter!!\n", __func__);
+
+	if (di_data->users >= DI_MAX_USERS) {
+		pr_err("%s: users number is out of range(%d)!\n", __func__,
+		    DI_MAX_USERS);
+		return -EMFILE;
+	}
+
+	atomic_set(&di_data->enable, 1);
+
+	di_data->flag_size = (FLAG_WIDTH*FLAG_HIGH)/4;
+
+	di_data->mem_in_params.size = di_data->flag_size;
+	ret = di_mem_request(&(di_data->mem_in_params));
+	if (ret < 0) {
+		pr_err("%s: request in_flag mem failed\n", __func__);
+		return -1;
+	}
+
+	di_data->in_flag_phy = (void *)di_data->mem_in_params.p_addr;
+
+	di_data->mem_out_params.size = di_data->flag_size;
+	ret = di_mem_request(&(di_data->mem_out_params));
+	if (ret < 0) {
+		pr_err("%s: request out_flag mem failed\n", __func__);
+		di_mem_release(&(di_data->mem_in_params));
+		return -1;
+	}
+
+	di_data->out_flag_phy = (void *)di_data->mem_out_params.p_addr;
+
+	ret = di_clk_enable();
+	if (ret) {
+		di_mem_release(&(di_data->mem_in_params));
+		di_mem_release(&(di_data->mem_out_params));
+		pr_err("%s: enable clk failed.\n", __func__);
+		return ret;
+	}
+	di_internal_clk_enable();
+	di_set_init();
+
+	di_data->users++;
+#endif
+	return 0;
+}
+
+
+static int sunxi_di_release(struct inode *inode, struct file *file)
+{
+#ifndef DI_MULPLEX_SUPPORT
+	dprintk(DEBUG_DATA_INFO, "%s: enter!!\n", __func__);
+
+	if (di_data->users == 0) {
+		pr_err("%s:users number is already Zero, no need to release!\n",
+		    __func__);
+		return 0;
+	}
+	di_data->users--;
+	atomic_set(&di_data->enable, 0);
+
+	di_irq_enable(0);
+	di_reset();
+	di_internal_clk_disable();
+	di_clk_disable();
+
+	if (di_data->mem_in_params.v_addr != NULL)
+		di_mem_release(&(di_data->mem_in_params));
+	if (di_data->mem_out_params.v_addr != NULL)
+		di_mem_release(&(di_data->mem_out_params));
+#endif
+	return 0;
+}
+static struct file sunxi_di_file;
+int sunxi_di_close(unsigned int id)
+{
+	sunxi_di_release(0, &sunxi_di_file);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_di_close);
+
+unsigned int sunxi_di_request(void)
+{
+	sunxi_di_open(0, &sunxi_di_file);
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(sunxi_di_request);
+
+int sunxi_di_commit(struct __di_para_t2 *di_para, struct file *filp)
+{
+	int ret;
+
+	ret = di_process(di_para, &sunxi_di_file);
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(sunxi_di_commit);
+
+static const struct file_operations sunxi_di_fops = {
+	.owner = THIS_MODULE,
+	.llseek = noop_llseek,
+	.unlocked_ioctl = sunxi_di_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= sunxi_di_compat_ioctl,
+#endif
+	.open = sunxi_di_open,
+	.release = sunxi_di_release,
+};
+
+static u64 sunxi_di_dma_mask = DMA_BIT_MASK(32);
+
+static int sunxi_di_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	s32 ret;
+
+	iommu_dev = &pdev->dev;
+	dprintk(DEBUG_INIT, "%s: enter!!\n", __func__);
+
+	if (!of_device_is_available(node)) {
+		pr_err("%s: di status disable!!\n", __func__);
+		return -EPERM;
+	}
+
+	di_data = kzalloc(sizeof(*di_data), GFP_KERNEL);
+	if (di_data == NULL) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	atomic_set(&di_data->di_complete, 0);
+	atomic_set(&di_data->enable, 0);
+	di_data->mem_in_params.v_addr = NULL;
+	di_data->mem_out_params.v_addr = NULL;
+
+	init_waitqueue_head(&di_data->wait);
+
+	di_data->time_value = DI_TIMEOUT;
+
+	di_wq = create_singlethread_workqueue("di_wq");
+	if (!di_wq) {
+		pr_err("Creat DE-Interlace workqueue failed.\n");
+		ret = -ENOMEM;
+		goto create_work_err;
+	}
+
+	if (sunxi_di_major == -1) {
+		sunxi_di_major = register_chrdev(0, DI_MODULE_NAME,
+						&sunxi_di_fops);
+		if (sunxi_di_major < 0) {
+			pr_err("%s: Failed to register character device\n",
+				__func__);
+			ret = -1;
+			goto register_chrdev_err;
+		} else
+			dprintk(DEBUG_INIT,
+				"%s: sunxi_di_major = %d\n", __func__,
+				sunxi_di_major);
+	}
+
+	di_dev_class = class_create(THIS_MODULE, DI_MODULE_NAME);
+	if (IS_ERR(di_dev_class))
+		return -1;
+	di_device = device_create(di_dev_class, NULL,  MKDEV(sunxi_di_major, 0),
+			NULL, DI_MODULE_NAME);
+	di_device->dma_mask = &sunxi_di_dma_mask;
+	di_device->coherent_dma_mask = DMA_BIT_MASK(32);
+	ret = sunxi_di_params_init(pdev);
+	if (ret) {
+		pr_err("%s di init params failed!\n", __func__);
+		goto init_para_err;
+	}
+
+#ifdef CONFIG_PM
+	di_data->di_pm_domain.ops.suspend = sunxi_di_suspend;
+	di_data->di_pm_domain.ops.resume = sunxi_di_resume;
+	di_device->pm_domain = &(di_data->di_pm_domain);
+#endif
+
+	ret = sysfs_create_group(&di_device->kobj, &di_attribute_group);
+	if (ret) {
+		pr_err("%s di_attribute_group create failed!\n", __func__);
+		return ret;
+	}
+
+#ifdef DI_MULPLEX_SUPPORT
+	gsunxi_dev = kzalloc(sizeof(struct sunxi_didev), GFP_KERNEL);
+	if (!gsunxi_dev)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&gsunxi_dev->di_list);
+	spin_lock_init(&gsunxi_dev->slock);
+	mutex_init(&gsunxi_dev->mlock);
+	mutex_init(&gsunxi_dev->dilock);
+	idr_init(&gsunxi_dev->idr);
+	gsunxi_dev->dev = &pdev->dev;
+	gsunxi_dev->handles = RB_ROOT;
+#endif
+	return 0;
+
+init_para_err:
+	if (sunxi_di_major > 0) {
+		device_destroy(di_dev_class, MKDEV(sunxi_di_major, 0));
+		class_destroy(di_dev_class);
+		unregister_chrdev(sunxi_di_major, DI_MODULE_NAME);
+	}
+register_chrdev_err:
+	if (di_wq != NULL) {
+		flush_workqueue(di_wq);
+		destroy_workqueue(di_wq);
+		di_wq = NULL;
+	}
+create_work_err:
+	kfree(di_data);
+
+	return ret;
+}
+
+static int sunxi_di_remove(struct platform_device *pdev)
+{
+#ifdef DI_MULPLEX_SUPPORT
+	if (gsunxi_dev && (gsunxi_dev->count != 0)) {
+		struct sunxi_di *di = NULL, *di_tmp = NULL;
+		unsigned long flags;
+
+		pr_warn("%s(), there are still %d users, force release them\n",
+		    __func__, gsunxi_dev->count);
+		spin_lock_irqsave(&gsunxi_dev->slock, flags);
+		list_for_each_entry_safe(di, di_tmp,
+						&gsunxi_dev->di_list, list) {
+			list_del(&di->list);
+			gsunxi_dev->count--;
+			kfree((void *)di);
+		}
+		spin_unlock_irqrestore(&gsunxi_dev->slock, flags);
+	}
+
+	kfree(gsunxi_dev);
+#endif
+	sysfs_remove_group(&di_device->kobj, &di_attribute_group);
+	sunxi_di_params_exit();
+	if (sunxi_di_major > 0) {
+		device_destroy(di_dev_class, MKDEV(sunxi_di_major, 0));
+		class_destroy(di_dev_class);
+		unregister_chrdev(sunxi_di_major, DI_MODULE_NAME);
+	}
+	if (di_wq != NULL) {
+		flush_workqueue(di_wq);
+		destroy_workqueue(di_wq);
+		di_wq = NULL;
+	}
+	kfree(di_data);
+
+	pr_info("%s: module unloaded\n", __func__);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_di_match[] = {
+	 { .compatible = "allwinner,sunxi-deinterlace", },
+	 {},
+};
+MODULE_DEVICE_TABLE(of, sunxi_di_match);
+
+
+static struct platform_driver di_platform_driver = {
+	.probe  = sunxi_di_probe,
+	.remove = sunxi_di_remove,
+	.driver = {
+		.name	= DI_MODULE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_di_match,
+	},
+};
+
+static int __init sunxi_di_init(void)
+{
+	pr_info("Deinterlace Module initialized.\n");
+	return platform_driver_register(&di_platform_driver);
+}
+
+static void __exit sunxi_di_exit(void)
+{
+	platform_driver_unregister(&di_platform_driver);
+}
+#ifdef CONFIG_ARCH_SUN8IW11P1
+subsys_initcall(sunxi_di_init);
+#else
+module_init(sunxi_di_init);
+#endif
+module_exit(sunxi_di_exit);
+module_param_named(debug_mask, debug_mask, int, 0644);
+MODULE_DESCRIPTION("DE-Interlace driver");
+MODULE_AUTHOR("Ming Li<liming@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/char/sunxi-di/drv_div2x/sunxi-di.h b/drivers/char/sunxi-di/drv_div2x/sunxi-di.h
new file mode 100644
index 000000000..9c6789954
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div2x/sunxi-di.h
@@ -0,0 +1,88 @@
+/*
+ * Allwinner SoCs de-interlace driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef _SUNXI_DI_H
+#define _SUNXI_DI_H
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/pm.h>
+#include "di.h"
+
+#define DI_RESERVED_MEM
+
+#define DI_MODULE_NAME "deinterlace"
+#define DI_TIMEOUT     30             /* DI-Interlace 30ms timeout */
+#define DI_MODULE_TIMEOUT               0x1055
+#define FLAG_WIDTH                      (2048)
+#define FLAG_HIGH                       (1100)
+
+#if ((defined CONFIG_ARCH_SUN8IW12P1) ||\
+	(defined CONFIG_ARCH_SUN8IW17P1) ||\
+	(defined CONFIG_ARCH_SUN50IW6P1))
+#define DI_V2X_SUPPORT
+#endif
+
+#if (defined CONFIG_ARCH_SUN50IW6P1) || (defined CONFIG_ARCH_SUN8IW17P1)
+#define USE_DMA_BUF
+#endif
+
+#if ((defined CONFIG_ARCH_SUN8IW12P1) || (defined CONFIG_ARCH_SUN8IW17P1))
+#define DI_V22
+#define SUPPORT_DNS
+#endif
+
+#ifdef CONFIG_ARCH_SUN50IW6P1
+#define DI_V23
+#endif
+
+#if (defined CONFIG_ARCH_SUN8IW17P1)
+#define DI_MULPLEX_SUPPORT
+#endif
+
+typedef struct {
+	void __iomem *base_addr;
+	struct __di_mem_t mem_in_params;
+	struct __di_mem_t mem_out_params;
+	atomic_t     di_complete;
+	atomic_t     enable;
+	wait_queue_head_t wait;
+	void *in_flag_phy;
+	void *out_flag_phy;
+	size_t  flag_size;
+	u32  irq_number;
+	u32  time_value;
+#ifdef CONFIG_PM
+	struct dev_pm_domain di_pm_domain;
+#endif
+	unsigned int users;
+} di_struct, *pdi_struct;
+
+#define	DI_IOC_MAGIC		'D'
+#define	DI_IOCSTART		_IOWR(DI_IOC_MAGIC, 0, struct __di_rectsz_t)
+#define DI_IOCSTART2	_IOWR(DI_IOC_MAGIC, 1, struct __di_rectsz_t)
+#define DI_IOCSETMODE	_IOWR(DI_IOC_MAGIC, 2, struct __di_mode_t)
+#define DI_REQUEST	_IOWR(DI_IOC_MAGIC, 3, struct __di_rectsz_t)
+#define DI_RELEASE	_IOWR(DI_IOC_MAGIC, 4, struct __di_rectsz_t)
+
+enum {
+	DEBUG_INIT = 1U << 0,
+	DEBUG_INT = 1U << 1,
+	DEBUG_DATA_INFO = 1U << 2,
+	DEBUG_SUSPEND = 1U << 3,
+	DEBUG_TEST = 1U << 4,
+};
+
+#define dprintk(level_mask, fmt, arg...)\
+	do {\
+		if (unlikely(debug_mask & level_mask)) \
+		printk(fmt, ## arg);\
+	} while (0)
+#endif
+
diff --git a/drivers/char/sunxi-di/drv_div3x/Makefile b/drivers/char/sunxi-di/drv_div3x/Makefile
new file mode 100644
index 000000000..efe0747da
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/Makefile
@@ -0,0 +1,10 @@
+sunxi_di_dir := drv_div3x
+sunxi_di := $(sunxi_di_dir)/di_driver.o  \
+			$(sunxi_di_dir)/di_client.o \
+			$(sunxi_di_dir)/di_fops.o \
+#			$(sunxi_di_dir)/di_utils.o
+
+ifeq ($(CONFIG_ARCH_SUN50IW9),y)
+sunxi_di += $(sunxi_di_dir)/lowlevel_v3x/di300.o \
+			$(sunxi_di_dir)/lowlevel_v3x/di300_alg.o
+endif
diff --git a/drivers/char/sunxi-di/drv_div3x/di_client.c b/drivers/char/sunxi-di/drv_div3x/di_client.c
new file mode 100644
index 000000000..b14f6285d
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_client.c
@@ -0,0 +1,681 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "di_client.h"
+#include "di_dev.h"
+#include "di_utils.h"
+#include "di_debug.h"
+#include "sunxi_di.h"
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#define DI_TNR_BUF_ALIGN_LEN 16
+#define DI_MD_BUF_ALIGN_LEN 32
+
+extern int di_drv_get_version(struct di_version *version);
+extern int di_drv_client_inc(struct di_client *c);
+extern int di_drv_client_dec(struct di_client *c);
+extern int di_drv_is_valid_client(struct di_client *c);
+extern int di_drv_process_fb(struct di_client *c);
+
+static int di_client_alloc_mbuf(struct di_mapped_buf **mbuf, u32 size)
+{
+	struct di_mapped_buf *p = *mbuf;
+
+	if (p != NULL) {
+		u32 size_alloced = PAGE_ALIGN(size);
+
+		if (p->size_alloced != size_alloced) {
+			di_dma_buf_unmap_free(p);
+			p = NULL;
+			*mbuf = NULL;
+		} else {
+			p->size_request = size;
+		}
+	}
+	if (p == NULL) {
+		p = di_dma_buf_alloc_map(size);
+		if (p == NULL)
+			return -ENOMEM;
+	}
+	memset((void *)p->vir_addr, 0, p->size_alloced);
+	*mbuf = p;
+
+	return 0;
+}
+
+static int di_client_setup_md_buf(struct di_client *c)
+{
+	int ret = 0;
+	u32 w_bit = c->video_size.width * 2;
+	u32 w_stride = ALIGN(w_bit, DI_MD_BUF_ALIGN_LEN * 8) / 8;
+	u32 h = c->video_size.height;
+	u32 size = h * w_stride;
+
+	ret = di_client_alloc_mbuf(&(c->md_buf.mbuf[0]), size);
+	if (ret)
+		return ret;
+	ret = di_client_alloc_mbuf(&(c->md_buf.mbuf[1]), size);
+	if (ret) {
+		if (c->md_buf.mbuf[0]) {
+			di_dma_buf_unmap_free(c->md_buf.mbuf[0]);
+			c->md_buf.mbuf[0] = NULL;
+		}
+		return ret;
+	}
+
+	c->md_buf.dir = 0;
+	c->md_buf.w_bit = w_bit;
+	c->md_buf.w_stride = w_stride;
+	c->md_buf.h = h;
+
+	return 0;
+}
+
+int di_client_reset(struct di_client *c, void *data)
+{
+	u32 i;
+
+	DI_DEBUG("%s: %s\n", c->name, __func__);
+
+	c->para_checked = false;
+	c->unreset = false;
+	c->proc_fb_seqno = 0;
+	c->di_detect_result = 0;
+	c->interlace_detected_counts = 0;
+	c->lastest_interlace_detected_frame = 0;
+	c->interlace_detected_counts_exceed_first_p_frame = 0;
+	c->progressive_detected_counts = 0;
+	c->progressive_detected_first_frame = 0;
+	c->lastest_progressive_detected_frame = 0;
+	c->apply_fixed_para = true;
+	atomic_set(&c->wait_con, DI_PROC_STATE_IDLE);
+
+	c->in_fb0 = c->in_fb1 = c->in_fb2 =
+		c->out_dit_fb0 = c->out_dit_fb1 = c->out_tnr_fb0 =
+		c->dma_di = c->dma_p = c->dma_c =
+		c->di_w0 = c->di_w1 = c->tnr_w = NULL;
+	for (i = 0; i < ARRAY_SIZE(c->fb_pool); i++) {
+		if (c->fb_pool[i].dma_item) {
+			di_dma_buf_self_unmap(c->fb_pool[i].dma_item);
+			c->fb_pool[i].dma_item = NULL;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(c->md_buf.mbuf); i++) {
+		if (c->md_buf.mbuf[i]) {
+			di_dma_buf_unmap_free(c->md_buf.mbuf[i]);
+			c->md_buf.mbuf[i] = NULL;
+		}
+	}
+
+	di_dev_reset_cdata((void *)c->dev_cdata);
+
+	return 0;
+}
+
+/*checking and correcting di_client para before running proccess_fb*/
+int di_client_check_para(struct di_client *c, void *data)
+{
+	DI_DEBUG("%s: %s\n", c->name, __func__);
+
+	if (c->para_checked == true)
+		return 0;
+
+	if (c->unreset == true) {
+		DI_ERR("%s: do reset before setting, then check\n", c->name);
+		return -EINVAL;
+	}
+
+	c->proc_fb_seqno = 0;
+	c->di_detect_result = 0;
+	c->interlace_detected_counts = 0;
+	c->lastest_interlace_detected_frame = 0;
+	c->interlace_detected_counts_exceed_first_p_frame = 0;
+	c->progressive_detected_counts = 0;
+	c->progressive_detected_first_frame = 0;
+	c->lastest_progressive_detected_frame = 0;
+	c->apply_fixed_para = true;
+
+	if ((c->video_size.height == 0)
+		|| ((c->video_size.height & 0x1) != 0)
+		|| (c->video_size.width == 0)
+		|| ((c->video_size.width & 0x1) != 0)) {
+		DI_ERR("%s: invalid size W(%d)xH(%d)\n",
+			c->name, c->video_size.height, c->video_size.width);
+		goto err_out;
+	}
+
+	if ((c->dit_mode.intp_mode == DI_DIT_INTP_MODE_MOTION)
+		&& (c->dit_mode.out_frame_mode == DI_DIT_OUT_2FRAME)
+		/*&& (c->tnr_mode.mode != DI_TNR_MODE_INVALID)
+		&& (c->fmd_en.en != 0)*/) {
+		DI_DEBUG("%s: this is 60hz mode\n", c->name);
+		c->mode = DI_MODE_60HZ;
+		c->md_en = true;
+		if (c->tnr_mode.mode)
+			c->tnr_en = true;
+		else
+			c->tnr_en = false;
+		c->vof_buf_en = true;
+		c->dma_di = c->in_fb0 = &c->fb_pool[0];
+		c->dma_p = c->in_fb1 = &c->fb_pool[1];
+		c->dma_c = c->in_fb2 = &c->fb_pool[2];
+		c->di_w0 = c->out_dit_fb0 = &c->fb_pool[3];
+		c->di_w1 = c->out_dit_fb1 = &c->fb_pool[4];
+		c->tnr_w = c->out_tnr_fb0 = &c->fb_pool[5];
+	} else if ((c->dit_mode.intp_mode == DI_DIT_INTP_MODE_MOTION)
+		&& (c->dit_mode.out_frame_mode == DI_DIT_OUT_1FRAME)
+		/*&& (c->tnr_mode.mode != DI_TNR_MODE_INVALID)
+		&& (c->fmd_en.en != 0)*/) {
+		DI_DEBUG("%s: this is 30hz mode\n", c->name);
+		c->mode = DI_MODE_30HZ;
+		c->md_en = true;
+		if (c->tnr_mode.mode)
+			c->tnr_en = true;
+		else
+			c->tnr_en = false;
+		c->vof_buf_en = false;
+		c->dma_p = c->in_fb0 = &c->fb_pool[0];
+		c->dma_c = c->in_fb1 = &c->fb_pool[1];
+		c->di_w1 = c->out_dit_fb0 = &c->fb_pool[2];
+		c->tnr_w = c->out_tnr_fb0 = &c->fb_pool[3];
+	} else if ((c->dit_mode.intp_mode == DI_DIT_INTP_MODE_BOB)
+		&& (c->dit_mode.out_frame_mode == DI_DIT_OUT_1FRAME)
+		&& (c->tnr_mode.mode == DI_TNR_MODE_INVALID)
+		&& (c->fmd_en.en == 0)) {
+		DI_DEBUG("%s: this is bob mode\n", c->name);
+		c->mode = DI_MODE_BOB;
+		c->md_en = false;
+		c->tnr_en = false;
+		c->vof_buf_en = false;
+		c->dma_p = c->in_fb0 = &c->fb_pool[0];
+		c->di_w1 = c->out_dit_fb0 = &c->fb_pool[1];
+	} else if ((c->dit_mode.intp_mode == DI_DIT_INTP_MODE_WEAVE)
+		&& (c->dit_mode.out_frame_mode == DI_DIT_OUT_1FRAME)
+		&& (c->tnr_mode.mode == DI_TNR_MODE_INVALID)
+		&& (c->fmd_en.en == 0)) {
+		DI_DEBUG("%s: this is weave mode\n", c->name);
+		c->mode = DI_MODE_WEAVE;
+		c->md_en = false;
+		c->tnr_en = false;
+		c->vof_buf_en = false;
+		c->dma_p = c->in_fb0 = &c->fb_pool[0];
+		c->di_w1 = c->out_dit_fb0 = &c->fb_pool[1];
+	} else if ((c->dit_mode.intp_mode == DI_DIT_INTP_MODE_INVALID)
+		&& (c->dit_mode.out_frame_mode == DI_DIT_OUT_0FRAME)
+		&& (c->tnr_mode.mode != DI_TNR_MODE_INVALID)
+		&& (c->fmd_en.en == 0)) {
+		DI_DEBUG("%s: this is only-tnr mode\n", c->name);
+		c->mode = DI_MODE_TNR;
+		c->md_en = true;
+		c->tnr_en = true;
+		c->vof_buf_en = false;
+		c->dma_p = c->in_fb0 = &c->fb_pool[0];
+		c->dma_c = c->in_fb1 = &c->fb_pool[1];
+		c->tnr_w = c->out_tnr_fb0 = &c->fb_pool[2];
+	} else {
+		DI_ERR("%s: wrong paras:\n  "
+			"dit_mode:%d,%d; tnr:%d,%d; fmd_en:%d\n",
+			c->name,
+			c->dit_mode.intp_mode, c->dit_mode.out_frame_mode,
+			c->tnr_mode.mode, c->tnr_mode.level, c->fmd_en.en);
+		goto err_out;
+	}
+
+	if (c->md_en)
+		if (di_client_setup_md_buf(c))
+			goto err_out;
+
+	atomic_set(&c->wait_con, DI_PROC_STATE_IDLE);
+	di_dev_reset_cdata((void *)c->dev_cdata);
+
+	c->para_checked = true;
+	c->unreset = true;
+
+	return 0;
+
+err_out:
+	c->para_checked = false;
+	return -EINVAL;
+}
+
+static bool di_client_check_fb_arg(struct di_client *c,
+	struct di_process_fb_arg *fb_arg)
+{
+	DI_DEBUG("%s pulldown[%s] topFieldFirst[%s] baseFiled[%s]\n",
+		fb_arg->is_interlace ? "Interlace" : "P",
+		fb_arg->is_pulldown ? "Y" : "N",
+		fb_arg->top_field_first ? "Y" : "N",
+		fb_arg->base_field ? "TOP" : "BOTTOM");
+	DI_DEBUG("out fb0 info:format:%u dma_buf_fd:%d "
+	"buf:(y_addr:0x%llx)(cb_addr:0x%llx)(cr_addr:0x%llx)(ystride:%d)(cstride:%d) "
+	"size:(%dx%d)\n",
+	fb_arg->out_dit_fb0.format, fb_arg->out_dit_fb0.dma_buf_fd,
+	fb_arg->out_dit_fb0.buf.y_addr, fb_arg->out_dit_fb0.buf.cb_addr, fb_arg->out_dit_fb0.buf.cr_addr,
+	fb_arg->out_dit_fb0.buf.ystride, fb_arg->out_dit_fb0.buf.cstride,
+	fb_arg->out_dit_fb0.size.width, fb_arg->out_dit_fb0.size.height);
+
+	DI_DEBUG("out fb1 info:format:%u dma_buf_fd:%d "
+	"buf:(y_addr:0x%llx)(cb_addr:0x%llx)(cr_addr:0x%llx)(ystride:%d)(cstride:%d)"
+	"size:(%dx%d)\n",
+	fb_arg->out_dit_fb1.format, fb_arg->out_dit_fb1.dma_buf_fd,
+	fb_arg->out_dit_fb1.buf.y_addr, fb_arg->out_dit_fb1.buf.cb_addr, fb_arg->out_dit_fb1.buf.cr_addr,
+	fb_arg->out_dit_fb1.buf.ystride, fb_arg->out_dit_fb1.buf.cstride,
+	fb_arg->out_dit_fb1.size.width, fb_arg->out_dit_fb1.size.height);
+
+	/* TODO: add more check ? */
+	return true;
+}
+
+static int di_client_get_fb(struct di_client *c,
+	struct di_dma_fb *dma_fb, struct di_fb *fb,
+	enum dma_data_direction dir)
+{
+	DI_DEBUG("%s: buf_addr[0x%llx,0x%llx,0x%llx],"
+		"buf_stride[%d,%d],fmt=%s,fd=%d,size[%d,%d]\n",
+		c->name,
+		fb->buf.y_addr, fb->buf.cb_addr,
+		fb->buf.cr_addr,
+		fb->buf.ystride, fb->buf.cstride,
+		di_format_to_string(fb->format),
+		fb->dma_buf_fd,
+		fb->size.width, fb->size.height);
+
+	if (dma_fb->dma_item != NULL) {
+		di_dma_buf_self_unmap(dma_fb->dma_item);
+		dma_fb->dma_item = NULL;
+	}
+	if (fb->dma_buf_fd >= 0) {
+		dma_fb->dma_item = di_dma_buf_self_map(fb->dma_buf_fd, dir);
+		if (dma_fb->dma_item == NULL) {
+			DI_ERR("%s: %s,%d\n", c->name, __func__, __LINE__);
+			return -EINVAL;
+		}
+		fb->buf.y_addr +=
+			(u64)(dma_fb->dma_item->dma_addr);
+		if (fb->buf.cb_addr)
+			fb->buf.cb_addr += (u64)(dma_fb->dma_item->dma_addr);
+		if (fb->buf.cr_addr)
+			fb->buf.cr_addr += (u64)(dma_fb->dma_item->dma_addr);
+		DI_DEBUG("%s:dma_addr=0x%llx,yuv[0x%llx,0x%llx,0x%llx]\n",
+			c->name, (u64)(dma_fb->dma_item->dma_addr),
+			fb->buf.y_addr, fb->buf.cb_addr, fb->buf.cr_addr);
+	} else {
+		DI_DEBUG("%s: On phy_addr_buf method\n", c->name);
+	}
+	dma_fb->fb = fb;
+
+	return 0;
+}
+
+static int di_client_get_fbs(struct di_client *c)
+{
+	struct di_process_fb_arg *fb_arg = &c->fb_arg;
+
+	if ((c->in_fb0 != NULL)
+		&& di_client_get_fb(c, c->in_fb0,
+			&fb_arg->in_fb0, DMA_TO_DEVICE))
+		return -EINVAL;
+	if ((c->in_fb1 != NULL)
+		&& di_client_get_fb(c, c->in_fb1,
+			&fb_arg->in_fb1, DMA_TO_DEVICE))
+		return -EINVAL;
+	if ((c->in_fb2 != NULL)
+		&& di_client_get_fb(c, c->in_fb2,
+			&fb_arg->in_fb2, DMA_TO_DEVICE))
+		return -EINVAL;
+	if ((c->out_dit_fb0 != NULL)
+		&& di_client_get_fb(c, c->out_dit_fb0,
+			&fb_arg->out_dit_fb0, DMA_FROM_DEVICE))
+		return -EINVAL;
+	if ((c->out_dit_fb1 != NULL)
+		&& di_client_get_fb(c, c->out_dit_fb1,
+			&fb_arg->out_dit_fb1, DMA_FROM_DEVICE))
+		return -EINVAL;
+
+	if ((c->out_tnr_fb0 != NULL)
+		&& (c->tnr_mode.mode > 0)) {
+		if (di_client_get_fb(c, c->out_tnr_fb0,
+				&fb_arg->out_tnr_fb0, DMA_FROM_DEVICE))
+			return -EINVAL;
+
+		/*NOTE: when use tnr, the output format must be planner*/
+		if (di_format_get_planar_num(c->out_tnr_fb0->fb->format) != 3) {
+			DI_ERR("%s: invalid %s(%d) for out_tnr_fb0\n", c->name,
+				di_format_to_string(c->out_tnr_fb0->fb->format),
+				c->out_tnr_fb0->fb->format);
+			return -EINVAL;
+		}
+
+		/*NOTE: when use tnr, the output format must be planner*/
+		if ((c->out_dit_fb0 != NULL)
+			&& (di_format_get_planar_num(
+				c->out_dit_fb0->fb->format) != 3)) {
+			DI_ERR("%s: invalid %s(%d) for out_dit_fb0\n", c->name,
+				di_format_to_string(c->out_dit_fb0->fb->format),
+				c->out_dit_fb0->fb->format);
+			return -EINVAL;
+		}
+
+		/*NOTE: when use tnr, the output format must be planner*/
+		if ((c->out_dit_fb1 != NULL)
+			&& (di_format_get_planar_num(
+				c->out_dit_fb1->fb->format) != 3)) {
+			DI_ERR("%s: invalid %s(%d) for out_dit_fb1\n", c->name,
+				di_format_to_string(c->out_dit_fb1->fb->format),
+				c->out_dit_fb1->fb->format);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int di_client_put_fbs(struct di_client *c)
+{
+	u32 i;
+
+	for (i = 0; i < ARRAY_SIZE(c->fb_pool); i++) {
+		struct di_dma_fb *fb = &(c->fb_pool[i]);
+
+		fb->fb = NULL;
+		if (fb->dma_item != NULL) {
+			di_dma_buf_self_unmap(fb->dma_item);
+			fb->dma_item = NULL;
+		}
+	}
+	return 0;
+}
+
+int di_client_process_fb(struct di_client *c,
+	struct di_process_fb_arg *fb_arg)
+{
+	int ret = 0;
+	ktime_t time;
+	unsigned long long t0 = 0, t1 = 0, t2 = 0, t3 = 0;
+
+	time = ktime_get();
+	t0 = ktime_to_us(time);
+	if (c->para_checked == false) {
+		DI_ERR("%s: para unchecked\n", c->name);
+		return -EINVAL;
+	}
+
+	if (!di_client_check_fb_arg(c, fb_arg)) {
+		DI_ERR("%s: check_fb_arg fail\n", c->name);
+		return -EINVAL;
+	}
+	memcpy((void *)&c->fb_arg, fb_arg, sizeof(c->fb_arg));
+
+	ret = di_client_get_fbs(c);
+
+	time = ktime_get();
+	t1 = ktime_to_us(time);
+
+	if (!ret)
+		ret = di_drv_process_fb(c);
+
+	if ((c->mode == DI_MODE_60HZ
+		|| c->mode == DI_MODE_30HZ
+		|| c->mode == DI_MODE_WEAVE)
+		&& c->di_detect_result == DI_DETECT_PROGRESSIVE) {
+		DI_INFO("di detect result:progressive, di_mode:%s\n",
+			c->mode == DI_MODE_60HZ ? "60HZ" :
+			c->mode == DI_MODE_30HZ ? "30HZ" : "weave");
+		if (!c->progressive_detected_counts)
+			c->progressive_detected_first_frame = c->proc_fb_seqno;
+		if (c->progressive_detected_counts == 0xffffffffffffffff)
+			c->interlace_detected_counts = 0;
+		c->progressive_detected_counts++;
+		c->lastest_progressive_detected_frame = c->proc_fb_seqno;
+		ret = FB_PROCESS_ERROR_INTERLACE_TYPE;
+	} else {
+		DI_INFO("di detect result:interlace, di_mode:%s\n",
+			c->mode == DI_MODE_60HZ ? "60HZ" :
+			c->mode == DI_MODE_30HZ ? "30HZ" :
+			c->mode == DI_MODE_BOB ? "bob" :
+			c->mode == DI_MODE_TNR ? "tnr only" :
+			"weave");
+		c->interlace_detected_counts++;
+		c->lastest_interlace_detected_frame = c->proc_fb_seqno;
+		if (c->progressive_detected_counts
+			&& (c->interlace_detected_counts
+				> c->progressive_detected_counts))
+			c->interlace_detected_counts_exceed_first_p_frame++;
+	}
+
+	time = ktime_get();
+	t2 = ktime_to_us(time);
+
+	di_client_put_fbs(c);
+
+	time = ktime_get();
+	t3 = ktime_to_us(time);
+
+	DI_TEST("total:%lluus     t0~t1:%lluus  t1~t2:%lluus  t2~t3:%lluus\n",
+		(t3 - t0),
+		(t1 - t0),
+		(t2 - t1),
+		(t3 - t2));
+	return ret;
+}
+
+int di_client_set_video_size(struct di_client *c, struct di_size *size)
+{
+	DI_DEBUG("%s: video_size[%d x %d]\n", c->name,
+		size->width, size->height);
+
+	c->video_size.width = size->width;
+	c->video_size.height = size->height;
+	return 0;
+}
+
+int di_client_set_video_crop(struct di_client *c, struct di_rect *rect)
+{
+	DI_DEBUG("%s: video_crop:(%u, %u)  (%u, %u)\n", c->name,
+		rect->left, rect->top, rect->right, rect->bottom);
+
+	c->dit_out_crop.left = rect->left;
+	c->dit_out_crop.top = rect->top;
+	c->dit_out_crop.right = rect->right;
+	c->dit_out_crop.bottom = rect->bottom;
+
+	memcpy((void *)&c->md_out_crop, (void *)&c->dit_out_crop,
+		sizeof(c->md_out_crop));
+	memcpy((void *)&c->fmd_out_crop, (void *)&c->dit_out_crop,
+		sizeof(c->fmd_out_crop));
+	memcpy((void *)&c->tnr_out_crop, (void *)&c->dit_out_crop,
+		sizeof(c->tnr_out_crop));
+	memcpy((void *)&c->dit_demo_crop, (void *)&c->dit_out_crop,
+		sizeof(c->dit_demo_crop));
+	memcpy((void *)&c->tnr_demo_crop, (void *)&c->dit_out_crop,
+		sizeof(c->tnr_demo_crop));
+
+	return 0;
+}
+
+int di_client_set_demo_crop(struct di_client *c,
+			struct di_demo_crop_arg *demo_arg)
+{
+	DI_DEBUG("%s: demo crop: dit:(%u, %u)  (%u, %u) "
+		"tnr: (%u, %u)  (%u, %u)\n", c->name,
+		demo_arg->dit_demo.left, demo_arg->dit_demo.top,
+		demo_arg->dit_demo.right, demo_arg->dit_demo.bottom,
+		demo_arg->tnr_demo.left, demo_arg->tnr_demo.top,
+		demo_arg->tnr_demo.right, demo_arg->tnr_demo.bottom);
+
+	demo_arg->dit_demo.left = demo_arg->dit_demo.left
+		- (demo_arg->dit_demo.left % 4);
+	demo_arg->dit_demo.top = demo_arg->dit_demo.top
+		- (demo_arg->dit_demo.top % 4);
+	demo_arg->dit_demo.right = demo_arg->dit_demo.right
+		- (demo_arg->dit_demo.right % 4);
+	demo_arg->dit_demo.bottom = demo_arg->dit_demo.bottom
+		- (demo_arg->dit_demo.bottom % 4);
+
+	demo_arg->tnr_demo.left = demo_arg->tnr_demo.left
+		- (demo_arg->tnr_demo.left % 4);
+	demo_arg->tnr_demo.top = demo_arg->tnr_demo.top
+		- (demo_arg->tnr_demo.top % 4);
+	demo_arg->tnr_demo.right = demo_arg->tnr_demo.right
+		- (demo_arg->tnr_demo.right % 4);
+	demo_arg->tnr_demo.bottom = demo_arg->tnr_demo.bottom
+		- (demo_arg->tnr_demo.bottom % 4);
+
+	memcpy((void *)&c->dit_demo_crop, (void *)&demo_arg->dit_demo,
+		sizeof(c->dit_demo_crop));
+	memcpy((void *)&c->tnr_demo_crop, (void *)&demo_arg->tnr_demo,
+		sizeof(c->tnr_demo_crop));
+
+	return 0;
+}
+
+int di_client_set_dit_mode(struct di_client *c, struct di_dit_mode *mode)
+{
+	DI_DEBUG("%s: dit_mode: intp_mode=%d, out_frame_mode=%d\n",
+		c->name, mode->intp_mode, mode->out_frame_mode);
+
+	c->dit_mode.intp_mode = mode->intp_mode;
+	c->dit_mode.out_frame_mode = mode->out_frame_mode;
+	return 0;
+}
+
+int di_client_set_tnr_mode(struct di_client *c, struct di_tnr_mode *mode)
+{
+	DI_DEBUG("%s: tnr_mode: mode=%d, level=%d\n",
+		c->name, mode->mode, mode->level);
+
+	c->tnr_mode.mode = mode->mode;
+	c->tnr_mode.level = mode->level;
+	return 0;
+}
+
+int di_client_set_fmd_enable(struct di_client *c, struct di_fmd_enable *en)
+{
+	DI_DEBUG("%s: fmd_en: en=%d\n", c->name, en->en);
+
+	c->fmd_en.en = en->en;
+	return 0;
+}
+
+int di_client_get_version(struct di_client *c,
+	struct di_version *version)
+{
+	return di_drv_get_version(version);
+}
+
+int di_client_set_timeout(struct di_client *c,
+	struct di_timeout_ns *timeout)
+{
+	DI_DEBUG("%s:wait4start=%llu,wait4finish=%llu\n",
+		c->name, timeout->wait4start, timeout->wait4finish);
+	if (timeout->wait4start > 0)
+		c->timeout.wait4start = timeout->wait4start;
+	if (timeout->wait4finish > 0)
+		c->timeout.wait4finish = timeout->wait4finish;
+
+	return 0;
+}
+
+void *di_client_create(const char *name)
+{
+	struct di_client *client;
+
+	if (!name) {
+		DI_ERR("%s: Name cannot be null\n", __func__);
+		return NULL;
+	}
+
+	client = kzalloc(sizeof(*client) + di_dev_get_cdata_size(),
+		GFP_KERNEL);
+	if (client == NULL) {
+		DI_ERR("kzalloc for client%s fail\n", name);
+		return NULL;
+	}
+
+	client->name = kstrdup(name, GFP_KERNEL);
+	if (client->name == NULL) {
+		kfree(client);
+		DI_ERR("kstrdup for name(%s) fail\n", name);
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&client->node);
+
+	client->timeout.wait4start = 3 * 1000000000UL;
+	client->timeout.wait4finish = 3 * 1000000000UL;
+
+	init_waitqueue_head(&client->wait);
+	atomic_set(&client->wait_con, DI_PROC_STATE_IDLE);
+
+	client->apply_fixed_para = true;
+
+	client->dev_cdata = (uintptr_t)(
+		(char *)&client->dev_cdata + sizeof(client->dev_cdata));
+
+	if (di_drv_client_inc(client)) {
+		kfree(client);
+		return NULL;
+	}
+
+	return client;
+}
+EXPORT_SYMBOL_GPL(di_client_create);
+
+void di_client_destroy(void *client)
+{
+	struct di_client *c = (struct di_client *)client;
+	u32 i;
+
+	if (!di_drv_is_valid_client(c)) {
+		DI_ERR("%s, invalid client(%p)\n", __func__, c);
+		return;
+	}
+	di_drv_client_dec(c);
+
+	for (i = 0; i < ARRAY_SIZE(c->fb_pool); i++)
+		if (c->fb_pool[i].dma_item)
+			di_dma_buf_self_unmap(c->fb_pool[i].dma_item);
+
+	for (i = 0; i < ARRAY_SIZE(c->md_buf.mbuf); i++)
+		if (c->md_buf.mbuf[i])
+			di_dma_buf_unmap_free(c->md_buf.mbuf[i]);
+
+	di_dev_reset_cdata((void *)c->dev_cdata);
+
+	kfree(c->name);
+	kfree(c);
+}
+EXPORT_SYMBOL_GPL(di_client_destroy);
+
+int di_client_mem_request(struct di_client *c, void *data)
+{
+	struct di_mem_arg *mem = (struct di_mem_arg *)data;
+
+	mem->handle = di_mem_request(mem->size, &mem->phys_addr);
+
+	if (mem->handle < 0)
+		return -1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(di_client_mem_request);
+
+int di_client_mem_release(struct di_client *c, void *data)
+{
+	struct di_mem_arg *mem = (struct di_mem_arg *)data;
+
+	return mem->handle = di_mem_release(mem->handle);
+}
+EXPORT_SYMBOL_GPL(di_client_mem_release);
diff --git a/drivers/char/sunxi-di/drv_div3x/di_client.h b/drivers/char/sunxi-di/drv_div3x/di_client.h
new file mode 100644
index 000000000..0223aed11
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_client.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_CLIENT_H_
+#define _DI_CLIENT_H_
+
+#include "sunxi_di.h"
+#include "di_utils.h"
+
+#include <linux/types.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+
+#define DI_CLIENT_CNT_MAX 32
+
+#define DI_IN_FB_NUM_MAX 3
+#define DI_OUT_FB_NUM_MAX 3
+#define DI_FB_NUM_MAX (DI_IN_FB_NUM_MAX + DI_OUT_FB_NUM_MAX)
+
+enum di_mode {
+	DI_MODE_INVALID = 0,
+	DI_MODE_60HZ,
+	DI_MODE_30HZ,
+	DI_MODE_BOB,
+	DI_MODE_WEAVE,
+	DI_MODE_TNR, /* only tnr */
+};
+
+enum {
+	DI_PROC_STATE_IDLE = 0,
+	DI_PROC_STATE_FINISH = DI_PROC_STATE_IDLE,
+	DI_PROC_STATE_WAIT2START,
+	DI_PROC_STATE_2START,
+	DI_PROC_STATE_WAIT4FINISH,
+	DI_PROC_STATE_FINISH_ERR,
+};
+
+enum {
+	DI_DETECT_INTERLACE = 0,
+	DI_DETECT_PROGRESSIVE = 1,
+};
+
+/* buffer for md flags */
+struct di_md_buf {
+	u32 dir;
+	u32 w_bit;
+	u32 w_stride;
+	u32 h;
+	struct di_mapped_buf *mbuf[2];
+};
+
+/* for process fb */
+struct di_dma_fb {
+	struct di_fb *fb;
+	struct di_dma_item *dma_item;
+};
+
+struct di_client {
+	struct list_head node;
+	const char *name;
+
+	/* user setting para */
+	struct di_timeout_ns timeout;
+	struct di_size video_size;
+	struct di_dit_mode dit_mode;
+	struct di_tnr_mode tnr_mode;
+	struct di_fmd_enable fmd_en;
+	/* inner setting para */
+	enum di_mode mode;
+	bool md_en;
+	bool tnr_en;
+	bool vof_buf_en;
+	struct di_rect md_out_crop;
+	struct di_rect dit_out_crop;
+	struct di_rect tnr_out_crop;
+	struct di_rect fmd_out_crop;
+	struct di_rect dit_demo_crop;
+	struct di_rect tnr_demo_crop;
+	u32 vof_blk_size_sel;
+
+	struct di_process_fb_arg fb_arg;
+
+	/* dma fb resources pointers */
+	struct di_dma_fb *in_fb0;
+	struct di_dma_fb *in_fb1;
+	struct di_dma_fb *in_fb2;
+	struct di_dma_fb *out_dit_fb0;
+	struct di_dma_fb *out_dit_fb1;
+	struct di_dma_fb *out_tnr_fb0;
+	struct di_dma_fb *dma_di;
+	struct di_dma_fb *dma_p;
+	struct di_dma_fb *dma_c;
+	struct di_dma_fb *di_w0;
+	struct di_dma_fb *di_w1;
+	struct di_dma_fb *tnr_w;
+	/*dma fb resources. it is the memory that the above di_dma_fb* member point to*/
+	struct di_dma_fb fb_pool[DI_FB_NUM_MAX];
+
+	struct di_md_buf md_buf;
+
+	/* runtime context */
+	wait_queue_head_t wait;
+	atomic_t wait_con;
+	u64 proc_fb_seqno;
+	bool apply_fixed_para;
+	bool para_checked;
+	bool unreset;
+
+	u8 di_detect_result;
+	u64 interlace_detected_counts;
+	u64 lastest_interlace_detected_frame;
+	u64 interlace_detected_counts_exceed_first_p_frame;
+	u64 progressive_detected_counts;
+	u64 lastest_progressive_detected_frame;
+	u64 progressive_detected_first_frame;
+
+	/* dev_cdata must be at last!!! */
+	uintptr_t dev_cdata;
+};
+
+void *di_client_create(const char *name);
+void di_client_destroy(void *c);
+
+int di_client_mem_request(struct di_client *c, void *data);
+int di_client_mem_release(struct di_client *c, void *data);
+
+int di_client_get_version(struct di_client *c, struct di_version *version);
+int di_client_reset(struct di_client *c, void *data);
+int di_client_check_para(struct di_client *c, void *data);
+int di_client_set_timeout(struct di_client *c, struct di_timeout_ns *timeout);
+int di_client_set_video_size(struct di_client *c, struct di_size *size);
+int di_client_set_video_crop(struct di_client *c, struct di_rect *rect);
+int di_client_set_demo_crop(struct di_client *c,
+			struct di_demo_crop_arg *demo_arg);
+int di_client_set_dit_mode(struct di_client *c, struct di_dit_mode *mode);
+int di_client_set_tnr_mode(struct di_client *c, struct di_tnr_mode *mode);
+int di_client_set_fmd_enable(struct di_client *c, struct di_fmd_enable *en);
+int di_client_process_fb(struct di_client *c, struct di_process_fb_arg *fb_arg);
+
+
+#endif /* ifndef _DI_CLIENT_H_ */
diff --git a/drivers/char/sunxi-di/drv_div3x/di_debug.h b/drivers/char/sunxi-di/drv_div3x/di_debug.h
new file mode 100644
index 000000000..39fe93dd6
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_debug.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_DEBUG_H_
+#define _DI_DEBUG_H_
+
+#include <linux/printk.h>
+
+#if defined(CONFIG_FPGA_V4_PLATFORM) || defined(CONFIG_FPGA_V7_PLATFORM)
+#define DI_FPGA_TEST
+#endif
+
+/*
+ * debug control, you can switch on (delete 'x' suffix)
+ * to enable log output and assert mechanism.
+ */
+#define CONFIG_ENABLE_DEBUG
+
+#define PRINT printk
+
+/*
+ * debug level,
+ * if is DEBUG_LEVEL_DISABLE, no log is allowed output,
+ * if is DEBUG_LEVEL_ERR, only ERR is allowed output,
+ * if is DEBUG_LEVEL_INFO, ERR and INFO are allowed output,
+ * if is DEBUG_LEVEL_DEBUG, all log are allowed output,
+ */
+enum debug_level {
+	DEBUG_LEVEL_DISABLE = 0,
+	DEBUG_LEVEL_ERR,
+	DEBUG_LEVEL_INFO,
+	DEBUG_LEVEL_DEBUG,
+	DEBUG_LEVEL_TEST,
+	DEBUG_LEVEL_FMD,
+	DEBUG_LEVEL_MAX,
+};
+
+extern int debug_mask;
+
+#define DI_ERR(...)                      \
+do {                                     \
+	if (debug_mask >= DEBUG_LEVEL_ERR \
+		&& debug_mask < DEBUG_LEVEL_TEST) { \
+		PRINT(__VA_ARGS__);              \
+	}                                    \
+} while (0)
+
+#define DI_INFO(...)                      \
+do {                                      \
+	if (debug_mask >= DEBUG_LEVEL_INFO \
+		&& debug_mask < DEBUG_LEVEL_TEST) { \
+		PRINT(__VA_ARGS__);               \
+	}                                     \
+} while (0)
+
+#define DI_DEBUG(...)                      \
+do {                                       \
+	if (debug_mask >= DEBUG_LEVEL_DEBUG \
+		&& debug_mask < DEBUG_LEVEL_TEST) { \
+		PRINT(__VA_ARGS__);                \
+	}                                      \
+} while (0)
+
+#define DI_TEST(...)                      \
+do {                                       \
+	if (debug_mask == DEBUG_LEVEL_TEST) { \
+		PRINT(__VA_ARGS__);                \
+	}                                      \
+} while (0)
+
+#define DI_FMD(...)                      \
+do {                                       \
+	if (debug_mask == DEBUG_LEVEL_FMD \
+		|| debug_mask == DEBUG_LEVEL_DEBUG) { \
+		PRINT(__VA_ARGS__);                \
+	}                                      \
+} while (0)
+#endif /* _DI_DEBUG_H_ */
diff --git a/drivers/char/sunxi-di/drv_div3x/di_dev.h b/drivers/char/sunxi-di/drv_div3x/di_dev.h
new file mode 100644
index 000000000..a3c0c8c5a
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_dev.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_DEV_H_
+#define _DI_DEV_H_
+
+#ifdef CONFIG_ARCH_SUN50IW9
+#define USE_DI300
+#endif
+
+#ifdef USE_DI300
+#include "lowlevel_v3x/di300.h"
+#endif
+
+#endif /* #ifndef _DI_DEV_H_ */
diff --git a/drivers/char/sunxi-di/drv_div3x/di_driver.c b/drivers/char/sunxi-di/drv_div3x/di_driver.c
new file mode 100644
index 000000000..95b81ab2a
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_driver.c
@@ -0,0 +1,1052 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "di_driver.h"
+#include "di_dev.h"
+#include "di_fops.h"
+#include "di_utils.h"
+#include "di_debug.h"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+
+
+#define DI_MODULE_NAME "deinterlace"
+#define TAG "[DI]"
+
+#define DI_VERSION_MAJOR 1
+#define DI_VERSION_MINOR 0
+#define DI_VERSION_PATCHLEVEL 0
+
+static struct di_driver_data *di_drvdata;
+static unsigned int di_debug_mode;
+
+unsigned int di_device_get_debug_mode(void)
+{
+	return di_debug_mode;
+}
+
+int di_drv_get_version(struct di_version *version)
+{
+	if (version) {
+		version->version_major = DI_VERSION_MAJOR;
+		version->version_minor = DI_VERSION_MINOR;
+		version->version_patchlevel = DI_VERSION_PATCHLEVEL;
+		version->ip_version = di_dev_get_ip_version();
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static ssize_t di_device_debug_mode_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t n = 0;
+
+	n += sprintf(buf + n, "1:enable debug mode   0:disable debug mode\n");
+	n += sprintf(buf + n, "current debug_mode:%d\n", di_debug_mode);
+
+	return n;
+}
+
+static ssize_t di_device_debug_mode_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	char *end;
+
+	di_debug_mode = (unsigned int)simple_strtoull(buf, &end, 0);
+
+	return count;
+}
+
+static DEVICE_ATTR(debug_mode, S_IWUSR | S_IRUGO,
+	di_device_debug_mode_show, di_device_debug_mode_store);
+
+static ssize_t
+di_device_debug_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+
+	n += sprintf(buf + n,
+	"echo [level] > /sys/class/deinterlace/deinterlace/debug\n");
+
+	n += sprintf(buf + n, "level 0: disable all kinds of di logs\n");
+	n += sprintf(buf + n, "level 1: enable error di logs\n");
+	n += sprintf(buf + n, "level 2: enable info di logs\n");
+	n += sprintf(buf + n, "level 3: enable debug di logs\n");
+	n += sprintf(buf + n, "level 4: enable debug di time detect logs\n");
+	n += sprintf(buf + n, "level 5: enable film mode detect logs\n");
+
+	n += sprintf(buf + n, "\nNow the debug level is:%d\n", debug_mask);
+
+	return n;
+}
+
+static ssize_t
+di_device_debug_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int val;
+	char *end;
+
+	retval = count;
+	val = simple_strtoull(buf, &end, 0);
+
+	if (val < DEBUG_LEVEL_MAX) {
+		debug_mask = val;
+	} else {
+		pr_err("ERROR: invalid input log level:%u\n", val);
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static DEVICE_ATTR(debug, S_IWUSR | S_IRUGO,
+	di_device_debug_show, di_device_debug_store);
+
+static ssize_t
+di_device_info_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct di_driver_data *data = di_drvdata;
+	ssize_t n = 0;
+
+	n += sprintf(buf + n, "DI Current Info:\n");
+	n += sprintf(buf + n, "irq_no:%u\n", data->irq_no);
+	n += sprintf(buf + n, "dev enable:%u pm_state:%s\n",
+		data->dev_enable, data->pm_state ? "suspend" : "resume");
+	n += sprintf(buf + n, "need_apply_fixed_para:%u\n",
+		data->need_apply_fixed_para);
+	n += sprintf(buf + n, "driver state:%s\n",
+		data->state ? "busy" : "idle");
+	return n;
+}
+
+static DEVICE_ATTR(info, S_IWUSR | S_IRUGO,
+	di_device_info_show, NULL);
+
+static char debug_client_name[30];
+
+static ssize_t dump_client_info(struct di_client *client, char *buf)
+{
+	ssize_t n = 0;
+
+	if (!client)
+		return 0;
+	n += sprintf(buf + n, "clients:%s basic info:\n", client->name);
+	n += sprintf(buf + n, "di_mode:%s\n",
+		client->mode == DI_MODE_60HZ ? "60HZ" :
+		client->mode == DI_MODE_30HZ ? "30HZ" :
+		client->mode == DI_MODE_BOB ? "bob" :
+		client->mode == DI_MODE_WEAVE ? "weave" :
+		client->mode == DI_MODE_TNR ? "only tnr" : "Unknowed");
+	n += sprintf(buf + n, "proc_fb_seqno:%llu\n", client->proc_fb_seqno);
+
+	n += sprintf(buf + n, "di_detect_result:%s\n",
+		client->di_detect_result ? "progressive" : "interlace");
+	n += sprintf(buf + n, "interlace_detected_counts:%llu\n",
+		client->interlace_detected_counts);
+	n += sprintf(buf + n, "lastest_interlace_detected_frame:%llu\n",
+		client->lastest_interlace_detected_frame);
+	n += sprintf(buf + n, "progressive_detected_counts:%llu\n",
+		client->progressive_detected_counts);
+	n += sprintf(buf + n, "progressive_detected_first_frame:%llu\n",
+		client->progressive_detected_first_frame);
+	n += sprintf(buf + n, "lastest_progressive_detected_frame:%llu\n",
+		client->lastest_progressive_detected_frame);
+	n += sprintf(buf + n, "warning!!! detection:interlace_detected_counts_exceed_first_progressive_frame:%llu\n",
+		client->interlace_detected_counts_exceed_first_p_frame);
+	return n;
+}
+static ssize_t di_device_client_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+
+	n += sprintf(buf + n, "All of the di clients name:\n");
+	list_for_each_entry(client, &drvdata->clients, node)
+		n += sprintf(buf + n, "%s\n", client->name);
+	n += sprintf(buf + n, "\n\n");
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		n += dump_client_info(client, buf + n);
+		if (!strcmp(client->name, debug_client_name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		n += sprintf(buf + n, "Wrong debug_client_name:%s, please ",
+			debug_client_name);
+		n += sprintf(buf + n,
+		 "echo [client_name] > /sys/class/deinterlace/deinterlace/client\n");
+		return n;
+	}
+
+	n += sprintf(buf + n, "%s info\n",
+			debug_client_name);
+
+	return n;
+}
+
+static ssize_t
+di_device_client_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+	char name[30] = { 0 };
+
+	memcpy(name, buf, count);
+
+	name[count - 1] = '\0';
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(name, client->name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		DI_ERR("ERROR client name input:%s\n", buf);
+		return count;
+	}
+
+	strcpy(debug_client_name, client->name);
+
+	pr_info("set the debug client name:%s\n", debug_client_name);
+
+	return count;
+}
+
+static DEVICE_ATTR(client, S_IWUSR | S_IRUGO,
+	di_device_client_show, di_device_client_store);
+
+static ssize_t di_device_timeout_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+
+
+	n += sprintf(buf + n, "debug_client_name:%s\n", debug_client_name);
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(client->name, debug_client_name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		n += sprintf(buf + n, "Wrong debug_client_name:%s, please ",
+				debug_client_name);
+		n += sprintf(buf + n,
+		 "echo [client_name] > /sys/class/deinterlace/deinterlace/client\n");
+		return n;
+	}
+
+	n += sprintf(buf + n, "wait4start:%lld  wait4finish:%lld\n",
+		client->timeout.wait4start, client->timeout.wait4finish);
+
+	return n;
+}
+
+static ssize_t
+di_device_timeout_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t n = 0;
+	unsigned long long start, finish;
+	char *end;
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+
+
+	pr_info("debug_client_name:%s\n", debug_client_name);
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(client->name, debug_client_name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		pr_info("Wrong debug_client_name:%s, please ", debug_client_name);
+		pr_info("echo [client_name] > /sys/class/deinterlace/deinterlace/client\n");
+		return n;
+	}
+
+	start = simple_strtoull(buf, &end, 0);
+	pr_info("set timeout, wait2start:%lld\n", start);
+
+	if ((*end != ' ') && (*end != ',')) {
+		pr_err("error separator:%c\n", *end);
+		return count;
+	}
+
+	finish = simple_strtoull(end + 1, &end, 0);
+	pr_info("set timeout, wait2finish:%lld\n", finish);
+
+	client->timeout.wait4start = start;
+	client->timeout.wait4finish = finish;
+
+	pr_info("set timeout wait4start:%lld  wait4finish:%lld\n",
+		client->timeout.wait4start, client->timeout.wait4finish);
+
+	return count;
+}
+
+static DEVICE_ATTR(timeout, S_IWUSR | S_IRUGO,
+	di_device_timeout_show, di_device_timeout_store);
+
+static ssize_t di_device_tnrmode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+
+
+	n += sprintf(buf + n, "debug_client_name:%s\n", debug_client_name);
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(client->name, debug_client_name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		n += sprintf(buf + n, "Wrong debug_client_name:%s, please ",
+				debug_client_name);
+		n += sprintf(buf + n,
+		 "echo [client_name] > /sys/class/deinterlace/deinterlace/client\n");
+		return n;
+	}
+
+	n += sprintf(buf + n, "TNR mode:%d  level:%d\n",
+		client->tnr_mode.mode, client->tnr_mode.level);
+
+	return n;
+}
+
+static ssize_t
+di_device_tnrmode_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t n = 0;
+	unsigned int mode, level;
+	char *end;
+	struct di_client *client;
+	bool find = false;
+	struct di_driver_data *drvdata = di_drvdata;
+
+
+	pr_info("debug_client_name:%s\n", debug_client_name);
+
+	list_for_each_entry(client, &drvdata->clients, node) {
+		if (!strcmp(client->name, debug_client_name)) {
+			find = true;
+			break;
+		}
+	}
+
+	if (!find) {
+		pr_info("Wrong debug_client_name:%s, please ", debug_client_name);
+		pr_info("echo [client_name] > /sys/class/deinterlace/deinterlace/client\n");
+		return n;
+	}
+
+	mode = (unsigned int)simple_strtoull(buf, &end, 0);
+
+	if ((*end != ' ') && (*end != ',')) {
+		pr_err("error separator:%c\n", *end);
+		return count;
+	}
+
+	level = (unsigned int)simple_strtoull(end + 1, &end, 0);
+
+	client->tnr_mode.mode = mode;
+	client->tnr_mode.level = level;
+
+	pr_info("TNR mode:%d  level:%d\n",
+		client->tnr_mode.mode, client->tnr_mode.level);
+
+	return count;
+}
+
+static DEVICE_ATTR(tnrmode, S_IWUSR | S_IRUGO,
+	di_device_tnrmode_show, di_device_tnrmode_store);
+
+static struct attribute *di_device_attrs[] = {
+	 &dev_attr_debug_mode.attr,
+	&dev_attr_debug.attr,
+	&dev_attr_info.attr,
+	&dev_attr_client.attr,
+	&dev_attr_timeout.attr,
+	&dev_attr_tnrmode.attr,
+	NULL
+};
+
+static struct attribute_group di_device_attr_group = {
+	.attrs	= di_device_attrs,
+};
+
+static const struct attribute_group *di_device_attr_groups[] = {
+	&di_device_attr_group,
+	NULL
+};
+
+static int di_init_hw(struct di_driver_data *drvdata)
+{
+	di_dev_set_reg_base(drvdata->reg_base);
+	return 0;
+}
+
+static int di_clk_enable(struct di_driver_data *drvdata)
+{
+	if (!IS_ERR_OR_NULL(drvdata->iclk)) {
+		int ret = clk_prepare_enable(drvdata->iclk);
+
+		if (ret) {
+			DI_ERR(TAG"try to enable di clk failed!\n");
+			return ret;
+		}
+
+		if (!IS_ERR_OR_NULL(drvdata->clk_bus))
+			clk_prepare_enable(drvdata->clk_bus);
+
+		if (!IS_ERR_OR_NULL(drvdata->rst_bus_di))
+			reset_control_deassert(drvdata->rst_bus_di);
+	} else {
+		DI_INFO(TAG"di clk handle is invalid for enable\n");
+	}
+	return 0;
+}
+
+static int di_clk_disable(struct di_driver_data *drvdata)
+{
+	if (!IS_ERR_OR_NULL(drvdata->iclk)) {
+		clk_disable_unprepare(drvdata->iclk);
+		if (!IS_ERR_OR_NULL(drvdata->rst_bus_di))
+			reset_control_assert(drvdata->rst_bus_di);
+
+	} else
+		DI_INFO(TAG"di clk handle is invalid!\n");
+	return 0;
+}
+
+static int di_check_enable_device_locked(
+	struct di_driver_data *drvdata)
+{
+	int ret = 0;
+
+	DI_DEBUG(TAG"client_cnt=%d, pm_state=%d, dev_en=%d\n",
+		drvdata->client_cnt, drvdata->pm_state, drvdata->dev_enable);
+
+	if (drvdata->pm_state == DI_PM_STATE_SUSPEND)
+		return 0;
+
+	if ((drvdata->client_cnt > 0)
+		&& (drvdata->dev_enable == false)) {
+		ret = di_clk_enable(drvdata);
+		if (ret)
+			return ret;
+		drvdata->dev_enable = true;
+		di_dev_enable_irq(DI_IRQ_FLAG_PROC_FINISH, 1);
+	} else if ((drvdata->client_cnt == 0)
+		&& (drvdata->dev_enable == true)) {
+		di_dev_enable_irq(DI_IRQ_FLAG_PROC_FINISH, 0);
+		ret = di_clk_disable(drvdata);
+		if (ret)
+			return ret;
+		drvdata->dev_enable = false;
+	} else if (drvdata->client_cnt < 0) {
+		DI_ERR(TAG"err client_cnt=%d\n", drvdata->client_cnt);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+bool di_drv_is_valid_client(struct di_client *c)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+	struct di_client *client;
+	bool valid = false;
+
+	if (c) {
+		mutex_lock(&drvdata->mlock);
+		list_for_each_entry(client, &drvdata->clients, node) {
+			if (client == c) {
+				valid = true;
+				break;
+			}
+		}
+		mutex_unlock(&drvdata->mlock);
+	}
+
+	if (!valid)
+		DI_ERR("invalid client[0x%p]\n", c);
+
+	return valid;
+}
+
+int di_drv_client_inc(struct di_client *c)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+	int client_cnt;
+
+	mutex_lock(&drvdata->mlock);
+	client_cnt = drvdata->client_cnt + 1;
+	if (client_cnt > DI_CLIENT_CNT_MAX) {
+		mutex_unlock(&drvdata->mlock);
+		DI_ERR(TAG"%s: %d > max_clients[%d]\n",
+			__func__, client_cnt, DI_CLIENT_CNT_MAX);
+		return -EINVAL;
+	}
+	drvdata->client_cnt = client_cnt;
+	list_add_tail(&c->node, &drvdata->clients);
+	di_check_enable_device_locked(drvdata);
+	mutex_unlock(&drvdata->mlock);
+
+	return 0;
+}
+
+int di_drv_client_dec(struct di_client *c)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+	int client_cnt;
+
+	mutex_lock(&drvdata->mlock);
+	list_del(&c->node);
+	if (drvdata->pre_client == c) {
+		drvdata->pre_client = NULL;
+		drvdata->need_apply_fixed_para = true;
+	}
+	client_cnt = drvdata->client_cnt;
+	if (client_cnt > 0) {
+		drvdata->client_cnt--;
+		di_check_enable_device_locked(drvdata);
+	} else {
+		mutex_unlock(&drvdata->mlock);
+		DI_INFO(TAG"%s:client_cnt=%d\n", __func__, client_cnt);
+		return -EINVAL;
+	}
+	mutex_unlock(&drvdata->mlock);
+
+	return 0;
+}
+
+static int di_drv_wait2start(
+	struct di_driver_data *drvdata, struct di_client *c)
+{
+	const u64 wait2start = c->timeout.wait4start;
+	long ret = 0;
+	unsigned long flags;
+	u32 id;
+	u32 wait_con;
+
+	spin_lock_irqsave(&drvdata->queue_lock, flags);
+
+	if (drvdata->task_cnt >= DI_TASK_CNT_MAX) {
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+		DI_ERR(TAG"too many tasks %d\n", drvdata->task_cnt);
+		return -EBUSY;
+	}
+
+	id = (drvdata->front + drvdata->task_cnt) % DI_TASK_CNT_MAX;
+	drvdata->queue[id] = c;
+	drvdata->task_cnt++;
+	if (drvdata->state == DI_DRV_STATE_IDLE) {
+		drvdata->state = DI_DRV_STATE_BUSY;
+		atomic_set(&c->wait_con, DI_PROC_STATE_2START);
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+		return 0;
+	}
+
+	if (wait2start == 0) {
+		drvdata->queue[id] = NULL;
+		drvdata->task_cnt--;
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+		DI_ERR(TAG"wait4start=%lluns too short to wait\n",
+			wait2start);
+		return -ETIMEDOUT;
+	}
+	atomic_set(&c->wait_con, DI_PROC_STATE_WAIT2START);
+
+	spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+
+	ret = wait_event_interruptible_hrtimeout(c->wait,
+		atomic_read(&c->wait_con) == DI_PROC_STATE_2START,
+		ns_to_ktime(wait2start));
+
+	if (atomic_read(&c->wait_con) != DI_PROC_STATE_2START) {
+		spin_lock_irqsave(&drvdata->queue_lock, flags);
+		wait_con = atomic_read(&c->wait_con); /* check-again */
+		if (wait_con != DI_PROC_STATE_2START) {
+			drvdata->queue[id] = NULL;
+			drvdata->task_cnt--;
+			spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+			DI_ERR(TAG"wait2start(%lluns) fail, con=%u, ret(%ld)\n",
+				wait2start, wait_con, ret);
+			return -ETIMEDOUT;
+		}
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+	}
+
+	return 0;
+}
+
+static int di_drv_wait4finish(
+	struct di_driver_data *drvdata, struct di_client *c)
+{
+	long ret = 0;
+	unsigned long flags;
+	int wait_con;
+	const u64 wait4finish = c->timeout.wait4finish;
+
+	ret = wait_event_interruptible_hrtimeout(c->wait,
+		atomic_read(&c->wait_con) != DI_PROC_STATE_WAIT4FINISH,
+		ns_to_ktime(wait4finish));
+
+	if (atomic_read(&c->wait_con) != DI_PROC_STATE_FINISH) {
+		spin_lock_irqsave(&drvdata->queue_lock, flags);
+		wait_con = atomic_read(&c->wait_con); /* check-again */
+		if (wait_con == DI_PROC_STATE_WAIT4FINISH) {
+			di_dev_reset();
+			di_dev_query_state_with_clear(DI_IRQ_STATE_PROC_FINISH);
+			drvdata->queue[drvdata->front] = NULL;
+			drvdata->front = (drvdata->front + 1) % DI_TASK_CNT_MAX;
+			drvdata->task_cnt--;
+			drvdata->state = DI_DRV_STATE_IDLE;
+		}
+		spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+
+		if (wait_con == DI_PROC_STATE_WAIT4FINISH) {
+			DI_ERR(TAG"wait4finish(%lluns) timeout, ret=%ld\n",
+				wait4finish, ret);
+			return ret ? ret : -ETIME;
+		} else if (wait_con != DI_PROC_STATE_FINISH) {
+			DI_ERR(TAG"wait4finish(%lluns) err, ret=%ld, con=%u\n",
+				wait4finish, ret, wait_con);
+			return ret ? ret : -wait_con;
+		}
+	}
+
+	DI_DEBUG("Processing frame %llu\n", c->proc_fb_seqno);
+	c->proc_fb_seqno++;
+	return 0;
+}
+
+static inline void di_drv_start(
+	struct di_driver_data *drvdata, struct di_client *c)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&drvdata->queue_lock, flags);
+	atomic_set(&c->wait_con, DI_PROC_STATE_WAIT4FINISH);
+	di_dev_start(1);
+	spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+}
+
+static void di_drv_survey_spot(
+	struct di_driver_data *drvdata, struct di_client *c)
+{
+	struct di_client *pre_client = NULL;
+
+	mutex_lock(&drvdata->mlock);
+
+	if (((drvdata->pre_client == NULL)
+		&& (drvdata->need_apply_fixed_para == false))
+		|| (drvdata->pre_client == c))
+		goto out;
+
+	pre_client = drvdata->pre_client;
+	if (pre_client) {
+		if ((pre_client->proc_fb_seqno > 0)
+			&& (pre_client->para_checked == true))
+			di_dev_save_spot(pre_client);
+	}
+	di_dev_restore_spot(c);
+	c->apply_fixed_para = true;
+
+out:
+	drvdata->pre_client = c;
+	drvdata->need_apply_fixed_para = false;
+	mutex_unlock(&drvdata->mlock);
+}
+
+/* caller must make sure c is valid */
+int di_drv_process_fb(struct di_client *c)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+	int ret = 0;
+
+	ret = di_drv_wait2start(drvdata, c);
+	if (ret)
+		return ret;
+
+	di_drv_survey_spot(drvdata, c);
+	if (unlikely(c->apply_fixed_para)) {
+		c->apply_fixed_para = false;
+		di_dev_apply_fixed_para(c);
+	}
+	ret = di_dev_apply_para(c);
+	di_dev_dump_reg_value();
+	di_drv_start(drvdata, c);
+
+	ret |= di_drv_wait4finish(drvdata, c);
+
+	return ret;
+}
+
+static irqreturn_t di_irq_handler(int irq, void *dev_id)
+{
+	struct di_driver_data *drvdata = dev_id;
+	unsigned long flags;
+	struct di_client *c;
+	int wait_con;
+	u32 hw_state;
+
+	if (irq != drvdata->irq_no)
+		return IRQ_NONE;
+
+	spin_lock_irqsave(&drvdata->queue_lock, flags);
+
+	hw_state = di_dev_query_state_with_clear(DI_IRQ_STATE_PROC_FINISH);
+
+	if (drvdata->task_cnt == 0)
+		goto irq_out;
+
+	c = drvdata->queue[drvdata->front];
+	wait_con = atomic_read(&c->wait_con);
+	if (wait_con == DI_PROC_STATE_WAIT4FINISH) {
+		if (hw_state & DI_IRQ_STATE_PROC_FINISH) {
+			di_dev_get_proc_result(c);
+			atomic_set(&c->wait_con, DI_PROC_STATE_FINISH);
+			wake_up_interruptible(&c->wait);
+		} else {
+			di_dev_reset();
+			atomic_set(&c->wait_con, DI_PROC_STATE_FINISH_ERR);
+			wake_up_interruptible(&c->wait);
+		}
+		drvdata->queue[drvdata->front] = NULL;
+		drvdata->task_cnt--;
+		drvdata->state = DI_DRV_STATE_IDLE;
+
+		if (drvdata->task_cnt == 0)
+			goto irq_out;
+
+		drvdata->front = (drvdata->front + 1) % DI_TASK_CNT_MAX;
+		c = drvdata->queue[drvdata->front];
+		wait_con = atomic_read(&c->wait_con);
+	}
+
+	if (wait_con == DI_PROC_STATE_WAIT2START) {
+		atomic_set(&c->wait_con, DI_PROC_STATE_2START);
+		drvdata->state = DI_DRV_STATE_BUSY;
+		wake_up_interruptible(&c->wait);
+	}
+
+irq_out:
+	spin_unlock_irqrestore(&drvdata->queue_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/* unload resources of di device */
+static void di_unload_resource(struct di_driver_data *drvdata)
+{
+	if (drvdata->reg_base)
+		iounmap(drvdata->reg_base);
+
+	if (drvdata->irq_no != 0)
+		DI_INFO(TAG"maybe should ummap irq[%d]...\n", drvdata->irq_no);
+
+	if (!IS_ERR_OR_NULL(drvdata->clk_source))
+		clk_put(drvdata->clk_source);
+	if (!IS_ERR_OR_NULL(drvdata->iclk))
+		clk_put(drvdata->iclk);
+}
+
+/* parse and load resources of di device */
+static int di_parse_dt(struct platform_device *pdev,
+	struct di_driver_data *drvdata)
+{
+	int ret = 0;
+	struct device_node *node = pdev->dev.of_node;
+
+	/* clk */
+	drvdata->iclk = of_clk_get(node, 0);
+	if (IS_ERR_OR_NULL(drvdata->iclk)) {
+		DI_ERR(TAG"get di clock failed!\n");
+		ret = PTR_ERR(drvdata->iclk);
+		goto err_out;
+	}
+
+	drvdata->rst_bus_di = devm_reset_control_get(&pdev->dev, "rst_bus_di");
+	if (IS_ERR(drvdata->rst_bus_di)) {
+		DI_ERR(TAG"get di bus reset control  failed!\n");
+		ret = PTR_ERR(drvdata->rst_bus_di);
+		goto err_out;
+	}
+
+	drvdata->clk_bus = of_clk_get(node, 1);
+	if (IS_ERR_OR_NULL(drvdata->clk_bus)) {
+		DI_ERR(TAG"get clk_source clock failed!\n");
+		ret = PTR_ERR(drvdata->clk_bus);
+		goto err_out;
+	}
+	/* fixme: set iclk's parent as clk_source */
+
+	/* irq */
+	drvdata->irq_no = irq_of_parse_and_map(node, 0);
+	if (drvdata->irq_no == 0) {
+		DI_ERR(TAG"platform_get_irq failed!\n");
+		ret = -EINVAL;
+		goto err_out;
+	}
+	ret = devm_request_irq(&pdev->dev, drvdata->irq_no,
+		di_irq_handler, 0, dev_name(&pdev->dev), drvdata);
+	if (ret) {
+		DI_ERR(TAG"devm_request_irq failed\n");
+		goto err_out;
+	}
+	DI_DEBUG(TAG"di irq_no=%u\n", drvdata->irq_no);
+
+	/* reg */
+	drvdata->reg_base = of_iomap(node, 0);
+	if (!drvdata->reg_base) {
+		DI_ERR(TAG"of_iomap failed\n");
+		ret =  -ENOMEM;
+		goto err_out;
+	}
+	DI_DEBUG(TAG"di reg_base=0x%p\n", drvdata->reg_base);
+
+err_out:
+	return ret;
+}
+
+static int di_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device_node *node = pdev->dev.of_node;
+	struct di_driver_data *drvdata = NULL;
+
+	if (!of_device_is_available(node)) {
+		DI_ERR(TAG"DEINTERLACE device is not configed\n");
+		return -ENODEV;
+	}
+
+	drvdata = kzalloc(sizeof(*drvdata), GFP_KERNEL);
+	if (drvdata == NULL) {
+		DI_ERR(TAG"kzalloc for drvdata failed\n");
+		return -ENOMEM;
+	}
+
+	ret = di_parse_dt(pdev, drvdata);
+	if (ret)
+		goto probe_done;
+	clk_prepare_enable(drvdata->iclk);
+
+	di_utils_set_dma_dev(&pdev->dev);
+
+	ret = di_init_hw(drvdata);
+	if (ret)
+		goto probe_done;
+
+	mutex_init(&drvdata->mlock);
+	INIT_LIST_HEAD(&drvdata->clients);
+	spin_lock_init(&drvdata->queue_lock);
+
+	alloc_chrdev_region(&drvdata->devt, 0, 1, DI_MODULE_NAME);
+	drvdata->pcdev = cdev_alloc();
+	cdev_init(drvdata->pcdev, &di_fops);
+	drvdata->pcdev->owner = THIS_MODULE;
+	ret = cdev_add(drvdata->pcdev, drvdata->devt, 1);
+	if (ret) {
+		DI_ERR(TAG"cdev add major(%d).\n", MAJOR(drvdata->devt));
+		goto probe_done;
+	}
+	drvdata->pclass = class_create(THIS_MODULE, DI_MODULE_NAME);
+	if (IS_ERR(drvdata->pclass)) {
+		DI_ERR(TAG"create class error\n");
+		ret = PTR_ERR(drvdata->pclass);
+		goto probe_done;
+	}
+
+	drvdata->pdev = device_create_with_groups(
+			drvdata->pclass,  NULL, drvdata->devt,
+			NULL, di_device_attr_groups,
+			DI_MODULE_NAME);
+	if (IS_ERR(drvdata->pdev)) {
+		DI_ERR(TAG"device_create error\n");
+		ret = PTR_ERR(drvdata->pdev);
+		goto probe_done;
+	}
+
+	di_drvdata = drvdata;
+	platform_set_drvdata(pdev, (void *)drvdata);
+
+	do {
+		struct di_version version;
+
+		di_drv_get_version(&version);
+		dev_info(&pdev->dev, "version[%d.%d.%d], ip=0x%x\n",
+			version.version_major,
+			version.version_minor,
+			version.version_patchlevel,
+			version.ip_version);
+	} while (0);
+
+	return 0;
+
+probe_done:
+	if (ret) {
+		di_dev_exit();
+		di_unload_resource(drvdata);
+		kfree(drvdata);
+		dev_err(&pdev->dev, "probe failed, errno %d!\n", ret);
+	}
+
+	return ret;
+
+}
+
+static int di_remove(struct platform_device *pdev)
+{
+	struct di_driver_data *drvdata;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	drvdata = platform_get_drvdata(pdev);
+	if (drvdata != NULL) {
+		platform_set_drvdata(pdev, NULL);
+		di_drvdata = NULL;
+
+		if (drvdata->client_cnt > 0)
+			DI_ERR(TAG"still has client_cnt=%d\n",
+				drvdata->client_cnt);
+
+		device_destroy(drvdata->pclass, drvdata->devt);
+		class_destroy(drvdata->pclass);
+		cdev_del(drvdata->pcdev);
+		unregister_chrdev_region(drvdata->devt, 1);
+
+		di_dev_exit();
+		di_unload_resource(drvdata);
+
+		kfree(drvdata);
+	}
+
+	return 0;
+}
+
+static int di_suspend(struct device *dev)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+
+	if (drvdata->state == DI_DRV_STATE_BUSY)
+		DI_INFO(TAG"drv busy on suspend !\n");
+
+	mutex_lock(&drvdata->mlock);
+	drvdata->pm_state = DI_PM_STATE_SUSPEND;
+	if (drvdata->dev_enable == true) {
+		if (drvdata->pre_client)
+			di_dev_save_spot(drvdata->pre_client);
+		di_dev_enable_irq(DI_IRQ_FLAG_PROC_FINISH, 0);
+		if (di_clk_disable(drvdata))
+			drvdata->dev_enable = false;
+	}
+	mutex_unlock(&drvdata->mlock);
+	return 0;
+}
+
+static int di_resume(struct device *dev)
+{
+	struct di_driver_data *drvdata = di_drvdata;
+
+	mutex_lock(&drvdata->mlock);
+	if (drvdata->client_cnt > 0) {
+		if (di_clk_enable(drvdata))
+			drvdata->dev_enable = true;
+		di_dev_enable_irq(DI_IRQ_FLAG_PROC_FINISH, 1);
+		if (drvdata->pre_client) {
+			di_dev_restore_spot(drvdata->pre_client);
+			drvdata->pre_client->apply_fixed_para = true;
+		}
+	}
+	drvdata->pm_state = DI_PM_STATE_RESUME;
+	mutex_unlock(&drvdata->mlock);
+	return 0;
+}
+
+static const struct dev_pm_ops di_pm_ops = {
+	.suspend = di_suspend,
+	.resume = di_resume,
+};
+
+static const struct of_device_id di_dt_match[] = {
+	{.compatible = "allwinner,sunxi-deinterlace"},
+	{},
+};
+
+static struct platform_driver di_driver = {
+	.probe = di_probe,
+	.remove = di_remove,
+	.driver = {
+		.name = DI_MODULE_NAME,
+		.owner = THIS_MODULE,
+		.pm = &di_pm_ops,
+		.of_match_table = di_dt_match,
+	},
+};
+
+module_platform_driver(di_driver);
+
+int debug_mask = DEBUG_LEVEL_ERR;
+module_param_named(debug_mask, debug_mask, int, 0644);
+
+MODULE_DEVICE_TABLE(of, di_dt_match);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("hezuyao@allwinnertech.com");
+MODULE_AUTHOR("zhengwanyu@allwinnertech.com");
+MODULE_DESCRIPTION("Sunxi De-Interlace");
diff --git a/drivers/char/sunxi-di/drv_div3x/di_driver.h b/drivers/char/sunxi-di/drv_div3x/di_driver.h
new file mode 100644
index 000000000..f05822d2f
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_driver.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_DRIVER_H_
+#define _DI_DRIVER_H_
+
+#include "di_client.h"
+
+#include <linux/types.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+
+#define DI_TASK_CNT_MAX DI_CLIENT_CNT_MAX
+
+enum di_drv_state {
+	DI_DRV_STATE_IDLE = 0,
+	DI_DRV_STATE_BUSY,
+};
+
+enum di_pm_state {
+	DI_PM_STATE_RESUME = 0,
+	DI_PM_STATE_SUSPEND,
+	DI_PM_STATE_UNKNOWN,
+};
+
+struct di_driver_data {
+	dev_t devt;
+	struct cdev *pcdev;
+	struct class *pclass;
+	struct device *pdev;
+
+	void __iomem *reg_base;
+	u32  irq_no;
+	struct clk *clk_source;
+	struct clk *clk_bus;
+	struct clk *iclk;
+	struct reset_control *rst_bus_di;
+
+	struct mutex mlock;
+	struct list_head clients;
+	int client_cnt;
+	bool dev_enable;
+	enum di_pm_state pm_state;
+	struct di_client *pre_client;
+	bool need_apply_fixed_para;
+
+	spinlock_t queue_lock;
+	u32 front;
+	u32 task_cnt; /* client task count in queue */
+	struct di_client *queue[DI_TASK_CNT_MAX];
+	enum di_drv_state state;
+
+};
+
+#endif /* #ifndef _DI_DRIVER_H_ */
diff --git a/drivers/char/sunxi-di/drv_div3x/di_fops.c b/drivers/char/sunxi-di/drv_div3x/di_fops.c
new file mode 100644
index 000000000..569738fd9
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_fops.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "sunxi_di.h"
+#include "di_client.h"
+
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+
+typedef int di_ioctl_t(struct di_client *c, void *data);
+
+struct di_ioctl_desc {
+	unsigned int cmd;
+	di_ioctl_t *func;
+	const char *name;
+};
+
+#define DI_IOCTL_DEF(ioctl, _func)	\
+	[DI_IOCTL_NR(ioctl)] = {		\
+		.cmd = ioctl,			\
+		.func = (di_ioctl_t *)_func,	\
+		.name = #ioctl			\
+	}
+
+/* Ioctl table */
+static const struct di_ioctl_desc di_ioctls[] = {
+	DI_IOCTL_DEF(DI_IOC_GET_VERSION, di_client_get_version),
+	DI_IOCTL_DEF(DI_IOC_RESET, di_client_reset),
+	DI_IOCTL_DEF(DI_IOC_CHECK_PARA, di_client_check_para),
+	DI_IOCTL_DEF(DI_IOC_SET_TIMEOUT, di_client_set_timeout),
+	DI_IOCTL_DEF(DI_IOC_SET_VIDEO_SIZE, di_client_set_video_size),
+	DI_IOCTL_DEF(DI_IOC_SET_VIDEO_CROP, di_client_set_video_crop),
+	DI_IOCTL_DEF(DI_IOC_SET_DIT_MODE, di_client_set_dit_mode),
+	DI_IOCTL_DEF(DI_IOC_SET_TNR_MODE, di_client_set_tnr_mode),
+	DI_IOCTL_DEF(DI_IOC_SET_DEMO_CROP, di_client_set_demo_crop),
+	DI_IOCTL_DEF(DI_IOC_SET_FMD_ENABLE, di_client_set_fmd_enable),
+	DI_IOCTL_DEF(DI_IOC_PROCESS_FB, di_client_process_fb),
+
+	DI_IOCTL_DEF(DI_IOC_MEM_REQUEST, di_client_mem_request),
+	DI_IOCTL_DEF(DI_IOC_MEM_RELEASE, di_client_mem_release),
+};
+
+#define DI_IOCTL_COUNT	ARRAY_SIZE(di_ioctls)
+
+static long di_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = -EINVAL;
+	struct di_client *c = file->private_data;
+	const struct di_ioctl_desc *ioctl = NULL;
+	unsigned int nr = DI_IOCTL_NR(cmd);
+	char stack_kdata[128];
+	char *kdata = NULL;
+	unsigned int in_size, out_size, ksize;
+
+	if ((c == NULL)
+		|| (nr >= DI_IOCTL_COUNT)) {
+		return -EINVAL;
+	}
+
+	in_size = out_size = ksize = _IOC_SIZE(cmd);
+	if ((cmd & IOC_IN) == 0)
+		in_size = 0;
+	if ((cmd & IOC_OUT) == 0)
+		out_size = 0;
+
+	if (ksize <= sizeof(stack_kdata)) {
+		kdata = stack_kdata;
+	} else {
+		kdata = kmalloc(ksize, GFP_KERNEL);
+		if (!kdata) {
+			ret = -ENOMEM;
+			goto err;
+		}
+	}
+
+	ioctl = &di_ioctls[nr];
+	if (!ioctl->func) {
+		ret = -EINVAL;
+		goto err;
+	}
+	if (in_size > 0) {
+		if (copy_from_user(kdata, (void __user *)arg, in_size) != 0) {
+			ret = -EFAULT;
+			goto err;
+		}
+	}
+	ret = ioctl->func(c, (void *)kdata);
+	if (!ret && out_size > 0)
+		if (copy_to_user((void __user *)arg, kdata, out_size) != 0)
+			ret = -EFAULT;
+
+err:
+	if (kdata != stack_kdata)
+		kfree(kdata);
+
+	return ret;
+}
+
+static int di_open(struct inode *inode, struct file *file)
+{
+	void *client;
+	char debug_name[64];
+
+	snprintf(debug_name, 64, "client_%u",
+		task_pid_nr(current->group_leader));
+	client = di_client_create(debug_name);
+	if (client == NULL)
+		return -EINVAL;
+	file->private_data = client;
+	return 0;
+}
+
+static int di_release(struct inode *inode, struct file *file)
+{
+	di_client_destroy(file->private_data);
+	return 0;
+}
+
+int di_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long mypfn = vma->vm_pgoff;
+	unsigned long vmsize = vma->vm_end - vma->vm_start;
+
+	vma->vm_pgoff = 0;
+
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	if (remap_pfn_range(vma, vma->vm_start, mypfn,
+			    vmsize, vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+const struct file_operations di_fops = {
+	.owner = THIS_MODULE,
+	.open = di_open,
+	.release = di_release,
+	.unlocked_ioctl = di_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = di_ioctl,
+#endif
+	.mmap = di_mmap,
+};
diff --git a/drivers/char/sunxi-di/drv_div3x/di_fops.h b/drivers/char/sunxi-di/drv_div3x/di_fops.h
new file mode 100644
index 000000000..4f8dbbbc6
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_fops.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_FOPS_H_
+#define _DI_FOPS_H_
+
+#include <linux/fs.h>
+
+extern const struct file_operations di_fops;
+
+#endif /* #ifndef _DI_FOPS_H_ */
\ No newline at end of file
diff --git a/drivers/char/sunxi-di/drv_div3x/di_utils.c b/drivers/char/sunxi-di/drv_div3x/di_utils.c
new file mode 100644
index 000000000..3ec05b533
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_utils.c
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "di_utils.h"
+#include "di_debug.h"
+
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <drm/drm_fourcc.h>
+
+#define TAG "[DI_UTILS]"
+
+static struct device *dma_dev;
+
+void di_utils_set_dma_dev(struct device *dev)
+{
+	dma_dev = dev;
+}
+
+
+static struct info_mem di_mem[MAX_DI_MEM_INDEX];
+void *di_malloc(__u32 bytes_num, uintptr_t *phy_addr)
+{
+	void *address = NULL;
+
+#if defined(CONFIG_ION_SUNXI)
+	u32 actual_bytes;
+
+	if (bytes_num != 0) {
+		actual_bytes = PAGE_ALIGN(bytes_num);
+
+		address = dma_alloc_coherent(dma_dev, actual_bytes,
+					     (dma_addr_t *) phy_addr,
+					     GFP_KERNEL);
+		if (address) {
+			DI_INFO("dma_alloc_coherent ok, address=0x%p, size=0x%x\n",
+			    (void *)(*(unsigned long *)phy_addr), bytes_num);
+			return address;
+		}
+
+		DI_ERR("dma_alloc_coherent fail, size=0x%x\n", bytes_num);
+		return NULL;
+	}
+	DI_ERR("%s size is zero\n", __func__);
+#else
+	unsigned map_size = 0;
+	struct page *page;
+
+	if (bytes_num != 0) {
+		map_size = PAGE_ALIGN(bytes_num);
+		page = alloc_pages(GFP_KERNEL, get_order(map_size));
+		if (page != NULL) {
+			address = page_address(page);
+			if (address == NULL) {
+				free_pages((unsigned long)(page),
+					   get_order(map_size));
+				DI_ERR("page_address fail!\n");
+				return NULL;
+			}
+			*phy_addr = virt_to_phys(address);
+			return address;
+		}
+		DI_ERR("alloc_pages fail!\n");
+		return NULL;
+	}
+	DI_ERR("%s size is zero\n", __func__);
+#endif
+
+	return NULL;
+}
+
+void di_free(void *virt_addr, void *phy_addr, unsigned int size)
+{
+#if defined(CONFIG_ION_SUNXI)
+	u32 actual_bytes;
+
+	actual_bytes = PAGE_ALIGN(size);
+	if (phy_addr && virt_addr)
+		dma_free_coherent(dma_dev, actual_bytes, virt_addr,
+				  (dma_addr_t) phy_addr);
+#else
+	unsigned map_size = PAGE_ALIGN(size);
+	unsigned page_size = map_size;
+
+	if (virt_addr == NULL)
+		return;
+
+	free_pages((unsigned long)virt_addr, get_order(page_size));
+#endif
+}
+
+__s32 di_get_free_mem_index(void)
+{
+	__u32 i = 0;
+
+	for (i = 0; i < MAX_DI_MEM_INDEX; i++) {
+		if (di_mem[i].b_used == 0)
+			return i;
+	}
+	return -1;
+}
+
+int di_mem_request(__u32 size, u64 *phyaddr)
+{
+	__s32 sel;
+	unsigned long ret = 0;
+	uintptr_t phy_addr;
+
+	sel = di_get_free_mem_index();
+	if (sel < 0) {
+		DI_ERR("di_get_free_mem_index fail!\n");
+		return -EINVAL;
+	}
+
+	ret = (unsigned long)di_malloc(size, &phy_addr);
+	if (ret != 0) {
+		di_mem[sel].virt_addr = (void *)ret;
+		memset(di_mem[sel].virt_addr, 0, size);
+		di_mem[sel].phy_addr = phy_addr;
+		di_mem[sel].mem_len = size;
+		di_mem[sel].b_used = 1;
+		*phyaddr = phy_addr;
+
+		DI_INFO("map_di_memory[%d]: pa=%08lx va=%p size:%x\n", sel,
+		     di_mem[sel].phy_addr, di_mem[sel].virt_addr, size);
+		return sel;
+	}
+	DI_ERR("fail to alloc reserved memory!\n");
+	return -ENOMEM;
+}
+
+int di_mem_release(__u32 sel)
+{
+	if (di_mem[sel].b_used == 0) {
+		DI_ERR("mem not used in di_mem_release,%d\n", sel);
+		return -EINVAL;
+	}
+
+	di_free((void *)di_mem[sel].virt_addr, (void *)di_mem[sel].phy_addr,
+		 di_mem[sel].mem_len);
+	memset(&di_mem[sel], 0, sizeof(struct info_mem));
+
+	return 0;
+}
+
+static struct di_dma_item *di_dma_item_create(
+	struct dma_buf *dmabuf,
+	struct dma_buf_attachment *attach,
+	struct sg_table *sgt,
+	enum dma_data_direction dir)
+{
+	struct di_dma_item *item;
+	struct sg_table *sgt_bak;
+	struct scatterlist *sgl, *sgl_bak;
+	s32 sg_count = 0;
+	int i;
+
+	/*DEFINE_DMA_ATTRS(attrs);
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);*/
+
+	item = kzalloc(sizeof(*item), GFP_KERNEL);
+	if (item == NULL) {
+		DI_ERR(TAG"alloc mem for dma_item fail\n");
+		return NULL;
+	}
+
+	sgt_bak = kzalloc(sizeof(*sgt_bak), GFP_KERNEL);
+	if (sgt_bak == NULL) {
+		DI_ERR(TAG"alloc mem for sgt_bak fail\n");
+		goto err_item_kfree;
+	}
+	if (sg_alloc_table(sgt_bak, sgt->nents, GFP_KERNEL)) {
+		DI_ERR(TAG"alloc sgt fail\n");
+		goto err_sgt_kfree;
+	}
+
+	sgl_bak = sgt_bak->sgl;
+	for_each_sg(sgt->sgl, sgl, sgt->nents, i)  {
+		sg_set_page(sgl_bak, sg_page(sgl), sgl->length, sgl->offset);
+		sgl_bak = sg_next(sgl_bak);
+	}
+	sg_count = dma_map_sg_attrs(dma_dev,
+		sgt_bak->sgl, sgt_bak->nents, dir, DMA_ATTR_SKIP_CPU_SYNC);
+	if (sg_count != 1) {
+		DI_ERR(TAG"dma_map_sg_attrs failed:%d\n", sg_count);
+		goto err_free_sgt;
+	}
+
+	item->buf = dmabuf;
+	item->attach = attach;
+	item->sgt_org = sgt;
+	item->sgt_bak = sgt_bak;
+	item->dir = dir;
+	item->dma_addr = sg_dma_address(sgt_bak->sgl);
+
+	return item;
+
+err_free_sgt:
+	sg_free_table(sgt_bak);
+
+err_sgt_kfree:
+	kfree(sgt_bak);
+
+err_item_kfree:
+	kfree(item);
+
+	return NULL;
+}
+
+struct di_dma_item *di_dma_buf_self_map(
+	int fd, enum dma_data_direction dir)
+{
+	struct di_dma_item *dma_item = NULL;
+
+	struct dma_buf *dmabuf = NULL;
+	struct dma_buf_attachment *attach = NULL;
+	struct sg_table *sgt = NULL;
+
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		DI_ERR(TAG"dma buf get fail. fd=%d\n", fd);
+		return NULL;
+	}
+
+	attach = dma_buf_attach(dmabuf, dma_dev);
+	if (IS_ERR(attach)) {
+		DI_ERR(TAG"dma buf attach fail\n");
+		goto out_buf_put;
+	}
+
+	sgt = dma_buf_map_attachment(attach, dir);
+	if (IS_ERR_OR_NULL(sgt)) {
+		DI_ERR(TAG"dma_buf_map_attachment fail\n");
+		goto out_buf_detach;
+	}
+
+	dma_item = di_dma_item_create(dmabuf, attach, sgt, dir);
+	if (dma_item != NULL)
+		return dma_item;
+
+/* out_buf_unmap: */
+	dma_buf_unmap_attachment(attach, sgt, dir);
+
+out_buf_detach:
+	dma_buf_detach(dmabuf, attach);
+
+out_buf_put:
+	dma_buf_put(dmabuf);
+
+	return dma_item;
+}
+
+void di_dma_buf_self_unmap(struct di_dma_item *item)
+{
+	/*DEFINE_DMA_ATTRS(attrs);
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);*/
+
+	dma_unmap_sg_attrs(dma_dev, item->sgt_bak->sgl,
+		item->sgt_bak->nents, item->dir, DMA_ATTR_SKIP_CPU_SYNC);
+	dma_buf_unmap_attachment(item->attach,
+		item->sgt_bak, item->dir);
+	sg_free_table(item->sgt_bak);
+	kfree(item->sgt_bak);
+	dma_buf_detach(item->buf, item->attach);
+	dma_buf_put(item->buf);
+
+	kfree(item);
+}
+
+struct di_mapped_buf *di_dma_buf_alloc_map(u32 size)
+{
+	struct di_mapped_buf *mbuf =
+		kzalloc(sizeof(*mbuf), GFP_KERNEL);
+
+	if (mbuf == NULL) {
+		DI_ERR(TAG"kzalloc for mapped buf fail, size=%d\n",
+			(u32)sizeof(*mbuf));
+		return NULL;
+	}
+
+	mbuf->size_request = size;
+	mbuf->size_alloced = PAGE_ALIGN(size);
+	mbuf->vir_addr = dma_alloc_coherent(dma_dev,
+		mbuf->size_alloced, &mbuf->dma_addr, GFP_KERNEL);
+	if (mbuf->vir_addr == NULL) {
+		DI_ERR(TAG"dma_alloc_coherent fail, size=0x%x->0x%x\n",
+			mbuf->size_request, mbuf->size_alloced);
+		kfree(mbuf);
+		return NULL;
+	}
+
+	DI_DEBUG(TAG"%s: addr[%p,%p], size=0x%x\n", __func__,
+		mbuf->vir_addr, (void *)mbuf->dma_addr, mbuf->size_alloced);
+
+	return mbuf;
+}
+
+void di_dma_buf_unmap_free(struct di_mapped_buf *mbuf)
+{
+	DI_DEBUG(TAG"%s: addr[%p,%p], size=0x%x\n", __func__,
+		mbuf->vir_addr, (void *)mbuf->dma_addr, mbuf->size_alloced);
+	dma_free_coherent(dma_dev, mbuf->size_alloced,
+		mbuf->vir_addr, mbuf->dma_addr);
+	kfree(mbuf);
+}
+
+const char *di_format_to_string(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_YUV420:
+		return "YU12";
+	case DRM_FORMAT_YVU420:
+		return "YV12";
+	case DRM_FORMAT_YUV422:
+		return "YU16";
+	case DRM_FORMAT_YVU422:
+		return "YV16";
+	case DRM_FORMAT_NV12:
+		return "NV12";
+	case DRM_FORMAT_NV21:
+		return "NV21";
+	case DRM_FORMAT_NV16:
+		return "NV16";
+	case DRM_FORMAT_NV61:
+		return "NV61";
+	default:
+		DI_INFO(TAG"%s format(0x%x)\n", __func__, format);
+		return "unknown format";
+	}
+}
+
+u32 di_format_get_planar_num(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		return 3;
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+		return 2;
+	default:
+		DI_INFO(TAG"%s:%s\n", __func__,
+			di_format_to_string(format));
+		return 1;
+	}
+}
+
+u32 di_format_get_uvseq(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV61:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_YVU422:
+		/* TODO: add more format to support */
+		return DI_UVSEQ_VU;
+	default:
+		return DI_UVSEQ_UV;
+	}
+}
diff --git a/drivers/char/sunxi-di/drv_div3x/di_utils.h b/drivers/char/sunxi-di/drv_div3x/di_utils.h
new file mode 100644
index 000000000..658017184
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/di_utils.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI_UTILS_H_
+#define _DI_UTILS_H_
+
+#include <linux/types.h>
+#include <linux/dma-buf.h>
+
+#define MAX_DI_MEM_INDEX       100
+
+struct info_mem {
+	unsigned long phy_addr;
+	void *virt_addr;
+	__u32 b_used;
+	__u32 mem_len;
+};
+
+struct di_dma_item {
+	struct dma_buf *buf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt_org;
+	struct sg_table *sgt_bak;
+	enum dma_data_direction dir;
+	dma_addr_t dma_addr;
+};
+
+struct di_mapped_buf {
+	u32 size_request;
+	u32 size_alloced;
+	void *vir_addr;
+	dma_addr_t dma_addr;
+};
+
+void di_utils_set_dma_dev(struct device *dev);
+
+int di_mem_release(__u32 sel);
+int di_mem_request(__u32 size, u64 *phyaddr);
+
+struct di_dma_item *di_dma_buf_self_map(
+	int fd, enum dma_data_direction dir);
+void di_dma_buf_self_unmap(struct di_dma_item *item);
+
+struct di_mapped_buf *di_dma_buf_alloc_map(u32 size);
+void di_dma_buf_unmap_free(struct di_mapped_buf *mbuf);
+
+
+enum {
+	DI_UVSEQ_UV = 0, /* uv-combined: LSB U0V0U1V1 MSB */
+	DI_UVSEQ_VU = 1, /* uv-combined: LSB V0U0V1U1 MSB */
+};
+
+const char *di_format_to_string(u32 format);
+u32 di_format_get_planar_num(u32 format);
+u32 di_format_get_uvseq(u32 format);
+
+#endif /* #ifndef _DI_UTILS_H_ */
diff --git a/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300.c b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300.c
new file mode 100644
index 000000000..c4b8d7ab3
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300.c
@@ -0,0 +1,1158 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "di300.h"
+#include "di300_reg.h"
+#include "di300_alg.h"
+#include "../di_client.h"
+#include "../di_utils.h"
+#include "../di_debug.h"
+#include "../sunxi_di.h"
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#define TAG "[DI_DEV]"
+
+struct di_dev_vof_buf {
+	u8 buf_a[DI_VOF_BUF_SIZE_MAX];
+	u8 buf_b[DI_VOF_BUF_SIZE_MAX];
+	u8 buf_c[DI_VOF_BUF_SIZE_MAX];
+	u8 buf_d[DI_VOF_BUF_SIZE_MAX];
+};
+
+/* each client has its owned di_dev_cdata */
+struct di_dev_cdata {
+	struct di_dev_proc_result proc_rst;
+
+	u32 vof_buf_sel;
+	struct di_dev_vof_buf *vof_buf;
+};
+
+static struct di_reg *di_reg_base;
+
+static inline struct di_reg *di_dev_get_reg_base(void)
+{
+	return di_reg_base;
+}
+
+void di_dev_set_reg_base(void __iomem *reg_base)
+{
+	di_reg_base = (struct di_reg *)reg_base;
+}
+
+void di_dev_exit(void)
+{
+	di_reg_base = 0;
+}
+
+/*
+* convert format to the format that indecated in DI HW
+*/
+static u32 di_dev_convert_fmt(u32 format)
+{
+	switch (format) {
+	/*YV12 YV21*/
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+		return 0;
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV21:
+		return 1;
+	/*YV16 YV61*/
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		return 2;
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+		return 3;
+	default:
+		DI_ERR(TAG"unknown format=%s(0x%x)\n",
+			di_format_to_string(format), format);
+		return 0;
+	}
+}
+
+/*set output address
+* set out put fb y/cb/cr address
+*/
+static void di_dev_set_out_addr(struct di_fb *fb,
+	struct di_addr *addr_reg)
+{
+	u64 addr[3] = {0, 0, 0};
+
+	addr[0] = fb->buf.y_addr;
+	if (fb->buf.cb_addr == 0) {
+		addr[1] = fb->buf.cr_addr;
+		addr[2] = 0;
+	} else if (fb->buf.cr_addr == 0) {
+		addr[1] = fb->buf.cb_addr;
+		addr[2] = 0;
+	} else {
+		addr[1] = fb->buf.cb_addr;
+		addr[2] = fb->buf.cr_addr;
+	}
+
+	addr_reg->laddr[0] = (u32)addr[0];
+	addr_reg->laddr[1] = (u32)addr[1];
+	addr_reg->laddr[2] = (u32)addr[2];
+	addr_reg->haddr.bits.addr0 = (u32)(addr[0] >> 32);
+	addr_reg->haddr.bits.addr1 = (u32)(addr[1] >> 32);
+	addr_reg->haddr.bits.addr2 = (u32)(addr[2] >> 32);
+
+}
+
+/*set input address
+* set input fb y/cb/cr address of  top filed and bottom filed
+*/
+static void di_dev_set_in_addr(struct di_fb *fb,
+	struct di_in_addr *addr_reg)
+{
+	u64 addr[3] = {0, 0, 0};
+	u64 addr_b[3] = {0, 0, 0};
+
+	addr[0] = fb->buf.y_addr;
+	if (fb->buf.cb_addr == 0) {
+		addr[1] = fb->buf.cr_addr;
+		addr[2] = 0;
+	} else if (fb->buf.cr_addr == 0) {
+		addr[1] = fb->buf.cb_addr;
+		addr[2] = 0;
+	} else {
+		addr[1] = fb->buf.cb_addr;
+		addr[2] = fb->buf.cr_addr;
+	}
+	addr_b[0] = addr[0] + fb->buf.ystride;
+	addr_b[1] = addr[1] ? (addr[1] + fb->buf.cstride) : 0;
+	addr_b[2] = addr[2] ? (addr[2] + fb->buf.cstride) : 0;
+
+	addr_reg->top.laddr[0] = (u32)addr[0];
+	addr_reg->top.laddr[1] = (u32)addr[1];
+	addr_reg->top.laddr[2] = (u32)addr[2];
+	addr_reg->top.haddr.bits.addr0 = (u32)(addr[0] >> 32);
+	addr_reg->top.haddr.bits.addr1 = (u32)(addr[1] >> 32);
+	addr_reg->top.haddr.bits.addr2 = (u32)(addr[2] >> 32);
+	addr_reg->bot.laddr[0] = (u32)addr_b[0];
+	addr_reg->bot.laddr[1] = (u32)addr_b[1];
+	addr_reg->bot.laddr[2] = (u32)addr_b[2];
+	addr_reg->bot.haddr.bits.addr0 = (u32)(addr_b[0] >> 32);
+	addr_reg->bot.haddr.bits.addr1 = (u32)(addr_b[1] >> 32);
+	addr_reg->bot.haddr.bits.addr2 = (u32)(addr_b[2] >> 32);
+
+}
+
+/*set fb
+* 1.set format, uvseq,pitch,phy address of di/pre/cur fb to reg
+* 2.set format, pitch,phy address of dit_out0/dit_out1/tnr_out0 fb to reg
+*/
+static void di_dev_set_fb(struct di_client *c)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	struct di_fb *fb;
+
+	if (c->dma_di) {
+		fb = c->dma_di->fb;
+
+		/*di300 Only Support planner and uv/vu combine*/
+		reg->fmt.bits.in0fmt = di_dev_convert_fmt(fb->format);
+		if (di_format_get_planar_num(fb->format) == 2)
+			reg->fmt.bits.uvseq = di_format_get_uvseq(fb->format);
+		/*set pitch of field0 and field1*/
+		reg->in_f01_pitch[0].bits.f01 = fb->buf.ystride << 1;
+		reg->in_f01_pitch[1].bits.f01 = fb->buf.cstride << 1;
+		reg->in_f01_pitch[2].bits.f01 = fb->buf.cstride << 1;
+		di_dev_set_in_addr(fb, &reg->in_f0_addr);
+	}
+
+	if (c->dma_p) {
+		fb = c->dma_p->fb;
+		reg->fmt.bits.in1fmt = di_dev_convert_fmt(fb->format);
+		if (di_format_get_planar_num(fb->format) == 2)
+			reg->fmt.bits.uvseq = di_format_get_uvseq(fb->format);
+		reg->in_f01_pitch[0].bits.f23 = fb->buf.ystride << 1;
+		reg->in_f01_pitch[1].bits.f23 = fb->buf.cstride << 1;
+		reg->in_f01_pitch[2].bits.f23 = fb->buf.cstride << 1;
+		di_dev_set_in_addr(fb, &reg->in_f1_addr);
+	}
+
+	if (c->dma_c) {
+		fb = c->dma_c->fb;
+		reg->fmt.bits.in2fmt = di_dev_convert_fmt(fb->format);
+		if (di_format_get_planar_num(fb->format) == 2)
+			reg->fmt.bits.uvseq = di_format_get_uvseq(fb->format);
+		reg->in_f2_pitch[0].bits.val = fb->buf.ystride << 1;
+		reg->in_f2_pitch[1].bits.val = fb->buf.cstride << 1;
+		reg->in_f2_pitch[2].bits.val = fb->buf.cstride << 1;
+		di_dev_set_in_addr(fb, &reg->in_f2_addr);
+	}
+
+	if (c->di_w0) {
+		fb = c->di_w0->fb;
+		reg->fmt.bits.ditfmt = di_dev_convert_fmt(fb->format);
+		reg->out_dit_pitch[0].bits.val = fb->buf.ystride;
+		reg->out_dit_pitch[1].bits.val = fb->buf.cstride;
+		reg->out_dit_pitch[2].bits.val = fb->buf.cstride;
+		di_dev_set_out_addr(fb, &reg->out_dit0_addr);
+	}
+
+	if (c->di_w1) {
+		fb = c->di_w1->fb;
+		reg->fmt.bits.ditfmt = di_dev_convert_fmt(fb->format);
+		reg->out_dit_pitch[0].bits.val = fb->buf.ystride;
+		reg->out_dit_pitch[1].bits.val = fb->buf.cstride;
+		reg->out_dit_pitch[2].bits.val = fb->buf.cstride;
+		di_dev_set_out_addr(fb, &reg->out_dit1_addr);
+	}
+
+	if (c->tnr_w && c->tnr_en) {
+		fb = c->tnr_w->fb;
+		reg->fmt.bits.tnrfmt = di_dev_convert_fmt(fb->format);
+		reg->out_tnr_pitch[0].bits.val = fb->buf.ystride;
+		reg->out_tnr_pitch[1].bits.val = fb->buf.cstride;
+		reg->out_tnr_pitch[2].bits.val = fb->buf.cstride;
+		di_dev_set_out_addr(fb, &reg->out_tnr_addr);
+	}
+
+}
+
+
+/*Set in/out flag phy address to reg*/
+static void di_dev_set_md_buf(struct di_client *c)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	struct di_mapped_buf *in_buf = NULL;
+	struct di_mapped_buf *out_buf = NULL;
+
+	in_buf = c->md_buf.mbuf[c->md_buf.dir & 1];
+	c->md_buf.dir ^= 1;
+	out_buf = c->md_buf.mbuf[c->md_buf.dir & 1];
+	reg->in_flag_laddr = (u32)(in_buf->dma_addr);
+	reg->out_flag_laddr = (u32)(out_buf->dma_addr);
+	reg->flag_haddr.bits.in_addr =
+		(u32)((u64)in_buf->dma_addr >> 32);
+	reg->flag_haddr.bits.out_addr =
+		(u32)((u64)out_buf->dma_addr >> 32);
+}
+
+/*
+* set to para
+* top means it is the module topped on DIT,MD,TNR module
+* 1. set top_filed_first para
+* 2. set in/out flag addr para
+* 3. set format, uvseq,pitch,phy address of fbs
+*/
+static s32 di_dev_set_top_para(struct di_client *c)
+{
+	struct di_dev_cdata *cdata;
+	struct di_dev_proc_result *proc_rst;
+	struct __alg_hist *alg_hist;
+	struct __di_para_t *di_para;
+	struct __alg_para_t *alg_para;
+	u8 tff;
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	if (!c) {
+		DI_ERR("%s di_client is NULL\n", __func__);
+		return -1;
+	}
+	cdata = (struct di_dev_cdata *)c->dev_cdata;
+
+	if (!cdata) {
+		DI_ERR("%s cdata is NULL\n", __func__);
+		return -1;
+	}
+
+	proc_rst = &cdata->proc_rst;
+	alg_hist = &proc_rst->alg_hist;
+	di_para = &proc_rst->di_para;
+	alg_para = &di_para->alg_para;
+
+	c->fb_arg.top_field_first =
+			di_para->bff ? 0 : 1;
+	DI_INFO("top_field_first:%d di_para->bff:%d\n", c->fb_arg.top_field_first, di_para->bff);
+	tff = c->fb_arg.top_field_first ? 1 : 0;
+	if (c->dit_mode.intp_mode == DI_DIT_INTP_MODE_BOB)
+		tff ^= (c->fb_arg.base_field ? 1 : 0);
+	DI_INFO("set tff:%d\n", tff);
+	reg->forder.bits.bff = tff ? 0 : 1;
+
+	if (c->md_en)
+		di_dev_set_md_buf(c);
+
+	di_dev_set_fb(c);
+
+	return 0;
+}
+
+/*set params of MD Module
+* set left/right value of window horizon crop
+* set top/bottom value of window vetical crop
+*/
+static s32 di_dev_set_md_para(struct di_client *c)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	/*reg->md_croph.dwval = (c->md_out_crop.left & 0xfffffffc) |
+		((((c->md_out_crop.right + 1) & 0xfffffffc) - 1)
+		<< 16);
+	reg->md_cropv.dwval = (c->md_out_crop.top & 0xfffffffc) |
+		((((c->md_out_crop.bottom + 1) & 0xfffffffc) - 1)
+		<< 16);*/
+	if ((c->md_out_crop.left % 4 != 0)
+		|| (c->md_out_crop.right % 4 != 0)
+		|| (c->md_out_crop.top % 4 != 0)
+		|| (c->md_out_crop.bottom % 4 != 0)) {
+		DI_ERR("crop value error, DI300 only support the crop that 4bytes aligned\n");
+		return -1;
+	}
+	reg->md_croph.dwval = c->md_out_crop.left | ((c->md_out_crop.right - 1) << 16);
+	reg->md_cropv.dwval = c->md_out_crop.top | ((c->md_out_crop.bottom - 1) << 16);
+	return 0;
+}
+
+/* set para to dit module
+* 1. set left/right/top/bottom value of dit and demo window crop
+* 2. set field_weave_phase_f1/2, video_exist_f1/2  through itd_alg/fmd_alg/vof_alg
+*/
+static s32 di_dev_set_dit_para(struct di_client *c)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	struct di_dev_cdata *cdata =
+			(struct di_dev_cdata *)c->dev_cdata;
+	struct di_dev_proc_result *proc_rst = &cdata->proc_rst;
+	struct __alg_hist *alg_hist = &proc_rst->alg_hist;
+	struct __di_para_t *di_para = &proc_rst->di_para;
+	struct __alg_para_t *alg_para = &di_para->alg_para;
+
+	/*reg->dit_croph.dwval = (c->dit_out_crop.left & 0xfffffffe) |
+		((((c->dit_out_crop.right + 1) & 0xfffffffe) - 1)
+		<< 16);
+	reg->dit_cropv.dwval = (c->dit_out_crop.top & 0xfffffffc) |
+		((((c->dit_out_crop.bottom + 1) & 0xfffffffc) - 1)
+		<< 16);*/
+	if ((c->dit_out_crop.left % 4 != 0)
+		|| (c->dit_out_crop.right % 4 != 0)
+		|| (c->dit_out_crop.top % 4 != 0)
+		|| (c->dit_out_crop.bottom % 4 != 0)) {
+		DI_ERR("dit_out crop value error, DI300 only support the crop that 4bytes aligned\n");
+		return -1;
+	}
+
+	if (c->dit_out_crop.right > 0)
+		reg->dit_croph.dwval = c->dit_out_crop.left
+			| ((c->dit_out_crop.right - 1) << 16);
+	else
+		reg->dit_croph.dwval = c->dit_out_crop.left;
+
+	if (c->dit_out_crop.bottom > 0)
+		reg->dit_cropv.dwval = c->dit_out_crop.top
+			| ((c->dit_out_crop.bottom - 1) << 16);
+	else
+		reg->dit_cropv.dwval = c->dit_out_crop.top;
+
+	/*reg->dit_demoh.dwval = (c->dit_demo_crop.left & 0xfffffffe) |
+	    ((((c->dit_demo_crop.right + 1) & 0xfffffffe) - 1)
+	     << 16);
+	reg->dit_demov.dwval = (c->dit_demo_crop.top & 0xfffffffc) |
+	    ((((c->dit_demo_crop.bottom + 1) & 0xfffffffc) - 1)
+	     << 16);*/
+	if ((c->dit_demo_crop.left % 4 != 0)
+		|| (c->dit_demo_crop.right % 4 != 0)
+		|| (c->dit_demo_crop.top % 4 != 0)
+		|| (c->dit_demo_crop.bottom % 4 != 0)) {
+		DI_ERR("dit demo crop value error, DI300 only support the crop that 4bytes aligned\n");
+		return -1;
+	}
+
+	if (c->dit_demo_crop.right > 0)
+		reg->dit_demoh.dwval = c->dit_demo_crop.left
+			| ((c->dit_demo_crop.right - 1) << 16);
+	else
+		reg->dit_demoh.dwval = c->dit_demo_crop.left;
+
+	if (c->dit_demo_crop.bottom > 0)
+		reg->dit_demov.dwval = c->dit_demo_crop.top
+			| ((c->dit_demo_crop.bottom - 1) << 16);
+	else
+		reg->dit_demov.dwval = c->dit_demo_crop.top;
+
+	if (alg_para->alg_en == 0)
+		return 0;
+
+	/* film mode and vof */
+	reg->dit_inter_para.bits.field_weave_f1 = 0;
+	reg->dit_inter_para.bits.field_weave_chroma_f1 = 0;
+	reg->dit_inter_para.bits.field_weave_phase_f1 = 1;
+	reg->dit_inter_para.bits.field_weave_f2 = 0;
+	reg->dit_inter_para.bits.field_weave_chroma_f2 = 0;
+	reg->dit_inter_para.bits.field_weave_phase_f2 = 1;
+	reg->dit_inter_para.bits.video_exist_f1 = 0;
+	reg->dit_inter_para.bits.video_exist_f2 = 0;
+
+	/* TODO: itd_alg parameters feedback */
+	if (alg_para->itd_alg_para.itd_alg_en) {
+		if (alg_hist->itd_alg_hist.is_progressive_lock == 1 &&
+		    alg_hist->itd_alg_hist.is_temp_di_f3 == 0 &&
+		    alg_hist->vof_alg_hist.text_field_exist_f3 == 0) {
+			reg->dit_inter_para.bits.field_weave_f1 = 1;
+			/* For safety, DONOT enable field weave for chroma */
+			/* reg->dit_inter_para.bits.field_weave_chroma_f1 = 0; */
+			reg->dit_inter_para.bits.field_weave_phase_f1 =
+			    alg_hist->itd_alg_hist.weave_phase_f3;
+		}
+
+		if (alg_hist->itd_alg_hist.is_progressive_lock == 1 &&
+		    alg_hist->itd_alg_hist.is_temp_di_f4 == 0 &&
+		    alg_hist->vof_alg_hist.text_field_exist_f4 == 0) {
+			reg->dit_inter_para.bits.field_weave_f2 = 1;
+			/* For safety, DONOT enable field weave for chroma */
+			/* reg->dit_inter_para.bits.field_weave_chroma_f2 = 0; */
+			reg->dit_inter_para.bits.field_weave_phase_f2 =
+			    alg_hist->itd_alg_hist.weave_phase_f4;
+		}
+
+	}
+
+	if (alg_para->fmd_alg_para.fmd_alg_en) {
+		if (alg_hist->fmd_alg_hist.is_fm_lock_f3 == 1 &&
+			alg_hist->fmd_alg_hist.is_temp_di_f3 == 0 &&
+			alg_hist->vof_alg_hist.text_field_exist_f3 == 0) {
+			reg->dit_inter_para.bits.field_weave_f1 = 1;
+			/* For safety, DONOT enable field weave for chroma */
+			/* reg->dit_inter_para.bits.field_weave_chroma_f1 = 0; */
+			reg->dit_inter_para.bits.field_weave_phase_f1 =
+				alg_hist->fmd_alg_hist.weave_phase_f3;
+		}
+
+		if (alg_hist->fmd_alg_hist.is_fm_lock_f4 == 1 &&
+			alg_hist->fmd_alg_hist.is_temp_di_f4 == 0 &&
+			alg_hist->vof_alg_hist.text_field_exist_f4 == 0) {
+			reg->dit_inter_para.bits.field_weave_f2 = 1;
+			/* For safety, DONOT enable field weave for chroma */
+			/* reg->dit_inter_para.bits.field_weave_chroma_f2 = 0; */
+			reg->dit_inter_para.bits.field_weave_phase_f2 =
+				alg_hist->fmd_alg_hist.weave_phase_f4;
+		}
+	}
+
+	if (alg_para->vof_alg_para.vof_alg_en) {
+		if (alg_hist->vof_alg_hist.video_field_exist_f3)
+			reg->dit_inter_para.bits.video_exist_f1 = 1;
+
+		if (alg_hist->vof_alg_hist.video_field_exist_f4)
+			reg->dit_inter_para.bits.video_exist_f2 = 1;
+	}
+	return 0;
+}
+
+/*set window params of FMD Module
+* set left/right value of window horizon crop
+* set top/bottom value of window vetical crop
+*/
+static s32 di_dev_set_fmd_para(struct di_client *c)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	if (di_device_get_debug_mode())
+		return 0;
+
+	if (c->mode == DI_MODE_60HZ) {
+		u32 vof_buf_sel = reg->fmd_glb.bits.vof_buf_sel;
+
+		vof_buf_sel ^= 1;
+		reg->fmd_glb.bits.vof_buf_sel = vof_buf_sel;
+	}
+
+	/*reg->fmd_croph.dwval = (c->fmd_out_crop.left & 0xfffffffc) |
+		((((c->fmd_out_crop.right + 1) & 0xfffffffc) - 1)
+		<< 16);
+	reg->fmd_cropv.dwval = (c->fmd_out_crop.top & 0xfffffffc) |
+		((((c->fmd_out_crop.bottom + 1) & 0xfffffffc) - 1)
+		<< 16);*/
+
+	if ((c->fmd_out_crop.left % 4 != 0)
+		|| (c->fmd_out_crop.right % 4 != 0)
+		|| (c->fmd_out_crop.top % 4 != 0)
+		|| (c->fmd_out_crop.bottom % 4 != 0)) {
+		DI_ERR("crop value error, DI300 only support the crop that 4bytes aligned\n");
+		return -1;
+	}
+	reg->fmd_croph.dwval = c->fmd_out_crop.left | ((c->fmd_out_crop.right - 1) << 16);
+	reg->fmd_cropv.dwval = c->fmd_out_crop.top | ((c->fmd_out_crop.bottom - 1) << 16);
+
+	return 0;
+}
+
+static s32 di_dev_set_tnr_para(struct di_client *c)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	struct di_dev_cdata *cdata =
+			(struct di_dev_cdata *)c->dev_cdata;
+	struct di_dev_proc_result *proc_rst = &cdata->proc_rst;
+	struct __alg_hist *alg_hist = &proc_rst->alg_hist;
+	struct __di_para_t *di_para = &proc_rst->di_para;
+	struct __alg_para_t *alg_para = &di_para->alg_para;
+
+	if (di_device_get_debug_mode())
+		return 0;
+	/*reg->tnr_croph.dwval = (c->tnr_out_crop.left & 0xfffffffc) |
+		((((c->tnr_out_crop.right + 1) & 0xfffffffc) - 1)
+		<< 16);
+	reg->tnr_cropv.dwval = (c->tnr_out_crop.top & 0xfffffffc) |
+		((((c->tnr_out_crop.bottom + 1) & 0xfffffffc) - 1)
+		<< 16);*/
+
+	if ((c->tnr_out_crop.left % 4 != 0)
+		|| (c->tnr_out_crop.right % 4 != 0)
+		|| (c->tnr_out_crop.top % 4 != 0)
+		|| (c->tnr_out_crop.bottom % 4 != 0)) {
+		DI_ERR("tnr_out crop value error, DI300 only support the crop that 4bytes aligned\n");
+		return -1;
+	}
+
+	if (c->tnr_out_crop.right > 0)
+		reg->tnr_croph.dwval = c->tnr_out_crop.left
+			| ((c->tnr_out_crop.right - 1) << 16);
+	else
+		reg->tnr_croph.dwval = c->tnr_out_crop.left;
+
+	if (c->tnr_out_crop.bottom > 0)
+		reg->tnr_cropv.dwval = c->tnr_out_crop.top
+			| ((c->tnr_out_crop.bottom - 1) << 16);
+	else
+		reg->tnr_cropv.dwval = c->tnr_out_crop.top;
+
+	/*reg->tnr_demoh.dwval = (c->tnr_demo_crop.left & 0xfffffffc) |
+	    ((((c->tnr_demo_crop.right + 1) & 0xfffffffc) - 1)
+	     << 16);
+	reg->tnr_demov.dwval = (c->tnr_demo_crop.top & 0xfffffffc) |
+	    ((((c->tnr_demo_crop.bottom + 1) & 0xfffffffc) - 1)
+	     << 16);*/
+	if ((c->tnr_demo_crop.left % 4 != 0)
+		|| (c->tnr_demo_crop.right % 4 != 0)
+		|| (c->tnr_demo_crop.top % 4 != 0)
+		|| (c->tnr_demo_crop.bottom % 4 != 0)) {
+		DI_ERR("tnr_demo crop value error, DI300 only support the crop that 4bytes aligned\n");
+		return -1;
+	}
+
+	if (c->tnr_demo_crop.right > 0)
+		reg->tnr_demoh.dwval = c->tnr_demo_crop.left
+			| ((c->tnr_demo_crop.right - 1) << 16);
+	else
+		reg->tnr_demoh.dwval = c->tnr_demo_crop.left;
+
+	if (c->tnr_demo_crop.bottom > 0)
+		reg->tnr_demov.dwval = c->tnr_demo_crop.top
+			| ((c->tnr_demo_crop.bottom - 1) << 16);
+	else
+		reg->tnr_demov.dwval = c->tnr_demo_crop.top;
+
+	if (alg_para->alg_en == 0)
+		return 0;
+
+	if (alg_para->fmd_alg_para.fmd_alg_en) {
+		/* TNR : is_scene_changed */
+		reg->tnr_md_result.bits.is_scene_changed =
+			(alg_hist->fmd_alg_hist.is_scenechange_f3 == 1) ||
+			(alg_hist->fmd_alg_hist.is_scenechange_f4 == 1);
+
+		/* TNR : is_contain_bad_frame */
+		if ((alg_hist->fmd_alg_hist.film_mode_f4 == FM_32 ||
+			alg_hist->fmd_alg_hist.film_mode_f4 == FM_2332 ||
+			alg_hist->fmd_alg_hist.film_mode_f4 == FM_32322 ||
+			alg_hist->fmd_alg_hist.film_mode_f4 == FM_55 ||
+			alg_hist->fmd_alg_hist.film_mode_f4 == FM_87) &&
+			alg_hist->fmd_alg_hist.is_fm_lock_f4 == 1)
+			reg->tnr_md_result.bits.is_contain_bad_frame = 1;
+		else
+			reg->tnr_md_result.bits.is_contain_bad_frame = 0;
+	}
+
+	/* TNR : reset accumulation regs */
+	reg->tnr_sum_weight_y = 0x0;
+	reg->tnr_sum_weight_u = 0x0;
+	reg->tnr_sum_weight_v = 0x0;
+	reg->tnr_sum_gain_y = 0x0;
+	reg->tnr_sum_gain_u = 0x0;
+	reg->tnr_sum_gain_v = 0x0;
+	reg->tnr_sum_still_out = 0x0;
+	reg->tnr_sum_weight_y_cnt = 0x0;
+	reg->tnr_sum_gain_y_cnt = 0x0;
+
+	if (alg_para->tnr_alg_para.tnr_alg_en
+		&& alg_para->tnr_alg_para.tnr_mode == DI_TNR_MODE_ADAPTIVE) {
+		/* fixme: get the correct gain value */
+		reg->tnr_strength.bits.y = alg_hist->tnr_alg_hist.gain;
+		reg->tnr_strength.bits.u = alg_hist->tnr_alg_hist.gain;
+		reg->tnr_strength.bits.v = alg_hist->tnr_alg_hist.gain;
+	}
+
+	return 0;
+}
+
+/*
+ * di_dev_get_proc_result wil be called in finished-irq.
+ * It just get some paras of current fb-process.
+ */
+s32 di_dev_get_proc_result(void *client)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	struct di_client *c = (struct di_client *)client;
+	struct di_dev_cdata *cdata = (struct di_dev_cdata *)c->dev_cdata;
+	struct di_dev_proc_result *proc_rst = &cdata->proc_rst;
+	struct __hw_hist *hw_hist = &proc_rst->hw_hist;
+	struct __fmd_hist *fmd_hist = &hw_hist->fmd_hist;
+	struct __tnr_hist *tnr_hist = &hw_hist->tnr_hist;
+	struct __itd_hist *itd_hist = &hw_hist->itd_hist;
+
+	fmd_hist->FMD_FID12 = reg->fmd_fid12.bits.cnt;
+	fmd_hist->FMD_FID23 = reg->fmd_fid23.bits.cnt;
+	fmd_hist->FOD_FID30 = reg->fod_fid30.bits.cnt;
+	fmd_hist->FOD_FID32 = reg->fod_fid32.bits.cnt;
+	fmd_hist->FOD_FID10 = reg->fod_fid10.bits.cnt;
+	fmd_hist->FOD_FID12 = reg->fod_fid12.bits.cnt;
+	fmd_hist->FMD_FRD02 = reg->fmd_frd02.bits.cnt;
+	fmd_hist->FMD_FRD13 = reg->fmd_frd13.bits.cnt;
+
+	DI_INFO("di_dev_get_proc_result, FOD_FID10:%d FOD_FID32:%d\n", fmd_hist->FOD_FID10, fmd_hist->FOD_FID32);
+
+	fmd_hist->FIELD_MAX_VIDEO_NUM_F3 =
+		reg->fmd_field_hist0.bits.max_video_num;
+	fmd_hist->FIELD_MAX_TEXT_NUM_F3 =
+		reg->fmd_field_hist0.bits.max_text_num;
+	fmd_hist->FIELD_MAX_TEXT_POS_F3 =
+		reg->fmd_field_hist0.bits.max_text_pos;
+	fmd_hist->FIELD_TEXT_ROW_NUM_F3 =
+		reg->fmd_field_hist0.bits.text_row_num;
+
+	fmd_hist->FIELD_MAX_VIDEO_NUM_F4 =
+		reg->fmd_field_hist1.bits.max_video_num;
+	fmd_hist->FIELD_MAX_TEXT_NUM_F4 =
+		reg->fmd_field_hist1.bits.max_text_num;
+	fmd_hist->FIELD_MAX_TEXT_POS_F4 =
+		reg->fmd_field_hist1.bits.max_text_pos;
+	fmd_hist->FIELD_TEXT_ROW_NUM_F4 =
+		reg->fmd_field_hist1.bits.text_row_num;
+
+	itd_hist->FMD_FID12 = reg->fmd_fid12.bits.cnt;
+	itd_hist->FMD_FID23 = reg->fmd_fid23.bits.cnt;
+
+	tnr_hist->tnr_sum_weight_y = reg->tnr_sum_weight_y;
+	tnr_hist->tnr_sum_weight_u = reg->tnr_sum_weight_u;
+	tnr_hist->tnr_sum_weight_v = reg->tnr_sum_weight_v;
+	tnr_hist->tnr_sum_gain_y = reg->tnr_sum_gain_y;
+	tnr_hist->tnr_sum_gain_u = reg->tnr_sum_gain_u;
+	tnr_hist->tnr_sum_gain_v = reg->tnr_sum_gain_v;
+	tnr_hist->tnr_sum_still_out = reg->tnr_sum_still_out;
+	tnr_hist->tnr_sum_weight_y_cnt = reg->tnr_sum_weight_y_cnt;
+	tnr_hist->tnr_sum_gain_y_cnt = reg->tnr_sum_gain_y_cnt;
+
+	return 0;
+}
+
+/* figure out current fb-process paras by using pre fb-process result paras. */
+static s32 di_dev_calc_proc_result(struct di_client *c)
+{
+	struct di_dev_cdata *cdata = (struct di_dev_cdata *)c->dev_cdata;
+	struct di_dev_proc_result *proc_rst = &cdata->proc_rst;
+	struct __alg_hist *alg_hist = &proc_rst->alg_hist;
+
+	/* Run Alg */
+	di_alg(proc_rst);
+
+	/* Print result */
+	/* FOD */
+	if (alg_hist->fod_alg_hist.is_fieldorderchange) {
+		DI_DEBUG(TAG"[FOD]Field order changed.\n");
+	}
+
+	if (alg_hist->fod_alg_hist.bff_fix)
+		DI_DEBUG(TAG"[FOD]Current field order:BFF.\n");
+	else
+		DI_DEBUG(TAG"[FOD]Current field order:TFF.\n");
+
+	/* ITD */
+	if (alg_hist->itd_alg_hist.is_progressive_lock) {
+		c->di_detect_result = DI_DETECT_PROGRESSIVE;
+		DI_DEBUG(TAG"[ITD]Progressive locked.\n");
+	} else {
+		c->di_detect_result = DI_DETECT_INTERLACE;
+		DI_DEBUG(TAG"[ITD]Interlaced detected.\n");
+	}
+
+	/* FMD */
+	if (alg_hist->fmd_alg_hist.is_non22_lock) {
+		switch (alg_hist->fmd_alg_hist.film_mode_non22) {
+		case 1:
+			DI_FMD(TAG"[FMD]Film mode 32 locked.\n");
+			break;
+		case 2:
+			DI_FMD(TAG"[FMD]Film mode 2332 locked.\n");
+			break;
+		case 3:
+			DI_FMD(TAG"[FMD]Film mode 2224 locked.\n");
+			DI_FMD(TAG"[FMD]Film mode 22 locked. is actually a progressive video\n");
+			c->di_detect_result = DI_DETECT_PROGRESSIVE;
+			break;
+		case 4:
+			DI_FMD(TAG"[FMD]Film mode 32322 locked.\n");
+			break;
+		case 5:
+			DI_FMD(TAG"[FMD]Film mode 55 locked.\n");
+			break;
+		case 6:
+			DI_FMD(TAG"[FMD]Film mode 64 locked.\n");
+			break;
+		case 7:
+			DI_FMD(TAG"[FMD]Film mode 87 locked.\n");
+			break;
+		default:
+			DI_FMD(TAG"[FMD]Film mode 22 locked. is actually a progressive video\n");
+			c->di_detect_result = DI_DETECT_PROGRESSIVE;
+			break;
+		}
+	} else if (alg_hist->fmd_alg_hist.is_22_lock) {
+		DI_FMD(TAG"[FMD]Film mode 22 locked. is actually a progressive video\n");
+		c->di_detect_result = DI_DETECT_PROGRESSIVE;
+	} else {
+		DI_DEBUG(TAG"[FMD]Film mode unlocked.\n");
+	}
+
+	/* VOF */
+	if (alg_hist->vof_alg_hist.video_field_exist_f3
+		|| alg_hist->vof_alg_hist.video_field_exist_f4) {
+		DI_DEBUG(TAG"[VOF]Video field exited.\n");
+	} else {
+		DI_DEBUG(TAG"[VOF]Video field not exited.\n");
+	}
+
+	if (alg_hist->vof_alg_hist.text_field_exist_f3
+		|| alg_hist->vof_alg_hist.text_field_exist_f4) {
+		DI_DEBUG(TAG"[VOF]Text field exited.\n");
+	} else {
+		DI_DEBUG(TAG"[VOF]Text field not exited.\n");
+	}
+
+	/* Modify Hardware Parameters */
+	di_alg_hist_to_hardware(c, proc_rst);
+	return 0;
+}
+
+/* apply fb-process para every process. */
+s32 di_dev_apply_para(void *client)
+{
+	struct di_client *c = (struct di_client *)client;
+
+	DI_DEBUG(TAG"%s: c=%p  seqno:%llu\n", __func__, c, c->proc_fb_seqno);
+
+	if (c->proc_fb_seqno > 0)
+		di_dev_calc_proc_result(c);
+	di_dev_set_top_para(c);
+	di_dev_set_md_para(c);/*crop*/
+	di_dev_set_dit_para(c);
+	if (c->fmd_en.en)
+		di_dev_set_fmd_para(c);
+	if (c->tnr_en)
+		di_dev_set_tnr_para(c);
+
+	return 0;
+}
+
+/*
+ * di_dev_apply_fixed_para will be called in these conditions:
+ * a) at 1st time of continuous fb-process of a const-mode client; or
+ * b) at 1st time of fb-process after resume.
+ */
+s32 di_dev_apply_fixed_para(void *client)
+{
+	struct di_client *c = (struct di_client *)client;
+	struct di_dev_cdata *cdata =
+		(struct di_dev_cdata *)c->dev_cdata;
+	struct di_reg *reg = di_dev_get_reg_base();
+	u32 dwval = 0;
+	u32 vof_blk_size_sel = 0;
+
+	if (di_device_get_debug_mode())
+		return 0;
+
+	DI_DEBUG(TAG"%s: c=%p\n", __func__, c);
+
+	/* apply top fixed para */
+	dwval = 0;
+	if (c->dit_mode.intp_mode != DI_DIT_INTP_MODE_INVALID)
+		dwval |= (1 << 0);
+	if (c->md_en)
+		dwval |= (1 << 1);
+	if (c->tnr_en)
+		dwval |= (1 << 2);
+	if (c->fmd_en.en)
+		dwval |= (1 << 3);
+	reg->func_en.dwval = dwval;
+
+	dwval = (c->video_size.width - 1) & 0x7FF;
+	dwval |= (((c->video_size.height - 1) & 0x7FF) << 16);
+	reg->size.dwval = dwval;
+
+	dwval = 0;
+	if (c->md_en) {
+		/* TODO: check flag_pitch = ((width + 127) >> 2) & 0xffffffe0 */
+		reg->flag_pitch.dwval = c->md_buf.w_stride;
+		dwval |= ((1 << 12) | (1 << 28));
+	} else {
+		reg->flag_pitch.dwval = 0;
+	}
+	if (c->dma_c)
+		dwval |= 1;
+	if (c->dma_p)
+		dwval |= (1 << 4);
+	if (c->dma_di)
+		dwval |= (1 << 8);
+	if (c->di_w0)
+		dwval |= (1 << 16);
+	if (c->di_w1)
+		dwval |= (1 << 20);
+	if (c->tnr_w)
+		dwval |= (1 << 24);
+
+	dwval |= (1 << 31);
+	reg->dma_ctl.dwval = dwval;
+	//reg->dma_ctl.bits.mclk_gate = 1;
+
+	/* apply md fixed para */
+	reg->md_para.dwval = 0x21360c04;
+
+	/* apply dit fixed para */
+	dwval = reg->dit_setting.dwval;
+	dwval &= 0x700;
+	dwval |= (1 << 5);
+	switch (c->dit_mode.intp_mode) {
+	case DI_DIT_INTP_MODE_MOTION:
+		dwval |= (1 | (1 << 4) | (1 << 16));
+		if (c->dit_mode.out_frame_mode == DI_DIT_OUT_2FRAME)
+			dwval |= (1 << 20);
+		break;
+	case DI_DIT_INTP_MODE_BOB:
+		dwval |= (1 | (1 << 16));
+		break;
+	case DI_DIT_INTP_MODE_WEAVE:
+		break;
+	case DI_DIT_INTP_MODE_INVALID:
+		break;
+	default:
+		DI_ERR(TAG"bad dit intp mode %d\n", c->dit_mode.intp_mode);
+		break;
+	}
+	if (c->dit_mode.out_frame_mode == DI_DIT_OUT_2FRAME) {
+		dwval &= ~(1 << 24);
+	} else {
+		dwval &= ~(1 << 20);
+		dwval |= (1 << 24);
+	}
+	reg->dit_setting.dwval = dwval;
+	reg->dit_setting.bits.ela_demo_win_en = 1;
+	reg->dit_setting.bits.field_weave_demo_win_en = 1;
+	reg->dit_setting.bits.video_blend_demo_win_en = 1;
+
+	reg->dit_chr_para0.dwval = 0x30058000;
+	dwval = 0x04300000;
+	/* want to reduce flicker of chroma text when noisy video */
+	/* dwval |= (1 << 8); */
+	/* want to reduce flicker of chorma when noisy video */
+	/* dwval |= 1; */
+	reg->dit_chr_para1.dwval = dwval;
+	reg->dit_intra_para.dwval = 0x514240ac;
+	reg->dit_inter_para.dwval = 0x22000000;
+
+	/* apply fmd fixed para */
+	/* block size of VOF : 0-8x8(default); 1-16x16 */
+	vof_blk_size_sel = 0;
+	if (c->mode == DI_MODE_60HZ)
+		reg->fmd_glb.dwval = (1 << 31) | vof_blk_size_sel;
+	else
+		reg->fmd_glb.dwval = (0 << 31) | vof_blk_size_sel;
+	c->vof_blk_size_sel = vof_blk_size_sel;
+
+	reg->fmd_diff_th0.dwval = 0xff03ff00;
+	reg->fmd_diff_th1.dwval = 0x0003ff00;
+	reg->fmd_diff_th2.dwval = 0x0220ff00;
+	reg->fmd_feat_th0.dwval = 0x05200405;
+	reg->fmd_feat_th1.dwval = 0x030100c0;
+	reg->fmd_feat_th2.dwval = 0x00020609;
+	reg->fmd_mot_th.dwval = 0x02090010;
+	reg->fmd_text_th.dwval = 0x000000c0;
+	if (vof_blk_size_sel) {
+		reg->fmd_blk_th.dwval = 0x00555520;
+		dwval = 3 * c->video_size.width * c->video_size.height /
+			(720 * 480 * 4);
+		dwval |= ((2 * c->video_size.width * c->video_size.height /
+			(720 * 480 * 4)) << 8);
+	} else {
+		reg->fmd_blk_th.dwval = 0x00151508;
+		dwval = 3 * c->video_size.width * c->video_size.height /
+			(720 * 480);
+		dwval |= ((2 * c->video_size.width * c->video_size.height /
+			(720 * 480)) << 8);
+	}
+	reg->fmd_row_th.dwval = dwval | (60 << 16);
+
+	/* apply tnr fixed para */
+	reg->tnr_strength.dwval = 0x003a3a3a;
+	reg->tnr_dark_th.dwval = 0x00010101;
+	reg->tnr_dark_protect.dwval = 0x00030303;
+	reg->tnr_dark_para_y.dwval = 0x01000100;
+	reg->tnr_dark_para_u.dwval = 0x01000100;
+	reg->tnr_dark_para_v.dwval = 0x01000100;
+	reg->tnr_fth_detect.dwval = 0x00640101;
+	reg->tnr_dt_filter.dwval = 0x0040000f;
+	reg->tnr_weight_lbound.dwval = 0x3f201610;
+	reg->tnr_abn_detect.dwval = 0x00780101;
+	reg->tnr_th_sum.dwval = 0x00000000;
+	reg->tnr_sum_weight_y = 0x0;
+	reg->tnr_sum_weight_u = 0x0;
+	reg->tnr_sum_weight_v = 0x0;
+	reg->tnr_sum_gain_y = 0x0;
+	reg->tnr_sum_gain_u = 0x0;
+	reg->tnr_sum_gain_v = 0x0;
+	reg->tnr_sum_still_out = 0x0;
+	reg->tnr_sum_weight_y_cnt = 0x0;
+	reg->tnr_sum_gain_y_cnt = 0x0;
+	reg->tnr_th_dark_dth.dwval = 0x00000202;
+	reg->tnr_random_cfg.dwval = 0x02031c01;
+	reg->tnr_random_gen = 0x0;
+	reg->tnr_md_result.dwval = 0x00000000;
+
+	/* apply alg fixed para */
+	di_alg_fixed_para(c, &(cdata->proc_rst));
+
+	return 0;
+}
+
+s32 di_dev_save_spot(void *client)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	struct di_client *c = (struct di_client *)client;
+	struct di_dev_cdata *cdata =
+		(struct di_dev_cdata *)c->dev_cdata;
+
+	if (c->mode != DI_MODE_60HZ)
+		return 0;
+
+	if (cdata->vof_buf == NULL) {
+		cdata->vof_buf = kzalloc(
+			sizeof(*(cdata->vof_buf)), GFP_KERNEL);
+		if (!cdata->vof_buf) {
+			DI_ERR(TAG"kzalloc for vof_buf failed, size=%d\n",
+				(u32)sizeof(*(cdata->vof_buf)));
+			return -1;
+		}
+	}
+
+	reg->bist_ctl.bits.bist_mode_en = 1;
+	memcpy((void *)cdata->vof_buf,
+		(void *)((u8 *)reg + DI_VOF_BUF_REG_ADDR_A),
+		sizeof(*(cdata->vof_buf)));
+	reg->bist_ctl.bits.bist_mode_en = 0;
+	cdata->vof_buf_sel = reg->fmd_glb.bits.vof_buf_sel;
+
+	return 0;
+}
+
+s32 di_dev_restore_spot(void *client)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	struct di_client *c = (struct di_client *)client;
+	struct di_dev_cdata *cdata =
+		(struct di_dev_cdata *)c->dev_cdata;
+
+	if ((c->mode != DI_MODE_60HZ)
+		|| (cdata->vof_buf == NULL))
+		return 0;
+
+	reg->bist_ctl.bits.bist_mode_en = 1;
+	memcpy((void *)((u8 *)reg + DI_VOF_BUF_REG_ADDR_A),
+		(void *)cdata->vof_buf,
+		sizeof(*(cdata->vof_buf)));
+	reg->bist_ctl.bits.bist_mode_en = 0;
+	reg->fmd_glb.bits.vof_buf_sel = cdata->vof_buf_sel;
+
+	return 0;
+}
+
+s32 di_dev_enable_irq(u32 irq_flag, u32 en)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	u32 reg_val = readl(&reg->int_ctl);
+
+	if (en)
+		reg_val |= irq_flag;
+	else
+		reg_val &= ~irq_flag;
+	writel(reg_val, &reg->int_ctl);
+
+	return 0;
+}
+
+/*clear di finish bit*/
+u32 di_dev_query_state_with_clear(u32 irq_state)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	u32 reg_val = readl(&reg->status);
+	u32 state = reg_val & irq_state & DI_IRQ_STATE_MASK;
+
+	reg_val &= ~DI_IRQ_STATE_MASK;
+	reg_val |= state;
+	writel(reg_val, &reg->status); /* w1c */
+
+	return state;
+}
+
+void di_dev_start(u32 start)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	reg->start.dwval = start;
+}
+
+/* reset then stop reset */
+void di_dev_reset(void)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+	const u32 t = 1;
+
+	reg->reset.bits.reset = 1;
+	udelay(t);
+	reg->reset.bits.reset = 0;
+}
+
+u32 di_dev_get_cdata_size(void)
+{
+	return (u32)sizeof(struct di_dev_cdata);
+}
+
+u32 di_dev_reset_cdata(void *dev_cdata)
+{
+	struct di_dev_cdata *cdata = (struct di_dev_cdata *)dev_cdata;
+
+	if (cdata->vof_buf)
+		kfree(cdata->vof_buf);
+
+	memset((void *)cdata, 0, sizeof(*cdata));
+
+	return 0;
+}
+
+u32 di_dev_get_ip_version(void)
+{
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	return reg->ip_version;
+}
+
+void di_dev_dump_reg_value(void)
+{
+	unsigned int *addr;
+	unsigned long i;
+	struct di_reg *reg = di_dev_get_reg_base();
+
+	addr = (unsigned int *)reg;
+
+	DI_INFO("GENERAL TOP REG:\n");
+	for (i = 0x0; i <= 0x38; i += 4) {
+		if ((i % 16) == 0)
+			DI_INFO("0x%08lx:", i);
+		DI_INFO("0x%08x ", *((unsigned int *)((unsigned long)addr + i)));
+		if (((i + 4) % 16) == 0)
+			DI_INFO("\n");
+	}
+	DI_INFO("\n");
+
+	DI_INFO("TOP PITCH REG:\n");
+	for (i = 0x40; i <= 0x78; i += 4) {
+		if ((i % 16) == 0)
+			DI_INFO("0x%08lx:", i);
+		DI_INFO("0x%08x ", *((unsigned int *)((unsigned long)addr + i)));
+		if (((i + 4) % 16) == 0)
+			DI_INFO("\n");
+
+	}
+	DI_INFO("\n");
+
+	DI_INFO("TOP ADDR REG:\n");
+	for (i = 0x90; i <= 0x128; i += 4) {
+		if ((i % 16) == 0)
+			DI_INFO("0x%08lx:", i);
+		DI_INFO("0x%08x ", *((unsigned int *)((unsigned long)addr + i)));
+		if (((i + 4) % 16) == 0)
+			DI_INFO("\n");
+
+	}
+	DI_INFO("\n");
+
+	DI_INFO("MD REG:\n");
+	for (i = 0x180; i <= 0x194; i += 4) {
+		if ((i % 16) == 0)
+			DI_INFO("0x%08lx:", i);
+		DI_INFO("0x%08x ", *((unsigned int *)((unsigned long)addr + i)));
+		if (((i + 4) % 16) == 0)
+			DI_INFO("\n");
+
+	}
+	DI_INFO("\n");
+
+	DI_INFO("DIT REG:\n");
+	for (i = 0x1a0; i <= 0x1cc; i += 4) {
+		if ((i % 16) == 0)
+			DI_INFO("0x%08lx:", i);
+		DI_INFO("0x%08x ", *((unsigned int *)((unsigned long)addr + i)));
+		if (((i + 4) % 16) == 0)
+			DI_INFO("\n");
+
+	}
+	DI_INFO("\n");
+
+	DI_INFO("FMD REG:\n");
+	for (i = 0x1d0; i <= 0x234; i += 4) {
+		if ((i % 16) == 0)
+			DI_INFO("0x%08lx:", i);
+		DI_INFO("0x%08x ", *((unsigned int *)((unsigned long)addr + i)));
+		if (((i + 4) % 16) == 0)
+			DI_INFO("\n");
+
+	}
+	DI_INFO("\n");
+
+	DI_INFO("TNR REG:\n");
+	for (i = 0x240; i <= 0x2ac; i += 4) {
+		if ((i % 16) == 0)
+			DI_INFO("0x%08lx:", i);
+		DI_INFO("0x%08x ", *((unsigned int *)((unsigned long)addr + i)));
+		if (((i + 4) % 16) == 0)
+			DI_INFO("\n");
+
+	}
+	DI_INFO("\n");
+
+	DI_INFO("DEBUG REG:\n");
+	for (i = 0x2d0; i <= 0x2e8; i += 4) {
+		if ((i % 16) == 0)
+			DI_INFO("0x%08lx:", i);
+		DI_INFO("0x%08x ", *((unsigned int *)((unsigned long)addr + i)));
+		if (((i + 4) % 16) == 0)
+			DI_INFO("\n");
+
+	}
+	DI_INFO("\n");
+}
diff --git a/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300.h b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300.h
new file mode 100644
index 000000000..14226697c
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI300_H_
+#define _DI300_H_
+
+#include <linux/types.h>
+
+
+enum di_irq_flag {
+	DI_IRQ_FLAG_PROC_FINISH = 0x1 << 0,
+	DI_IRQ_FLAG_MASK =
+		DI_IRQ_FLAG_PROC_FINISH,
+};
+
+enum di_irq_state {
+	DI_IRQ_STATE_PROC_FINISH  = 0x1 << 0,
+	DI_IRQ_STATE_MASK =
+		DI_IRQ_STATE_PROC_FINISH,
+};
+
+void di_dev_set_reg_base(void __iomem *reg_base);
+void di_dev_exit(void);
+
+s32 di_dev_apply_fixed_para(void *client);
+s32 di_dev_apply_para(void *client);
+s32 di_dev_get_proc_result(void *client);
+s32 di_dev_save_spot(void *client);
+s32 di_dev_restore_spot(void *client);
+s32 di_dev_enable_irq(u32 irq_flag, u32 en);
+u32 di_dev_query_state_with_clear(u32 irq_state);
+void di_dev_start(u32 start);
+void di_dev_reset(void);
+
+u32 di_dev_get_cdata_size(void);
+u32 di_dev_reset_cdata(void *dev_cdata);
+
+/* works after di_dev_enable??? */
+u32 di_dev_get_ip_version(void);
+
+void di_dev_dump_reg_value(void);
+
+
+#endif /* #ifndef _DI300_H_ */
diff --git a/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_alg.c b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_alg.c
new file mode 100644
index 000000000..a80996872
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_alg.c
@@ -0,0 +1,2147 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "di300_alg.h"
+#include "../di_debug.h"
+
+u32 p2_period[8] = { PROD22, PROD32, PROD2332, PROD2224, PROD32322,
+	PROD55, PROD64, PROD87
+};
+
+/* p2 lowhigh */
+u8 p2_lh_22[PROD22] = { 1, 1 };
+u8 p2_lh_32[PROD32] = { 1, 1, 1, 0, 1 };
+u8 p2_lh_2332[PROD2332] = { 1, 1, 1, 0, 1, 1, 0, 1, 1, 1 };
+u8 p2_lh_2224[PROD2224] = { 1, 1, 1, 1, 1, 1, 1, 0, 0, 1 };
+u8 p2_lh_32322[PROD32322] = { 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1 };
+u8 p2_lh_55[PROD55] = { 1, 0, 0, 0, 1 };
+u8 p2_lh_64[PROD64] = { 1, 0, 0, 0, 0, 1, 1, 0, 0, 1 };
+u8 p2_lh_87[PROD87] = { 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1 };
+
+/* p1 lowhigh */
+u8 p1_lh_22[PROD22] = { 0, 1 };
+u8 p1_lh_32[PROD32] = { 0, 1, 0, 0, 1 };
+u8 p1_lh_2332[PROD2332] = { 0, 1, 0, 0, 1, 0, 0, 1, 0, 1 };
+u8 p1_lh_2224[PROD2224] = { 0, 1, 0, 1, 0, 1, 0, 0, 0, 1 };
+u8 p1_lh_32322[PROD32322] = { 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1 };
+u8 p1_lh_55[PROD55] = { 0, 0, 0, 0, 1 };
+u8 p1_lh_64[PROD64] = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 1 };
+u8 p1_lh_87[PROD87] = { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 };
+
+/* field weave phase */
+u8 fw_ph_22[PROD22] = { 0, 2 };
+u8 fw_ph_32[PROD32] = { 2, 0, 2, 1, 0 };
+u8 fw_ph_2332[PROD2332] = { 2, 0, 2, 1, 0, 2, 1, 0, 2, 0 };
+u8 fw_ph_2224[PROD2224] = { 2, 0, 2, 0, 2, 0, 2, 1, 1, 0 };
+u8 fw_ph_32322[PROD32322] = { 2, 1, 0, 2, 0, 2, 1, 0, 2, 0, 2, 0 };
+u8 fw_ph_55[PROD55] = { 2, 1, 1, 1, 0 };
+u8 fw_ph_64[PROD64] = { 2, 1, 1, 1, 1, 0, 2, 1, 1, 0 };
+u8 fw_ph_87[PROD87] = { 2, 1, 1, 1, 1, 1, 1, 0, 2, 1, 1, 1, 1, 1, 0 };
+
+/*******************************************************************/
+/*                  Field Order Detection Algorithm                */
+/*******************************************************************/
+static void di_alg_field_order_detection(
+	struct __fmd_hist *fmd_hist,
+	struct __di_para_t *di_para,
+	struct __fod_alg_hist *alg_hist)
+{
+	s32 mf0diff, mf1diff, intraf0diff, intraf1diff;
+	struct __fod_alg_para *alg_para = &di_para->alg_para.fod_alg_para;
+	s32 maxmfdiff;
+	s32 diffs;
+
+	/* f0t and f1b */
+	mf0diff = (di_para->bff) ? fmd_hist->FOD_FID12 : fmd_hist->FOD_FID30;
+	/* f0b and f1t */
+	mf1diff = (di_para->bff) ? fmd_hist->FOD_FID30 : fmd_hist->FOD_FID12;
+
+	intraf0diff = fmd_hist->FOD_FID10;	/* f0t and f0b */
+	intraf1diff = fmd_hist->FOD_FID32;	/* f1t and f1b */
+
+	maxmfdiff = mf0diff >= mf1diff ? mf0diff : mf1diff;
+	/* one of intra-frame difference not small than
+	 * mean(or max) of inter-frame difference
+	 */
+	if (intraf0diff * alg_para->R_kick > maxmfdiff ||
+	    intraf1diff * alg_para->R_kick > maxmfdiff) {
+		diffs = mf0diff - mf1diff;
+
+		DI_INFO("large than maxmfdiff, intraf0diff:%d intraf1diff:%d alg_para->R_kick:%d\n",
+				intraf0diff, intraf1diff, alg_para->R_kick);
+		DI_INFO("mf0diff:%d mf1diff:%d\n", mf0diff, mf1diff);
+		DI_INFO("di_para->bff:%d\n", di_para->bff);
+		if (di_para->bff == 0) {
+			if ((diffs < 0) &&
+			    ((mf0diff * alg_para->R_rev_10) < (mf1diff * 10)) &&
+			    (mf1diff > alg_para->T_rev)) {
+				DI_INFO("bff 0, diffs:%d\n", diffs);
+				DI_INFO("R_rev_10 compare:%d %d\n",
+					mf0diff * alg_para->R_rev_10, mf1diff * 10);
+				DI_INFO("mf1diff:%d T_rev:%d\n", mf1diff, alg_para->T_rev);
+				alg_hist->rev_cnt_bff += 1;
+			} else {
+				alg_hist->rev_cnt_bff = 0;
+				alg_hist->rev_cnt_tff = 0;
+			}
+		} else {
+			if ((diffs > 0) &&
+			    ((mf1diff * alg_para->R_rev_10) < (mf0diff * 10)) &&
+			    (mf0diff > alg_para->T_rev)) {
+				DI_INFO("bff 1, diffs:%d\n", diffs);
+				DI_INFO("R_rev_10 compare:%d %d\n",
+					mf1diff * alg_para->R_rev_10, mf0diff * 10);
+				DI_INFO("mf1diff:%d T_rev:%d\n", mf0diff, alg_para->T_rev);
+				alg_hist->rev_cnt_tff += 1;
+			} else {
+				alg_hist->rev_cnt_bff = 0;
+				alg_hist->rev_cnt_tff = 0;
+			}
+		}
+
+		DI_INFO("rev_cnt_bff:%d rev_cnt_tff:%d T_rev_time:%d\n",
+				alg_hist->rev_cnt_bff, alg_hist->rev_cnt_tff, alg_para->T_rev_time);
+		if (alg_hist->rev_cnt_bff == alg_para->T_rev_time) {
+			alg_hist->bff_fix = 1;
+			alg_hist->rev_cnt_bff = 0;
+			alg_hist->rev_cnt_tff = 0;
+			alg_hist->is_fieldorderchange = 1;
+		} else if (alg_hist->rev_cnt_tff == alg_para->T_rev_time) {
+			alg_hist->bff_fix = 0;
+			alg_hist->rev_cnt_bff = 0;
+			alg_hist->rev_cnt_tff = 0;
+			alg_hist->is_fieldorderchange = 1;
+		} else {
+			alg_hist->bff_fix = di_para->bff;
+			alg_hist->is_fieldorderchange = 0;
+		}
+	} else {
+		DI_INFO("lower than maxmfdiff\n");
+		alg_hist->bff_fix = di_para->bff;
+		alg_hist->is_fieldorderchange = 0;
+	}
+}
+
+/*******************************************************************/
+/*                    Film Mode Detection Algorithm                */
+/*******************************************************************/
+static u32 di_alg_fmd_sc_detect(u32 sc_array[], u32 *sc_length,
+	u32 cur_totalfid, u32 r_sc,
+	u32 t_p1diff, u32 t_p1diff_u, u32 cadence_cur)
+{
+	u32 is_scenechange;
+	u32 i;
+	u32 sum_sc, mean_sc;
+
+	is_scenechange = 0;
+	if (*sc_length == 4) {
+		sum_sc = 0;
+		for (i = 0; i < *sc_length; i++)
+			sum_sc += sc_array[i];
+		mean_sc = sum_sc / 4;
+
+		if ((cur_totalfid > mean_sc * r_sc &&
+		     cur_totalfid > t_p1diff) || (cur_totalfid > t_p1diff_u))
+			is_scenechange = 1;
+	} else {
+		if (cur_totalfid > t_p1diff_u)
+			is_scenechange = 1;
+	}
+
+	/* update sc_array */
+	if (cadence_cur) {
+		if (*sc_length < 4 && *sc_length > 0) {
+			(*sc_length)++;
+			sc_array[(*sc_length) - 1] = cur_totalfid;
+		} else {
+			for (i = 0; i < 3; i++)
+				sc_array[i] = sc_array[i + 1];
+			sc_array[3] = cur_totalfid;
+		}
+	}
+
+	return is_scenechange;
+}
+
+static u32 di_alg_fmd_22_trace(u32 weave_phase_pre,
+	u32 *weave_phase_cur, u32 cadence_cur,
+	u32 is_scenechange, u32 is_scenetrace)
+{
+	u32 predict_lowhigh;
+	u32 is_lock;
+
+	/* update weave_phase */
+	*weave_phase_cur = (1 - weave_phase_pre);
+
+	/* update predict_lowhigh */
+	predict_lowhigh = (*weave_phase_cur) ? 0 : 1;
+
+	/* trace */
+	is_lock = 1;
+
+	/* Lost lock situation
+	 * 1.normal cadence break situation
+	 * 2.scene change break situation
+	 */
+	if (predict_lowhigh == 0 && cadence_cur == 1)
+		is_lock = 0;
+	else if ((is_scenechange && predict_lowhigh == 0) ||
+		(is_scenetrace && predict_lowhigh == 1 && cadence_cur == 0))
+		is_lock = 0;
+
+	return is_lock;
+}
+
+static u32 di_alg_fmd_22_detect(
+	u32 cadence_cur[], u32 init_field_cnt,
+	u32 *weave_phase, s32 period22_x0,
+	s32 period22_10, u32 fmd_22_en)
+{
+	u32 is_lock;
+	u32 ped = 2;
+	s32 i;
+	s32 log_10, log_x0;
+
+	is_lock = 0;
+	log_10 = 0;
+	log_x0 = 0;
+
+	if ((!init_field_cnt) || (init_field_cnt > FMD22FIELDNUM)) {
+		DI_DEBUG("WARN: %s init_field_cnt is too big\n", __func__);
+		DI_DEBUG("WARN: init_field_cnt:%d  FMD22FIELDNUM:%d\n", init_field_cnt,
+								FMD22FIELDNUM);
+		return is_lock;
+	}
+
+	if (init_field_cnt > 0 && cadence_cur[init_field_cnt - 1] == 0 &&
+	    init_field_cnt >= period22_x0 * ped && fmd_22_en == 1) {
+		for (i = 1; i <= period22_x0; i++) {
+			if (cadence_cur[init_field_cnt - i * ped] == 1 &&
+			    cadence_cur[init_field_cnt - i * ped + 1] == 0)
+				log_10++;
+			if (cadence_cur[init_field_cnt - i * ped + 1] == 0)
+				log_x0++;
+		}
+
+		if (log_x0 == period22_x0 && log_10 >= period22_10) {
+			is_lock = 1;
+			*weave_phase = 1;
+		}
+	}
+	return is_lock;
+}
+
+static void di_alg_fmd_p1(u32 cur_fid, u32 pre_fid, u32 t_thrl,
+	u32 t_thrh, u32 avgns, u32 r_film22rel, u32 r_film22rel2,
+	u32 cad_low_array[], u32 *cad_low_length, u32 *cadence_cur)
+{
+	u32 high_fid, low_fid;
+	u32 highcan;
+	s32 i;
+	u32 sum_cad_low, mean_cad_low, cad_low_valid;
+
+	high_fid = cur_fid >= pre_fid ? cur_fid : pre_fid;
+	low_fid = cur_fid <= pre_fid ? cur_fid : pre_fid;
+
+	highcan = (cur_fid > pre_fid) ? 1 : 0;
+
+	if (*cad_low_length < 10) {
+		cad_low_valid = 0;
+		mean_cad_low = 0;
+	} else {
+		cad_low_valid = 1;
+		sum_cad_low = 0;
+		for (i = 0; i < 10; i++)
+			sum_cad_low += cad_low_array[i];
+		mean_cad_low = sum_cad_low / 10;
+	}
+
+	/* decide cadence_cur */
+	if (((highcan == 1) &&
+		(low_fid < t_thrl) &&
+		((low_fid + avgns) * r_film22rel < (high_fid + avgns))) ||
+		(cur_fid > t_thrh) ||
+		(low_fid > t_thrl) ||
+		(((cur_fid + avgns) > r_film22rel2 * (mean_cad_low + avgns)) &&
+		(cad_low_valid == 1))) {
+		*cadence_cur = 1;
+	} else {
+		*cadence_cur = 0;
+	}
+
+	/* update cad_low_array */
+	if (*cadence_cur == 0) {
+		if (*cad_low_length < 10) {
+			cad_low_array[*cad_low_length] = cur_fid;
+			*cad_low_length = *cad_low_length + 1;
+		} else {
+			for (i = 0; i < 9; i++)
+				cad_low_array[i] = cad_low_array[i + 1];
+			cad_low_array[9] = cur_fid;
+		}
+	}
+}
+
+static void di_alg_fmd_22(struct __fmd_hist *fmd_hist,
+	struct __di_para_t *di_para,
+	struct __fmd_alg_hist *alg_hist,
+	u32 is_fo_change, u32 is_text_field, u32 base_field)
+{
+	u32 p1_init_phase = alg_hist->p1_init_phase;
+	u32 init_field_cnt_22 = alg_hist->init_field_cnt_22;
+	u32 is_22_lock_pre = alg_hist->is_22_lock;
+	s32 sc_trace_cnt = alg_hist->sc_trace_cnt;
+	u32 sc_length = alg_hist->sc_length;
+	u32 pre_totalfid = alg_hist->pre_totalfid;
+	u32 cur_totalfid = (base_field) ? fmd_hist->FMD_FID23 :
+	    fmd_hist->FMD_FID12;
+	u32 cad_low_length = alg_hist->cad_low_length;
+	u32 weave_phase_22_pre = alg_hist->weave_phase_22;
+	u32 weave_phase_22_cur = 0;
+	u32 is_22_lock_cur;
+	u32 is_scenechange;
+	u32 is_scenetrace;
+	u32 is_22_temp_di;
+	u32 cadence_cur;
+
+	s32 i, width, heightf;
+	u32 t_p1diffthrl, t_p1diffthrh, avgns;
+	u32 t_p1diff, t_p1diff_u;
+
+	width = di_para->width;
+	heightf = di_para->height / 2;
+
+	/* if no pre field fid, pass the detection */
+	if (alg_hist->pre_totalfid_valid == 0)
+		goto ALG_FMD_22_END;
+
+	/* Calculate cadence_cur */
+	t_p1diffthrl = di_para->alg_para.fmd_alg_para.t_p1diffthrl_pixel *
+	    width * heightf;
+	t_p1diffthrh = di_para->alg_para.fmd_alg_para.t_p1diffthrh_pixel *
+	    width * heightf;
+	avgns = di_para->alg_para.fmd_alg_para.avgns_pixel * width * heightf;
+
+	di_alg_fmd_p1(cur_totalfid, pre_totalfid, t_p1diffthrl, t_p1diffthrh,
+		avgns,
+		di_para->alg_para.fmd_alg_para.r_film22rel,
+		di_para->alg_para.fmd_alg_para.r_film22rel2,
+		alg_hist->cad_low_array, &cad_low_length, &cadence_cur);
+
+	/* Update cadence_cur */
+	if (init_field_cnt_22 < FMD22FIELDNUM) {
+		alg_hist->cadence_cur[init_field_cnt_22] = cadence_cur;
+	} else {
+		for (i = 0; i < FMD22FIELDNUM - 1; i++)
+			alg_hist->cadence_cur[i] = alg_hist->cadence_cur[i + 1];
+		alg_hist->cadence_cur[FMD22FIELDNUM - 1] = cadence_cur;
+	}
+
+	p1_init_phase = (init_field_cnt_22 < 1) ? 0 : 1;
+	if (init_field_cnt_22 < FMD22FIELDNUM)
+		init_field_cnt_22++;
+
+	t_p1diff = di_para->alg_para.fmd_alg_para.t_p1diff_pixel *
+	    width * heightf;
+	t_p1diff_u = di_para->alg_para.fmd_alg_para.t_p1diff_u_pixel *
+	    width * heightf;
+	is_scenechange = di_alg_fmd_sc_detect(alg_hist->sc_array, &sc_length,
+		cur_totalfid, di_para->alg_para.fmd_alg_para.r_sc,
+		t_p1diff, t_p1diff_u, cadence_cur);
+
+	if (is_scenechange)
+		init_field_cnt_22 = 0;
+
+	/* trace or detect */
+	is_scenetrace = (is_22_lock_pre && sc_trace_cnt > 0) ? 1 : 0;
+	if (is_22_lock_pre) {	/* if last field 2-2 lock */
+		is_22_lock_cur = di_alg_fmd_22_trace(
+			weave_phase_22_pre, &weave_phase_22_cur,
+			cadence_cur, is_scenechange, is_scenetrace);
+
+		if (is_text_field)	/* when text exist, all film mode unlock */
+			is_22_lock_cur = 0;
+
+		if (is_22_lock_cur) {
+			if (is_scenechange)
+				sc_trace_cnt =
+				    di_para->alg_para.fmd_alg_para.sc_trace_fnum;
+
+			if (is_scenetrace)
+				sc_trace_cnt -= 1;
+		} else {
+			init_field_cnt_22 = 0;
+			sc_trace_cnt = 0;
+			cad_low_length = 0;
+		}
+	} else {
+		if (p1_init_phase == 1 && is_text_field == 0)
+			is_22_lock_cur =
+				di_alg_fmd_22_detect(alg_hist->cadence_cur,
+					init_field_cnt_22, &weave_phase_22_cur,
+					di_para->alg_para.fmd_alg_para.period22_x0,
+					di_para->alg_para.fmd_alg_para.period22_10,
+					di_para->alg_para.fmd_alg_para.fmd_22_en);
+		else
+			is_22_lock_cur = 0;
+	}
+
+	/* is_22_temp_di */
+	if (is_22_lock_cur
+		&& (is_scenechange || is_scenetrace))
+		is_22_temp_di = 1;
+	else
+		is_22_temp_di = 0;
+
+	/* update hist */
+	alg_hist->p1_init_phase = p1_init_phase;
+	alg_hist->init_field_cnt_22 = init_field_cnt_22;
+	alg_hist->is_22_lock = is_22_lock_cur;
+	alg_hist->is_22_temp_di = is_22_temp_di;
+	alg_hist->sc_trace_cnt = sc_trace_cnt;
+	alg_hist->sc_length = sc_length;
+	alg_hist->cad_low_length = cad_low_length;
+	alg_hist->weave_phase_22 = weave_phase_22_cur;
+
+	if (base_field)
+		alg_hist->is_scenechange_f4 = is_scenechange;
+	else
+		alg_hist->is_scenechange_f3 = is_scenechange;
+	if (base_field)
+		alg_hist->is_scenechange_f4 = is_scenechange;
+	else
+		alg_hist->is_scenechange_f3 = is_scenechange;
+
+ALG_FMD_22_END:
+	alg_hist->pre_totalfid = cur_totalfid;
+	alg_hist->pre_totalfid_valid = 1;
+}
+
+static void di_alg_fmd_init_lh(
+	u32 p2_array[15], u32 *high_p2diff, u32 *low_p2diff)
+{
+	s32 i, j;
+	u32 max_seq[9];
+	u32 min_maxseq;
+	u32 sum_seq5678, mean5678;
+
+	/* max_seq[0] */
+	max_seq[0] = p2_array[0];
+	*low_p2diff = p2_array[0];
+	for (j = 1; j < 6; j++) {
+		if (max_seq[0] < p2_array[j])
+			max_seq[0] = p2_array[j];
+
+		if (*low_p2diff > p2_array[j])
+			*low_p2diff = p2_array[j];
+	}
+
+	/* max_seq[1] ~ max_seq[8] */
+	for (i = 1; i < 9; i++) {
+		if (p2_array[i + 5] > max_seq[i - 1])
+			max_seq[i] = p2_array[i + 5];
+		else
+			max_seq[i] = max_seq[i - 1];
+
+		if (*low_p2diff > p2_array[i + 5])
+			*low_p2diff = p2_array[i + 5];
+	}
+
+	min_maxseq = max_seq[1];
+	for (i = 2; i < 9; i++) {
+		if (min_maxseq > max_seq[i])
+			min_maxseq = max_seq[i];
+	}
+
+	sum_seq5678 = 0;
+	for (i = 5; i < 9; i++) {
+		sum_seq5678 += max_seq[i];
+	}
+	mean5678 = sum_seq5678 / 4;
+
+	*high_p2diff = (mean5678 + min_maxseq) / 2;
+
+}
+
+static s32 di_alg_fmd_calc_meanlowbefore(
+	u32 p2diff_la[], u32 la_length, u32 low_p2diff)
+{
+	s32 meanlowbefore;
+	u32 i;
+	u32 tmp_sum;
+
+	tmp_sum = 0;
+	switch (la_length) {
+	case 0:
+		meanlowbefore = low_p2diff;
+		break;
+	case 1:
+		meanlowbefore = p2diff_la[0];
+		break;
+	case 2:
+		meanlowbefore = (p2diff_la[0] + p2diff_la[1]) / 2;
+		break;
+	case 3:
+		meanlowbefore = (p2diff_la[1] + p2diff_la[2]) / 2;
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		for (i = la_length - 4; i < la_length; i++)
+			tmp_sum += p2diff_la[i];
+		meanlowbefore = tmp_sum / 4;
+		break;
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+		for (i = la_length - 8; i < la_length; i++)
+			tmp_sum += p2diff_la[i];
+		meanlowbefore = tmp_sum / 8;
+		break;
+	default:
+		for (i = 0; i < la_length; i++)
+			tmp_sum += p2diff_la[i];
+		meanlowbefore = tmp_sum / 16;
+		break;
+
+	}
+	return meanlowbefore;
+}
+
+static s32 di_alg_fmd_calc_biaslowbefore(
+	u32 p2diff_la[], u32 la_length, s32 meanlowbefore)
+{
+	s32 biaslowbefore;
+	u32 i;
+	u32 tmp_sum;
+
+	tmp_sum = 0;
+	switch (la_length) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		biaslowbefore = 0;
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		for (i = la_length - 4; i < la_length; i++)
+			tmp_sum +=
+			    abs((s32) p2diff_la[i] - (s32) meanlowbefore);
+		biaslowbefore = tmp_sum / 4;
+		break;
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+		for (i = la_length - 8; i < la_length; i++)
+			tmp_sum +=
+			    abs((s32) p2diff_la[i] - (s32) meanlowbefore);
+		biaslowbefore = tmp_sum / 8;
+		break;
+	default:
+		for (i = 0; i < la_length; i++)
+			tmp_sum +=
+			    abs((s32) p2diff_la[i] - (s32) meanlowbefore);
+		biaslowbefore = tmp_sum / 16;
+		break;
+	}
+	return biaslowbefore;
+}
+
+static s32 di_alg_fmd_calc_meanhighbefore(
+	u32 p2diff_ha[], u32 ha_length, u32 high_p2diff)
+{
+	s32 meanhighbefore;
+	u32 i;
+	u32 tmp_sum;
+
+	tmp_sum = 0;
+	switch (ha_length) {
+	case 0:
+		meanhighbefore = high_p2diff;
+		break;
+	case 1:
+		meanhighbefore = p2diff_ha[0];
+		break;
+	case 2:
+		meanhighbefore = (p2diff_ha[0] + p2diff_ha[1]) / 2;
+		break;
+	case 3:
+		meanhighbefore = (p2diff_ha[1] + p2diff_ha[2]) / 2;
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		for (i = ha_length - 4; i < ha_length; i++)
+			tmp_sum += p2diff_ha[i];
+		meanhighbefore = tmp_sum / 4;
+		break;
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+		for (i = ha_length - 8; i < ha_length; i++)
+			tmp_sum += p2diff_ha[i];
+		meanhighbefore = tmp_sum / 8;
+		break;
+	default:
+		for (i = 0; i < ha_length; i++)
+			tmp_sum += p2diff_ha[i];
+		meanhighbefore = tmp_sum / 16;
+		break;
+
+	}
+	return meanhighbefore;
+}
+
+static void di_alg_fmd_calc_classifier_var(
+	u32 p2diff_la[], u32 p2diff_ha[],
+	u32 la_length, u32 ha_length,
+	u32 high_p2diff, u32 low_p2diff,
+	s32 *meanlowbefore, s32 *biaslowbefore, s32 *meanhighbefore)
+{
+	*meanlowbefore = di_alg_fmd_calc_meanlowbefore(
+		p2diff_la, la_length, low_p2diff);
+	*biaslowbefore = di_alg_fmd_calc_biaslowbefore(
+		p2diff_la, la_length, *meanlowbefore);
+	*meanhighbefore = di_alg_fmd_calc_meanhighbefore(
+		p2diff_ha, ha_length, high_p2diff);
+}
+
+static u32 di_alg_fmd_calc_lowhigh(s32 tmp_value, s32 meanlowbefore,
+	s32 biaslowbefore, s32 meanhighbefore,
+	u32 la_length, u32 high_p2diff,
+	s32 hl_ratio, s32 r_sigma3, s32 t_mlb,
+	s32 t_value, u32 r_lowcad, s32 t_sigma3, u32 r_sc)
+{
+	u32 low_high;
+	s32 sigma3;
+
+	low_high = 0;
+
+	/* classifier */
+	if ((meanhighbefore - tmp_value) <=
+	    (tmp_value - meanlowbefore) * (s32) r_lowcad) {
+		if (la_length < 4) {
+			if ((tmp_value - meanlowbefore) * 16 >
+			    hl_ratio * (meanhighbefore - meanlowbefore))
+				low_high = 1;
+		} else {
+			sigma3 = 3 * biaslowbefore * r_sigma3;
+
+			if (meanlowbefore < t_mlb) {
+				/* hl_ratio = hl_ratio; */
+			} else if (meanlowbefore < t_mlb * 3 / 2)
+				hl_ratio = hl_ratio - 1;
+			else if (meanlowbefore < 2 * t_mlb)
+				hl_ratio = hl_ratio - 2;
+			else
+				hl_ratio = hl_ratio - 3;
+
+			if ((tmp_value > t_value) ||
+				(tmp_value > (meanlowbefore + sigma3)))
+				low_high = 1;
+			else if ((sigma3 > t_sigma3) ||
+				(sigma3 * 4 < meanlowbefore)) {
+				if ((tmp_value - meanlowbefore) * 16 >
+					hl_ratio * (meanhighbefore - meanlowbefore))
+					low_high = 1;
+			}
+		}
+	}
+	return low_high;
+}
+
+static void di_alg_fmd_feedback(u32 p2diff_la[], u32 p2diff_ha[],
+	s32 *la_length, s32 *ha_length,
+	u32 low_high, u32 tmp_value,
+	u32 meanhighbefore, u32 r_fb_sc,
+	u32 low_index[], u32 high_index[], u32 field_index)
+{
+	u32 i;
+	if (low_high) {
+		if (tmp_value > meanhighbefore * r_fb_sc)
+			tmp_value = meanhighbefore;
+
+		if (*ha_length == 16) {
+			for (i = 0; i < 15; i++) {
+				p2diff_ha[i] = p2diff_ha[i + 1];
+				high_index[i] = high_index[i + 1];
+			}
+		} else {
+			*ha_length = *ha_length + 1;
+		}
+
+		if (*ha_length > 0) {
+			p2diff_ha[*ha_length - 1] = tmp_value;
+			high_index[*ha_length - 1] = field_index;
+		}
+	} else {
+		if (*la_length == 16) {
+			for (i = 0; i < 15; i++) {
+				p2diff_la[i] = p2diff_la[i + 1];
+				low_index[i] = low_index[i + 1];
+			}
+		} else {
+			*la_length = *la_length + 1;
+		}
+
+		if (*la_length > 0) {
+			p2diff_la[*la_length - 1] = tmp_value;
+			low_index[*la_length - 1] = field_index;
+		}
+	}
+}
+
+static u32 di_alg_fmd_lowhigh_classifier(u32 p2_array_cur,
+	u32 p2diff_la[], u32 p2diff_ha[],
+	s32 *la_length, s32 *ha_length,
+	u32 high_p2diff, u32 low_p2diff,
+	u32 *low_index, u32 *high_index, s32 hl_ratio,
+	s32 r_sigma3, s32 t_mlb, s32 t_value,
+	u32 r_lowcad, s32 t_sigma3,
+	u32 r_sc, u32 r_fb_sc, u32 field_index)
+{
+	u32 low_high;
+	s32 tmp_value;
+	s32 meanlowbefore, biaslowbefore, meanhighbefore;
+
+	if (p2_array_cur > high_p2diff * r_sc)
+		tmp_value = high_p2diff;
+	else
+		tmp_value = p2_array_cur;
+
+	di_alg_fmd_calc_classifier_var(p2diff_la, p2diff_ha,
+		*la_length, *ha_length, high_p2diff, low_p2diff,
+		&meanlowbefore, &biaslowbefore, &meanhighbefore);
+	low_high = di_alg_fmd_calc_lowhigh(tmp_value, meanlowbefore,
+		biaslowbefore, meanhighbefore,
+		*la_length, high_p2diff,
+		hl_ratio, r_sigma3, t_mlb, t_value,
+		r_lowcad, t_sigma3, r_sc);
+	di_alg_fmd_feedback(p2diff_la, p2diff_ha,
+		la_length, ha_length, low_high, tmp_value,
+		meanhighbefore, r_fb_sc, low_index,
+		high_index, field_index);
+
+	return low_high;
+}
+
+static u32 di_alg_fmd_non22_phase(u32 phase, u32 film_mode)
+{
+	u32 new_phase;
+	u32 period;
+
+	period = p2_period[film_mode];
+	new_phase = phase + 1;
+
+	return new_phase = new_phase % period;
+}
+
+static u32 di_alg_fmd_non22_p2_trace(
+	u32 phase, u32 film_mode, u32 lowhigh,
+	u32 cadence_cur, u32 cur_totalfid,
+	u32 fid_trace_en, u32 t_p1diff_trace)
+{
+	u32 is_lock;
+	u32 predict_lowhigh;
+	u8 *p2_lh, *p1_lh;
+
+	is_lock = 1;
+
+	switch (film_mode) {
+	case 1:
+		p2_lh = p2_lh_32;
+		break;
+	case 2:
+		p2_lh = p2_lh_2332;
+		break;
+	case 3:
+		p2_lh = p2_lh_2224;
+		break;
+	case 4:
+		p2_lh = p2_lh_32322;
+		break;
+	case 5:
+		p2_lh = p2_lh_55;
+		break;
+	case 6:
+		p2_lh = p2_lh_64;
+		break;
+	case 7:
+		p2_lh = p2_lh_87;
+		break;
+	default:
+		p2_lh = p2_lh_22;
+		break;
+	}
+
+	predict_lowhigh = p2_lh[phase];
+
+	/* use p2diff to trace */
+	if (predict_lowhigh == 0 && lowhigh == 1)
+		is_lock = 0;
+
+	/* use p1diff to trace */
+	if (fid_trace_en) {
+		switch (film_mode) {
+		case 1:
+			p1_lh = p1_lh_32;
+			break;
+		case 2:
+			p1_lh = p1_lh_2332;
+			break;
+		case 3:
+			p1_lh = p1_lh_2224;
+			break;
+		case 4:
+			p1_lh = p1_lh_32322;
+			break;
+		case 5:
+			p1_lh = p1_lh_55;
+			break;
+		case 6:
+			p1_lh = p1_lh_64;
+			break;
+		case 7:
+			p1_lh = p1_lh_87;
+			break;
+		default:
+			p1_lh = p1_lh_22;
+			break;
+		}
+
+		predict_lowhigh = p1_lh[phase];
+
+		if (predict_lowhigh == 0 && cadence_cur == 1 &&
+		    cur_totalfid >= t_p1diff_trace)
+			is_lock = 0;
+	}
+
+	return is_lock;
+}
+
+static u32 di_alg_fmd_non22_p1_trace(
+	u32 phase, u32 film_mode, u32 cadence_cur)
+{
+	u32 is_lock;
+	u8 *p1_lh;
+	u32 predict_lowhigh;
+
+	is_lock = 1;
+
+	switch (film_mode) {
+	case 1:
+		p1_lh = p1_lh_32;
+		break;
+	case 2:
+		p1_lh = p1_lh_2332;
+		break;
+	case 3:
+		p1_lh = p1_lh_2224;
+		break;
+	case 4:
+		p1_lh = p1_lh_32322;
+		break;
+	case 5:
+		p1_lh = p1_lh_55;
+		break;
+	case 6:
+		p1_lh = p1_lh_64;
+		break;
+	case 7:
+		p1_lh = p1_lh_87;
+		break;
+	default:
+		p1_lh = p1_lh_22;
+		break;
+	}
+
+	predict_lowhigh = p1_lh[phase];
+
+	if (predict_lowhigh == 0 && cadence_cur == 1)
+		is_lock = 0;
+
+	return is_lock;
+}
+
+static u32 di_alg_fmd_index_detect_ped1(
+	u32 pat, s32 enterperiod,
+	s32 index_length, u32 index_diff[])
+{
+	u32 log_ok;
+	s32 i;
+	u32 is_lock;
+
+	log_ok = 0;
+	is_lock = 0;
+	if (index_length >= enterperiod) {
+		for (i = 1; i <= enterperiod; i++) {
+			if (index_diff[index_length - i] == pat)
+				log_ok++;
+			else {
+				is_lock = 0;
+				goto LOCK_DETECT_FAIL;
+			}
+		}
+		is_lock = 1;
+	}
+LOCK_DETECT_FAIL:
+	return is_lock;
+}
+
+static u32 di_alg_fmd_index_detect_ped2(s32 ped, u32 pat2[],
+	s32 enterperiod, s32 index_length, u32 index_diff[])
+{
+	u32 log_ok;
+	s32 i;
+	u32 is_lock;
+
+	log_ok = 0;
+	is_lock = 0;
+	if (index_length >= enterperiod * ped) {
+		for (i = 1; i <= enterperiod; i++) {
+			if (index_diff[index_length - i * ped] == pat2[0] &&
+			    index_diff[index_length - i * ped + 1] == pat2[1])
+				log_ok++;
+			else {
+				is_lock = 0;
+				goto LOCK_DETECT_FAIL;
+			}
+		}
+		is_lock = 1;
+	}
+LOCK_DETECT_FAIL:
+	return is_lock;
+}
+
+static u32 di_alg_fmd_index_detect_ped4(s32 ped, u32 pat4[],
+	s32 enterperiod, s32 index_length, u32 index_diff[])
+{
+	u32 log_ok;
+	s32 i;
+	u32 is_lock;
+
+	log_ok = 0;
+	is_lock = 0;
+	if (index_length >= enterperiod * ped) {
+		for (i = 1; i <= enterperiod; i++) {
+			if (index_diff[index_length - i * ped] == pat4[0] &&
+			    index_diff[index_length - i * ped + 1] == pat4[1] &&
+			    index_diff[index_length - i * ped + 2] == pat4[2] &&
+			    index_diff[index_length - i * ped + 3] == pat4[3])
+				log_ok++;
+			else {
+				is_lock = 0;
+				goto LOCK_DETECT_FAIL;
+			}
+		}
+		is_lock = 1;
+	}
+LOCK_DETECT_FAIL:
+	return is_lock;
+}
+
+static u32 di_alg_fmd_non22_detect(
+	u32 low_index[], u32 high_index[],
+	s32 la_length, s32 ha_length, u32 lowhigh[],
+	u32 *mode, u32 *phase,
+	u32 fmd_32_en, s32 period32,
+	u32 fmd_2224_en, s32 period2224,
+	u32 fmd_2332_en, s32 period2332,
+	u32 fmd_32322_en, s32 period32322,
+	u32 fmd_55_en, s32 period55,
+	u32 fmd_64_en, s32 period64,
+	u32 fmd_87_en, s32 period87)
+{
+	u32 is_lock;
+	u32 low_index_diff[15], high_index_diff[15];
+	s32 i;
+	u32 recycle;
+	u32 sum_lowhigh;
+	u32 usehighidx;
+	s32 ped;
+
+	is_lock = 0;
+
+	recycle = 0;
+	if (la_length > 2) {
+		for (i = 0; i < la_length - 1; i++) {
+			if (low_index[i] > low_index[i + 1]) {
+				/* recycle */
+				low_index_diff[i] = 0xf0000000 - low_index[i] +
+				    low_index[i + 1];
+				recycle++;
+			} else {
+				low_index_diff[i] = low_index[i + 1] -
+				    low_index[i];
+			}
+		}
+	}
+
+	/* more than 1 time recycle, it must be a non-film mode video */
+	if (recycle > 1)
+		return is_lock;
+
+	recycle = 0;
+	if (ha_length > 2) {
+		for (i = 0; i < ha_length - 1; i++) {
+			if (high_index[i] > high_index[i + 1]) {
+				/* recycle */
+				high_index_diff[i] = 0xf0000000 -
+				    high_index[i] + high_index[i + 1];
+				recycle++;
+			} else {
+				high_index_diff[i] = high_index[i + 1] -
+				    high_index[i];
+			}
+		}
+	}
+
+	/* more than 1 time recycle, it must be a non-film mode video */
+	if (recycle > 1)
+		return is_lock;
+
+	sum_lowhigh = 0;
+	for (i = 0; i < FMD32FIELDNUM; i++)
+		sum_lowhigh += lowhigh[i];
+
+	usehighidx = (sum_lowhigh > FMD32FIELDNUM / 2) ? 0 : 1;
+
+	if (usehighidx) {
+		if (fmd_55_en) {
+			/* phase5 */
+			u32 pat2[2][2] = { {1, 4}, {4, 1} };
+			ped = 2;
+			is_lock = di_alg_fmd_index_detect_ped2(ped, pat2[0],
+				period55, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_55;
+				*phase = 4;
+				return is_lock;
+			}
+
+			/* phase1 */
+			is_lock = di_alg_fmd_index_detect_ped2(ped, pat2[1],
+				period55, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_55;
+				*phase = 0;
+				return is_lock;
+			}
+		}
+
+		if (fmd_64_en) {
+			/* phase10 */
+			u32 pat4[4][4] = {
+				{1, 5, 1, 3},
+				{5, 1, 3, 1},
+				{1, 3, 1, 5},
+				{3, 1, 5, 1}
+			};
+			ped = 4;
+			is_lock = di_alg_fmd_index_detect_ped4(ped, pat4[0],
+				period64, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_64;
+				*phase = 9;
+				return is_lock;
+			}
+
+			/* phase1 */
+			is_lock = di_alg_fmd_index_detect_ped4(ped, pat4[1],
+				period64, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_64;
+				*phase = 0;
+				return is_lock;
+			}
+
+			/* phase6 */
+			is_lock = di_alg_fmd_index_detect_ped4(ped, pat4[2],
+				period64, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_64;
+				*phase = 5;
+				return is_lock;
+			}
+
+			/* phase7 */
+			is_lock = di_alg_fmd_index_detect_ped4(ped, pat4[3],
+				period64, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_64;
+				*phase = 6;
+				return is_lock;
+			}
+		}
+
+		if (fmd_87_en) {
+			/* phase15 */
+			u32 pat4[4][4] = {
+				{1, 7, 1, 6},
+				{7, 1, 6, 1},
+				{1, 6, 1, 7},
+				{6, 1, 7, 1}
+			};
+			ped = 4;
+			is_lock = di_alg_fmd_index_detect_ped4(ped, pat4[0],
+				period87, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_87;
+				*phase = 14;
+				return is_lock;
+			}
+
+			/* phase1 */
+			is_lock = di_alg_fmd_index_detect_ped4(ped, pat4[1],
+				period87, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_87;
+				*phase = 0;
+				return is_lock;
+			}
+
+			/* phase8 */
+			is_lock = di_alg_fmd_index_detect_ped4(ped, pat4[2],
+				period87, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_87;
+				*phase = 7;
+				return is_lock;
+			}
+
+			/* phase9 */
+			is_lock = di_alg_fmd_index_detect_ped4(ped, pat4[3],
+				period87, ha_length - 1, high_index_diff);
+			if (is_lock) {
+				*mode = FM_87;
+				*phase = 8;
+				return is_lock;
+			}
+		}
+	} else {
+		if (fmd_32_en) {
+			/* phase4 */
+			u32 pat1 = 5;
+			ped = 1;
+			is_lock = di_alg_fmd_index_detect_ped1(pat1,
+				period32, la_length - 1, low_index_diff);
+			if (is_lock) {
+				*mode = FM_32;
+				*phase = 3;
+				return is_lock;
+			}
+		}
+
+		if (fmd_2332_en) {
+			/* phase4 */
+			u32 pat2[2][2] = { {3, 7}, {7, 3} };
+			ped = 2;
+			is_lock = di_alg_fmd_index_detect_ped2(ped, pat2[0],
+				period2332, la_length - 1, low_index_diff);
+			if (is_lock) {
+				*mode = FM_2332;
+				*phase = 3;
+				return is_lock;
+			}
+
+			/* phase7 */
+			is_lock = di_alg_fmd_index_detect_ped2(ped, pat2[1],
+				period2332, la_length - 1, low_index_diff);
+			if (is_lock) {
+				*mode = FM_2332;
+				*phase = 6;
+				return is_lock;
+			}
+		}
+
+		if (fmd_2224_en) {
+			/* phase8 */
+			u32 pat2[2][2] = { {1, 9}, {9, 1} };
+			ped = 2;
+			is_lock = di_alg_fmd_index_detect_ped2(ped, pat2[0],
+				period2224, la_length - 1, low_index_diff);
+			if (is_lock) {
+				*mode = FM_2224;
+				*phase = 7;
+				return is_lock;
+			}
+
+			/* phase9 */
+			is_lock = di_alg_fmd_index_detect_ped2(ped, pat2[1],
+				period2224, la_length - 1, low_index_diff);
+			if (is_lock) {
+				*mode = FM_2224;
+				*phase = 8;
+				return is_lock;
+			}
+		}
+
+		if (fmd_32322_en) {
+			/* phase2 */
+			u32 pat2[2][2] = { {5, 7}, {7, 5} };
+			ped = 2;
+			is_lock = di_alg_fmd_index_detect_ped2(ped, pat2[0],
+				period32322, la_length - 1, low_index_diff);
+			if (is_lock) {
+				*mode = FM_32322;
+				*phase = 1;
+				return is_lock;
+			}
+
+			/* phase7 */
+			is_lock = di_alg_fmd_index_detect_ped2(ped, pat2[1],
+				period32322, la_length - 1, low_index_diff);
+			if (is_lock) {
+				*mode = FM_32322;
+				*phase = 6;
+				return is_lock;
+			}
+		}
+	}
+	return is_lock;
+}
+
+static void di_alg_fmd_non22(struct __fmd_hist *fmd_hist,
+	struct __di_para_t *di_para,
+	struct __fmd_alg_hist *alg_hist,
+	u32 is_fo_change, u32 is_text_field, u32 base_field)
+{
+	s32 init_field_cnt = alg_hist->init_field_cnt_non22;
+	u32 is_scenechange = base_field ?
+	    alg_hist->is_scenechange_f4 : alg_hist->is_scenechange_f3;
+	u32 is_lock_pre = alg_hist->is_non22_lock;
+	u32 is_lock_cur = 0;
+	s32 la_length = alg_hist->la_length;
+	s32 ha_length = alg_hist->ha_length;
+	u32 *p2diff_la = alg_hist->p2diff_la;
+	u32 *p2diff_ha = alg_hist->p2diff_ha;
+	u32 *low_index = alg_hist->low_index;
+	u32 *high_index = alg_hist->high_index;
+	u32 *p2_array = alg_hist->p2_array;
+	u32 *lowhigh = alg_hist->lowhigh;
+	u32 cur_totalfrd = (base_field) ? fmd_hist->FMD_FRD13 :
+	    fmd_hist->FMD_FRD02;
+	u32 cur_totalfid = (base_field) ? fmd_hist->FMD_FID23 :
+	    fmd_hist->FMD_FID12;
+	u32 weave_phase_pre = alg_hist->weave_phase_non22;
+	u32 film_mode_non22 = alg_hist->film_mode_non22;
+	u32 *cadence_cur = alg_hist->cadence_cur;
+	u32 init_field_cnt_22 = alg_hist->init_field_cnt_22;
+	u32 field_index = alg_hist->field_index;
+	u32 is_non22_temp_di;
+	u32 weave_phase_cur = 0;
+	u32 cad_low_length = alg_hist->cad_low_length;
+	s32 i, width, heightf, init_cnt;
+	s32 not_enough_for_p2, first_time_p2_ok, p2_init_phase;
+	u32 high_p2diff, low_p2diff;
+
+	DI_DEBUG("base_field:%d\ncur_totalfrd:0x%x\ncur_totalfid:0x%x\n",
+		base_field, cur_totalfrd, cur_totalfid);
+
+	width = di_para->width;
+	heightf = di_para->height / 2;
+
+	if (field_index == 0xf0000000)
+		field_index = 0;
+	else
+		field_index++;
+
+	if (is_scenechange) {
+		init_field_cnt = -2;
+		la_length = 0;
+		ha_length = 0;
+	}
+
+	if (init_field_cnt < (FMD32FIELDNUM - 1)) {
+		not_enough_for_p2 = 1;
+		first_time_p2_ok = 0;
+		p2_init_phase = 0;
+	} else if (init_field_cnt == (FMD32FIELDNUM - 1)) {
+		not_enough_for_p2 = 0;
+		first_time_p2_ok = 1;
+		p2_init_phase = 1;
+	} else {
+		not_enough_for_p2 = 0;
+		first_time_p2_ok = 0;
+		p2_init_phase = 1;
+	}
+
+	if (init_field_cnt < FMD32FIELDNUM)
+		init_field_cnt++;
+
+	if (init_field_cnt > 0) {
+		if (first_time_p2_ok | not_enough_for_p2)
+			p2_array[init_field_cnt - 1] = cur_totalfrd;
+		else {
+			for (i = 0; i < FMD32FIELDNUM - 1; i++)
+				p2_array[i] = p2_array[i + 1];
+			p2_array[FMD32FIELDNUM - 1] = cur_totalfrd;
+		}
+	}
+
+	/* classifier low_high */
+	if (not_enough_for_p2 == 0) {
+		di_alg_fmd_init_lh(p2_array, &high_p2diff, &low_p2diff);
+		if (first_time_p2_ok) {
+			init_cnt = 0;
+		} else if (not_enough_for_p2 == 0) {
+			init_cnt = FMD32FIELDNUM - 1;
+			/* update lowhigh */
+			for (i = 0; i < FMD32FIELDNUM - 1; i++)
+				lowhigh[i] = lowhigh[i + 1];
+		}
+		for (i = init_cnt; i < FMD32FIELDNUM; i++) {
+			lowhigh[i] = di_alg_fmd_lowhigh_classifier(p2_array[i],
+				p2diff_la, p2diff_ha,
+				&la_length, &ha_length,
+				high_p2diff, low_p2diff,
+				low_index, high_index,
+				di_para->alg_para.fmd_alg_para.hl_ratio,
+				di_para->alg_para.fmd_alg_para.r_sigma3,
+				di_para->alg_para.fmd_alg_para.t_mlb,
+				di_para->alg_para.fmd_alg_para.t_value,
+				di_para->alg_para.fmd_alg_para.r_lowcad,
+				di_para->alg_para.fmd_alg_para.t_sigma3_pixel_d10
+					* width * heightf / 10,
+				di_para->alg_para.fmd_alg_para.r_sc,
+				di_para->alg_para.fmd_alg_para.r_fb_sc,
+				field_index + i - (FMD32FIELDNUM - 1));
+		}
+	}
+
+	/* trace or detect */
+	if (is_lock_pre) {
+		/* last field lock */
+		/* update phase */
+		weave_phase_cur = di_alg_fmd_non22_phase(
+			weave_phase_pre, film_mode_non22);
+
+		if (p2_init_phase && init_field_cnt > 0
+			&& init_field_cnt_22 > 0) {
+			/* enough p2 to trace */
+			is_lock_cur = di_alg_fmd_non22_p2_trace(
+				weave_phase_cur, film_mode_non22,
+				lowhigh[init_field_cnt - 1],
+				cadence_cur[init_field_cnt_22 - 1],
+				cur_totalfid,
+				di_para->alg_para.fmd_alg_para.fid_trace_en,
+				di_para->alg_para.fmd_alg_para.t_p1diff_trace_pixel
+					* width * heightf);
+		} else if (init_field_cnt_22 > 0) {
+			/* not enough p2 to trace, use p1 trace */
+			is_lock_cur = di_alg_fmd_non22_p1_trace(weave_phase_cur,
+				film_mode_non22, cadence_cur[init_field_cnt_22 - 1]);
+		}
+
+		if (is_text_field)
+			is_lock_cur = 0;
+
+		if (is_lock_cur == 0) {
+			cad_low_length = 0;
+			if (p2_init_phase) {
+				init_field_cnt = 0;
+				la_length = 0;
+				ha_length = 0;
+			}
+		}
+	} else {
+		if (p2_init_phase == 1 && is_text_field == 0)
+			is_lock_cur =
+			    di_alg_fmd_non22_detect(low_index, high_index,
+					la_length, ha_length, lowhigh,
+					&film_mode_non22, &weave_phase_cur,
+					di_para->alg_para.fmd_alg_para.fmd_32_en,
+					di_para->alg_para.fmd_alg_para.period32,
+					di_para->alg_para.fmd_alg_para.fmd_2224_en,
+					di_para->alg_para.fmd_alg_para.period2224,
+					di_para->alg_para.fmd_alg_para.fmd_2332_en,
+					di_para->alg_para.fmd_alg_para.period2332,
+					di_para->alg_para.fmd_alg_para.fmd_32322_en,
+					di_para->alg_para.fmd_alg_para.period32322,
+					di_para->alg_para.fmd_alg_para.fmd_55_en,
+					di_para->alg_para.fmd_alg_para.period55,
+					di_para->alg_para.fmd_alg_para.fmd_64_en,
+					di_para->alg_para.fmd_alg_para.period64,
+					di_para->alg_para.fmd_alg_para.fmd_87_en,
+					di_para->alg_para.fmd_alg_para.period87);
+		else
+			is_lock_cur = 0;
+	}
+
+	/* is_non22_temp_di */
+	if ((is_lock_cur == 1) && (p2_init_phase == 0))
+		is_non22_temp_di = 1;
+	else
+		is_non22_temp_di = 0;
+
+	/* update hist */
+	alg_hist->p2_init_phase = p2_init_phase;
+	alg_hist->init_field_cnt_non22 = init_field_cnt;
+	alg_hist->is_non22_lock = is_lock_cur;
+	alg_hist->weave_phase_non22 = weave_phase_cur;
+	alg_hist->film_mode_non22 = film_mode_non22;
+	alg_hist->is_non22_temp_di = is_non22_temp_di;
+	alg_hist->cad_low_length = cad_low_length;
+	alg_hist->la_length = la_length;
+	alg_hist->ha_length = ha_length;
+	alg_hist->field_index = field_index;
+}
+
+static void di_alg_fmd_decision(
+	struct __fmd_alg_hist *alg_hist, u32 base_field)
+{
+	u32 is_fm_lock;
+	u32 weave_phase;
+	u32 is_temp_di;
+	u32 film_mode;
+	u8 *fw_ph;
+
+	if (alg_hist->is_non22_lock) {
+		is_fm_lock = 1;
+		film_mode = alg_hist->film_mode_non22;
+
+		switch (alg_hist->film_mode_non22) {
+		case 1:
+			fw_ph = fw_ph_32;
+			break;
+		case 2:
+			fw_ph = fw_ph_2332;
+			break;
+		case 3:
+			fw_ph = fw_ph_2224;
+			break;
+		case 4:
+			fw_ph = fw_ph_32322;
+			break;
+		case 5:
+			fw_ph = fw_ph_55;
+			break;
+		case 6:
+			fw_ph = fw_ph_64;
+			break;
+		case 7:
+			fw_ph = fw_ph_87;
+			break;
+		default:
+			fw_ph = fw_ph_22;
+			break;
+		}
+		if (alg_hist->is_non22_temp_di)
+			weave_phase = 1;
+		else
+			weave_phase = fw_ph[alg_hist->weave_phase_non22];
+	} else if (alg_hist->is_22_lock) {
+		is_fm_lock = 1;
+		film_mode = FM_22;
+
+		if (alg_hist->is_22_temp_di)
+			weave_phase = 1;
+		else
+			weave_phase = fw_ph_22[alg_hist->weave_phase_22];
+	} else {
+		is_fm_lock = 0;
+		weave_phase = 1;
+		film_mode = FM_NULL;
+	}
+
+	if (alg_hist->is_22_temp_di || alg_hist->is_non22_temp_di)
+		is_temp_di = 1;
+	else
+		is_temp_di = 0;
+
+	/* if conflict */
+	if (alg_hist->is_non22_lock && alg_hist->is_22_lock) {
+		/* except 2-2 and 2-2-2-4/ 6-4 conflict is allowed */
+		if (alg_hist->film_mode_non22 != FM_2224 &&
+		    alg_hist->film_mode_non22 != FM_64) {
+			is_fm_lock = 0;
+			alg_hist->is_non22_lock = 0;
+			alg_hist->is_22_lock = 0;
+		}
+	}
+
+	DI_DEBUG("base_field=%d, is_fm_lock=%d\n", base_field, is_fm_lock);
+	if (base_field) {
+		alg_hist->is_fm_lock_f4 = is_fm_lock;
+		alg_hist->weave_phase_f4 = weave_phase;
+		alg_hist->is_temp_di_f4 = is_temp_di;
+		alg_hist->film_mode_f4 = film_mode;
+	} else {
+		alg_hist->is_fm_lock_f3 = is_fm_lock;
+		alg_hist->weave_phase_f3 = weave_phase;
+		alg_hist->is_temp_di_f3 = is_temp_di;
+		alg_hist->film_mode_f3 = film_mode;
+	}
+}
+
+static void di_alg_film_mode_detection(
+	struct __fmd_hist *fmd_hist,
+	struct __di_para_t *di_para,
+	struct __alg_hist *alg_hist,
+	u32 base_field)
+{
+	u32 is_fo_change;
+	u32 is_text_field;
+
+	is_fo_change = alg_hist->fod_alg_hist.is_fieldorderchange;
+	is_text_field = alg_hist->vof_alg_hist.text_field_exist_f3 |
+	    alg_hist->vof_alg_hist.text_field_exist_f4;
+
+	/* p1diff update/ scene change detect/ 2-2 film mode detect and trace */
+	di_alg_fmd_22(fmd_hist, di_para, &alg_hist->fmd_alg_hist,
+		is_fo_change, is_text_field, base_field);
+
+	/* p2diff update/ non 2-2 film mode detect and trace */
+	di_alg_fmd_non22(fmd_hist, di_para, &alg_hist->fmd_alg_hist,
+		is_fo_change, is_text_field, base_field);
+
+	/* film mode decision */
+	di_alg_fmd_decision(&alg_hist->fmd_alg_hist, base_field);
+}
+
+static void di_alg_itd_22(struct __itd_hist *itd_hist,
+	struct __di_para_t *di_para, struct __itd_alg_hist *alg_hist,
+	u32 is_fo_change, u32 is_text_field, u32 base_field)
+{
+	u32 p1_init_phase = alg_hist->p1_init_phase;
+	u32 init_field_cnt_22 = alg_hist->init_field_cnt_22;
+	u32 is_progressive_lock_pre = alg_hist->is_progressive_lock;
+	s32 sc_trace_cnt = alg_hist->sc_trace_cnt;
+	u32 sc_length = alg_hist->sc_length;
+	u32 pre_totalfid = alg_hist->pre_totalfid;
+	u32 cur_totalfid =
+	    (base_field) ? itd_hist->FMD_FID23 : itd_hist->FMD_FID12;
+	u32 cad_low_length = alg_hist->cad_low_length;
+	u32 weave_phase_22_pre = alg_hist->weave_phase_22;
+	u32 weave_phase_22_cur = 0;
+	u32 is_progressive_lock_cur;
+	u32 is_scenechange;
+	u32 is_scenetrace;
+	u32 is_22_temp_di;
+	u32 cadence_cur;
+	u32 weave_phase = 0;
+
+	s32 i, width, heightf;
+	u32 t_p1diffthrl, t_p1diffthrh, avgns;
+	u32 t_p1diff, t_p1diff_u;
+
+	width = di_para->width;
+	heightf = di_para->height / 2;
+
+	/* if no pre field fid, pass the detection */
+	if (alg_hist->pre_totalfid_valid == 0)
+		goto ALG_FMD_22_END;
+
+	/* Calculate cadence_cur */
+	t_p1diffthrl = di_para->alg_para.itd_alg_para.t_p1diffthrl_pixel
+		* width * heightf;
+	t_p1diffthrh = di_para->alg_para.itd_alg_para.t_p1diffthrh_pixel
+		* width * heightf;
+	avgns = di_para->alg_para.itd_alg_para.avgns_pixel * width * heightf;
+
+	di_alg_fmd_p1(cur_totalfid, pre_totalfid, t_p1diffthrl, t_p1diffthrh,
+		avgns, di_para->alg_para.itd_alg_para.r_film22rel,
+		di_para->alg_para.itd_alg_para.r_film22rel2,
+		alg_hist->cad_low_array, &cad_low_length, &cadence_cur);
+
+	/* Update cadence_cur */
+	if (init_field_cnt_22 < FMD22FIELDNUM) {
+		alg_hist->cadence_cur[init_field_cnt_22] = cadence_cur;
+	} else {
+		for (i = 0; i < FMD22FIELDNUM - 1; i++)
+			alg_hist->cadence_cur[i] = alg_hist->cadence_cur[i + 1];
+		alg_hist->cadence_cur[FMD22FIELDNUM - 1] = cadence_cur;
+	}
+
+	p1_init_phase = (init_field_cnt_22 < 1) ? 0 : 1;
+	if (init_field_cnt_22 < FMD22FIELDNUM)
+		init_field_cnt_22++;
+
+	t_p1diff = di_para->alg_para.itd_alg_para.t_p1diff_pixel
+	    * width * heightf;
+	t_p1diff_u = di_para->alg_para.itd_alg_para.t_p1diff_u_pixel
+		* width * heightf;
+	is_scenechange = di_alg_fmd_sc_detect(alg_hist->sc_array,
+		&sc_length, cur_totalfid,
+		di_para->alg_para.itd_alg_para.r_sc,
+		t_p1diff, t_p1diff_u, cadence_cur);
+
+	if (is_scenechange)
+		init_field_cnt_22 = 0;
+
+	/* trace or detect */
+	is_scenetrace = (is_progressive_lock_pre && sc_trace_cnt > 0) ? 1 : 0;
+	if (is_progressive_lock_pre) {
+		/* if last field 2-2 lock */
+		is_progressive_lock_cur = di_alg_fmd_22_trace(weave_phase_22_pre,
+			&weave_phase_22_cur, cadence_cur,
+			is_scenechange, is_scenetrace);
+
+		/* when text exist, all film mode unlock */
+		if (is_text_field)
+			is_progressive_lock_cur = 0;
+
+		if (is_progressive_lock_cur) {
+			if (is_scenechange)
+				sc_trace_cnt =
+				    di_para->alg_para.itd_alg_para.sc_trace_fnum;
+
+			if (is_scenetrace)
+				sc_trace_cnt -= 1;
+		} else {
+			init_field_cnt_22 = 0;
+			sc_trace_cnt = 0;
+			cad_low_length = 0;
+		}
+	} else {
+		if (p1_init_phase == 1 && is_text_field == 0)
+			is_progressive_lock_cur = di_alg_fmd_22_detect(
+				alg_hist->cadence_cur, init_field_cnt_22,
+				&weave_phase_22_cur,
+				di_para->alg_para.itd_alg_para.period22_x0,
+				di_para->alg_para.itd_alg_para.period22_10, 1);
+		else
+			is_progressive_lock_cur = 0;
+	}
+
+	/* is_22_temp_di */
+	if (is_progressive_lock_cur
+		&& (is_scenechange || is_scenetrace))
+		is_22_temp_di = 1;
+	else
+		is_22_temp_di = 0;
+
+	if (is_progressive_lock_cur) {
+		if (is_22_temp_di)
+			weave_phase = 1;
+		else
+			weave_phase = fw_ph_22[is_progressive_lock_cur];
+	}
+
+	/* update hist */
+	alg_hist->p1_init_phase = p1_init_phase;
+	alg_hist->init_field_cnt_22 = init_field_cnt_22;
+	alg_hist->is_progressive_lock = is_progressive_lock_cur;
+	alg_hist->sc_trace_cnt = sc_trace_cnt;
+	alg_hist->sc_length = sc_length;
+	alg_hist->cad_low_length = cad_low_length;
+	alg_hist->weave_phase_22 = weave_phase_22_cur;
+
+	if (base_field)
+		alg_hist->is_scenechange_f4 = is_scenechange;
+	else
+		alg_hist->is_scenechange_f3 = is_scenechange;
+
+	if (base_field)
+		alg_hist->is_scenechange_f4 = is_scenechange;
+	else
+		alg_hist->is_scenechange_f3 = is_scenechange;
+
+	if (base_field) {
+		alg_hist->weave_phase_f4 = weave_phase;
+		alg_hist->is_temp_di_f4 = is_22_temp_di;
+	} else {
+		alg_hist->weave_phase_f3 = weave_phase;
+		alg_hist->is_temp_di_f3 = is_22_temp_di;
+	}
+
+ALG_FMD_22_END:
+	alg_hist->pre_totalfid = cur_totalfid;
+	alg_hist->pre_totalfid_valid = 1;
+}
+
+static void di_alg_iterlace_detection(
+	struct __itd_hist *itd_hist,
+	struct __di_para_t *di_para,
+	struct __alg_hist *alg_hist,
+	u32 base_field)
+{
+	u32 is_fo_change;
+	u32 is_text_field;
+
+	is_fo_change = alg_hist->fod_alg_hist.is_fieldorderchange;
+	is_text_field = alg_hist->vof_alg_hist.text_field_exist_f3
+	    || alg_hist->vof_alg_hist.text_field_exist_f4;
+
+	/* p1diff update/ scene change detect/ 2-2 film mode detect and trace */
+	di_alg_itd_22(itd_hist, di_para, &alg_hist->itd_alg_hist,
+		is_fo_change, is_text_field, base_field);
+}
+
+/*******************************************************************/
+/*                 Video-On-Film Detection Algorithm               */
+/*******************************************************************/
+static void di_alg_video_field(
+	struct __fmd_hist *fmd_hist,
+	struct __di_para_t *di_para,
+	struct __vof_alg_hist *alg_hist,
+	u32 base_field)
+{
+	struct __vof_alg_para *alg_para = &di_para->alg_para.vof_alg_para;
+	s32 field_num;
+	s32 i;
+	u32 sum_field_num, sum_field_num5;
+	u32 *pre_field_status, *cur_field_status;
+	s32 larger_than_th0_field_cnt5, larger_than_th0_field_cnt10;
+	s32 larger_than_zero_field_cnt10;
+
+	field_num = alg_para->fade_out_video_field_num;
+
+	pre_field_status = (base_field == 0) ? &alg_hist->video_field_exist_f4 :
+	    &alg_hist->video_field_exist_f3;
+
+	cur_field_status = (base_field == 0) ? &alg_hist->video_field_exist_f3 :
+	    &alg_hist->video_field_exist_f4;
+	/* update field_max_video_num_array */
+	for (i = 0; i < field_num - 1; i++)
+		alg_hist->field_max_video_num_array[i] =
+		    alg_hist->field_max_video_num_array[i + 1];
+
+	if (field_num > 0)
+		alg_hist->field_max_video_num_array[field_num - 1] = (base_field == 0) ?
+			fmd_hist->FIELD_MAX_VIDEO_NUM_F3 : fmd_hist->FIELD_MAX_VIDEO_NUM_F4;
+
+	larger_than_th0_field_cnt10 = 0;
+	larger_than_zero_field_cnt10 = 0;
+	sum_field_num = 0;
+	for (i = 0; i < field_num; i++) {
+		sum_field_num += alg_hist->field_max_video_num_array[i];
+		larger_than_th0_field_cnt10 +=
+		    alg_hist->field_max_video_num_array[i] >
+		    alg_para->video_field_th0 ? 1 : 0;
+		larger_than_zero_field_cnt10 +=
+		    alg_hist->field_max_video_num_array[i] > 0 ? 1 : 0;
+	}
+
+	larger_than_th0_field_cnt5 = 0;
+	sum_field_num5 = 0;
+	for (i = field_num - 1; i >= field_num - 5; i--) {
+		sum_field_num5 += alg_hist->field_max_video_num_array[i];
+		larger_than_th0_field_cnt5 +=
+		    alg_hist->field_max_video_num_array[i] >
+		    alg_para->video_field_th0 ? 1 : 0;
+	}
+
+	if (*pre_field_status) {	/* video exist last field */
+		/* Last field_num field don't exist any video row */
+		if (sum_field_num == 0)
+			*cur_field_status = 0;
+		else		/* remain video exist this field */
+			*cur_field_status = 1;
+	} else {
+		if (sum_field_num5 > alg_para->video_field_th1 &&
+		    larger_than_th0_field_cnt5 == 5) {
+			*cur_field_status = 1;
+		} else {
+			if (sum_field_num > alg_para->video_field_th2 &&
+			    larger_than_th0_field_cnt10 > 0 &&
+			    larger_than_zero_field_cnt10 == 10)
+				*cur_field_status = 1;
+			else
+				*cur_field_status = 0;
+		}
+	}
+}
+
+static void di_alg_text_field(struct __fmd_hist *fmd_hist,
+	struct __di_para_t *di_para,
+	struct __vof_alg_hist *alg_hist,
+	u32 base_field)
+{
+	struct __vof_alg_para *alg_para = &di_para->alg_para.vof_alg_para;
+	s32 fade_out_field_num, fade_in_field_num;
+	s32 i;
+	u32 sum_field_num, max_blk_pos;
+	u32 *pre_field_status, *cur_field_status;
+	s32 larger_than_th1_field_cnt, larger_than_th2_field_cnt;
+	s32 blksize = di_para->blksize;
+
+	fade_out_field_num = alg_para->fade_out_text_field_num;
+	fade_in_field_num = alg_para->fade_in_text_field_num;
+
+	pre_field_status = (base_field == 0) ? &alg_hist->text_field_exist_f4 :
+	    &alg_hist->text_field_exist_f3;
+
+	cur_field_status = (base_field == 0) ? &alg_hist->text_field_exist_f3 :
+	    &alg_hist->text_field_exist_f4;
+
+	max_blk_pos = (base_field == 0) ? fmd_hist->FIELD_MAX_TEXT_POS_F3 :
+	    fmd_hist->FIELD_MAX_TEXT_POS_F4;
+
+	/* update field_max_text_num_array */
+	for (i = 0; i < fade_out_field_num - 1; i++)
+		alg_hist->field_max_text_num_array[i] =
+		    alg_hist->field_max_text_num_array[i + 1];
+
+	if (fade_out_field_num > 0)
+		alg_hist->field_max_text_num_array[fade_out_field_num - 1] =
+			(base_field == 0) ? fmd_hist->FIELD_MAX_TEXT_NUM_F3 :
+			fmd_hist->FIELD_MAX_TEXT_NUM_F4;
+
+	/* update field_text_num_array */
+	for (i = 0; i < fade_out_field_num - 1; i++)
+		alg_hist->field_text_num_array[i] =
+		    alg_hist->field_text_num_array[i + 1];
+
+	if (fade_out_field_num > 0)
+		alg_hist->field_text_num_array[fade_out_field_num - 1] =
+			(base_field == 0) ? fmd_hist->FIELD_TEXT_ROW_NUM_F3 :
+			fmd_hist->FIELD_TEXT_ROW_NUM_F4;
+
+	sum_field_num = 0;
+	larger_than_th1_field_cnt = 0;
+	larger_than_th2_field_cnt = 0;
+	for (i = 0; i < fade_out_field_num; i++) {
+		sum_field_num += alg_hist->field_max_text_num_array[i];
+		larger_than_th1_field_cnt +=
+		    alg_hist->field_max_text_num_array[i] >
+		    alg_para->text_field_th1 ? 1 : 0;
+		larger_than_th2_field_cnt +=
+		    alg_hist->field_text_num_array[i] >
+		    alg_para->text_field_th2 ? 1 : 0;
+
+	}
+
+	if (*pre_field_status == 0) {
+		if ((larger_than_th1_field_cnt ==
+		     alg_para->fade_in_text_field_num) &&
+		    (sum_field_num > alg_para->text_field_th0) &&
+		    (larger_than_th2_field_cnt ==
+		     alg_para->fade_in_text_field_num) &&
+		    (max_blk_pos * 2 * blksize > alg_para->text_field_pos_u) &&
+		    (max_blk_pos * 2 * blksize < alg_para->text_field_pos_l))
+			*cur_field_status = 1;
+		else
+			*cur_field_status = 0;
+	} else {
+		if (larger_than_th1_field_cnt == 0)
+			*cur_field_status = 0;
+		else
+			*cur_field_status = 1;
+	}
+
+}
+
+static void di_alg_video_on_film_detection(
+	struct __fmd_hist *fmd_hist,
+	struct __di_para_t *di_para,
+	struct __vof_alg_hist *alg_hist)
+{
+	/* Field 3 */
+	di_alg_video_field(fmd_hist, di_para, alg_hist, 0);
+	di_alg_text_field(fmd_hist, di_para, alg_hist, 0);
+
+	/* Field 4 */
+	di_alg_video_field(fmd_hist, di_para, alg_hist, 1);
+	di_alg_text_field(fmd_hist, di_para, alg_hist, 1);
+}
+
+static void di_alg_tnr_strengths_adjustment(
+	struct __tnr_hist *tnr_hist,
+	struct __di_para_t *di_para,
+	struct __alg_hist *alg_hist)
+{
+	u32 gain_next;
+
+	if ((alg_hist->fmd_alg_hist.is_scenechange_f3 != 1) &&
+	    (alg_hist->fmd_alg_hist.is_scenechange_f4 != 1)) {
+
+		u64 noise_weight_num, noise_weight_den;
+		u64 still_weight_num, still_weight_den;
+		u64 cur_weight, den;
+
+		/*
+		* u64 noise_level, noise_predict;
+		* noise_level = tnr_hist->tnr_sum_gain_y
+		*	/ tnr_hist->tnr_sum_gain_y_cnt;
+		* noise_predict = alg_hist->tnr_alg_hist.gain *
+		*	di_para->alg_para.tnr_alg_para.k_max_noise_num * 64
+		*	/ 63 / di_para->alg_para.tnr_alg_para.k_max_noise_den;
+		* noise_weight = noise_level / noise_predict;
+		*/
+		noise_weight_num = tnr_hist->tnr_sum_gain_y
+			* di_para->alg_para.tnr_alg_para.k_max_noise_den * 63;
+		noise_weight_den = tnr_hist->tnr_sum_gain_y_cnt
+			* alg_hist->tnr_alg_hist.gain
+			* di_para->alg_para.tnr_alg_para.k_max_noise_num * 64;
+
+		/*
+		* u64 still_level;
+		* still_level = tnr_hist->tnr_sum_still_out
+		*	/ (di_para->width * di_para->height);
+		* still_weight = still_level * di_para->alg_para.tnr_alg_para.k_max_still_den
+		*	/ di_para->alg_para.tnr_alg_para.k_max_still_num;
+		*/
+		still_weight_num = tnr_hist->tnr_sum_still_out
+			* di_para->alg_para.tnr_alg_para.k_max_still_den;
+		still_weight_den = di_para->width * di_para->height
+			* di_para->alg_para.tnr_alg_para.k_max_still_num;
+
+		cur_weight = noise_weight_num * still_weight_num;
+		den = noise_weight_den * still_weight_den;
+		if (den != 0) {
+			do_div(cur_weight, den);
+		} else {
+			cur_weight = 0;
+			DI_ERR("ERR: %s zero den\n", __func__);
+		}
+
+		#if 0
+		DI_DEBUG("tnr_sum_gain_y=%d,k_max_noise_den=%d->noise_weight_num=%llu\n"
+			"tnr_sum_gain_y_cnt=%d,gain=%d,k_max_noise_num=%d->noise_weight_den=%llu\n"
+			"tnr_sum_still_out=%d,k_max_still_den=%d->still_weight_num=%llu\n"
+			"w=%d,h=%d,k_max_still_num=%d->still_weight_den=%llu\n"
+			"cur_weight=%llu\n",
+			tnr_hist->tnr_sum_gain_y,
+			di_para->alg_para.tnr_alg_para.k_max_noise_den,
+			noise_weight_num,
+			tnr_hist->tnr_sum_gain_y_cnt,
+			alg_hist->tnr_alg_hist.gain,
+			di_para->alg_para.tnr_alg_para.k_max_noise_num,
+			noise_weight_den,
+			tnr_hist->tnr_sum_still_out,
+			di_para->alg_para.tnr_alg_para.k_max_still_den,
+			still_weight_num,
+			di_para->width, di_para->height,
+			di_para->alg_para.tnr_alg_para.k_max_still_num,
+			still_weight_den,
+			cur_weight);
+		#endif
+
+		gain_next = ((u32)cur_weight + 31 * alg_hist->tnr_alg_hist.gain) / 32;
+		gain_next = max(di_para->alg_para.tnr_alg_para.tnr_adaptive_gain_th_l, gain_next);
+		gain_next = min(di_para->alg_para.tnr_alg_para.tnr_adaptive_gain_th, gain_next);
+	} else {
+		gain_next = di_para->alg_para.tnr_alg_para.tnr_adaptive_gain_th;
+	}
+
+	alg_hist->tnr_alg_hist.gain = gain_next;
+}
+
+/*******************************************************************/
+/*                      DI300 Algorithm Top                        */
+/*******************************************************************/
+void di_alg(struct di_dev_proc_result *proc_rst)
+{
+	struct __hw_hist *hw_hist = &proc_rst->hw_hist;
+	struct __alg_hist *alg_hist = &proc_rst->alg_hist;
+	struct __di_para_t *di_para = &proc_rst->di_para;
+
+	if (di_para->alg_para.alg_en) {
+		/* TODO : add itd and tnr alg para initial */
+		if (di_para->alg_para.itd_alg_para.itd_alg_en) {
+			di_alg_iterlace_detection(&hw_hist->itd_hist,
+				di_para, alg_hist, 0);
+			di_alg_iterlace_detection(&hw_hist->itd_hist,
+				di_para, alg_hist, 1);
+		}
+
+		if (di_para->alg_para.fod_alg_para.fod_alg_en) {
+			di_alg_field_order_detection(&hw_hist->fmd_hist,
+				di_para, &alg_hist->fod_alg_hist);
+		}
+
+		if (di_para->alg_para.vof_alg_para.vof_alg_en) {
+			di_alg_video_on_film_detection(&hw_hist->fmd_hist,
+				di_para, &alg_hist->vof_alg_hist);
+		}
+
+		if (di_para->alg_para.fmd_alg_para.fmd_alg_en) {
+			di_alg_film_mode_detection(&hw_hist->fmd_hist,
+				di_para, alg_hist, 0);
+			di_alg_film_mode_detection(&hw_hist->fmd_hist,
+				di_para, alg_hist, 1);
+		}
+
+		if (di_para->alg_para.tnr_alg_para.tnr_alg_en) {
+			di_alg_tnr_strengths_adjustment(
+				&hw_hist->tnr_hist, di_para, alg_hist);
+		}
+	}
+}
+
+/*******************************************************************/
+/*            Algorithm and Hardware Data Exchange                 */
+/*******************************************************************/
+
+/* Set algorithm parameters from hardware setting */
+void di_alg_fixed_para(struct di_client *c,
+	struct di_dev_proc_result *proc_rst)
+{
+	struct __di_para_t *di_para = &proc_rst->di_para;
+	struct __alg_para_t *alg_para = &di_para->alg_para;
+	struct __alg_hist *alg_hist = &proc_rst->alg_hist;
+
+	di_para->bff = c->fb_arg.top_field_first ? 0 : 1;
+	di_para->width = c->video_size.width;
+	di_para->height = c->video_size.height;
+	di_para->blksize = c->vof_blk_size_sel ? 16 : 8;
+
+	alg_para->fod_alg_para.fod_alg_en = (c->mode == DI_MODE_60HZ) ||
+	    (c->mode == DI_MODE_30HZ) || (c->mode == DI_MODE_WEAVE);
+
+	/* Enable FMD and VOF when scan type of video information is interlaced
+	 * No matter the progressive video is detected to be a interlaced video
+	 */
+	alg_para->fmd_alg_para.fmd_alg_en = (c->mode == DI_MODE_60HZ) &&
+	    (c->fb_arg.is_interlace == 1);
+
+	alg_para->vof_alg_para.vof_alg_en = (c->mode == DI_MODE_60HZ) &&
+	    (c->fb_arg.is_interlace == 1);
+
+	/* Enable ITD when scan type of video information is progressive */
+	alg_para->itd_alg_para.itd_alg_en =
+		((c->mode == DI_MODE_60HZ) ||
+		(c->mode == DI_MODE_30HZ) ||
+		(c->mode == DI_MODE_WEAVE));
+
+	/* Enable TNR adaptive gain control when TNR module enable */
+	alg_para->tnr_alg_para.tnr_alg_en = c->tnr_en;
+
+	alg_para->alg_en = 1;
+
+	alg_para->fod_alg_para.R_kick = 5;
+	alg_para->fod_alg_para.R_rev_10 = 11;
+	alg_para->fod_alg_para.T_rev = 0;
+	alg_para->fod_alg_para.T_rev_time = 15;
+
+	alg_para->vof_alg_para.fade_out_video_field_num = 10;
+	alg_para->vof_alg_para.video_field_th0 = 3 * di_para->width *
+	    di_para->height / 720 / 480;
+	alg_para->vof_alg_para.video_field_th1 = 25 * di_para->width *
+	    di_para->height / 720 / 480;
+	alg_para->vof_alg_para.video_field_th2 = 15 * di_para->width *
+	    di_para->height / 720 / 480;
+	alg_para->vof_alg_para.fade_in_text_field_num = 20;
+	alg_para->vof_alg_para.fade_out_text_field_num = 59;
+	alg_para->vof_alg_para.text_field_th0 = 20 * 3 * di_para->width *
+	    di_para->height / 720 / 480;
+	alg_para->vof_alg_para.text_field_th1 = 3 * di_para->width *
+	    di_para->height / 720 / 480;
+	alg_para->vof_alg_para.text_field_th2 = 0;	/* ignored first */
+	alg_para->vof_alg_para.text_field_pos_u = di_para->height / 4;
+	alg_para->vof_alg_para.text_field_pos_l = 3 * di_para->height / 4;
+
+	alg_para->fmd_alg_para.fmd_55_en = 1;
+	alg_para->fmd_alg_para.fmd_64_en = 1;
+	alg_para->fmd_alg_para.fmd_87_en = 1;
+	alg_para->fmd_alg_para.fmd_2332_en = 1;
+	alg_para->fmd_alg_para.fmd_2224_en = 1;
+	alg_para->fmd_alg_para.fmd_32322_en = 1;
+	alg_para->fmd_alg_para.fmd_32_en = 1;
+	alg_para->fmd_alg_para.fmd_22_en = 1;
+
+	alg_para->fmd_alg_para.r_sc = 2;
+	alg_para->fmd_alg_para.hl_ratio = 6;
+	alg_para->fmd_alg_para.r_sigma3 = 1;
+	alg_para->fmd_alg_para.t_mlb = 2;
+	alg_para->fmd_alg_para.t_value = 300000000;
+	alg_para->fmd_alg_para.r_lowcad = 2;
+	alg_para->fmd_alg_para.r_fb_sc = 2;
+	alg_para->fmd_alg_para.t_sigma3_pixel_d10 = 1;
+	alg_para->fmd_alg_para.fid_trace_en = 1;
+	alg_para->fmd_alg_para.t_p1diff_trace_pixel = 2;
+
+	alg_para->fmd_alg_para.t_p1diffthrl_pixel = 20;
+	alg_para->fmd_alg_para.t_p1diffthrh_pixel = 40;
+	alg_para->fmd_alg_para.avgns_pixel = 0;
+	alg_para->fmd_alg_para.r_film22rel = 3;
+	alg_para->fmd_alg_para.r_film22rel2 = 3;
+	alg_para->fmd_alg_para.sc_trace_fnum = 11;
+
+	alg_para->fmd_alg_para.t_p1diff_pixel = 20;
+	alg_para->fmd_alg_para.t_p1diff_u_pixel = 40;
+
+	alg_para->fmd_alg_para.period22_x0 = 25;
+	alg_para->fmd_alg_para.period22_10 = 20;
+
+	alg_para->fmd_alg_para.period32 = 3;
+	alg_para->fmd_alg_para.period2224 = 3;
+	alg_para->fmd_alg_para.period2332 = 3;
+	alg_para->fmd_alg_para.period32322 = 3;
+	alg_para->fmd_alg_para.period55 = 3;
+	alg_para->fmd_alg_para.period64 = 3;
+	alg_para->fmd_alg_para.period87 = 3;
+
+	alg_para->itd_alg_para.itd_alg_en = 1;
+	alg_para->itd_alg_para.r_sc = 2;
+	alg_para->itd_alg_para.t_p1diffthrl_pixel = 20;
+	alg_para->itd_alg_para.t_p1diffthrh_pixel = 40;
+	alg_para->itd_alg_para.avgns_pixel = 0;
+	alg_para->itd_alg_para.r_film22rel = 3;
+	alg_para->itd_alg_para.r_film22rel2 = 3;
+	alg_para->itd_alg_para.sc_trace_fnum = 11;	/* sc_trace_fieldnum */
+	alg_para->itd_alg_para.t_p1diff_pixel = 20;
+	alg_para->itd_alg_para.t_p1diff_u_pixel = 40;
+	alg_para->itd_alg_para.period22_x0 = 25;	/* required period to detect 2-2 */
+	alg_para->itd_alg_para.period22_10 = 20;	/* required period to detect 2-2 */
+
+	/* TODO : add itd and tnr alg para initial */
+	alg_para->tnr_alg_para.tnr_mode = c->tnr_mode.mode;
+	if (c->tnr_mode.level == DI_TNR_LEVEL_LOW) {
+		alg_para->tnr_alg_para.tnr_adaptive_gain_th = 38;
+		alg_para->tnr_alg_para.tnr_adaptive_gain_th_l = 16;
+	} else if (c->tnr_mode.level == DI_TNR_LEVEL_MIDDLE) {
+		alg_para->tnr_alg_para.tnr_adaptive_gain_th = 48;
+		alg_para->tnr_alg_para.tnr_adaptive_gain_th_l = 28;
+	} else {
+		alg_para->tnr_alg_para.tnr_adaptive_gain_th = 62;
+		alg_para->tnr_alg_para.tnr_adaptive_gain_th_l = 52;
+	}
+
+	alg_para->tnr_alg_para.k_max_still_num = 5;
+	alg_para->tnr_alg_para.k_max_still_den = 2;
+	alg_para->tnr_alg_para.k_max_noise_num = 2;
+	alg_para->tnr_alg_para.k_max_noise_den = 1;
+
+	alg_hist->tnr_alg_hist.gain =
+	    alg_para->tnr_alg_para.tnr_adaptive_gain_th;
+}
+
+void di_alg_hist_to_hardware(struct di_client *c,
+	struct di_dev_proc_result *proc_rst)
+{
+	struct __alg_hist *alg_hist = &proc_rst->alg_hist;
+	struct __di_para_t *di_para = &proc_rst->di_para;
+	struct __alg_para_t *alg_para = &di_para->alg_para;
+
+	if (alg_para->alg_en == 0)
+		return;
+
+	if (alg_para->fod_alg_para.fod_alg_en) {
+		if (alg_hist->fod_alg_hist.is_fieldorderchange) {
+			di_para->bff = alg_hist->fod_alg_hist.bff_fix;
+			DI_INFO("is_fieldorderchange, bff:%d\n", di_para->bff);
+		}
+	}
+}
diff --git a/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_alg.h b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_alg.h
new file mode 100644
index 000000000..788ac0918
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_alg.h
@@ -0,0 +1,374 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI300_ALG_H_
+#define _DI300_ALG_H_
+
+#include <linux/types.h>
+#include "../di_client.h"
+
+enum FILMMODE {
+	FM_22 = 0,
+	FM_32,
+	FM_2332,
+	FM_2224,
+	FM_32322,
+	FM_55,
+	FM_64,
+	FM_87,
+	FM_NULL = 10
+};
+
+/* array */
+#define PROD22 2
+#define PROD32 5
+#define PROD2332 10
+#define PROD2224 10
+#define PROD32322 12
+#define PROD55 5
+#define PROD64 10
+#define PROD87 15
+
+/* software algorithm parameters */
+struct __fod_alg_para {
+	u32 fod_alg_en;	/* enable field order detection alg */
+
+	s32 R_kick;
+	s32 R_rev_10;		/* R_rev * 10 */
+	s32 T_rev;
+	u32 T_rev_time;
+};
+
+struct __fmd_alg_para {
+	u32 fmd_alg_en;	/* enable film mode detection alg */
+
+	u32 fmd_55_en;
+	u32 fmd_64_en;
+	u32 fmd_87_en;
+	u32 fmd_2332_en;
+	u32 fmd_2224_en;
+	u32 fmd_32322_en;
+	u32 fmd_32_en;
+	u32 fmd_22_en;
+
+	/* non-22 detect */
+	u32 r_sc;
+	s32 hl_ratio;
+	u32 r_sigma3;
+	s32 t_mlb;
+	s32 t_value;
+	u32 r_lowcad;
+	u32 r_fb_sc;
+	s32 t_sigma3_pixel_d10;
+	u32 fid_trace_en;
+	u32 t_p1diff_trace_pixel;
+
+	/* 22 detect */
+	u32 t_p1diffthrl_pixel;
+	u32 t_p1diffthrh_pixel;
+	u32 avgns_pixel;
+	u32 r_film22rel;
+	u32 r_film22rel2;
+	s32 sc_trace_fnum;	/* sc_trace_fieldnum */
+
+	/* scene change */
+	u32 t_p1diff_pixel;
+	u32 t_p1diff_u_pixel;
+
+	/* lock para */
+	s32 period22_x0;	/* required period to detect 2-2 */
+	s32 period22_10;	/* required period to detect 2-2 */
+
+	s32 period32;		/* required period to detect 3-2 */
+	s32 period2224;		/* required period to detect 2-2-2-4 */
+	s32 period2332;		/* required period to detect 2-3-3-2 */
+	s32 period32322;	/* required period to detect 3-2-3-2-2 */
+	s32 period55;		/* required period to detect 5-5 */
+	s32 period64;		/* required period to detect 6-4 */
+	s32 period87;		/* required period to detect 8-7 */
+};
+
+struct __vof_alg_para {
+	u32 vof_alg_en;	/* enable Video-On-Film detection alg */
+
+	/* Fade out Field number for Video disappear */
+	u32 fade_out_video_field_num;
+	/* 5 field max video row number threshold */
+	u32 video_field_th0;
+	/* sum of 5 field max video row number threshold */
+	u32 video_field_th1;
+	/* 10 field max video row number threshold */
+	u32 video_field_th2;
+
+	/* Fade in Field number for Text appear */
+	u32 fade_in_text_field_num;
+	/* Fade out Field number for Text disappear */
+	u32 fade_out_text_field_num;
+	/* N field sum of max text row number threshold */
+	u32 text_field_th0;
+	/* N field max text row number threshold */
+	u32 text_field_th1;
+	/* N field text row number threshold */
+	u32 text_field_th2;
+	/* Up vertical position threshold for text */
+	u32 text_field_pos_u;
+	/* Down vertical position threshold for text */
+	u32 text_field_pos_l;
+};
+
+struct __itd_alg_para {
+	u32 itd_alg_en;
+	/* TODO: add interlace detection alg parameter here! */
+	/* non-22 detect */
+	u32 r_sc;
+
+	/* 22 detect */
+	u32 t_p1diffthrl_pixel;
+	u32 t_p1diffthrh_pixel;
+	u32 avgns_pixel;
+	u32 r_film22rel;
+	u32 r_film22rel2;
+	s32 sc_trace_fnum;	/* sc_trace_fieldnum */
+
+	/* scene change */
+	u32 t_p1diff_pixel;
+	u32 t_p1diff_u_pixel;
+
+	/* lock para */
+	s32 period22_x0;	/* required period to detect 2-2 */
+	s32 period22_10;	/* required period to detect 2-2 */
+};
+
+struct __tnr_alg_para {
+	u32 tnr_alg_en;
+	/* TODO: add tnr adaptive gain control alg parameter here! */
+	s32 tnr_mode;
+	u32 tnr_adaptive_gain_th;
+	u32 tnr_adaptive_gain_th_l;
+	u32 k_max_still_num;
+	u32 k_max_still_den;
+	u32 k_max_noise_num;
+	u32 k_max_noise_den;
+};
+
+struct __alg_para_t {
+	u32 alg_en;	/* enable software alg */
+
+	struct __fod_alg_para fod_alg_para;
+	struct __fmd_alg_para fmd_alg_para;
+	struct __vof_alg_para vof_alg_para;
+	struct __itd_alg_para itd_alg_para;
+	struct __tnr_alg_para tnr_alg_para;
+};
+
+/* DI parameters */
+struct __di_para_t {
+	s32 width;
+	s32 height;
+	u32 bff;
+	u32 blksize;
+
+	struct __alg_para_t alg_para;
+};
+
+/* Algorithm Histogram */
+struct __fod_alg_hist {
+	u32 bff_fix;	/* The detected Field Order */
+	u32 is_fieldorderchange;
+	u32 rev_cnt_tff;
+	u32 rev_cnt_bff;
+};
+
+/* determine by the maximum field number for 22 film mode detection */
+#define FMD22FIELDNUM 50
+/* determine by the maximum field number for all non22 film mode detection */
+#define FMD32FIELDNUM 15
+
+struct __itd_alg_hist {
+	/* main */
+	u32 weave_phase_f3;
+	u32 is_temp_di_f3;
+
+	u32 weave_phase_f4;
+	u32 is_temp_di_f4;
+
+	u32 is_scenechange_f3;
+	u32 is_scenechange_f4;
+
+	/* 2-2 */
+	u32 is_progressive_lock;
+	u32 weave_phase_22;
+
+	/* other para */
+	s32 init_field_cnt_22;
+	u32 p1_init_phase;
+
+	u32 cad_low_length;
+	u32 sc_length;
+	s32 sc_trace_cnt;
+	u32 pre_totalfid;	/* field diff of last field */
+	u32 pre_totalfid_valid;
+
+	u32 cadence_cur[FMD22FIELDNUM];
+	u32 cad_low_array[10];
+	u32 sc_array[4];
+};
+
+struct __fmd_alg_hist {
+	/* main */
+	u32 is_fm_lock_f3;
+	u32 weave_phase_f3;
+	u32 is_temp_di_f3;
+	u32 film_mode_f3;
+
+	u32 is_fm_lock_f4;
+	u32 weave_phase_f4;
+	u32 is_temp_di_f4;
+	u32 film_mode_f4;
+
+	u32 is_scenechange_f3;
+	u32 is_scenechange_f4;
+
+	/* 2-2 */
+	u32 is_22_lock;
+	u32 weave_phase_22;
+	u32 is_22_temp_di;
+
+	/* non 2-2 */
+	u32 is_non22_lock;
+	u32 film_mode_non22;
+	u32 weave_phase_non22;
+	u32 is_non22_temp_di;
+
+	/* other para */
+	s32 init_field_cnt_22;
+	s32 init_field_cnt_non22;
+	u32 p1_init_phase;
+	u32 p2_init_phase;
+
+	s32 la_length;
+	s32 ha_length;
+
+	u32 cad_low_length;
+	u32 sc_length;
+	s32 sc_trace_cnt;
+	u32 pre_totalfid;	/* field diff of last field */
+	u32 pre_totalfid_valid;
+
+	u32 p2_array[16];
+	u32 lowhigh[FMD32FIELDNUM];
+	u32 cadence_cur[FMD22FIELDNUM];
+	u32 cad_low_array[10];
+	u32 p2diff_la[16];
+	u32 p2diff_ha[16];
+	u32 low_index[16];	/* record low cad field number */
+	u32 high_index[16];	/* record low cad field number */
+	u32 sc_array[4];
+	u32 field_index;	/*current field index */
+};
+
+struct __vof_alg_hist {
+	/* video field detect */
+	/* History Max Video Row Number of past fields */
+	u32 field_max_video_num_array[10];
+
+	u32 video_field_exist_f3;	/* Video Exist in this field3 */
+	u32 video_field_exist_f4;	/* Video Exist in this field4 */
+
+	/* text field detect */
+	/* History Max Text Row Number of past field */
+	u32 field_max_text_num_array[59];
+	/* History Text Row Number of past field */
+	u32 field_text_num_array[59];
+
+	u32 text_field_exist_f3;	/* Text Exist in this field3 */
+	u32 text_field_exist_f4;	/* Text Exist in this field4 */
+
+};
+
+struct __tnr_alg_hist {
+	u32 gain;
+};
+
+struct __alg_hist {
+	struct __fod_alg_hist fod_alg_hist;
+	struct __fmd_alg_hist fmd_alg_hist;
+	struct __vof_alg_hist vof_alg_hist;
+	struct __itd_alg_hist itd_alg_hist;
+	struct __tnr_alg_hist tnr_alg_hist;
+};
+
+/* Hardware Histogram */
+struct __fmd_hist {
+	u32 FMD_FID12;	/* 0x1e0 */
+	u32 FMD_FID23;	/* 0x1e4 */
+	u32 FOD_FID30;	/* 0x1e8 */
+	u32 FOD_FID32;	/* 0x1ec */
+	u32 FOD_FID10;	/* 0x1f0 */
+	u32 FOD_FID12;	/* 0x1f4 */
+	u32 FMD_FRD02;	/* 0x1f8 */
+	u32 FMD_FRD13;	/* 0x1fc */
+
+	u32 FIELD_MAX_VIDEO_NUM_F3;	/* 0x21c */
+	u32 FIELD_MAX_TEXT_NUM_F3;
+	u32 FIELD_MAX_TEXT_POS_F3;
+	u32 FIELD_TEXT_ROW_NUM_F3;
+
+	u32 FIELD_MAX_VIDEO_NUM_F4;	/* 0x220 */
+	u32 FIELD_MAX_TEXT_NUM_F4;
+	u32 FIELD_MAX_TEXT_POS_F4;
+	u32 FIELD_TEXT_ROW_NUM_F4;
+};
+
+struct __itd_hist {
+	u32 FMD_FID12;	/* 0x1e0 */
+	u32 FMD_FID23;	/* 0x1e4 */
+};
+
+struct __tnr_hist {
+	u32 tnr_sum_weight_y;	/* 0x26C */
+	u32 tnr_sum_weight_u;	/* 0x270 */
+	u32 tnr_sum_weight_v;	/* 0x274 */
+	u32 tnr_sum_gain_y;	/* 0x278 */
+	u32 tnr_sum_gain_u;	/* 0x27C */
+	u32 tnr_sum_gain_v;	/* 0x280 */
+	u32 tnr_sum_still_out;	/* 0x284 */
+	u32 tnr_sum_weight_y_cnt;	/* 0x288 */
+	u32 tnr_sum_gain_y_cnt;	/* 0x28C */
+};
+
+struct __hw_hist {
+	struct __fmd_hist fmd_hist;
+	struct __tnr_hist tnr_hist;
+	struct __itd_hist itd_hist;
+};
+
+struct di_dev_proc_result {
+	/* the part of input-paras by reading reg */
+	struct __hw_hist hw_hist;
+	/*
+	 * output-paras from dealing input-paras.
+	 * some of output-paras may become input-paras in next dealing.
+	 */
+	struct __alg_hist alg_hist;
+
+	struct __di_para_t di_para;
+};
+
+void di_alg(struct di_dev_proc_result *proc_rst);
+void di_alg_fixed_para(struct di_client *c,
+		       struct di_dev_proc_result *proc_rst);
+void di_alg_hist_to_hardware(struct di_client *c,
+			     struct di_dev_proc_result *proc_rst);
+
+#endif /* _DI300_ALG_H_ */
diff --git a/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_reg.h b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_reg.h
new file mode 100644
index 000000000..15e07489f
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/lowlevel_v3x/di300_reg.h
@@ -0,0 +1,886 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DI300_REG_H_
+#define _DI300_REG_H_
+
+#include <linux/types.h>
+
+#define MD_FLAG_ALIGN 32
+
+#define DI_VOF_BUF_REG_ADDR_A 0x10000
+#define DI_VOF_BUF_REG_ADDR_B 0x10140
+#define DI_VOF_BUF_REG_ADDR_C 0x10280
+#define DI_VOF_BUF_REG_ADDR_D 0x103C0
+#define DI_VOF_BUF_SIZE_MAX 0x140
+
+
+
+union di_reset_reg {
+	u32 dwval;
+	struct {
+		u32 res0:31;
+		u32 reset:1;
+	} bits;
+};
+
+union di_func_vsn_reg {
+	u32 dwval;
+	struct {
+		u32 res0:16;
+		u32 overlay_exist:2;
+		u32 online_support:2;
+		u32 offline_support:2;
+		u32 dns_exist:2;
+		u32 tnr_exist:2;
+		u32 fmd_exist:2;
+		u32 res1:4;
+	} bits;
+};
+
+union di_start_reg {
+	u32 dwval;
+	struct {
+		u32 start:1;
+		u32 res0:31;
+	} bits;
+};
+
+union di_int_ctl_reg {
+	u32 dwval;
+	struct {
+		u32 finish_int_en:1;
+		u32 res0:31;
+	} bits;
+};
+
+union di_status_reg {
+	u32 dwval;
+	struct {
+		u32 finish_flag:1;
+		u32 res0:7;
+		u32 busy:1;
+		u32 res1:23;
+	} bits;
+};
+
+union di_func_en_reg {
+	u32 dwval;
+	struct {
+		u32 dit_en:1;
+		u32 md_en:1;
+		u32 tnr_en:1;
+		u32 fmd_en:1;
+		u32 res0:28;
+	} bits;
+};
+
+union di_dma_ctl_reg {
+	u32 dwval;
+	struct {
+		u32 dma_c:1; /*in_fb2 gating*/
+		u32 res0:3;
+		u32 dma_p:1; /*in_fb1 gating*/
+		u32 res1:3;
+		u32 dma_di:1; /*in_fb0 gating*/
+		u32 res2:3;
+		u32 dmafr:1; /*pre-frame motion info gating*/
+		u32 res3:3;
+		u32 diw0:1; /*out_fb0 gating*/
+		u32 res4:3;
+		u32 diw1:1; /*out_fb1 gating*/
+		u32 res5:3;
+		u32 tnrw:1; /*out_fbtnr gating*/
+		u32 res6:3;
+		u32 dmafw:1; /*cur_frame motion info gating*/
+		u32 res7:2;
+		u32 mclk_gate:1;
+	} bits;
+};
+
+union di_rdma_cmd_ctl_reg {
+	u32 dwval;
+	struct {
+		u32 dma_di_len:8;
+		u32 dma_p_len:8;
+		u32 dma_c_len:8;
+		u32 dmafr_len:8;
+	} bits;
+};
+
+union di_wdma_cmd_ctl_reg {
+	u32 dwval;
+	struct {
+		u32 diw0_len:8;
+		u32 diw1_len:8;
+		u32 tnrw_len:8;
+		u32 dmafw_len:8;
+	} bits;
+};
+
+union di_size_reg {
+	u32 dwval;
+	struct {
+		u32 width:11;
+		u32 res0:5;
+		u32 height:11;
+		u32 res1:5;
+	} bits;
+};
+
+/*
+* format:
+* 0:planner YUV420   1:UV combined YUV420
+* 2:planner YUV422   3:UV combined YUV422
+*/
+union di_fmt_reg {
+	u32 dwval;
+	struct {
+		u32 in0fmt:2; /*in_fb0 format*/
+		u32 res0:2;
+		u32 in1fmt:2; /*in_fb1 format*/
+		u32 res1:2;
+		u32 in2fmt:2; /*in_fb2 format*/
+		u32 res2:2;
+		u32 tnrfmt:2; /*tnrout_fb format*/
+		u32 res3:2;
+		u32 ditfmt:2; /*ditout_fb format */
+		u32 res4:10;
+		u32 uvseq:1; /*uv sequence: 0:vuvuvu  1:uvuvuv*/
+		u32 res5:3;
+	} bits;
+};
+
+union di_field_order_reg {
+	u32 dwval;
+	struct {
+		u32 bff:1; /* bottom field fist */
+		u32 res0:31;
+	} bits;
+};
+
+union di_2pitch_reg {
+	u32 dwval;
+	struct {
+		u32 f01:16; /* field 0/1 */
+		u32 f23:16; /* field 2/3 */
+	} bits;
+};
+
+union di_pitch_reg {
+	u32 dwval;
+	struct {
+		u32 val:16;
+		u32 res0:16;
+	} bits;
+};
+
+union di_haddr_reg {
+	u32 dwval;
+	struct {
+		u32 addr0:8;
+		u32 addr1:8;
+		u32 addr2:8;
+		u32 res0:8;
+	} bits;
+};
+
+struct di_addr {
+	u32 laddr[3];
+	union di_haddr_reg haddr;
+};
+
+struct di_in_addr {
+	struct di_addr top;
+	struct di_addr bot;
+};
+
+struct di_field_addr_reg {
+	u32 laddr[3];
+	union di_haddr_reg haddr;
+};
+
+union di_flag_haddr_reg {
+	u32 dwval;
+	struct {
+		u32 in_addr:8;
+		u32 out_addr:8;
+		u32 res0:16;
+	} bits;
+};
+
+union di_bist_ctl_reg {
+	u32 dwval;
+	struct {
+		u32 bist_start:1;
+		u32 bist_busy:1;
+		u32 res0:2;
+		u32 bist_mode_en:1;
+		u32 res1:11;
+		u32 bist_finish:1;
+		u32 bist_pass:1;
+		u32 res2:14;
+	} bits;
+};
+
+union di_bist_rand_reg {
+	u32 dwval;
+	struct {
+		u32 bist_rand_seed:31;
+		u32 bist_rand_en:1;
+	} bits;
+};
+
+union di_bist_ext_addr_reg {
+	u32 dwval;
+	struct {
+		u32 bist_ext_addr:16;
+		u32 res0:15;
+		u32 sram_clk_gating_mode:1;
+	} bits;
+};
+
+union di_mclk_bist_ext_addr_reg {
+	u32 dwval;
+	struct {
+		u32 sram_domain_sel:1;
+		u32 res0:30;
+		u32 sram_clk_gating_mode:1;
+	} bits;
+};
+
+/* MD */
+union md_para_reg {
+	u32 dwval;
+	struct {
+		u32 min_luma_th:8;
+		u32 max_luma_th:8;
+		u32 avg_luma_shifter:4;
+		u32 pix_static_th:2;
+		u32 res0:2;
+		u32 th_shift:4;
+		u32 mov_fac_nonedge:2;
+		u32 res1:2;
+	} bits;
+};
+
+/* DIT */
+union dit_setting_reg {
+	u32 dwval;
+	struct {
+		/*Y mode, 0:weave mode  1:motion adaptive*/
+		u32 dit_mode_luma:1;
+		u32 res0:3;
+		/*Y, motion blending function*/
+		u32 motion_blend_luma_en:1;
+		/*diagonal interpolation function enable*/
+		u32 diag_intp_en:1;
+		u32 res1:2;
+		u32 ela_demo_win_en:1;
+		u32 field_weave_demo_win_en:1;
+		u32 video_blend_demo_win_en:1;
+		u32 res2:5;
+		/*U/V mode, 0:weave mode  1:motion adaptive*/
+		u32 dit_mode_chroma:1;
+		u32 res3:3;
+		u32 motion_blend_chroma_en:1;
+		u32 res4:3;
+		/*0:2-frame mode  1:1-frame mode(Only base on field2)*/
+		u32 output_mode:1;
+		u32 res5:7;
+	} bits;
+};
+
+union dit_chroma_md_para0_reg {
+	u32 dwval;
+	struct {
+		u32 res0:8;
+		u32 spatial_th:8;
+		u32 diff_th:8;
+		u32 res1:4;
+		u32 pix_static_th:2;
+		u32 res2:2;
+	} bits;
+};
+
+union dit_chroma_md_para1_reg {
+	u32 dwval;
+	struct {
+		u32 blend_mode:4;
+		u32 res0:4;
+		u32 font_protect_en:1;
+		u32 res1:7;
+		u32 font_protect_th:8;
+		u32 font_protect_fac:5;
+		u32 res2:3;
+	} bits;
+};
+
+union dit_intra_intp_reg {
+	u32 dwval;
+	struct {
+		u32 ela_a:3;
+		u32 ela_en:1;
+		u32 ela_c:4;
+		u32 ela_cmax:8;
+		u32 ela_maxrat:2;
+		u32 res0:2;
+		u32 angle_limit:5;
+		u32 res1:3;
+		u32 angle_const_th:3;
+		u32 res2:1;
+	} bits;
+};
+
+union dit_inter_intp_reg {
+	u32 dwval;
+	struct {
+		u32 field_weave_f1:1;/*disable/enable weave for filed1*/
+		u32 video_exist_f1:1; /*disable/enable video bleanding when field_weave_f1 = 1*/
+		u32 field_weave_chroma_f1:1;;/*disable/enable weave for chroma channel of filed1*/
+		u32 res0:1;
+		u32 field_weave_phase_f1:2;
+		u32 res1:2;
+		u32 luma_cur_fac_f1:2;
+		u32 res2:2;
+		u32 chroma_cur_fac_f1:2;
+		u32 res3:2;
+		u32 field_weave_f2:1;
+		u32 video_exist_f2:1;
+		u32 field_weave_chroma_f2:1;
+		u32 res4:1;
+		u32 field_weave_phase_f2:2;
+		u32 res5:2;
+		u32 luma_cur_fac_f2:2;
+		u32 res6:2;
+		u32 chroma_cur_fac_f2:2;
+		u32 res7:2;
+	} bits;
+};
+
+/* FMD */
+union fmd_diff_th0_reg {
+	u32 dwval;
+	struct {
+		u32 p1_th:8;
+		u32 p1_th_u:8;
+		u32 p2_th:8;
+		u32 p2_th_u:8;
+	} bits;
+};
+
+union fmd_diff_th1_reg {
+	u32 dwval;
+	struct {
+		u32 p1_th:8;
+		u32 p1_th_u:8;
+		u32 p2_th:8;
+		u32 res0:8;
+	} bits;
+};
+
+union fmd_diff_th2_reg {
+	u32 dwval;
+	struct {
+		u32 p1_th:8;
+		u32 p1_th_u:8;
+		u32 p2_th:14;
+		u32 res0:2;
+	} bits;
+};
+
+union fmd_fid_hist_reg {
+	u32 dwval;
+	struct {
+		u32 cnt:30;
+		u32 res0:2;
+	} bits;
+};
+
+union fmd_frd_hist_reg {
+	u32 dwval;
+	struct {
+		u32 cnt:30;
+		u32 res0:2;
+	} bits;
+};
+
+
+union fmd_feat_th0_reg {
+	u32 dwval;
+	struct {
+		u32 d_th:8;
+		u32 highcomb_th:3;
+		u32 res0:5;
+		u32 mincontr:8;
+		u32 vp_th:8;
+	} bits;
+};
+
+union fmd_feat_th1_reg {
+	u32 dwval;
+	struct {
+		u32 f_th:11;
+		u32 res0:5;
+		u32 c_th_l:3;
+		u32 res1:5;
+		u32 c_th_h:3;
+		u32 res2:5;
+	} bits;
+};
+
+union fmd_feat_th2_reg {
+	u32 dwval;
+	struct {
+		u32 ccnt_th_l:5;
+		u32 res0:3;
+		u32 ccnt_th_m:5;
+		u32 res1:3;
+		u32 crowcnt_th:2;
+		u32 res2:14;
+	} bits;
+};
+
+union fmd_mot_th_reg {
+	u32 dwval;
+	struct {
+		u32 m_th:8;
+		u32 res0:8;
+		u32 mcnt_th:5;
+		u32 res1:3;
+		u32 mrowcnt_th:2;
+		u32 res2:6;
+	} bits;
+};
+
+union fmd_text_th_reg {
+	u32 dwval;
+	struct {
+		u32 t_th:8;
+		u32 res0:24;
+	} bits;
+};
+
+union fmd_blk_th_reg {
+	u32 dwval;
+	struct {
+		u32 blk_video_th:8;
+		u32 blk_text_th:8;
+		u32 blk_motion_th:8;
+		u32 res0:8;
+	} bits;
+};
+
+union fmd_row_th_reg {
+	u32 dwval;
+	struct {
+		u32 row_video_th:8;
+		u32 row_text_th:8;
+		u32 row_exit_video_th:8;
+		u32 res0:8;
+	} bits;
+};
+
+union fmd_field_hist_reg {
+	u32 dwval;
+	struct {
+		u32 max_video_num:8;
+		u32 max_text_num:8;
+		u32 max_text_pos:8;
+		u32 text_row_num:8;
+	} bits;
+};
+
+union fmd_glb_set_reg {
+	u32 dwval;
+	struct {
+		u32 blk_size:1;
+		u32 res0:3;
+		u32 vof_buf_sel:2;
+		u32 res1:25;
+		u32 vof_en:1;
+	} bits;
+};
+
+union tnr_strength_reg {
+	u32 dwval;
+	struct {
+		u32 v:8;
+		u32 u:8;
+		u32 y:8;
+		u32 res0:8;
+	} bits;
+};
+
+union tnr_dark_th_reg {
+	u32 dwval;
+	struct {
+		u32 v:6;
+		u32 res0:2;
+		u32 u:6;
+		u32 res1:2;
+		u32 y:6;
+		u32 res2:10;
+	} bits;
+};
+
+
+union tnr_dark_protect_reg {
+	u32 dwval;
+	struct {
+		u32 strength_v:3;
+		u32 res0:5;
+		u32 strength_u:3;
+		u32 res1:5;
+		u32 strength_y:3;
+		u32 res2:13;
+	} bits;
+};
+
+union tnr_dark_para_reg {
+	u32 dwval;
+	struct {
+		u32 std_shift:8;
+		u32 std_slope:8;
+		u32 avg_shift:8;
+		u32 avg_slope:8;
+	} bits;
+};
+
+/* fth: feather */
+union tnr_fth_detect_reg {
+	u32 dwval;
+	struct {
+		u32 th_fth3:3;
+		u32 res0:5;
+		u32 th_fth7:3;
+		u32 res1:5;
+		u32 th_st_fth:8; /* strong fth */
+		u32 res2:8;
+	} bits;
+};
+
+union tnr_dt_filter_reg {
+	u32 dwval;
+	struct {
+		u32 th_clamp:4;
+		u32 res0:12;
+		u32 th_max:7;
+		u32 res1:9;
+	} bits;
+};
+
+/* lbound: lower bound */
+union tnr_weight_lbound_reg {
+	u32 dwval;
+	struct {
+		u32 th_down3:8;
+		u32 th_down2:8;
+		u32 th_down1:8;
+		u32 th_down0:8;
+	} bits;
+};
+
+/* abn: abnormal */
+union tnr_abn_detect_reg {
+	u32 dwval;
+	struct {
+		u32 th_abn_weight:3;
+		u32 res0:5;
+		u32 th_fmm:3;/* fmm: film mode movement */
+		u32 res1:5;
+		u32 th_max_diff:8;
+		u32 res2:8;
+	} bits;
+};
+
+union tnr_th_sum_reg {
+	u32 dwval;
+	struct {
+		u32 th_sum_weight_v:2;
+		u32 res0:2;
+		u32 th_sum_weight_u:2;
+		u32 res1:2;
+		u32 th_sum_weight_y:2;
+		u32 res2:6;
+		u32 th_sum_gain_v:2;
+		u32 res3:2;
+		u32 th_sum_gain_u:2;
+		u32 res4:2;
+		u32 th_sum_gain_y:2;
+		u32 res5:6;
+	} bits;
+};
+
+union tnr_th_dark_dither_reg {
+	u32 dwval;
+	struct {
+		u32 th_random_dither_v:4;
+		u32 res0:4;
+		u32 th_random_dither_u:4;
+		u32 res1:4;
+		u32 th_random_dither_y:4;
+		u32 res2:12;
+	} bits;
+};
+
+union tnr_random_func_cfg_reg {
+	u32 dwval;
+	struct {
+		u32 rand_num_bits:5;
+		u32 res0:3;
+		u32 mod_bits:5;
+		u32 res1:3;
+		u32 rand_para_q:4;
+		u32 res2:4;
+		u32 rand_para_p:4;
+		u32 res3:4;
+	} bits;
+};
+
+union tnr_md_result_reg {
+	u32 dwval;
+	struct {
+		u32 is_scene_changed:1;
+		u32 res0:15;
+		u32 is_contain_bad_frame:1;
+		u32 res1:15;
+	} bits;
+};
+
+union tnr_coord_hori_reg {
+	u32 dwval;
+	struct {
+		u32 left:11;
+		u32 res0:5;
+		u32 right:11;
+		u32 res1:5;
+	} bits;
+};
+
+union tnr_coord_vert_reg {
+	u32 dwval;
+	struct {
+		u32 top:11;
+		u32 res0:5;
+		u32 bottom:11;
+		u32 res1:5;
+	} bits;
+};
+
+/* window */
+union win_horz_reg {
+	u32 dwval;
+	struct {
+		u32 x0:11;
+		u32 res0:5;
+		u32 x1:11;
+		u32 res1:5;
+	} bits;
+};
+
+union win_vert_reg {
+	u32 dwval;
+	struct {
+		u32 y0:11;
+		u32 res0:5;
+		u32 y1:11;
+		u32 res1:5;
+	} bits;
+};
+
+/* DEBUG */
+union top_debug0_reg {
+	u32 dwval;
+};
+
+union top_debug1_reg {
+	u32 dwval;
+};
+
+union top_debug2_reg {
+	u32 dwval;
+};
+
+union top_debug3_reg {
+	u32 dwval;
+};
+
+union top_debug4_reg {
+	u32 dwval;
+};
+
+union top_debug5_reg {
+	u32 dwval;
+};
+
+union top_debug6_reg {
+	u32 dwval;
+};
+
+/* RSC */
+union top_rand_ctl_reg {
+	u32 dwval;
+};
+
+union top_rand_clk_reg {
+	u32 dwval;
+};
+
+struct top_rsc {
+	union top_rand_ctl_reg rsc_ctl;
+	union top_rand_clk_reg rsc_clk;
+};
+
+/* register of di300 */
+struct di_reg {
+	/* TOP */
+	union di_reset_reg reset;                      /* 0x000 */
+	u32 res0[2];                                   /* 0x004 */
+	union di_func_vsn_reg func_vsn;                /* 0x00C */
+	union di_start_reg start;                      /* 0x010 */
+	union di_int_ctl_reg int_ctl;                  /* 0x014 */
+	union di_status_reg status;                    /* 0x018 */
+	u32 ip_version;                                /* 0x01C */
+	union di_func_en_reg func_en;                  /* 0x020 */
+	union di_dma_ctl_reg dma_ctl;                  /* 0x024 */
+	union di_rdma_cmd_ctl_reg rdma_cmd_ctl;        /* 0x028 */
+	union di_wdma_cmd_ctl_reg wdma_cmd_ctl;        /* 0x02C */
+	union di_size_reg size;                        /* 0x030 */
+	union di_fmt_reg fmt;                          /* 0x034 */
+	union di_field_order_reg forder;               /* 0x038 */
+	u32 res1;                                      /* 0x03C */
+	/* f01: frame 0,1 */  /*YUV*/
+	union di_2pitch_reg in_f01_pitch[3];           /* 0x040 */
+	u32 res2;                                      /* 0x04C */
+	/* f2: frame 2 */  /*YUV*/
+	union di_pitch_reg in_f2_pitch[3];             /* 0x050 */
+	u32 res3;                                      /* 0x05C */
+	  /*YUV*/
+	union di_pitch_reg out_tnr_pitch[3];           /* 0x060 */
+	u32 res4;                                      /* 0x06C */
+	  /*YUV*/
+	union di_pitch_reg out_dit_pitch[3];           /* 0x070 */
+	u32 res5;                                      /* 0x07C */
+	/* in&out flag itch of motion flag fb*/
+	union di_pitch_reg flag_pitch;                 /* 0x080 */
+	u32 res6[3];                                   /* 0x084 */
+	/* in_f0: input frame0 */
+	struct di_in_addr in_f0_addr;                  /* 0x090~0x0AC */
+	struct di_in_addr in_f1_addr;                  /* 0x0B0~0x0CC */
+	struct di_in_addr in_f2_addr;                  /* 0x0D0~0x0EC */
+	struct di_addr out_tnr_addr;                   /* 0x0F0~0x0FC */
+	struct di_addr out_dit0_addr;                  /* 0x100~0x10C */
+	struct di_addr out_dit1_addr;                  /* 0x110~0x11C */
+	u32 in_flag_laddr;                             /* 0x120 */
+	u32 out_flag_laddr;                            /* 0x124 */
+	union di_flag_haddr_reg flag_haddr;            /* 0x128 */
+	u32 res7[5];                                   /* 0x12C */
+	union di_bist_ctl_reg bist_ctl;                /* 0x140 */
+	union di_bist_rand_reg bist_rand;              /* 0x144 */
+	u32 bist_data0;                                /* 0x148 */
+	u32 bist_data1;                                /* 0x14C */
+	u32 bist_data2;                                /* 0x150 */
+	u32 bist_sts_cur_addr;                         /* 0x154 */
+	union di_bist_ext_addr_reg bist_haddr;         /* 0x158 */
+	union di_bist_ctl_reg mbist_ctl;               /* 0x15C */
+	union di_bist_rand_reg mbist_rand;             /* 0x160 */
+	u32 mbist_data0;                               /* 0x164 */
+	u32 mbist_data1;                               /* 0x168 */
+	u32 mbist_data2;                               /* 0x16c */
+	u32 mbist_sts_cur_addr;                        /* 0x170 */
+	union di_mclk_bist_ext_addr_reg mbist_haddr;   /* 0x174 */
+	u32 res8[2];                                   /* 0x178 */
+
+	/* MD */
+	union md_para_reg md_para;                     /* 0x180 */
+	u32 md_res0[3];                                /* 0x184 */
+	union win_horz_reg md_croph;                   /* 0x190 */
+	union win_vert_reg md_cropv;                   /* 0x194 */
+	u32 md_res1[2];                                /* 0x198 */
+
+	/* DIT */
+	union dit_setting_reg dit_setting;             /* 0x1a0 */
+	union dit_chroma_md_para0_reg dit_chr_para0;   /* 0x1a4 */
+	union dit_chroma_md_para1_reg dit_chr_para1;   /* 0x1a8 */
+	u32 dit_res0;                                  /* 0x1ac */
+	union dit_intra_intp_reg dit_intra_para;       /* 0x1b0 */
+	union dit_inter_intp_reg dit_inter_para;       /* 0x1b4 */
+	u32 dit_res1[2];                               /* 0x1b8 */
+	union win_horz_reg dit_croph;                  /* 0x1c0 */
+	union win_vert_reg dit_cropv;                  /* 0x1c4 */
+	union win_horz_reg dit_demoh;                  /* 0x1c8 */
+	union win_vert_reg dit_demov;                  /* 0x1cc */
+
+	/* FMD */ /*FMD difference Threshold*/
+	union fmd_diff_th0_reg fmd_diff_th0;           /* 0x1d0 */
+	union fmd_diff_th1_reg fmd_diff_th1;           /* 0x1d4 */
+	union fmd_diff_th2_reg fmd_diff_th2;           /* 0x1d8 */
+	u32 fmd_res0;                                  /* 0x1dc */
+	union fmd_fid_hist_reg fmd_fid12;              /* 0x1e0 */
+	union fmd_fid_hist_reg fmd_fid23;              /* 0x1e4 */
+	union fmd_fid_hist_reg fod_fid30;              /* 0x1e8 */
+	union fmd_fid_hist_reg fod_fid32;              /* 0x1ec */
+	union fmd_fid_hist_reg fod_fid10;              /* 0x1f0 */
+	union fmd_fid_hist_reg fod_fid12;              /* 0x1f4 */
+	union fmd_frd_hist_reg fmd_frd02;              /* 0x1f8 */
+	union fmd_frd_hist_reg fmd_frd13;              /* 0x1fc */
+	union fmd_feat_th0_reg fmd_feat_th0;           /* 0x200 */
+	union fmd_feat_th1_reg fmd_feat_th1;           /* 0x204 */
+	union fmd_feat_th2_reg fmd_feat_th2;           /* 0x208 */
+	union fmd_mot_th_reg fmd_mot_th;               /* 0x20c */
+	union fmd_text_th_reg fmd_text_th;             /* 0x210 */
+	union fmd_blk_th_reg fmd_blk_th;               /* 0x214 */
+	union fmd_row_th_reg fmd_row_th;               /* 0x218 */
+	union fmd_field_hist_reg fmd_field_hist0;      /* 0x21c */
+	union fmd_field_hist_reg fmd_field_hist1;      /* 0x220 */
+	union fmd_glb_set_reg fmd_glb;                 /* 0x224 */
+	u32 fmd_res1[2];                               /* 0x228 */
+	union win_horz_reg fmd_croph;                  /* 0x230 */
+	union win_vert_reg fmd_cropv;                  /* 0x234 */
+	u32 fmd_res2[2];                               /* 0x238 */
+
+	/* TNR */
+	union tnr_strength_reg tnr_strength;           /* 0x240 */
+	union tnr_dark_th_reg tnr_dark_th;             /* 0x244 */
+	union tnr_dark_protect_reg tnr_dark_protect;   /* 0x248 */
+	union tnr_dark_para_reg tnr_dark_para_y;       /* 0x24C */
+	union tnr_dark_para_reg tnr_dark_para_u;       /* 0x250 */
+	union tnr_dark_para_reg tnr_dark_para_v;       /* 0x254 */
+	union tnr_fth_detect_reg tnr_fth_detect;       /* 0x258 */
+	union tnr_dt_filter_reg tnr_dt_filter;         /* 0x25C */
+	union tnr_weight_lbound_reg tnr_weight_lbound; /* 0x260 */
+	union tnr_abn_detect_reg tnr_abn_detect;       /* 0x264 */
+	union tnr_th_sum_reg tnr_th_sum;               /* 0x268 */
+	u32 tnr_sum_weight_y;                          /* 0x26C */
+	u32 tnr_sum_weight_u;                          /* 0x270 */
+	u32 tnr_sum_weight_v;                          /* 0x274 */
+	u32 tnr_sum_gain_y;                            /* 0x278 */
+	u32 tnr_sum_gain_u;                            /* 0x27C */
+	u32 tnr_sum_gain_v;                            /* 0x280 */
+	u32 tnr_sum_still_out;                         /* 0x284 */
+	u32 tnr_sum_weight_y_cnt;                      /* 0x288 */
+	u32 tnr_sum_gain_y_cnt;                        /* 0x28C */
+	union tnr_th_dark_dither_reg tnr_th_dark_dth;  /* 0x290 */
+	union tnr_random_func_cfg_reg tnr_random_cfg;  /* 0x294 */
+	u32 tnr_random_gen;                            /* 0x298 */
+	union tnr_md_result_reg tnr_md_result;         /* 0x29C */
+	union win_horz_reg tnr_croph;                  /* 0x2A0 */
+	union win_vert_reg tnr_cropv;                  /* 0x2A4 */
+	union win_horz_reg tnr_demoh;                  /* 0x2A8 */
+	union win_vert_reg tnr_demov;                  /* 0x2AC */
+	u32 tnr_res0[8];                               /* 0x2B0 */
+
+};
+
+#endif /* _DI300_REG_H_ */
diff --git a/drivers/char/sunxi-di/drv_div3x/sunxi_di.h b/drivers/char/sunxi-di/drv_div3x/sunxi_di.h
new file mode 100644
index 000000000..1e2aa70f9
--- /dev/null
+++ b/drivers/char/sunxi-di/drv_div3x/sunxi_di.h
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2007-2018 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_SUNXI_DI_H_
+#define _UAPI_SUNXI_DI_H_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <drm/drm_fourcc.h>
+
+#ifndef __KERNEL__
+typedef __u8 u8;
+typedef __s32 s32;
+typedef __u32 u32;
+typedef __u64 u64;
+#endif /* #ifdef __KERNEL__ */
+
+
+enum {
+	DI_DIT_INTP_MODE_INVALID = 0x0,
+	DI_DIT_INTP_MODE_WEAVE,
+	DI_DIT_INTP_MODE_BOB,
+	DI_DIT_INTP_MODE_MOTION,
+};
+
+enum {
+	DI_DIT_OUT_0FRAME = 0x0,
+	DI_DIT_OUT_1FRAME,
+	DI_DIT_OUT_2FRAME,
+};
+
+enum {
+	DI_TNR_MODE_INVALID = 0,
+	DI_TNR_MODE_ADAPTIVE,
+	DI_TNR_MODE_FIX,
+};
+
+enum {
+	DI_TNR_LEVEL_HIGH = 0,
+	DI_TNR_LEVEL_MIDDLE,
+	DI_TNR_LEVEL_LOW,
+};
+
+enum {
+	FB_PROCESS_NO_ERROR = 0,
+	FB_PROCESS_ERROR_INTERLACE_TYPE = 1,
+};
+
+struct di_version {
+	u32 version_major;
+	u32 version_minor;
+	u32 version_patchlevel;
+
+	u32 ip_version;
+};
+
+struct di_timeout_ns {
+	u64 wait4start;
+	u64 wait4finish;
+};
+
+/*
+ * @intp_mode: see enum DI_DIT_INTP_MODE_XXX.
+ * @out_frame_mode: see enum DI_DIT_OUT_XFRAME.
+ */
+struct di_dit_mode {
+	u32 intp_mode;
+	u32 out_frame_mode;
+};
+
+/*
+ * @mode:
+ * @level:
+ */
+struct di_tnr_mode {
+	u32 mode;
+	u32 level;
+};
+
+/* 0:disable; 1:enable. */
+struct di_fmd_enable {
+	u32 en;
+};
+
+struct di_size {
+	u32 width;
+	u32 height;
+};
+
+struct di_rect {
+	u32 left;
+	u32 top;
+	u32 right;
+	u32 bottom;
+};
+
+/*
+ * support dma_buf method or phy_addr_buf method.
+ * 1.On dma_buf method:
+ *     @y_addr is address-offset of luma-buf to dma_addr;
+ *     @cb_addr/@cr_addr is address-offset of chroma-buf to dma_addr.
+ * 2.On phy_addr_buf method:
+ *     @y_addr is physical address of luma-buf;
+ *     @cb_addr/@cr_addr is physical address of chroma-buf.
+ *
+ * @ystride: line stride of luma buf. unit: byte.
+ * @cstride: line stride of chroma buf. unit: byte.
+ */
+struct di_buf {
+	u64 y_addr;
+	u64 cb_addr;
+	u64 cr_addr;
+	u32 ystride;
+	u32 cstride;
+};
+
+/*
+ * @format: see DRM_FORMAT_XXX in drm_fourcc.h.
+ * @dma_buf_fd: dma buf fd that from userspace.
+ *    @dma_buf_fd must be invalid(<0) on phy_addr_buf method.
+ * @size.width,@size.height: size of pixel datas of image. unit: pixel.
+ */
+struct di_fb {
+	u32 format;
+	s32 dma_buf_fd;
+	struct di_buf buf;
+	struct di_size size;
+};
+
+/*
+ * @base_field:
+ *     0: top_field;
+ *     1: bottom_field.
+ */
+struct di_process_fb_arg {
+
+	u8 is_interlace;
+	u8 is_pulldown; /* fixme: define enum value */
+	u8 top_field_first;
+	u8 base_field;
+
+	struct di_fb in_fb0;
+	struct di_fb in_fb1;
+	struct di_fb in_fb2;
+
+	struct di_fb out_dit_fb0;
+	struct di_fb out_dit_fb1;
+	struct di_fb out_tnr_fb0;
+
+};
+
+struct di_mem_arg {
+	unsigned int size;
+	unsigned int handle;
+	u64 phys_addr;
+};
+
+struct di_demo_crop_arg {
+	struct di_rect dit_demo;
+	struct di_rect tnr_demo;
+};
+
+#define DI_IOC_MAGIC 'D'
+#define DI_IO(nr)          _IO(DI_IOC_MAGIC, nr)
+#define DI_IOR(nr, size)   _IOR(DI_IOC_MAGIC, nr, size)
+#define DI_IOW(nr, size)   _IOW(DI_IOC_MAGIC, nr, size)
+#define DI_IOWR(nr, size)  _IOWR(DI_IOC_MAGIC, nr, size)
+#define DI_IOCTL_NR(n)     _IOC_NR(n)
+
+#define DI_IOC_GET_VERSION    DI_IOR(0x0, struct di_version)
+#define DI_IOC_RESET          DI_IO(0x1)
+#define DI_IOC_CHECK_PARA     DI_IO(0x2)
+#define DI_IOC_SET_TIMEOUT    DI_IOW(0x3, struct di_timeout_ns)
+#define DI_IOC_SET_VIDEO_SIZE DI_IOW(0x4, struct di_size)
+#define DI_IOC_SET_DIT_MODE   DI_IOW(0x5, struct di_dit_mode)
+#define DI_IOC_SET_TNR_MODE   DI_IOW(0x6, struct di_tnr_mode)
+#define DI_IOC_SET_FMD_ENABLE DI_IOW(0x7, struct di_fmd_enable)
+#define DI_IOC_PROCESS_FB     DI_IOW(0x8, struct di_process_fb_arg)
+#define DI_IOC_SET_VIDEO_CROP DI_IOW(0x9, struct di_rect)
+#define DI_IOC_MEM_REQUEST    DI_IOWR(0x10, struct di_mem_arg)
+#define DI_IOC_MEM_RELEASE    DI_IOWR(0x11, struct di_mem_arg)
+#define DI_IOC_SET_DEMO_CROP  DI_IOW(0x12, struct di_demo_crop_arg)
+
+extern unsigned int di_device_get_debug_mode(void);
+#endif /* #ifndef _UAPI_SUNXI_DI_H_ */
diff --git a/drivers/char/sunxi-sysinfo/Kconfig b/drivers/char/sunxi-sysinfo/Kconfig
new file mode 100644
index 000000000..ae0be45e4
--- /dev/null
+++ b/drivers/char/sunxi-sysinfo/Kconfig
@@ -0,0 +1,24 @@
+#
+# sunxi system information driver.
+#
+
+config SUNXI_SYS_INFO
+	tristate "sunxi system info driver"
+	default n
+	help
+	  This driver is used for query system information.
+	  If you don't know whether need it, please select y.
+
+config SUNXI_QA_TEST
+	bool "sunxi QA test"
+	depends on SUNXI_SYS_INFO
+	help
+	  support sunxi QA test.
+
+config SUNXI_SMC
+	tristate "sunxi smc interfaces"
+	default n
+	help
+	  This driver support smc call interfaces depended on
+	  monitor/aft/SecureOs. If you don't know whether need
+	  it, please select y.
diff --git a/drivers/char/sunxi-sysinfo/Makefile b/drivers/char/sunxi-sysinfo/Makefile
new file mode 100644
index 000000000..b8903b18e
--- /dev/null
+++ b/drivers/char/sunxi-sysinfo/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for sunxi system information driver
+#
+
+#obj-$(CONFIG_SUNXI_SYS_INFO) += sysinfo.o
+
+obj-$(CONFIG_SUNXI_SYS_INFO) += sunxi-sysinfo.o
+
+obj-$(CONFIG_SUNXI_SMC) += sunxi-smc.o
+
diff --git a/drivers/char/sunxi-sysinfo/sunxi-smc.c b/drivers/char/sunxi-sysinfo/sunxi-smc.c
new file mode 100644
index 000000000..301af4cbe
--- /dev/null
+++ b/drivers/char/sunxi-sysinfo/sunxi-smc.c
@@ -0,0 +1,233 @@
+/*
+ * Based on arch/arm64/kernel/chipid-sunxi.c
+ *
+ * Copyright (C) 2015 Allwinnertech Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/sunxi-smc.h>
+#include <linux/arm-smccc.h>
+#include <linux/bitops.h>
+
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#ifndef OPTEE_SMC_STD_CALL_VAL
+#define OPTEE_SMC_STD_CALL_VAL(func_num) \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32, \
+			   ARM_SMCCC_OWNER_TRUSTED_OS, (func_num))
+#endif
+
+#ifndef OPTEE_SMC_FAST_CALL_VAL
+#define OPTEE_SMC_FAST_CALL_VAL(func_num) \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, ARM_SMCCC_SMC_32, \
+			   ARM_SMCCC_OWNER_TRUSTED_OS, (func_num))
+#endif
+/*
+ * Function specified by SMC Calling convention.
+ */
+#define OPTEE_SMC_FUNCID_READ_REG  (17 | sunxi_smc_call_offset())
+#define OPTEE_SMC_READ_REG \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_READ_REG)
+
+
+#define OPTEE_SMC_FUNCID_WRITE_REG  (18 | sunxi_smc_call_offset())
+#define OPTEE_SMC_WRITE_REG \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_WRITE_REG)
+
+#define OPTEE_SMC_FUNCID_COPY_ARISC_PARAS  (19 | sunxi_smc_call_offset())
+#define OPTEE_SMC_COPY_ARISC_PARAS \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_COPY_ARISC_PARAS)
+#define ARM_SVC_COPY_ARISC_PARAS    OPTEE_SMC_COPY_ARISC_PARAS
+
+#define OPTEE_SMC_FUNCID_GET_TEEADDR_PARAS  (20 | sunxi_smc_call_offset())
+#define OPTEE_SMC_GET_TEEADDR_PARAS \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_GET_TEEADDR_PARAS)
+#define ARM_SVC_GET_TEEADDR_PARAS    OPTEE_SMC_GET_TEEADDR_PARAS
+
+#define OPTEE_SMC_FUNCID_GET_DRMINFO	(15 | sunxi_smc_call_offset())
+#define OPTEE_SMC_GET_DRM_INFO \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_GET_DRMINFO)
+
+#ifdef CONFIG_ARM64
+/*cmd to call ATF service*/
+#define ARM_SVC_EFUSE_PROBE_SECURE_ENABLE    (0xc000fe03)
+#define ARM_SVC_READ_SEC_REG                 (0xC000ff05)
+#define ARM_SVC_WRITE_SEC_REG                (0xC000ff06)
+#else
+/*cmd to call TEE service*/
+#define ARM_SVC_READ_SEC_REG        OPTEE_SMC_READ_REG
+#define ARM_SVC_WRITE_SEC_REG       OPTEE_SMC_WRITE_REG
+#endif
+
+/*interface for smc */
+u32 sunxi_smc_readl(phys_addr_t addr)
+{
+#if defined(CONFIG_ARM64) || defined(CONFIG_TEE)
+	struct arm_smccc_res res;
+	arm_smccc_smc(ARM_SVC_READ_SEC_REG, addr, 0, 0, 0, 0, 0, 0, &res);
+	return res.a0;
+#else
+	void __iomem *vaddr = ioremap(addr, 4);
+	u32 ret;
+	ret = readl(vaddr);
+	iounmap(vaddr);
+	return ret;
+#endif
+}
+EXPORT_SYMBOL(sunxi_smc_readl);
+
+int sunxi_smc_writel(u32 value, phys_addr_t addr)
+{
+#if defined(CONFIG_ARM64) || defined(CONFIG_TEE)
+	struct arm_smccc_res res;
+	arm_smccc_smc(ARM_SVC_WRITE_SEC_REG, addr, value, 0, 0, 0, 0, 0, &res);
+	return res.a0;
+#else
+	void __iomem *vaddr = ioremap(addr, 4);
+	writel(value, vaddr);
+	iounmap(vaddr);
+	return 0;
+#endif
+}
+EXPORT_SYMBOL(sunxi_smc_writel);
+
+int sunxi_smc_copy_arisc_paras(phys_addr_t dest, phys_addr_t src, u32 len)
+{
+	struct arm_smccc_res res;
+	arm_smccc_smc(ARM_SVC_COPY_ARISC_PARAS, dest, src, len, 0, 0, 0, 0, &res);
+	return res.a0;
+}
+
+phys_addr_t sunxi_smc_get_teeaddr_paras(phys_addr_t resumeaddr)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(ARM_SVC_GET_TEEADDR_PARAS,
+		resumeaddr, 0, 0, 0, 0, 0, 0, &res);
+	return res.a0;
+}
+/*optee smc*/
+#define ARM_SMCCC_SMC_32		0
+#define ARM_SMCCC_SMC_64		1
+#define ARM_SMCCC_CALL_CONV_SHIFT	30
+
+#define ARM_SMCCC_OWNER_MASK		0x3F
+#define ARM_SMCCC_OWNER_SHIFT		24
+
+#define ARM_SMCCC_FUNC_MASK		0xFFFF
+#define ARM_SMCCC_OWNER_TRUSTED_OS	50
+
+#define ARM_SMCCC_IS_FAST_CALL(smc_val)	\
+	((smc_val) & (ARM_SMCCC_FAST_CALL << ARM_SMCCC_TYPE_SHIFT))
+#define ARM_SMCCC_IS_64(smc_val) \
+	((smc_val) & (ARM_SMCCC_SMC_64 << ARM_SMCCC_CALL_CONV_SHIFT))
+#define ARM_SMCCC_FUNC_NUM(smc_val)	((smc_val) & ARM_SMCCC_FUNC_MASK)
+#define ARM_SMCCC_OWNER_NUM(smc_val) \
+	(((smc_val) >> ARM_SMCCC_OWNER_SHIFT) & ARM_SMCCC_OWNER_MASK)
+
+#define ARM_SMCCC_CALL_VAL(type, calling_convention, owner, func_num) \
+	(((type) << ARM_SMCCC_TYPE_SHIFT) | \
+	((calling_convention) << ARM_SMCCC_CALL_CONV_SHIFT) | \
+	(((owner) & ARM_SMCCC_OWNER_MASK) << ARM_SMCCC_OWNER_SHIFT) | \
+	((func_num) & ARM_SMCCC_FUNC_MASK))
+
+#define OPTEE_SMC_FAST_CALL_VAL(func_num) \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, ARM_SMCCC_SMC_32, \
+			   ARM_SMCCC_OWNER_TRUSTED_OS, (func_num))
+
+#define OPTEE_SMC_FUNCID_CRYPT  16
+#define OPTEE_SMC_CRYPT \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CRYPT)
+
+#define TEESMC_RSSK_DECRYPT      5
+int sunxi_smc_refresh_hdcp(void)
+{
+	struct arm_smccc_res res;
+	arm_smccc_smc(OPTEE_SMC_CRYPT, TEESMC_RSSK_DECRYPT, 0, 0, 0, 0, 0, 0, &res);
+	return res.a0;
+}
+EXPORT_SYMBOL(sunxi_smc_refresh_hdcp);
+
+#define OPTEE_MSG_FUNCID_GET_OS_REVISION	0x0001
+#define OPTEE_SMC_CALL_GET_OS_REVISION \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_MSG_FUNCID_GET_OS_REVISION)
+
+int smc_tee_get_os_revision(uint32_t *major, uint32_t *minor)
+{
+	struct arm_smccc_res param = { 0 };
+
+	arm_smccc_smc(OPTEE_SMC_CALL_GET_OS_REVISION, 0, 0, 0, 0, 0, 0, 0,
+		      &param);
+	*major = param.a0;
+	*minor = param.a1;
+	return 0;
+}
+
+int sunxi_smc_call_offset(void)
+{
+	uint32_t major, minor;
+
+	smc_tee_get_os_revision(&major, &minor);
+	if ((major > 3) || ((major == 3) && (minor >= 5))) {
+		return SUNXI_OPTEE_SMC_OFFSET;
+	} else {
+		return 0;
+	}
+}
+
+int  optee_probe_drm_configure(unsigned long *drm_base,
+	size_t *drm_size, unsigned long  *tee_base)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(OPTEE_SMC_GET_DRM_INFO, 0, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0  != 0) {
+		printk("drm config service not available: %X", (uint32_t)res.a0);
+		return -EINVAL;
+	}
+
+	*drm_base = res.a1;
+	*drm_size = res.a2;
+	*tee_base = res.a3;
+
+	printk("drm_base=0x%x\n", (uint32_t)*drm_base);
+	printk("drm_size=0x%x\n", (uint32_t)*drm_size);
+	printk("tee_base=0x%x\n", (uint32_t)*tee_base);
+
+	return 0;
+}
+EXPORT_SYMBOL(optee_probe_drm_configure);
+
+static int __init sunxi_smc_init(void)
+{
+	return 0;
+}
+
+static void __exit sunxi_smc_exit(void)
+{
+}
+
+module_init(sunxi_smc_init);
+module_exit(sunxi_smc_exit);
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("weidonghui<weidonghui@allwinnertech.com>");
+MODULE_DESCRIPTION("sunxi smc.");
diff --git a/drivers/char/sunxi-sysinfo/sunxi-sysinfo-user.h b/drivers/char/sunxi-sysinfo/sunxi-sysinfo-user.h
new file mode 100644
index 000000000..b636f0514
--- /dev/null
+++ b/drivers/char/sunxi-sysinfo/sunxi-sysinfo-user.h
@@ -0,0 +1,24 @@
+/*
+ * The interface define of sysinfo dev for userspace.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * Matteo <duanmintao@allwinnertech.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __SUNXI_SYSINFO_USER_H__
+#define __SUNXI_SYSINFO_USER_H__
+
+#define CHECK_SOC_SECURE_ATTR 0x00
+#define CHECK_SOC_VERSION     0x01
+#define CHECK_SOC_BONDING     0x03
+#define CHECK_SOC_CHIPID      0x04
+#define CHECK_SOC_FT_ZONE     0x05
+#define CHECK_SOC_ROTPK_STATUS     0x06
+
+#endif /* end of __SUNXI_SYSINFO_USER_H__ */
+
diff --git a/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c b/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
new file mode 100644
index 000000000..aaf382a4e
--- /dev/null
+++ b/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
@@ -0,0 +1,252 @@
+/*
+ * Based on drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
+ *
+ * Copyright (C) 2015 Allwinnertech Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+#include <linux/sunxi-sid.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#include "sunxi-sysinfo-user.h"
+
+static s8 key_name[SUNXI_KEY_NAME_LEN];
+
+static int soc_info_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int soc_info_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long soc_info_ioctl(struct file *file, unsigned int ioctl_num,
+		unsigned long ioctl_param)
+{
+	int ret = 0;
+	char id[17] = "";
+
+	memset(id, 0, sizeof(id));
+
+	pr_debug("IOCTRL cmd: %#x, param: %#lx\n", ioctl_num, ioctl_param);
+	switch (ioctl_num) {
+	case CHECK_SOC_SECURE_ATTR:
+		ret = sunxi_soc_is_secure();
+		if (ret)
+			pr_debug("soc is secure. return value: %d\n", ret);
+		else
+			pr_debug("soc is normal. return value: %d\n", ret);
+		break;
+	case CHECK_SOC_VERSION:
+		ret = sunxi_get_soc_ver();
+		pr_debug("soc version:%x\n", ret);
+		break;
+	case CHECK_SOC_BONDING:
+		sunxi_get_soc_chipid_str(id);
+		ret = copy_to_user((void __user *)ioctl_param, id, 8);
+		pr_debug("soc id:%s\n", id);
+		break;
+	case CHECK_SOC_CHIPID:
+		sunxi_get_soc_chipid_str(id);
+		ret = copy_to_user((void __user *)ioctl_param, id, 16);
+		pr_debug("soc chipid:%s\n", id);
+		break;
+	case CHECK_SOC_FT_ZONE:
+		sunxi_get_soc_ft_zone_str(id);
+		ret = copy_to_user((void __user *)ioctl_param, id, 8);
+		pr_debug("ft zone:%s\n", id);
+		break;
+	case CHECK_SOC_ROTPK_STATUS:
+		sunxi_get_soc_rotpk_status_str(id);
+		ret = copy_to_user((void __user *)ioctl_param, id, 8);
+		pr_debug("rotpk status:%s\n", id);
+		break;
+	default:
+		pr_err("Unsupported cmd:%d\n", ioctl_num);
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long soc_info_compat_ioctl(struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	unsigned long translated_arg = (unsigned long)compat_ptr(arg);
+
+	return soc_info_ioctl(filp, cmd, translated_arg);
+}
+#endif
+
+static const struct file_operations soc_info_ops = {
+	.owner   = THIS_MODULE,
+	.open    = soc_info_open,
+	.release = soc_info_release,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = soc_info_compat_ioctl,
+#endif
+	.unlocked_ioctl = soc_info_ioctl,
+};
+
+struct miscdevice soc_info_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name  = "sunxi_soc_info",
+	.fops  = &soc_info_ops,
+};
+
+static ssize_t sys_info_show(struct class *class,
+			     struct class_attribute *attr, char *buf)
+{
+	int i;
+	int databuf[4] = {0};
+	char tmpbuf[129] = {0};
+	size_t size = 0;
+
+	/* platform */
+	sunxi_get_platform(tmpbuf, 129);
+	size += sprintf(buf + size, "sunxi_platform    : %s\n", tmpbuf);
+
+	/* secure */
+	size += sprintf(buf + size, "sunxi_secure      : ");
+	if (sunxi_soc_is_secure()) {
+		size += sprintf(buf + size, "%s\n", "secure");
+		/* rotpk status */
+		memset(tmpbuf, 0x0, sizeof(tmpbuf));
+		sunxi_get_soc_rotpk_status_str(tmpbuf);
+		size += sprintf(buf + size, "sunxi_rotpk       : %s\n", tmpbuf);
+	} else
+		size += sprintf(buf + size, "%s\n", "normal");
+
+#ifdef CONFIG_SUNXI_QA_TEST
+	/* chipid */
+	sunxi_get_soc_chipid((u8 *)databuf);
+
+	for (i = 0; i < 4; i++)
+		sprintf(tmpbuf + i*8, "%08x", databuf[i]);
+	tmpbuf[128] = 0;
+	size += sprintf(buf + size, "sunxi_chipid      : %s\n", tmpbuf);
+#endif
+	/* serial */
+	sunxi_get_serial((u8 *)databuf);
+	for (i = 0; i < 4; i++)
+		sprintf(tmpbuf + i*8, "%08x", databuf[i]);
+	tmpbuf[128] = 0;
+	size += sprintf(buf + size, "sunxi_serial      : %s\n", tmpbuf);
+
+	/* chiptype */
+	sunxi_get_soc_chipid_str(tmpbuf);
+	size += sprintf(buf + size, "sunxi_chiptype    : %s\n", tmpbuf);
+
+	/* socbatch number */
+	size += sprintf(buf + size, "sunxi_batchno     : %#x\n",
+			sunxi_get_soc_ver());
+
+	return size;
+}
+
+static ssize_t key_info_show(struct class *class,
+			     struct class_attribute *attr, char *buf)
+{
+	s32 i;
+	u32 *key_data = NULL;
+	size_t size = 0;
+
+	key_data = vmalloc(256);
+	if (key_data == NULL)
+		return -ENOMEM;
+
+	memset(key_data, 0, 256*4);
+	sunxi_efuse_readn(key_name, key_data, 256);
+	for (i = 0; i < 256; i++) {
+		if ((i > 0) && (key_data[i] == 0))
+			break;
+		if ((i > 0) && (i % 8 == 0))
+			size += sprintf(buf + size, "\n");
+
+		size += sprintf(buf + size, "%08x ", key_data[i]);
+	}
+	size += sprintf(buf + size, "\n");
+
+	vfree(key_data);
+	return size;
+}
+
+static ssize_t key_info_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	if (count >= SUNXI_KEY_NAME_LEN)
+		return -EINVAL;
+
+	memset(key_name, 0, SUNXI_KEY_NAME_LEN);
+	strncpy(key_name, buf, count);
+	return count;
+}
+
+static struct class_attribute info_class_attrs[] = {
+	__ATTR(sys_info, 0644, sys_info_show, NULL),
+	__ATTR(key_info, 0644, key_info_show, key_info_store),
+};
+
+static struct class info_class = {
+	.name           = "sunxi_info",
+	.owner          = THIS_MODULE,
+};
+
+static int __init sunxi_sys_info_init(void)
+{
+	s32 ret = 0, i;
+
+	ret = class_register(&info_class);
+	if (ret != 0)
+		return ret;
+	/* need some class specific sysfs attributes */
+	for (i = 0; i < ARRAY_SIZE(info_class_attrs); i++) {
+		ret = class_create_file(&info_class, &info_class_attrs[i]);
+		if (ret)
+			goto out_class_create_file_failed;
+	}
+
+	ret = misc_register(&soc_info_device);
+	if (ret != 0) {
+		pr_err("%s: misc_register() failed!(%d)\n", __func__, ret);
+		class_unregister(&info_class);
+		return ret;
+	}
+	return ret;
+out_class_create_file_failed:
+	class_unregister(&info_class);
+		return ret;
+}
+
+static void __exit sunxi_sys_info_exit(void)
+{
+	misc_deregister(&soc_info_device);
+	class_unregister(&info_class);
+}
+
+module_init(sunxi_sys_info_init);
+module_exit(sunxi_sys_info_exit);
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("xiafeng<xiafeng@allwinnertech.com>");
+MODULE_DESCRIPTION("sunxi sys info.");
diff --git a/drivers/char/sunxi_g2d/Kconfig b/drivers/char/sunxi_g2d/Kconfig
new file mode 100644
index 000000000..fa8a47231
--- /dev/null
+++ b/drivers/char/sunxi_g2d/Kconfig
@@ -0,0 +1,29 @@
+
+config SUNXI_G2D
+	depends on (ARCH_SUNXI)
+	tristate "SUNXI G2D Driver"
+	default n
+	help
+	  Enable sunxi platform 2D Graphics engine
+
+config SUNXI_G2D_MIXER
+	depends on (SUNXI_G2D)
+	bool "sunxi g2d mixer module"
+	default n
+	help
+	  Choose Y to enable mixer module of g2d
+
+config SUNXI_G2D_ROTATE
+	depends on (SUNXI_G2D)
+	bool "sunxi g2d rotate module"
+	default n
+	help
+	  Choose Y to enable rotate module of g2d
+
+config SUNXI_SYNCFENCE
+	depends on (SUNXI_G2D)
+	bool "sunxi sync fence implement for rotate jobs synchronous"
+	default n
+	help
+	  Choose Y to enable sync fence implement for sunxi G2D
+
diff --git a/drivers/char/sunxi_g2d/Makefile b/drivers/char/sunxi_g2d/Makefile
new file mode 100644
index 000000000..a958a6da8
--- /dev/null
+++ b/drivers/char/sunxi_g2d/Makefile
@@ -0,0 +1,20 @@
+#
+# Makefile for the kernel mixer device drivers.
+#
+
+include ${obj}/g2d_rcq/Makefile
+
+obj-$(CONFIG_SUNXI_G2D) += g2d_sunxi.o
+g2d_sunxi-${CONFIG_ARCH_SUN8IW12P1} += g2d_driver.o g2d_bsp_v2.o
+g2d_sunxi-${CONFIG_ARCH_SUN8IW17P1} += g2d_driver.o g2d_bsp_v2.o
+g2d_sunxi-${CONFIG_ARCH_SUN8IW11P1} += g2d_driver.o g2d_bsp_sun8iw11.o
+g2d_sunxi-${CONFIG_ARCH_SUN8IW15P1} += g2d_driver.o g2d_bsp_v2.o
+g2d_sunxi-${CONFIG_ARCH_SUN8IW16P1} += g2d_driver.o g2d_bsp_v2.o
+g2d_sunxi-${CONFIG_ARCH_SUN50IW9P1} += g2d_driver.o g2d_bsp_v2.o
+g2d_sunxi-${CONFIG_ARCH_SUN50IW9}   += g2d_driver.o g2d_bsp_v2.o
+g2d_sunxi-${CONFIG_ARCH_SUN50IW10P1} += g2d_driver.o g2d_bsp_v2.o
+
+g2d_sunxi-$(CONFIG_ARCH_SUN8IW19P1) += ${rcq_obj}
+g2d_sunxi-$(CONFIG_SUNXI_SYNCFENCE) += syncfence.o
+g2d_sunxi-$(CONFIG_ARCH_SUN8IW20) += ${rcq_obj}
+g2d_sunxi-$(CONFIG_ARCH_SUN20IW1) += ${rcq_obj}
diff --git a/drivers/char/sunxi_g2d/g2d_bsp.h b/drivers/char/sunxi_g2d/g2d_bsp.h
new file mode 100644
index 000000000..eb20255bc
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_bsp.h
@@ -0,0 +1,146 @@
+/* g2d_bsp.h
+ *
+ * Copyright (c)	2016 Allwinnertech Co., Ltd.
+ *					2016 gqs
+ *
+ * G2D driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __G2D_BSP_H
+#define __G2D_BSP_H
+
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include <asm/uaccess.h>
+#include <asm/memory.h>
+#include <asm/unistd.h>
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_iommu.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/string.h>
+#include <linux/g2d_driver.h>
+#include <linux/dma-buf.h>
+#include <linux/reset.h>
+
+#define G2D_FINISH_IRQ		(1<<8)
+#define G2D_ERROR_IRQ			(1<<9)
+
+extern u32 dbg_info;
+
+#define G2D_INFO_MSG(fmt, args...) \
+	do {\
+		if (dbg_info)\
+		pr_info("[G2D-%s] line:%d: " fmt, __func__, __LINE__, ##args);\
+	} while (0)
+
+typedef struct {
+	unsigned long g2d_base;
+} g2d_init_para;
+
+typedef struct {
+	g2d_init_para init_para;
+} g2d_dev_t;
+
+typedef enum {
+	G2D_RGB2YUV_709,
+	G2D_YUV2RGB_709,
+	G2D_RGB2YUV_601,
+	G2D_YUV2RGB_601,
+	G2D_RGB2YUV_2020,
+	G2D_YUV2RGB_2020,
+} g2d_csc_sel;
+
+typedef enum {
+	VSU_FORMAT_YUV422 = 0x00,
+	VSU_FORMAT_YUV420 = 0x01,
+	VSU_FORMAT_YUV411 = 0x02,
+	VSU_FORMAT_RGB = 0x03,
+	VSU_FORMAT_BUTT = 0x04,
+} vsu_pixel_format;
+
+#define VSU_ZOOM0_SIZE	1
+#define VSU_ZOOM1_SIZE	8
+#define VSU_ZOOM2_SIZE	4
+#define VSU_ZOOM3_SIZE	1
+#define VSU_ZOOM4_SIZE	1
+#define VSU_ZOOM5_SIZE	1
+
+#define VSU_PHASE_NUM            32
+#define VSU_PHASE_FRAC_BITWIDTH  19
+#define VSU_PHASE_FRAC_REG_SHIFT 1
+#define VSU_FB_FRAC_BITWIDTH     32
+
+#define VI_LAYER_NUMBER 1
+#define UI_LAYER_NUMBER 3
+
+__s32 g2d_bsp_open(void);
+__s32 g2d_bsp_close(void);
+__s32 g2d_bsp_reset(void);
+__s32 mixer_irq_query(void);
+__s32 rot_irq_query(void);
+__s32 g2d_mixer_reset(void);
+__s32 g2d_rot_reset(void);
+__s32 g2d_bsp_bld(g2d_image_enh *, g2d_image_enh *, __u32, g2d_ck *);
+__s32 g2d_fillrectangle(g2d_image_enh *dst, __u32 color_value);
+__s32 g2d_bsp_maskblt(g2d_image_enh *src, g2d_image_enh *ptn,
+		      g2d_image_enh *mask, g2d_image_enh *dst,
+		      __u32 back_flag, __u32 fore_flag);
+__s32 g2d_bsp_bitblt(g2d_image_enh *src, g2d_image_enh *dst, __u32 flag);
+__s32 g2d_byte_cal(__u32 format, __u32 *ycnt, __u32 *ucnt, __u32 *vcnt);
+
+extern int g2d_wait_cmd_finish(void);
+
+__u32	mixer_reg_init(void);
+__s32	mixer_blt(g2d_blt *para, enum g2d_scan_order scan_order);
+__s32	mixer_fillrectangle(g2d_fillrect *para);
+__s32	mixer_stretchblt(g2d_stretchblt *para, enum g2d_scan_order scan_order);
+__s32	mixer_maskblt(g2d_maskblt *para);
+__u32	mixer_set_palette(g2d_palette *para);
+__u64	mixer_get_addr(__u32 buffer_addr, __u32 format,
+			__u32 stride, __u32 x, __u32 y);
+__u32	mixer_set_reg_base(unsigned long addr);
+__u32	mixer_get_irq(void);
+__u32	mixer_get_irq0(void);
+__u32	mixer_clear_init(void);
+__u32	mixer_clear_init0(void);
+__s32	mixer_cmdq(__u32 addr);
+__u32	mixer_premultiply_set(__u32 flag);
+__u32	mixer_micro_block_set(g2d_blt *para);
+
+#endif	/* __G2D_BSP_H */
+
diff --git a/drivers/char/sunxi_g2d/g2d_bsp_sun8iw11.c b/drivers/char/sunxi_g2d/g2d_bsp_sun8iw11.c
new file mode 100644
index 000000000..e02b02735
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_bsp_sun8iw11.c
@@ -0,0 +1,1907 @@
+/* g2d_bsp.c
+ *
+ * Copyright (c)	2011 Allwinnertech Co., Ltd.
+ *					2011 Yupu Tang
+ *
+ * G2D driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ */
+
+#include "g2d_regs.h"
+#include "g2d_bsp.h"
+
+static unsigned long base_addr;
+
+ /* byte input */
+#define read_bvalue(offset)			get_bvalue(base_addr + offset)
+/* byte output */
+#define write_bvalue(offset, value)	put_bvalue(base_addr + offset, value)
+/* half word input */
+#define read_hvalue(offset)			get_hvalue(base_addr + offset)
+/* half word output */
+#define write_hvalue(offset, value)	put_hvalue(base_addr + offset, value)
+/* word input */
+#define read_wvalue(offset)			get_wvalue(base_addr + offset)
+/* word output */
+#define write_wvalue(offset, value)	put_wvalue(base_addr + offset, value)
+
+__s32 csc0coeff[12] = {
+
+	0x4a7, 0x1e6f, 0x1cbf, 0x877,
+	0x4a7, 0x00,  0x662,	0x3211,
+	0x4a7, 0x812, 0x00,	0x2eb1
+};
+__s32 csc1coeff[12] = {
+
+	0x4a7, 0x1e6f, 0x1cbf, 0x877,
+	0x4a7, 0x00,  0x662,	0x3211,
+	0x4a7, 0x812, 0x00,	0x2eb1
+};
+
+__s32 csc2coeff[12] = {
+
+	0x204, 0x107, 0x64, 0x100,		/* YG,YR,YB,YC */
+	0x1ED6, 0x1F69, 0x1C1, 0x800,	/* UG,UR,UB,UC */
+	0x1E87, 0x1C1, 0x1FB8, 0x800,	/* VG,VR,VB,VC */
+};
+
+__s32 csc2coeff_VUVU[12] = {
+
+	0x204, 0x107, 0x64, 0x100,		/* YG,YR,YB,YC */
+	0x1E87, 0x1C1, 0x1FB8, 0x800,	/* VG,VR,VB,VC */
+	0x1ED6, 0x1F69, 0x1C1, 0x800,	/* UG,UR,UB,UC */
+};
+
+__s32 scalercoeff[64] = {
+
+	/* Horizontal Filtering Coefficient(0x200-0x27c) */
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc,
+	0xff083dfc, 0x000a3bfb, 0xff0d39fb, 0xff0f37fb, 0xff1136fa,
+	0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb,
+	0xfc2127fc, 0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd,
+	0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,	0xfb370fff,
+	0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400,
+	0xfe3f0300, 0xff400100,
+
+	/* Vertical Filtering Coefficient(0x280-0x2fc) */
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc,
+	0xff083dfc, 0x000a3bfb, 0xff0d39fb, 0xff0f37fb, 0xff1136fa,
+	0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb,
+	0xfc2127fc, 0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd,
+	0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff, 0xfb370fff,
+	0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400,
+	0xfe3f0300, 0xff400100,
+};
+
+/* Set the Color Space Converter Coefficient Parameter */
+void csc_coeff_set(void)
+{
+	__u32 i, j;
+
+	/* 0x180-0x1ac */
+	for (i = 0, j = 0; i < 12; i++, j += 4)
+		write_wvalue(G2D_CSC01_ADDR_REG + j,
+			     (((csc1coeff[i] & 0xFFFF) << 16) |
+			      (csc0coeff[i] & 0xFFFF)));
+
+	/* 0x1c0-0x1ec */
+	for (i = 0, j = 0; i < 12; i++, j += 4)
+		write_wvalue(G2D_CSC2_ADDR_REG + j, csc2coeff[i]&0xFFFF);
+
+}
+
+/* Set the Scaling Horizontal/Vertical Filtering Coefficient Parameter */
+void scaler_coeff_set(void)
+{
+	__u32 i, j;
+
+	/* 0x200-0x2fc */
+	for (i = 0, j = 0; i < 64; i++, j += 4)
+		write_wvalue(G2D_SCALER_HFILTER_REG + j, scalercoeff[i]);
+
+}
+
+__u32 mixer_set_reg_base(unsigned long addr)
+{
+	base_addr = addr;
+	return 0;
+}
+
+/* clear most of the registers value to default */
+__u32 mixer_reg_init(void)
+{
+	__u32 i;
+
+	for (i = 0; i <= 0x148; i += 4)
+		write_wvalue(i, 0);
+	write_wvalue(G2D_SCAN_ORDER_REG, 0x15FF0000);
+
+	/* initial the color space converter parameter */
+	csc_coeff_set();
+
+	/* initial the scaler coefficient parameter */
+	scaler_coeff_set();
+
+	return 0;
+}
+
+__u32 mixer_set_fillcolor(__u32 color, __u32 sel)
+{
+	__u32 value;
+
+	if (sel == 1) {
+		value = read_wvalue(G2D_DMA1_CONTROL_REG) | G2D_FILL_ENABLE;
+		write_wvalue(G2D_DMA1_CONTROL_REG, value);
+		write_wvalue(G2D_DMA1_FILLCOLOR_REG, color);
+	} else if (sel == 2) {
+		value = read_wvalue(G2D_DMA2_CONTROL_REG) | G2D_FILL_ENABLE;
+		write_wvalue(G2D_DMA2_CONTROL_REG, value);
+		write_wvalue(G2D_DMA2_FILLCOLOR_REG, color);
+	} else if (sel == 3) {
+		value = read_wvalue(G2D_DMA3_CONTROL_REG) | G2D_FILL_ENABLE;
+		write_wvalue(G2D_DMA3_CONTROL_REG, value);
+		write_wvalue(G2D_DMA3_FILLCOLOR_REG, color);
+	} else {
+		value = read_wvalue(G2D_DMA0_CONTROL_REG) | G2D_FILL_ENABLE;
+		write_wvalue(G2D_DMA0_CONTROL_REG, value);
+		write_wvalue(G2D_DMA0_FILLCOLOR_REG, color);
+	}
+
+	return 0;
+}
+
+__u32 mixer_bpp_count(__u32 format)
+{
+	__u32 bpp = 32;
+
+	switch (format) {
+	case G2D_FMT_1BPP_MONO:
+	case G2D_FMT_1BPP_PALETTE:
+		bpp = 1;
+		break;
+
+	case G2D_FMT_2BPP_MONO:
+	case G2D_FMT_2BPP_PALETTE:
+		bpp = 2;
+		break;
+
+	case G2D_FMT_4BPP_MONO:
+	case G2D_FMT_4BPP_PALETTE:
+		bpp = 4;
+		break;
+
+	case G2D_FMT_8BPP_MONO:
+	case G2D_FMT_8BPP_PALETTE:
+	case G2D_FMT_PYUV422UVC:
+	case G2D_FMT_PYUV420UVC:
+	case G2D_FMT_PYUV411UVC:
+	case G2D_FMT_PYUV422:
+	case G2D_FMT_PYUV420:
+	case G2D_FMT_PYUV411:
+	case G2D_FMT_PYUV422UVC_MB16:
+	case G2D_FMT_PYUV420UVC_MB16:
+	case G2D_FMT_PYUV411UVC_MB16:
+	case G2D_FMT_PYUV422UVC_MB32:
+	case G2D_FMT_PYUV420UVC_MB32:
+	case G2D_FMT_PYUV411UVC_MB32:
+	case G2D_FMT_PYUV422UVC_MB64:
+	case G2D_FMT_PYUV420UVC_MB64:
+	case G2D_FMT_PYUV411UVC_MB64:
+	case G2D_FMT_PYUV422UVC_MB128:
+	case G2D_FMT_PYUV420UVC_MB128:
+	case G2D_FMT_PYUV411UVC_MB128:
+		bpp = 8;
+		break;
+
+	case G2D_FMT_IYUV422:
+	case G2D_FMT_RGB565:
+	case G2D_FMT_BGR565:
+	case G2D_FMT_ARGB1555:
+	case G2D_FMT_ABGR1555:
+	case G2D_FMT_RGBA5551:
+	case G2D_FMT_BGRA5551:
+	case G2D_FMT_ARGB4444:
+	case G2D_FMT_ABGR4444:
+	case G2D_FMT_RGBA4444:
+	case G2D_FMT_BGRA4444:
+		bpp = 16;
+		break;
+
+	case G2D_FMT_ARGB_AYUV8888:
+	case G2D_FMT_BGRA_VUYA8888:
+	case G2D_FMT_ABGR_AVUY8888:
+	case G2D_FMT_RGBA_YUVA8888:
+	case G2D_FMT_XRGB8888:
+	case G2D_FMT_BGRX8888:
+	case G2D_FMT_XBGR8888:
+	case G2D_FMT_RGBX8888:
+		bpp = 32;
+		break;
+
+	default:
+		bpp = 32;
+		break;
+	}
+	return bpp;
+
+}
+
+__u32 mixer_in_fmtseq_set(__u32 format, __u32 pixel_seq)
+{
+	__u32 val = 32;
+
+	switch (format) {
+	case G2D_FMT_1BPP_MONO:
+	case G2D_FMT_1BPP_PALETTE:
+		if (pixel_seq == G2D_SEQ_1BPP_LITTER_LITTER)
+			val = 0x3A;
+		else if (pixel_seq == G2D_SEQ_1BPP_BIG_LITTER)
+			val = 0x1A;
+		else if (pixel_seq == G2D_SEQ_1BPP_LITTER_BIG)
+			val = 0x2A;
+		else
+			val = 0xA;
+		break;
+
+	case G2D_FMT_2BPP_MONO:
+	case G2D_FMT_2BPP_PALETTE:
+		if (pixel_seq == G2D_SEQ_2BPP_LITTER_LITTER)
+			val = 0x39;
+		else if (pixel_seq == G2D_SEQ_2BPP_BIG_LITTER)
+			val = 0x19;
+		else if (pixel_seq == G2D_SEQ_2BPP_LITTER_BIG)
+			val = 0x29;
+		else
+			val = 0x9;
+		break;
+
+	case G2D_FMT_4BPP_MONO:
+	case G2D_FMT_4BPP_PALETTE:
+		if (pixel_seq == G2D_SEQ_P01234567)
+			val = 0x38;
+		else if (pixel_seq == G2D_SEQ_P67452301)
+			val = 0x18;
+		else if (pixel_seq == G2D_SEQ_P10325476)
+			val = 0x28;
+		else
+			val = 0x8;
+		break;
+
+	case G2D_FMT_8BPP_MONO:
+	case G2D_FMT_8BPP_PALETTE:
+		if (pixel_seq == G2D_SEQ_P0123)
+			val = 0x17;
+		else
+			val = 0x7;
+		break;
+
+	case G2D_FMT_PYUV422UVC:
+	case G2D_FMT_PYUV420UVC:
+	case G2D_FMT_PYUV411UVC:
+	case G2D_FMT_PYUV422UVC_MB16:
+	case G2D_FMT_PYUV420UVC_MB16:
+	case G2D_FMT_PYUV411UVC_MB16:
+	case G2D_FMT_PYUV422UVC_MB32:
+	case G2D_FMT_PYUV420UVC_MB32:
+	case G2D_FMT_PYUV411UVC_MB32:
+	case G2D_FMT_PYUV422UVC_MB64:
+	case G2D_FMT_PYUV420UVC_MB64:
+	case G2D_FMT_PYUV411UVC_MB64:
+	case G2D_FMT_PYUV422UVC_MB128:
+	case G2D_FMT_PYUV420UVC_MB128:
+	case G2D_FMT_PYUV411UVC_MB128:
+		val = 0x6;
+		break;
+
+	case G2D_FMT_IYUV422:
+		if (pixel_seq == G2D_SEQ_YVYU)
+			val = 0x14;
+		else
+			val = 0x4;
+		break;
+	case G2D_FMT_RGB565:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x13;
+		else
+			val = 0x3;
+		break;
+	case G2D_FMT_BGR565:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x93;
+		else
+			val = 0x83;
+		break;
+	case G2D_FMT_ARGB1555:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x12;
+		else
+			val = 0x2;
+		break;
+	case G2D_FMT_ABGR1555:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x92;
+		else
+			val = 0x82;
+		break;
+	case G2D_FMT_RGBA5551:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0xb2;
+		else
+			val = 0xa2;
+		break;
+	case G2D_FMT_BGRA5551:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x32;
+		else
+			val = 0x22;
+		break;
+	case G2D_FMT_ARGB4444:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x11;
+		else
+			val = 0x01;
+		break;
+	case G2D_FMT_ABGR4444:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x91;
+		else
+			val = 0x81;
+		break;
+	case G2D_FMT_RGBA4444:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0xb1;
+		else
+			val = 0xa1;
+		break;
+	case G2D_FMT_BGRA4444:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x31;
+		else
+			val = 0x21;
+		break;
+	case G2D_FMT_ARGB_AYUV8888:
+	case G2D_FMT_XRGB8888:
+		val = 0x0;
+		break;
+	case G2D_FMT_BGRA_VUYA8888:
+	case G2D_FMT_BGRX8888:
+		val = 0x20;
+		break;
+	case G2D_FMT_ABGR_AVUY8888:
+	case G2D_FMT_XBGR8888:
+		val = 0x80;
+		break;
+	case G2D_FMT_RGBA_YUVA8888:
+	case G2D_FMT_RGBX8888:
+		val = 0xa0;
+		break;
+
+	default:
+		val = 0;
+		break;
+	}
+	return val << 8;
+
+}
+
+__u32 mixer_in_csc_set(__u32 format)
+{
+	__u32 val = 0;
+
+	switch (format) {
+	case G2D_FMT_IYUV422:
+		val = 0x11;
+		break;
+	case G2D_FMT_PYUV422UVC:
+	case G2D_FMT_PYUV422UVC_MB16:
+	case G2D_FMT_PYUV422UVC_MB32:
+	case G2D_FMT_PYUV422UVC_MB64:
+	case G2D_FMT_PYUV422UVC_MB128:
+		val = 0x21;
+		break;
+	case G2D_FMT_PYUV420UVC:
+	case G2D_FMT_PYUV420UVC_MB16:
+	case G2D_FMT_PYUV420UVC_MB32:
+	case G2D_FMT_PYUV420UVC_MB64:
+	case G2D_FMT_PYUV420UVC_MB128:
+		val = 0x31;
+		break;
+	case G2D_FMT_PYUV411UVC:
+	case G2D_FMT_PYUV411UVC_MB16:
+	case G2D_FMT_PYUV411UVC_MB32:
+	case G2D_FMT_PYUV411UVC_MB64:
+	case G2D_FMT_PYUV411UVC_MB128:
+		val = 0x41;
+		break;
+
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+__u32 mixer_out_fmtseq_set(__u32 format, __u32 pixel_seq)
+{
+	__u32 val = 0;
+
+	switch (format) {
+	case G2D_FMT_1BPP_MONO:
+		if (pixel_seq == G2D_SEQ_1BPP_LITTER_LITTER)
+			val = 0x38A;
+		else if (pixel_seq == G2D_SEQ_1BPP_BIG_LITTER)
+			val = 0x18A;
+		else if (pixel_seq == G2D_SEQ_1BPP_LITTER_BIG)
+			val = 0x28A;
+		else
+			val = 0x8A;
+		break;
+
+	case G2D_FMT_2BPP_MONO:
+		if (pixel_seq == G2D_SEQ_2BPP_LITTER_LITTER)
+			val = 0x389;
+		else if (pixel_seq == G2D_SEQ_2BPP_BIG_LITTER)
+			val = 0x189;
+		else if (pixel_seq == G2D_SEQ_2BPP_LITTER_BIG)
+			val = 0x289;
+		else
+			val = 0x89;
+		break;
+
+	case G2D_FMT_4BPP_MONO:
+		if (pixel_seq == G2D_SEQ_P01234567)
+			val = 0x388;
+		else if (pixel_seq == G2D_SEQ_P67452301)
+			val = 0x188;
+		else if (pixel_seq == G2D_SEQ_P10325476)
+			val = 0x288;
+		else
+			val = 0x88;
+		break;
+
+	case G2D_FMT_8BPP_MONO:
+		if (pixel_seq == G2D_SEQ_P0123)
+			val = 0x187;
+		else
+			val = 0x87;
+		break;
+	case G2D_FMT_PYUV422:
+		val = 0x86;
+		break;
+	case G2D_FMT_PYUV422UVC:
+		val = 0x85;
+		break;
+	case G2D_FMT_PYUV420UVC:
+		val = 0x8b;
+		break;
+	case G2D_FMT_PYUV420:
+		val = 0x8c;
+		break;
+	case G2D_FMT_PYUV411UVC:
+		val = 0x8d;
+		break;
+	case G2D_FMT_PYUV411:
+		val = 0x8e;
+		break;
+	case G2D_FMT_IYUV422:
+		if (pixel_seq == G2D_SEQ_YVYU)
+			val = 0x184;
+		else
+			val = 0x84;
+		break;
+	case G2D_FMT_RGB565:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x183;
+		else
+			val = 0x3;
+		break;
+	case G2D_FMT_BGR565:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x983;
+		else
+			val = 0x883;
+		break;
+	case G2D_FMT_ARGB1555:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x182;
+		else
+			val = 0x82;
+		break;
+	case G2D_FMT_ABGR1555:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x982;
+		else
+			val = 0x882;
+		break;
+	case G2D_FMT_RGBA5551:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0xb82;
+		else
+			val = 0xa82;
+		break;
+	case G2D_FMT_BGRA5551:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x382;
+		else
+			val = 0x282;
+		break;
+	case G2D_FMT_ARGB4444:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x181;
+		else
+			val = 0x81;
+		break;
+	case G2D_FMT_ABGR4444:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x981;
+		else
+			val = 0x881;
+		break;
+	case G2D_FMT_RGBA4444:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0xb81;
+		else
+			val = 0xa81;
+		break;
+	case G2D_FMT_BGRA4444:
+		if (pixel_seq == G2D_SEQ_P01)
+			val = 0x381;
+		else
+			val = 0x281;
+		break;
+	case G2D_FMT_ARGB_AYUV8888:
+	case G2D_FMT_XRGB8888:
+		val = 0x80;
+		break;
+	case G2D_FMT_BGRA_VUYA8888:
+	case G2D_FMT_BGRX8888:
+		val = 0x280;
+		break;
+	case G2D_FMT_ABGR_AVUY8888:
+	case G2D_FMT_XBGR8888:
+		val = 0x880;
+		break;
+	case G2D_FMT_RGBA_YUVA8888:
+	case G2D_FMT_RGBX8888:
+		val = 0xa80;
+		break;
+
+	default:
+		val = 80;
+		break;
+	}
+	return val;
+
+}
+
+__u64 mixer_get_addr(__u32 buffer_addr, __u32 format, __u32 stride,
+			__u32 x, __u32 y)
+{
+	__u32	bpp = 0;
+	__u64	addr = 0;
+
+	bpp = mixer_bpp_count(format);
+	addr = (__u64) (buffer_addr) * 8 +
+			(__u64) ((stride * y + x) * bpp);	/* bits */
+
+	return addr;
+}
+
+__u32 mixer_get_irq(void)
+{
+	__u32 reg_val = 0;
+
+	reg_val = read_wvalue(G2D_STATUS_REG);
+
+	return reg_val;
+}
+
+__u32 mixer_get_irq0(void)
+{
+	__u32 reg_val = 0;
+
+	reg_val = read_wvalue(G2D_CMDQ_STS_REG);
+
+	return reg_val;
+}
+
+__u32 mixer_clear_init(void)
+{
+
+	write_wvalue(G2D_STATUS_REG, 0x300);
+	write_wvalue(G2D_CONTROL_REG, 0x0);
+
+	return 0;
+}
+
+__u32 mixer_clear_init0(void)
+{
+
+	write_wvalue(G2D_CMDQ_STS_REG, 0x100);
+	write_wvalue(G2D_CMDQ_CTL_REG, 0x0);
+
+	return 0;
+}
+
+__u32 mixer_set_rotate_reg(__u32 flag)
+{
+	__u32 rot = 0;
+
+	if (flag & G2D_BLT_FLIP_HORIZONTAL)
+		rot = 0x10;
+	else if (flag & G2D_BLT_FLIP_VERTICAL)
+		rot = 0x20;
+	else if (flag & G2D_BLT_ROTATE90)
+		rot = 0x50;
+	else if (flag & G2D_BLT_ROTATE180)
+		rot = 0x30;
+	else if (flag & G2D_BLT_ROTATE270)
+		rot = 0x60;
+	else if (flag & G2D_BLT_MIRROR45)
+		rot = 0x70;
+	else if (flag & G2D_BLT_MIRROR135)
+		rot = 0x40;
+	else
+		rot = 0;
+
+	return rot;
+}
+
+__s32 mixer_fillrectangle(g2d_fillrect *para)
+{
+	__u32 reg_val = 0;
+	__u64 addr_val;
+	__s32 result = 0;
+
+	mixer_reg_init();/* initial mixer register */
+
+	/* channel0 is the fill surface */
+	write_wvalue(G2D_DMA0_SIZE_REG,
+		     (para->dst_rect.w - 1) | ((para->dst_rect.h - 1) << 16));
+
+	/* globe alpha mode */
+	if (para->flag & G2D_FIL_PLANE_ALPHA)
+		reg_val |= (para->alpha << 24) | 0x4;
+	else if (para->flag & G2D_FIL_MULTI_ALPHA)
+		reg_val |= (para->alpha << 24) | 0x8;
+	reg_val |= 0x1;
+	write_wvalue(G2D_DMA0_CONTROL_REG, reg_val);
+	mixer_set_fillcolor(para->color, 0);
+	if ((para->flag & G2D_FIL_PLANE_ALPHA)
+	    || (para->flag & G2D_FIL_PIXEL_ALPHA)
+	    || (para->flag & G2D_FIL_MULTI_ALPHA)) {
+		/* channel3 is the dst surface */
+		addr_val =
+		    mixer_get_addr(para->dst_image.addr[0],
+				   para->dst_image.format, para->dst_image.w,
+				   para->dst_rect.x, para->dst_rect.y);
+		reg_val = (addr_val >> 32) & 0xF;	/* high addr in bits */
+		write_wvalue(G2D_DMA_HADDR_REG, reg_val << 24);
+		reg_val = addr_val & 0xFFFFFFFF;	/* low addr in bits */
+		write_wvalue(G2D_DMA3_LADDR_REG, reg_val);
+		write_wvalue(G2D_DMA3_STRIDE_REG,
+			     para->dst_image.w *
+			     mixer_bpp_count(para->dst_image.format));
+		write_wvalue(G2D_DMA3_SIZE_REG,
+			     (para->dst_rect.w -
+			      1) | ((para->dst_rect.h - 1) << 16));
+		reg_val = read_wvalue(G2D_DMA3_CONTROL_REG);
+
+		/* palette format */
+		if (para->dst_image.format > 0x19)
+			reg_val |= 0x2;
+		reg_val |=
+		    G2D_IDMA_ENABLE | mixer_in_fmtseq_set(para->dst_image.
+							  format,
+							  para->dst_image.
+							  pixel_seq);
+		write_wvalue(G2D_DMA3_CONTROL_REG, reg_val);
+		write_wvalue(G2D_CK_CONTROL_REG, 0x1);
+	}
+	write_wvalue(G2D_ROP_INDEX0_REG, 0x840);
+
+	/* output surface is the dst surface */
+	write_wvalue(G2D_OUTPUT_SIZE_REG,
+		     (para->dst_rect.w - 1) | ((para->dst_rect.h - 1) << 16));
+
+	addr_val =
+	    mixer_get_addr(para->dst_image.addr[0], para->dst_image.format,
+			   para->dst_image.w, para->dst_rect.x,
+			   para->dst_rect.y);
+	reg_val = (addr_val >> 32) & 0xF;	/* high addr in bits */
+	write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+	reg_val = addr_val & 0xFFFFFFFF;	/* low addr in bits */
+	write_wvalue(G2D_OUTPUT0_LADDR_REG, reg_val);
+
+	write_wvalue(G2D_OUTPUT0_STRIDE_REG,
+		     para->dst_image.w *
+		     mixer_bpp_count(para->dst_image.format));
+	write_wvalue(G2D_OUTPUT_CONTROL_REG,
+		     mixer_out_fmtseq_set(para->dst_image.format,
+					  para->dst_image.pixel_seq));
+
+	/* start */
+	write_wvalue(G2D_CONTROL_REG, 0);
+	write_wvalue(G2D_CONTROL_REG, 0x303);
+	result = g2d_wait_cmd_finish();
+
+	return result;
+}
+
+__s32 mixer_blt(g2d_blt *para, enum g2d_scan_order scan_order)
+{
+	__u32 bppnum = 0;
+	__u32 reg_val = 0;
+	__u64 addr_val;
+	__s32 result = 0;
+	__u32 i, j;
+
+	mixer_reg_init();	/* initial mixer register */
+	if ((para->dst_image.format > 0x16) && (para->dst_image.format < 0x1A)
+	    && (para->dst_image.pixel_seq == G2D_SEQ_VUVU)) {
+		for (i = 0, j = 0; i < 12; i++, j += 4)
+			write_wvalue(G2D_CSC2_ADDR_REG + j,
+					csc2coeff_VUVU[i] & 0xFFFF);
+						/* 0x1c0-0x1ec */
+	}
+
+	/* src surface */
+	addr_val =
+	    mixer_get_addr(para->src_image.addr[0], para->src_image.format,
+			   para->src_image.w, para->src_rect.x,
+			   para->src_rect.y);
+	reg_val = (addr_val >> 32) & 0xF;	/* high addr in bits */
+	write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+	reg_val = addr_val & 0xFFFFFFFF;	/* low addr in bits */
+	write_wvalue(G2D_DMA0_LADDR_REG, reg_val);
+	write_wvalue(G2D_DMA0_STRIDE_REG,
+		     para->src_image.w *
+		     mixer_bpp_count(para->src_image.format));
+	write_wvalue(G2D_DMA0_SIZE_REG,
+		     (para->src_rect.w - 1) | ((para->src_rect.h - 1) << 16));
+	reg_val = read_wvalue(G2D_DMA0_CONTROL_REG);
+	reg_val |=
+	    mixer_in_fmtseq_set(para->src_image.format,
+				para->src_image.pixel_seq) | G2D_IDMA_ENABLE;
+
+	/* rgbx/bgrx/xrgb/xbgr format */
+	if ((para->src_image.format > 0x03) && (para->src_image.format < 0x08))
+		reg_val |= (0xFF << 24) | 0x4;
+
+	/* palette format */
+	if ((para->src_image.format > 0x1C) && (para->src_image.format < 0x21))
+		reg_val |= 0x2;
+
+	/* globe alpha mode */
+	if (para->flag & G2D_BLT_PLANE_ALPHA)
+		reg_val |= (para->alpha << 24) | 0x4;
+	else if (para->flag & G2D_BLT_MULTI_ALPHA)
+		reg_val |= (para->alpha << 24) | 0x8;
+
+	/* rotate/mirror */
+	reg_val |= mixer_set_rotate_reg(para->flag);
+	write_wvalue(G2D_DMA0_CONTROL_REG, reg_val);
+	reg_val = mixer_in_csc_set(para->src_image.format);
+	write_wvalue(G2D_CSC0_CONTROL_REG, reg_val);
+	reg_val = mixer_in_csc_set(para->dst_image.format);
+	write_wvalue(G2D_CSC1_CONTROL_REG, reg_val);
+
+	/* pyuv422/420/411uvc */
+	if ((para->src_image.format > 0x16) &&
+			(para->src_image.format < 0x1A)) {
+		if (para->src_image.format == G2D_FMT_PYUV411UVC)
+			bppnum = 4;
+		else
+			bppnum = 8;
+		if (para->src_image.format == G2D_FMT_PYUV420UVC)
+			addr_val =
+			    (__u64) para->src_image.addr[1] * 8 +
+			    (__u64) ((para->src_image.w *
+				      (para->src_rect.y / 2) +
+				      para->src_rect.x) * bppnum);
+		else
+			addr_val =
+			    (__u64) para->src_image.addr[1] * 8 +
+			    (__u64) ((para->src_image.w * para->src_rect.y +
+				      para->src_rect.x) * bppnum);
+		reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+		reg_val |= ((addr_val >> 32) & 0xF) << 8;/* high addr in bits */
+		write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+		reg_val = addr_val & 0xFFFFFFFF;	/* low addr in bits */
+		write_wvalue(G2D_DMA1_LADDR_REG, reg_val);
+		write_wvalue(G2D_DMA1_STRIDE_REG, para->src_image.w * bppnum);
+		write_wvalue(G2D_DMA1_SIZE_REG,
+			     (para->src_rect.w -
+			      1) | ((para->src_rect.h - 1) << 16));
+		reg_val = read_wvalue(G2D_DMA1_CONTROL_REG);
+		reg_val |= (5 << 8) | G2D_IDMA_ENABLE;
+
+		/* rotate/mirror */
+		reg_val |= mixer_set_rotate_reg(para->flag);
+		write_wvalue(G2D_DMA1_CONTROL_REG, reg_val);
+	}
+	mixer_micro_block_set(para);
+	write_wvalue(G2D_DMA1_FILLCOLOR_REG, 0xFFFFFFFF);
+	write_wvalue(G2D_DMA2_FILLCOLOR_REG, 0xFFFFFFFF);
+
+	if ((para->flag & G2D_BLT_PIXEL_ALPHA)
+	    || (para->flag & G2D_BLT_PLANE_ALPHA)
+	    || (para->flag & G2D_BLT_MULTI_ALPHA)
+	    || (para->flag & G2D_BLT_SRC_COLORKEY)
+	    || (para->flag & G2D_BLT_DST_COLORKEY)) {
+		/* pyuv422/420/411uvc */
+		if ((para->dst_image.format > 0x16)
+		    && (para->dst_image.format < 0x1A)) {
+			if (para->dst_image.format == G2D_FMT_PYUV411UVC)
+				bppnum = 4;
+			else
+				bppnum = 8;
+			if (para->dst_image.format == G2D_FMT_PYUV420UVC)
+				addr_val =
+				    (__u64) para->dst_image.addr[1] * 8 +
+				    (__u64) ((para->dst_image.w *
+					      (para->dst_y / 2) +
+					      para->dst_x) * bppnum);
+			else
+				addr_val =
+				    (__u64) para->dst_image.addr[1] * 8 +
+				    (__u64) ((para->dst_image.w * para->dst_y +
+					      para->dst_x) * bppnum);
+			reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+			/* high addr in bits */
+			reg_val |= ((addr_val >> 32) & 0xF) << 16;
+			write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+			/* low addr in bits */
+			reg_val = addr_val & 0xFFFFFFFF;
+			write_wvalue(G2D_DMA2_LADDR_REG, reg_val);
+			write_wvalue(G2D_DMA2_STRIDE_REG,
+				     para->dst_image.w * bppnum);
+			write_wvalue(G2D_DMA2_SIZE_REG,
+				     (para->src_rect.w -
+				      1) | ((para->src_rect.h - 1) << 16));
+			reg_val = read_wvalue(G2D_DMA2_CONTROL_REG);
+			reg_val |= (5 << 8) | G2D_IDMA_ENABLE;
+			write_wvalue(G2D_DMA2_CONTROL_REG, reg_val);
+		}
+
+		/* channel3 is dst surface */
+		addr_val =
+		    mixer_get_addr(para->dst_image.addr[0],
+				   para->dst_image.format, para->dst_image.w,
+				   para->dst_x, para->dst_y);
+		reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+		reg_val |= ((addr_val >> 32) & 0xF) << 24;/*high addr in bits*/
+		write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+		reg_val = addr_val & 0xFFFFFFFF;	/* low addr in bits */
+		write_wvalue(G2D_DMA3_LADDR_REG, reg_val);
+		write_wvalue(G2D_DMA3_STRIDE_REG,
+			     para->dst_image.w *
+			     mixer_bpp_count(para->dst_image.format));
+		if ((para->flag & G2D_BLT_ROTATE90)
+		    || (para->flag & G2D_BLT_ROTATE270))
+			write_wvalue(G2D_DMA3_SIZE_REG,
+				     (para->src_rect.h -
+				      1) | ((para->src_rect.w - 1) << 16));
+		else
+			write_wvalue(G2D_DMA3_SIZE_REG,
+				     (para->src_rect.w -
+				      1) | ((para->src_rect.h - 1) << 16));
+		reg_val = read_wvalue(G2D_DMA3_CONTROL_REG);
+		reg_val |=
+		    mixer_in_fmtseq_set(para->dst_image.format,
+					para->dst_image.
+					pixel_seq) | G2D_IDMA_ENABLE;
+
+		/* rgbx/bgrx/xrgb/xbgr format */
+		if ((para->dst_image.format > 0x03)
+		    && (para->dst_image.format < 0x08)) {
+			reg_val |= (0xFF << 24) | 0x4;
+		}
+		write_wvalue(G2D_DMA3_CONTROL_REG, reg_val);
+	}
+
+	/* colorkey */
+	if (para->flag & G2D_BLT_SRC_COLORKEY) {
+		reg_val = 0x3;
+	} else if (para->flag & G2D_BLT_DST_COLORKEY) {
+		reg_val = 0x5;
+	} else if ((para->flag & G2D_BLT_PIXEL_ALPHA)
+		   || (para->flag & G2D_BLT_PLANE_ALPHA)
+		   || (para->flag & G2D_BLT_MULTI_ALPHA)) {
+		reg_val = 0x1;
+	} else {
+		reg_val = 0x0;
+	}
+	write_wvalue(G2D_CK_CONTROL_REG, reg_val);
+	write_wvalue(G2D_CK_MINCOLOR_REG, para->color);
+	write_wvalue(G2D_CK_MAXCOLOR_REG, para->color);
+
+	/* output surface is the dst surface */
+	if ((para->flag & G2D_BLT_ROTATE90) ||
+			(para->flag & G2D_BLT_ROTATE270)) {
+		write_wvalue(G2D_OUTPUT_SIZE_REG,
+			     (para->src_rect.h -
+			      1) | ((para->src_rect.w - 1) << 16));
+	} else {
+		write_wvalue(G2D_OUTPUT_SIZE_REG,
+			     (para->src_rect.w -
+			      1) | ((para->src_rect.h - 1) << 16));
+	}
+	addr_val =
+	    mixer_get_addr(para->dst_image.addr[0], para->dst_image.format,
+			   para->dst_image.w, para->dst_x, para->dst_y);
+	reg_val = (addr_val >> 32) & 0xF;	/* high addr in bits */
+	write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+	reg_val = addr_val & 0xFFFFFFFF;	/* low addr in bits */
+	write_wvalue(G2D_OUTPUT0_LADDR_REG, reg_val);
+	write_wvalue(G2D_OUTPUT0_STRIDE_REG,
+		     para->dst_image.w *
+		     mixer_bpp_count(para->dst_image.format));
+	reg_val =
+	    mixer_out_fmtseq_set(para->dst_image.format,
+				 para->dst_image.pixel_seq);
+	write_wvalue(G2D_OUTPUT_CONTROL_REG, reg_val);
+
+	if ((para->dst_image.format > 0x16) &&
+			(para->dst_image.format < 0x1D)) {
+		if ((para->dst_image.format == G2D_FMT_PYUV411UVC)
+		    || (para->dst_image.format == G2D_FMT_PYUV422)
+		    || (para->dst_image.format == G2D_FMT_PYUV420))
+			bppnum = 4;
+		else if (para->dst_image.format == G2D_FMT_PYUV411)
+			bppnum = 2;
+		else
+			bppnum = 8;
+		if ((para->dst_image.format == G2D_FMT_PYUV420UVC)
+		    || (para->dst_image.format == G2D_FMT_PYUV420))
+			addr_val =
+			    (__u64) para->dst_image.addr[1] * 8 +
+			    (__u64) ((para->dst_image.w * (para->dst_y / 2) +
+				      para->dst_x) * bppnum);
+		else
+			addr_val =
+			    (__u64) para->dst_image.addr[1] * 8 +
+			    (__u64) ((para->dst_image.w * para->dst_y +
+				      para->dst_x) * bppnum);
+		reg_val = read_wvalue(G2D_OUTPUT_HADDR_REG);
+		reg_val |= ((addr_val >> 32) & 0xF) << 8;/* high addr in bits */
+		write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+		reg_val = addr_val & 0xFFFFFFFF;	/* low addr in bits */
+		write_wvalue(G2D_OUTPUT1_LADDR_REG, reg_val);
+		write_wvalue(G2D_OUTPUT1_STRIDE_REG,
+			     para->dst_image.w * bppnum);
+		if (para->dst_image.format == G2D_FMT_PYUV420)
+			addr_val =
+			    (__u64) para->dst_image.addr[2] * 8 +
+			    (__u64) ((para->dst_image.w * (para->dst_y / 2) +
+				      para->dst_x) * bppnum);
+		else if ((para->dst_image.format == G2D_FMT_PYUV422)
+			 || (para->dst_image.format == G2D_FMT_PYUV411))
+			addr_val =
+			    (__u64) para->dst_image.addr[2] * 8 +
+			    (__u64) ((para->dst_image.w * para->dst_y +
+				      para->dst_x) * bppnum);
+		else
+			addr_val = 0;
+		reg_val = read_wvalue(G2D_OUTPUT_HADDR_REG);
+		reg_val |= ((addr_val >> 32) & 0xF) << 16;/*high addr in bits*/
+		write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+		reg_val = addr_val & 0xFFFFFFFF;	/* low addr in bits */
+		write_wvalue(G2D_OUTPUT2_LADDR_REG, reg_val);
+		write_wvalue(G2D_OUTPUT2_STRIDE_REG,
+			     para->dst_image.w * bppnum);
+		write_wvalue(G2D_CSC2_CONTROL_REG, 0x1);
+	}
+	if ((para->dst_image.format > 0x11) && (para->dst_image.format < 0x1D))
+		write_wvalue(G2D_CSC2_CONTROL_REG, 0x1);
+	if ((para->flag & G2D_BLT_PIXEL_ALPHA) | (para->
+						  flag & G2D_BLT_PLANE_ALPHA) |
+	    (para->flag & G2D_BLT_MULTI_ALPHA) | (para->
+						  flag & G2D_BLT_SRC_COLORKEY) |
+	    (para->flag & G2D_BLT_DST_COLORKEY))
+		write_wvalue(G2D_OALPHA_CONTROL_REG, 0x80);
+		/* 0x40: A2 area keep the dst alpha,0x80: A2 area keep the
+		 * src+dst(1-src) alpha value
+		 */
+	mixer_premultiply_set(para->flag);
+	/*scan order */
+	write_wvalue(G2D_SCAN_ORDER_REG, (scan_order & 0x3) << 8);
+
+	/* start */
+	write_wvalue(G2D_CONTROL_REG, 0x0);
+	write_wvalue(G2D_CONTROL_REG, 0x303);
+	result = g2d_wait_cmd_finish();
+
+	return result;
+}
+
+__s32 mixer_stretchblt(g2d_stretchblt *para, enum g2d_scan_order scan_order)
+{
+	__u32 bppnum = 0;
+	__u32 reg_val = 0;
+	__u32 reg_tmp = 0;
+	__u64 addr_val;
+	__u32 cnt, sinw, soutw, scaler_inx, scaler_iny, scaler_outx;
+	__u32 scaler_outy, i;
+	__s32 result = 0;
+
+	mixer_reg_init();/* initial mixer register */
+
+	/* src surface */
+	write_wvalue(G2D_DMA0_STRIDE_REG,
+		     para->src_image.w *
+		     mixer_bpp_count(para->src_image.format));
+	reg_val = read_wvalue(G2D_DMA0_CONTROL_REG);
+	reg_val |=
+	    mixer_in_fmtseq_set(para->src_image.format,
+				para->src_image.pixel_seq) | G2D_IDMA_ENABLE;
+
+	/* rgbx/bgrx/xrgb/xbgr format */
+	if ((para->src_image.format > 0x03) &&
+			(para->src_image.format < 0x08)) {
+		reg_val |= (0xFF<<24)|0x4;
+	}
+
+	/* palette format */
+	if (para->src_image.format > 0x1C)
+		reg_val |= 0x2;
+	/* globe alpha mode */
+	if (para->flag & G2D_BLT_PLANE_ALPHA)
+		reg_val |= (para->alpha<<24)|0x4;
+	else if (para->flag & G2D_BLT_MULTI_ALPHA)
+		reg_val |= (para->alpha<<24)|0x8;
+
+	/* rotate/mirror */
+	reg_val |= mixer_set_rotate_reg(para->flag);
+	write_wvalue(G2D_DMA0_CONTROL_REG, reg_val);
+	reg_val = mixer_in_csc_set(para->src_image.format);
+	write_wvalue(G2D_CSC0_CONTROL_REG, reg_val);
+	reg_val = mixer_in_csc_set(para->dst_image.format);
+	write_wvalue(G2D_CSC1_CONTROL_REG, reg_val);
+
+	/* sacler setting */
+	write_wvalue(G2D_SCALER_CONTROL_REG,
+			G2D_SCALER_4TAP4 | G2D_SCALER_ENABLE);
+	write_wvalue(G2D_SCALER_HPHASE_REG, 0);
+	write_wvalue(G2D_SCALER_VPHASE_REG, 0);
+	write_wvalue(G2D_ROP_INDEX0_REG, 0x840);
+
+	/* channel3 is dst surface */
+	write_wvalue(G2D_DMA3_STRIDE_REG,
+		     para->dst_image.w *
+		     mixer_bpp_count(para->dst_image.format));
+	reg_val = read_wvalue(G2D_DMA3_CONTROL_REG);
+	reg_val |=
+	    mixer_in_fmtseq_set(para->dst_image.format,
+				para->dst_image.pixel_seq);
+	if ((para->flag & G2D_BLT_PIXEL_ALPHA)
+	    || (para->flag & G2D_BLT_PLANE_ALPHA)
+	    || (para->flag & G2D_BLT_MULTI_ALPHA)
+	    || (para->flag & G2D_BLT_SRC_COLORKEY)
+	    || (para->flag & G2D_BLT_DST_COLORKEY))
+		reg_val |= G2D_IDMA_ENABLE;
+
+	/* rgbx/bgrx/xrgb/xbgr format */
+	if ((para->src_image.format > 0x03) && (para->src_image.format < 0x08))
+		reg_val |= (0xFF<<24)|0x4;
+	write_wvalue(G2D_DMA3_CONTROL_REG, reg_val);
+
+	/* colorkey */
+	if (para->flag & G2D_BLT_SRC_COLORKEY)
+
+		reg_val = 0x3;
+	else if (para->flag & G2D_BLT_DST_COLORKEY)
+
+		reg_val = 0x5;
+	else if ((para->flag & G2D_BLT_PIXEL_ALPHA)
+		   || (para->flag & G2D_BLT_PLANE_ALPHA)
+		   || (para->flag & G2D_BLT_MULTI_ALPHA))
+		reg_val = 1;
+	else
+		reg_val = 0x0;
+	write_wvalue(G2D_CK_CONTROL_REG, reg_val);
+	write_wvalue(G2D_CK_MINCOLOR_REG, para->color);
+	write_wvalue(G2D_CK_MAXCOLOR_REG, para->color);
+
+	write_wvalue(G2D_OUTPUT0_STRIDE_REG,
+		     para->dst_image.w *
+		     mixer_bpp_count(para->dst_image.format));
+	reg_val =
+	    mixer_out_fmtseq_set(para->dst_image.format,
+				 para->dst_image.pixel_seq);
+	write_wvalue(G2D_OUTPUT_CONTROL_REG, reg_val);
+	if ((para->flag & G2D_BLT_PIXEL_ALPHA) | (para->
+						  flag & G2D_BLT_PLANE_ALPHA) |
+	    (para->flag & G2D_BLT_MULTI_ALPHA) | (para->
+						  flag & G2D_BLT_SRC_COLORKEY) |
+	    (para->flag & G2D_BLT_DST_COLORKEY))
+		write_wvalue(G2D_OALPHA_CONTROL_REG, 0x80);
+		/* 0x40: A2 area keep the dst alpha,0x80: A2 area keep the
+		 * src+dst(1-src) alpha value
+		 */
+	mixer_premultiply_set(para->flag);
+
+	/* output width lager than 1024 pixel width */
+	if (para->dst_rect.w > 0x400) {
+		/* scaler up divide the output into 1024 pixel width part */
+		cnt = para->dst_rect.w / 1024;
+		cnt = (para->dst_rect.w % 1024) ? cnt : cnt - 1;
+		sinw = (para->src_rect.w / para->dst_rect.w) << 10;
+		sinw |=
+		    ((para->src_rect.w % para->dst_rect.w) << 10) /
+		    para->dst_rect.w;
+		if ((para->flag & G2D_BLT_ROTATE90)
+		    || (para->flag & G2D_BLT_ROTATE270)) {
+			sinw = (para->src_rect.h / para->dst_rect.w) << 10;
+			sinw |=
+			    ((para->src_rect.h % para->dst_rect.w) << 10) /
+			    para->dst_rect.w;
+		}
+		scaler_inx = para->src_rect.x;
+		scaler_iny = para->src_rect.y;
+		scaler_outx = para->dst_rect.x;
+		scaler_outy = para->dst_rect.y;
+		for (i = 0; i < cnt; i++) {
+			/* DMA0 */
+			addr_val =
+			    mixer_get_addr(para->src_image.addr[0],
+					   para->src_image.format,
+					   para->src_image.w, scaler_inx,
+					   para->src_rect.y);
+			reg_val = (addr_val >> 32) & 0xF;/* high addr in bits */
+			write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_DMA0_LADDR_REG, reg_val);
+			if (sinw < 1)
+				sinw = 1;
+			write_wvalue(G2D_DMA0_SIZE_REG, (sinw - 1) |
+					((para->src_rect.h - 1)<<16));
+			if ((para->flag & G2D_BLT_ROTATE90) ||
+					(para->flag & G2D_BLT_ROTATE270))
+				write_wvalue(G2D_DMA0_SIZE_REG,
+					(para->src_rect.w - 1) |
+					((sinw - 1)<<16));
+
+			/* DMA1 pyuv422/420/411uvc */
+			if ((para->src_image.format > 0x16) &&
+					(para->src_image.format < 0x1A)) {
+				if (para->src_image.format ==
+							G2D_FMT_PYUV411UVC)
+					bppnum = 4;
+				else
+					bppnum = 8;
+				if (para->src_image.format ==
+							G2D_FMT_PYUV420UVC)
+					addr_val = (__u64)para->src_image.addr[1] * 8 +
+						(__u64)((para->src_image.w *
+						(para->src_rect.y/2) +
+						scaler_inx) * bppnum);
+				else
+					addr_val = (__u64)para->src_image.addr[1] * 8 +
+						(__u64)((para->src_image.w *
+						para->src_rect.y +
+						scaler_inx) * bppnum);
+				reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+				/* high addr in bits */
+				reg_val |= ((addr_val>>32)&0xF)<<8;
+				write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+				/* low addr in bits */
+				reg_val = addr_val&0xFFFFFFFF;
+				write_wvalue(G2D_DMA1_LADDR_REG, reg_val);
+				write_wvalue(G2D_DMA1_STRIDE_REG,
+						para->src_image.w * bppnum);
+				if (sinw < 1)
+					sinw = 1;
+				write_wvalue(G2D_DMA1_SIZE_REG, (sinw - 1) |
+						((para->src_rect.h - 1)<<16));
+				reg_val = read_wvalue(G2D_DMA1_CONTROL_REG);
+				reg_val |= (5 << 8) | G2D_IDMA_ENABLE;
+
+				/* rotate/mirror */
+				reg_val |= mixer_set_rotate_reg(para->flag);
+				write_wvalue(G2D_DMA1_CONTROL_REG, reg_val);
+			}
+
+			/* scaler setting */
+		if ((para->flag & G2D_BLT_ROTATE90) ||
+				(para->flag & G2D_BLT_ROTATE270)) {
+			write_wvalue(G2D_SCALER_SIZE_REG,
+				(para->dst_rect.h - 1) | ((0x400 - 1)<<16));
+			reg_val = (para->src_rect.w/para->dst_rect.h)<<16;
+			reg_tmp = (para->src_rect.w%para->dst_rect.h);
+			reg_val |= (reg_tmp<<16)/para->dst_rect.h;
+			write_wvalue(G2D_SCALER_HFACTOR_REG, reg_val);
+			reg_val = (sinw/0x400)<<16;
+			reg_tmp = (sinw%0x400);
+			reg_val |= (reg_tmp<<16)/0x400;
+			write_wvalue(G2D_SCALER_VFACTOR_REG, reg_val);
+		} else {
+			write_wvalue(G2D_SCALER_SIZE_REG,
+				(0x400 - 1) | ((para->dst_rect.h - 1)<<16));
+			reg_val = (sinw/0x400)<<16;
+			reg_tmp = (sinw%0x400);
+			reg_val |= (reg_tmp<<16)/0x400;
+			write_wvalue(G2D_SCALER_HFACTOR_REG, reg_val);
+
+			reg_val = (para->src_rect.h/para->dst_rect.h)<<16;
+			reg_tmp = (para->src_rect.h%para->dst_rect.h);
+			reg_val |= (reg_tmp<<16)/para->dst_rect.h;
+			write_wvalue(G2D_SCALER_VFACTOR_REG, reg_val);
+		}
+		if ((para->flag & G2D_BLT_PIXEL_ALPHA) ||
+				(para->flag & G2D_BLT_PLANE_ALPHA) ||
+				(para->flag & G2D_BLT_MULTI_ALPHA) ||
+				(para->flag & G2D_BLT_SRC_COLORKEY) ||
+				(para->flag & G2D_BLT_DST_COLORKEY)) {
+			/* DMA2 pyuv422/420/411uvc */
+			if ((para->dst_image.format > 0x16) &&
+					(para->dst_image.format < 0x1A)) {
+				if (para->dst_image.format ==
+						G2D_FMT_PYUV411UVC)
+					bppnum = 4;
+				else
+					bppnum = 8;
+				if (para->dst_image.format ==
+						G2D_FMT_PYUV420UVC)
+					addr_val = (__u64)para->dst_image.addr[1] * 8 +
+						(__u64)((para->dst_image.w *
+						(para->dst_rect.y / 2) +
+						scaler_outx) * bppnum);
+				else
+					addr_val = (__u64)para->dst_image.addr[1] * 8 +
+						(__u64)((para->dst_image.w *
+						para->dst_rect.y +
+						scaler_outx) * bppnum);
+				reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+				/* high addr in bits */
+				reg_val |= ((addr_val>>32)&0xF)<<16;
+				write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+				/* low addr in bits */
+				reg_val = addr_val&0xFFFFFFFF;
+				write_wvalue(G2D_DMA2_LADDR_REG, reg_val);
+				write_wvalue(G2D_DMA2_STRIDE_REG,
+						para->dst_image.w*bppnum);
+				write_wvalue(G2D_DMA2_SIZE_REG, (0x400 - 1) |
+						((para->dst_rect.h - 1)<<16));
+				reg_val = read_wvalue(G2D_DMA2_CONTROL_REG);
+				reg_val |= (5<<8) | G2D_IDMA_ENABLE;
+				write_wvalue(G2D_DMA2_CONTROL_REG, reg_val);
+			}
+
+			/* DMA3 */
+			addr_val = mixer_get_addr(para->dst_image.addr[0],
+					para->dst_image.format,
+					para->dst_image.w, scaler_outx,
+					para->dst_rect.y);
+			reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+			reg_val = reg_val & 0xF0FFFFFF;
+			/* high addr in bits */
+			reg_val |= ((addr_val>>32)&0xF)<<24;
+			write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_DMA3_LADDR_REG, reg_val);
+			write_wvalue(G2D_DMA3_SIZE_REG, (0x400 - 1) |
+					((para->dst_rect.h - 1)<<16));
+		}
+			/* OUT */
+			write_wvalue(G2D_OUTPUT_SIZE_REG, (0x400 - 1) |
+					((para->dst_rect.h - 1)<<16));
+			if ((para->flag & G2D_BLT_ROTATE180))
+				scaler_outx = para->dst_rect.w - 0x400;
+			addr_val = mixer_get_addr(para->dst_image.addr[0],
+					para->dst_image.format,
+					para->dst_image.w, scaler_outx,
+					scaler_outy);
+			if ((para->flag & G2D_BLT_ROTATE270))
+			addr_val = mixer_get_addr(para->dst_image.addr[0],
+					para->dst_image.format,
+					para->dst_image.w,
+					scaler_outx-0x400,
+					scaler_outy);
+			reg_val = (addr_val>>32)&0xF;/* high addr in bits */
+			write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_OUTPUT0_LADDR_REG, reg_val);
+
+			/* OUT1 */
+			if ((para->dst_image.format > 0x16) &&
+					(para->dst_image.format < 0x1A)) {
+				if (para->dst_image.format ==
+						G2D_FMT_PYUV411UVC)
+					bppnum = 4;
+				else
+					bppnum = 8;
+				if (para->dst_image.format ==
+						G2D_FMT_PYUV420UVC)
+					addr_val = (__u64)para->dst_image.addr[1] * 8 +
+						(__u64)((para->dst_image.w *
+						(scaler_outy/2) +
+						scaler_outx) * bppnum);
+				else
+					addr_val = (__u64)para->dst_image.addr[1] * 8 +
+						(__u64)((para->dst_image.w *
+						scaler_outy +
+						scaler_outx) * bppnum);
+				reg_val = read_wvalue(G2D_OUTPUT_HADDR_REG);
+				/* high addr in bits */
+				reg_val |= ((addr_val>>32)&0xF)<<8;
+				write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+				/* low addr in bits */
+				reg_val = addr_val&0xFFFFFFFF;
+				write_wvalue(G2D_OUTPUT1_LADDR_REG, reg_val);
+				write_wvalue(G2D_OUTPUT1_STRIDE_REG,
+						para->dst_image.w*bppnum);
+				write_wvalue(G2D_CSC2_CONTROL_REG, 0x1);
+			}
+			if ((para->dst_image.format > 0x11) &&
+					(para->dst_image.format < 0x1D))
+				write_wvalue(G2D_CSC2_CONTROL_REG, 0x1);
+
+			scaler_inx += sinw;
+			if ((para->flag & G2D_BLT_ROTATE90)) {
+				scaler_outx += 0x400;
+				scaler_iny += sinw;
+				scaler_inx = para->src_rect.x;
+			} else if ((para->flag & G2D_BLT_ROTATE270)) {
+				scaler_outx = para->dst_rect.x;
+				scaler_iny += sinw;
+				scaler_inx = para->src_rect.x;
+			} else if ((para->flag & G2D_BLT_ROTATE180)) {
+				scaler_outy = para->dst_rect.y;
+				scaler_outx = para->dst_rect.x -
+							para->dst_image.w;
+			} else {
+				scaler_outy = para->dst_rect.y;
+				scaler_outx += 0x400;
+			}
+
+			/* start */
+			write_wvalue(G2D_CONTROL_REG, 0x0);
+			write_wvalue(G2D_CONTROL_REG, 0x303);
+			result |= g2d_wait_cmd_finish();
+			if (result != 0)
+				return result;
+		}
+
+		/* last block */
+		soutw = para->dst_rect.w - 0x400*cnt;
+		if ((para->flag & G2D_BLT_ROTATE90) ||
+				(para->flag & G2D_BLT_ROTATE270))
+			sinw = para->src_rect.h - sinw*cnt;
+		else
+			sinw = para->src_rect.w - sinw*cnt;
+
+		/* DMA0 */
+		addr_val = mixer_get_addr(para->src_image.addr[0],
+				para->src_image.format, para->src_image.w,
+				scaler_inx, para->src_rect.y);
+		if ((para->flag & G2D_BLT_ROTATE90) ||
+				(para->flag & G2D_BLT_ROTATE270))
+			addr_val = mixer_get_addr(para->src_image.addr[0],
+					para->src_image.format,
+					para->src_image.w,
+					scaler_inx, scaler_iny);
+		reg_val = (addr_val>>32)&0xF;/* high addr in bits */
+		write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+		reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+		write_wvalue(G2D_DMA0_LADDR_REG, reg_val);
+		write_wvalue(G2D_DMA0_SIZE_REG,
+				(sinw - 1) | ((para->src_rect.h - 1)<<16));
+		if ((para->flag & G2D_BLT_ROTATE90) ||
+				(para->flag & G2D_BLT_ROTATE270))
+			write_wvalue(G2D_DMA0_SIZE_REG,
+				(para->src_rect.w - 1) | ((sinw - 1)<<16));
+
+		/* DMA1 pyuv422/420/411uvc */
+		if ((para->src_image.format > 0x16) &&
+				(para->src_image.format < 0x1A)) {
+			if (para->src_image.format ==
+					G2D_FMT_PYUV411UVC)
+				bppnum = 4;
+			else
+				bppnum = 8;
+			if (para->src_image.format == G2D_FMT_PYUV420UVC)
+				addr_val = (__u64)para->src_image.addr[1] * 8 +
+					(__u64)((para->src_image.w *
+					(para->src_rect.y/2) +
+					scaler_inx) * bppnum);
+			else
+				addr_val = (__u64)para->src_image.addr[1] * 8 +
+					(__u64)((para->src_image.w *
+					para->src_rect.y +
+					scaler_inx) * bppnum);
+			reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+			reg_val |= ((addr_val>>32)&0xF)<<8;/*high addr in bits*/
+			write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_DMA1_LADDR_REG, reg_val);
+			write_wvalue(G2D_DMA1_STRIDE_REG,
+					para->src_image.w * bppnum);
+			if (sinw < 1)
+				sinw = 1;
+			write_wvalue(G2D_DMA1_SIZE_REG,
+				(sinw - 1) | ((para->src_rect.h - 1)<<16));
+			reg_val = read_wvalue(G2D_DMA1_CONTROL_REG);
+			reg_val |= (5<<8) | G2D_IDMA_ENABLE;
+
+			/* rotate/mirror */
+			reg_val |= mixer_set_rotate_reg(para->flag);
+			write_wvalue(G2D_DMA1_CONTROL_REG, reg_val);
+		}
+
+		/* scaler setting */
+		if (soutw < 1)
+			soutw = 1;
+		if ((para->flag & G2D_BLT_ROTATE90) ||
+				(para->flag & G2D_BLT_ROTATE270)) {
+			write_wvalue(G2D_SCALER_SIZE_REG,
+				(para->dst_rect.h - 1) | ((soutw - 1)<<16));
+			reg_val = (para->src_rect.w/para->dst_rect.h)<<16;
+			reg_tmp = (para->src_rect.w%para->dst_rect.h);
+			reg_val |= (reg_tmp<<16)/para->dst_rect.h;
+			write_wvalue(G2D_SCALER_HFACTOR_REG, reg_val);
+			reg_val = (sinw/soutw)<<16;
+			reg_tmp = (sinw%soutw);
+			reg_val |= (reg_tmp<<16)/soutw;
+			write_wvalue(G2D_SCALER_VFACTOR_REG, reg_val);
+		} else {
+			write_wvalue(G2D_SCALER_SIZE_REG,
+				(soutw - 1) | ((para->dst_rect.h - 1)<<16));
+			reg_val = (sinw/soutw)<<16;
+			reg_tmp = (sinw%soutw);
+			reg_val |= (reg_tmp<<16)/soutw;
+			write_wvalue(G2D_SCALER_HFACTOR_REG, reg_val);
+
+			reg_val = (para->src_rect.h/para->dst_rect.h)<<16;
+			reg_tmp = (para->src_rect.h%para->dst_rect.h);
+			reg_val |= (reg_tmp<<16)/para->dst_rect.h;
+			write_wvalue(G2D_SCALER_VFACTOR_REG, reg_val);
+		}
+	if ((para->flag & G2D_BLT_PIXEL_ALPHA) ||
+			(para->flag & G2D_BLT_PLANE_ALPHA) ||
+			(para->flag & G2D_BLT_MULTI_ALPHA) ||
+			(para->flag & G2D_BLT_SRC_COLORKEY) ||
+			(para->flag & G2D_BLT_DST_COLORKEY)) {
+		/* DMA2 pyuv422/420/411uvc */
+		if ((para->dst_image.format > 0x16) &&
+				(para->dst_image.format < 0x1A)) {
+			if (para->dst_image.format == G2D_FMT_PYUV411UVC)
+				bppnum = 4;
+			else
+				bppnum = 8;
+			if (para->dst_image.format == G2D_FMT_PYUV420UVC)
+				addr_val = (__u64)para->dst_image.addr[1] * 8 +
+					(__u64)((para->dst_image.w *
+					(para->dst_rect.y/2) +
+					scaler_outx) * bppnum);
+			else
+				addr_val = (__u64)para->dst_image.addr[1] * 8 +
+					(__u64)((para->dst_image.w *
+					para->dst_rect.y +
+					scaler_outx)*bppnum);
+			reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+			/*high addr in bits*/
+			reg_val |= ((addr_val>>32)&0xF)<<16;
+			write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_DMA2_LADDR_REG, reg_val);
+			write_wvalue(G2D_DMA2_STRIDE_REG,
+					para->dst_image.w*bppnum);
+			if (soutw < 1)
+				soutw = 1;
+			write_wvalue(G2D_DMA2_SIZE_REG,
+				(soutw - 1) | ((para->dst_rect.h - 1)<<16));
+			reg_val = read_wvalue(G2D_DMA2_CONTROL_REG);
+			reg_val |= (5<<8) | G2D_IDMA_ENABLE;
+			write_wvalue(G2D_DMA2_CONTROL_REG, reg_val);
+		}
+
+		/* DMA3 */
+		addr_val = mixer_get_addr(para->dst_image.addr[0],
+				para->dst_image.format, para->dst_image.w,
+				scaler_outx, para->dst_rect.y);
+		reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+		reg_val = reg_val&0xF0FFFFFF;
+		reg_val |= ((addr_val>>32)&0xF)<<24;/* high addr in bits */
+		write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+		reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+		write_wvalue(G2D_DMA3_LADDR_REG, reg_val);
+		write_wvalue(G2D_DMA3_SIZE_REG,
+				(soutw - 1) | ((para->dst_rect.h - 1)<<16));
+	}
+		/* OUT */
+		write_wvalue(G2D_OUTPUT_SIZE_REG,
+				(soutw - 1) | ((para->dst_rect.h - 1)<<16));
+		if ((para->flag & G2D_BLT_ROTATE90) ||
+				(para->flag & G2D_BLT_ROTATE270))
+			addr_val = mixer_get_addr(para->dst_image.addr[0],
+					para->dst_image.format,
+					para->dst_image.w,
+					scaler_outx, scaler_outy);
+		else
+			addr_val = mixer_get_addr(para->dst_image.addr[0],
+				para->dst_image.format, para->dst_image.w,
+				scaler_outx, para->dst_rect.y);
+		reg_val = (addr_val>>32)&0xF;/* high addr in bits */
+		write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+		reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+		write_wvalue(G2D_OUTPUT0_LADDR_REG, reg_val);
+
+		/* OUT1 */
+		if ((para->dst_image.format > 0x16) &&
+				(para->dst_image.format < 0x1A)) {
+			if (para->dst_image.format == G2D_FMT_PYUV411UVC)
+				bppnum = 4;
+			else
+				bppnum = 8;
+			if (para->dst_image.format == G2D_FMT_PYUV420UVC)
+				addr_val = (__u64)para->dst_image.addr[1] * 8 +
+					(__u64)((para->dst_image.w *
+					(para->dst_rect.y/2) +
+					scaler_outx)*bppnum);
+			else
+				addr_val = (__u64)para->dst_image.addr[1] * 8 +
+					(__u64)((para->dst_image.w *
+					para->dst_rect.y +
+					scaler_outx) * bppnum);
+			reg_val = read_wvalue(G2D_OUTPUT_HADDR_REG);
+			/* high addr in bits */
+			reg_val |= ((addr_val>>32)&0xF)<<8;
+			write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_OUTPUT1_LADDR_REG, reg_val);
+			write_wvalue(G2D_OUTPUT1_STRIDE_REG,
+					para->dst_image.w*bppnum);
+			write_wvalue(G2D_CSC2_CONTROL_REG, 0x1);
+		}
+		if ((para->dst_image.format > 0x11) &&
+				(para->dst_image.format < 0x1D))
+			write_wvalue(G2D_CSC2_CONTROL_REG, 0x1);
+
+		/*scan order*/
+		write_wvalue(G2D_SCAN_ORDER_REG, (scan_order & 0x3) << 8);
+		/* start */
+		write_wvalue(G2D_CONTROL_REG, 0x0);
+		write_wvalue(G2D_CONTROL_REG, 0x303);
+		result |= g2d_wait_cmd_finish();
+	}
+
+	/* output width smaller than 1024 pixel width */
+	else {
+		addr_val = mixer_get_addr(para->src_image.addr[0],
+				para->src_image.format, para->src_image.w,
+				para->src_rect.x, para->src_rect.y);
+		reg_val = (addr_val>>32)&0xF;/* high addr in bits */
+		write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+		reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+		write_wvalue(G2D_DMA0_LADDR_REG, reg_val);
+		write_wvalue(G2D_DMA0_SIZE_REG,
+			(para->src_rect.w - 1) | ((para->src_rect.h - 1)<<16));
+
+		if ((para->flag & G2D_BLT_ROTATE90) ||
+				(para->flag & G2D_BLT_ROTATE270)) {
+			write_wvalue(G2D_SCALER_SIZE_REG,
+					(para->dst_rect.h - 1) |
+					((para->dst_rect.w - 1)<<16));
+			reg_val = (para->src_rect.w/para->dst_rect.h)<<16;
+			reg_tmp = (para->src_rect.w%para->dst_rect.h);
+			reg_val |= (reg_tmp<<16)/para->dst_rect.h;
+			write_wvalue(G2D_SCALER_HFACTOR_REG, reg_val);
+			reg_val = (para->src_rect.h/para->dst_rect.w)<<16;
+			reg_tmp = (para->src_rect.h%para->dst_rect.w);
+			reg_val |= (reg_tmp<<16)/para->dst_rect.w;
+			write_wvalue(G2D_SCALER_VFACTOR_REG, reg_val);
+		} else {
+			write_wvalue(G2D_SCALER_SIZE_REG,
+					(para->dst_rect.w - 1) |
+					((para->dst_rect.h - 1)<<16));
+			reg_val = (para->src_rect.w/para->dst_rect.w)<<16;
+			reg_tmp = (para->src_rect.w%para->dst_rect.w);
+			reg_val |= (reg_tmp<<16)/para->dst_rect.w;
+			write_wvalue(G2D_SCALER_HFACTOR_REG, reg_val);
+			reg_val = (para->src_rect.h/para->dst_rect.h)<<16;
+			reg_tmp = (para->src_rect.h%para->dst_rect.h);
+			reg_val |= (reg_tmp<<16)/para->dst_rect.h;
+			write_wvalue(G2D_SCALER_VFACTOR_REG, reg_val);
+		}
+		/* pyuv422/420/411uvc */
+		if ((para->src_image.format > 0x16) &&
+				(para->src_image.format < 0x1A)) {
+			if (para->src_image.format == G2D_FMT_PYUV411UVC)
+				bppnum = 4;
+			else
+				bppnum = 8;
+			if (para->src_image.format == G2D_FMT_PYUV420UVC)
+				addr_val = (__u64)para->src_image.addr[1] * 8 +
+					(__u64)((para->src_image.w *
+					(para->src_rect.y/2) +
+					para->src_rect.x) * bppnum);
+			else
+				addr_val = (__u64)para->src_image.addr[1] * 8 +
+					(__u64)((para->src_image.w *
+					para->src_rect.y +
+					para->src_rect.x) * bppnum);
+			reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+			/* high addr in bits */
+			reg_val |= ((addr_val>>32)&0xF)<<8;
+			write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_DMA1_LADDR_REG, reg_val);
+			write_wvalue(G2D_DMA1_STRIDE_REG,
+					para->src_image.w*bppnum);
+			write_wvalue(G2D_DMA1_SIZE_REG,
+					(para->src_rect.w - 1) |
+					((para->src_rect.h - 1)<<16));
+			reg_val = read_wvalue(G2D_DMA1_CONTROL_REG);
+			reg_val |= (5<<8) | G2D_IDMA_ENABLE;
+			reg_val |= mixer_set_rotate_reg(para->flag);
+			write_wvalue(G2D_DMA1_CONTROL_REG, reg_val);
+		}
+	if ((para->flag & G2D_BLT_PIXEL_ALPHA) ||
+			(para->flag & G2D_BLT_PLANE_ALPHA) ||
+			(para->flag & G2D_BLT_MULTI_ALPHA) ||
+			(para->flag & G2D_BLT_SRC_COLORKEY) ||
+			(para->flag & G2D_BLT_DST_COLORKEY)) {
+		/* pyuv422/420/411uvc */
+		if ((para->dst_image.format > 0x16) &&
+				(para->dst_image.format < 0x1A)) {
+			if (para->dst_image.format == G2D_FMT_PYUV411UVC)
+				bppnum = 4;
+			else
+				bppnum = 8;
+			if (para->dst_image.format == G2D_FMT_PYUV420UVC)
+				addr_val = (__u64)para->dst_image.addr[1] * 8 +
+					(__u64)((para->dst_image.w *
+						(para->dst_rect.y/2) +
+						para->dst_rect.x) * bppnum);
+			else
+				addr_val = (__u64)para->dst_image.addr[1] * 8 +
+					(__u64)((para->dst_image.w *
+						para->dst_rect.y +
+						para->dst_rect.x) * bppnum);
+			reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+			/* high addr in bits */
+			reg_val |= ((addr_val>>32)&0xF)<<16;
+			write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_DMA2_LADDR_REG, reg_val);
+			write_wvalue(G2D_DMA2_STRIDE_REG,
+					para->dst_image.w * bppnum);
+			write_wvalue(G2D_DMA2_SIZE_REG,
+					(para->dst_rect.w - 1) |
+					((para->dst_rect.h - 1)<<16));
+			reg_val = read_wvalue(G2D_DMA2_CONTROL_REG);
+			reg_val |= (5<<8) | G2D_IDMA_ENABLE;
+			write_wvalue(G2D_DMA2_CONTROL_REG, reg_val);
+		}
+
+		addr_val = mixer_get_addr(para->dst_image.addr[0],
+				para->dst_image.format, para->dst_image.w,
+				para->dst_rect.x, para->dst_rect.y);
+		reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+		reg_val |= ((addr_val>>32)&0xF)<<24;/* high addr in bits */
+		write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+		reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+		write_wvalue(G2D_DMA3_LADDR_REG, reg_val);
+		write_wvalue(G2D_DMA3_SIZE_REG,
+				(para->dst_rect.w - 1) |
+				((para->dst_rect.h - 1)<<16));
+	}
+		/* output surface is the dst surface */
+		write_wvalue(G2D_OUTPUT_SIZE_REG,
+				(para->dst_rect.w - 1) |
+				((para->dst_rect.h - 1)<<16));
+		addr_val = mixer_get_addr(para->dst_image.addr[0],
+				para->dst_image.format, para->dst_image.w,
+				para->dst_rect.x, para->dst_rect.y);
+		reg_val = (addr_val>>32)&0xF;/* high addr in bits */
+		write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+		reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+		write_wvalue(G2D_OUTPUT0_LADDR_REG, reg_val);
+
+		if ((para->dst_image.format > 0x16) &&
+				(para->dst_image.format < 0x1D)) {
+			if ((para->dst_image.format == G2D_FMT_PYUV411UVC) ||
+				(para->dst_image.format == G2D_FMT_PYUV422) ||
+				(para->dst_image.format == G2D_FMT_PYUV420))
+				bppnum = 4;
+			else if (para->dst_image.format == G2D_FMT_PYUV411)
+				bppnum = 2;
+			else
+				bppnum = 8;
+			if ((para->dst_image.format == G2D_FMT_PYUV420UVC) ||
+				(para->dst_image.format == G2D_FMT_PYUV420))
+				addr_val = (__u64)para->dst_image.addr[1] * 8 +
+					(__u64)((para->dst_image.w *
+						(para->dst_rect.y/2) +
+						para->dst_rect.x) * bppnum);
+			else
+				addr_val = (__u64)para->dst_image.addr[1] * 8 +
+					(__u64)((para->dst_image.w *
+						para->dst_rect.y +
+						para->dst_rect.x) * bppnum);
+			reg_val = read_wvalue(G2D_OUTPUT_HADDR_REG);
+			/* high addr in bits */
+			reg_val |= ((addr_val>>32)&0xF)<<8;
+			write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_OUTPUT1_LADDR_REG, reg_val);
+			write_wvalue(G2D_OUTPUT1_STRIDE_REG,
+					para->dst_image.w * bppnum);
+			if (para->dst_image.format == G2D_FMT_PYUV420)
+				addr_val = (__u64)para->dst_image.addr[2] * 8 +
+					(__u64)((para->dst_image.w *
+						(para->dst_rect.y/2) +
+						para->dst_rect.x) * bppnum);
+			else if ((para->dst_image.format == G2D_FMT_PYUV422) ||
+				(para->dst_image.format == G2D_FMT_PYUV411))
+				addr_val = (__u64)para->dst_image.addr[2] * 8 +
+					(__u64)((para->dst_image.w *
+						para->dst_rect.y +
+						para->dst_rect.x) * bppnum);
+			else
+				addr_val = 0;
+			reg_val = read_wvalue(G2D_OUTPUT_HADDR_REG);
+			/* high addr in bits */
+			reg_val |= ((addr_val>>32)&0xF)<<16;
+			write_wvalue(G2D_OUTPUT_HADDR_REG, reg_val);
+			reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+			write_wvalue(G2D_OUTPUT2_LADDR_REG, reg_val);
+			write_wvalue(G2D_OUTPUT2_STRIDE_REG,
+					para->dst_image.w * bppnum);
+			write_wvalue(G2D_CSC2_CONTROL_REG, 0x1);
+		}
+		if ((para->dst_image.format > 0x11) &&
+				(para->dst_image.format < 0x1D))
+			write_wvalue(G2D_CSC2_CONTROL_REG, 0x1);
+
+		/*scan order*/
+		write_wvalue(G2D_SCAN_ORDER_REG, (scan_order & 0x3) << 8);
+
+		/* start */
+		write_wvalue(G2D_CONTROL_REG, 0x0);
+		write_wvalue(G2D_CONTROL_REG, 0x303);
+		result = g2d_wait_cmd_finish();
+	}
+
+	return result;
+}
+
+__u32 mixer_set_palette(g2d_palette *para)
+{
+	__u32 *pdest_end;
+	__u32 *psrc_cur;
+	__u32 *pdest_cur;
+
+	if (para->size > 0x400)
+		para->size = 0x400;
+	psrc_cur = para->pbuffer;
+	pdest_cur = (__u32 *)(base_addr+G2D_PALETTE_TAB_REG);
+	pdest_end = pdest_cur + (para->size>>2);
+
+	while (pdest_cur < pdest_end)
+		*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+
+	return 0;
+}
+
+__s32 mixer_cmdq(__u32 addr)
+{
+	__s32 result = 0;
+
+	write_wvalue(G2D_CONTROL_REG, 0x0);
+	write_wvalue(G2D_CMDQ_ADDR_REG, addr);
+
+	/* start */
+	write_wvalue(G2D_CMDQ_STS_REG, 0x100);
+	write_wvalue(G2D_CMDQ_CTL_REG, 0x0);
+	write_wvalue(G2D_CMDQ_CTL_REG, 0x103);
+	result = g2d_wait_cmd_finish();
+
+	return result;
+}
+
+__u32 mixer_premultiply_set(__u32 flag)
+{
+	__u32 reg_val;
+
+	reg_val = read_wvalue(G2D_CK_CONTROL_REG);
+
+	/* src premultiply, dst non-premultiply,
+	 * dst_c = src_c + dst_c*(1-src_a)/A;A = src_a + dst_a*(1-src_a)
+	 */
+	if (flag&G2D_BLT_SRC_PREMULTIPLY) {
+		reg_val |= (0x3<<6);
+		write_wvalue(G2D_CK_CONTROL_REG, reg_val);
+	}
+
+	/* src non-premultiply, dst(out) premultiply,
+	 * dst_c = src_c*src_a + dst_c*dst_a(1-src_a);
+	 * A = src_a + dst_a*(1-src_a)
+	 */
+	else if (flag&G2D_BLT_DST_PREMULTIPLY) {
+		reg_val |= (0x7<<5);
+		write_wvalue(G2D_CK_CONTROL_REG, reg_val);
+		write_wvalue(G2D_OALPHA_CONTROL_REG, 0xAA);
+	}
+
+	return 0;
+}
+
+__u32 mixer_micro_block_set(g2d_blt *para)
+{
+	__u32 reg_val, bppnum;
+	__u64 addr_val;
+
+	if (para->src_image.format > 0x20) {
+		if ((para->src_image.format == G2D_FMT_PYUV411UVC_MB16) ||
+			(para->src_image.format == G2D_FMT_PYUV411UVC_MB32) ||
+		   (para->src_image.format == G2D_FMT_PYUV411UVC_MB64) ||
+		   (para->src_image.format == G2D_FMT_PYUV411UVC_MB128))
+			bppnum = 4;
+		else
+			bppnum = 8;
+		if ((para->src_image.format == G2D_FMT_PYUV420UVC_MB16) ||
+			(para->src_image.format == G2D_FMT_PYUV420UVC_MB32) ||
+		   (para->src_image.format == G2D_FMT_PYUV420UVC_MB64) ||
+		   (para->src_image.format == G2D_FMT_PYUV420UVC_MB128))
+			addr_val = (__u64)para->src_image.addr[1] * 8 +
+				(__u64)((para->src_image.w *
+				(para->src_rect.y/2) +
+				para->src_rect.x) * bppnum);
+		else
+			addr_val = (__u64)para->src_image.addr[1] * 8 +
+				(__u64)((para->src_image.w *
+					para->src_rect.y +
+					para->src_rect.x) * bppnum);
+		reg_val = read_wvalue(G2D_DMA_HADDR_REG);
+		reg_val |= ((addr_val>>32)&0xF)<<8;/* high addr in bits */
+		write_wvalue(G2D_DMA_HADDR_REG, reg_val);
+		reg_val = addr_val&0xFFFFFFFF;/* low addr in bits */
+		write_wvalue(G2D_DMA1_LADDR_REG, reg_val);
+
+		write_wvalue(G2D_DMA1_STRIDE_REG, para->src_image.w*bppnum);
+		write_wvalue(G2D_DMA1_SIZE_REG,
+			(para->src_rect.w - 1) | ((para->src_rect.h - 1)<<16));
+		reg_val = read_wvalue(G2D_DMA1_CONTROL_REG);
+		reg_val |= (5<<8) | G2D_IDMA_ENABLE;
+
+		/* rotate/mirror */
+		reg_val |= mixer_set_rotate_reg(para->flag);
+		write_wvalue(G2D_DMA1_CONTROL_REG, reg_val);
+		if (para->src_image.format > 0x23 &&
+				para->src_image.format < 0x27)
+			reg_val = 0x29<<17;
+		else if	(para->src_image.format > 0x26 &&
+				para->src_image.format < 0x2A)
+			reg_val = 0x32<<17;
+		else if	(para->src_image.format > 0x29 &&
+				para->src_image.format < 0x2D)
+			reg_val = 0x3b<<17;
+		else
+			reg_val = 0x20<<17;
+		write_wvalue(G2D_DMA0_CONTROL_REG, (reg_val |
+			(read_wvalue(G2D_DMA0_CONTROL_REG)&0xff81ffff)));
+		write_wvalue(G2D_DMA1_CONTROL_REG, (reg_val |
+			(read_wvalue(G2D_DMA1_CONTROL_REG)&0xff81ffff)));
+		write_wvalue(G2D_DMA0_MBCTL_REG,
+				(para->src_rect.y&0xFFFF)<<16|
+				(para->src_rect.x&0xFFFF));
+		write_wvalue(G2D_DMA1_MBCTL_REG,
+				(para->src_rect.y&0xFFFF)<<16|
+				(para->src_rect.x&0xFFFF));
+
+	}
+
+	return 0;
+}
diff --git a/drivers/char/sunxi_g2d/g2d_bsp_v2.c b/drivers/char/sunxi_g2d/g2d_bsp_v2.c
new file mode 100644
index 000000000..d95025b03
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_bsp_v2.c
@@ -0,0 +1,2375 @@
+/*
+ * Allwinner SoCs g2d driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include "g2d_bsp.h"
+#include "g2d_regs_v2.h"
+#include <linux/types.h>
+#include <linux/stddef.h>
+
+static unsigned long base_addr;
+/* byte input */
+#define read_bvalue(offset)		get_bvalue(base_addr + offset)
+/* byte output */
+#define write_bvalue(offset, value)	put_bvalue(base_addr + offset, value)
+/* half word input */
+#define read_hvalue(offset)		get_hvalue(base_addr + offset)
+/* half word output */
+#define write_hvalue(offset, value)	put_hvalue(base_addr + offset, value)
+/* word input */
+#define read_wvalue(offset)		get_wvalue(base_addr + offset)
+/* word output */
+#define write_wvalue(offset, value)	put_wvalue(base_addr + offset, value)
+
+__s32 g2d_fc_set(__u32 sel, __u32 color_value);
+__s32 g2d_format_trans(__s32 data_fmt, __s32 pixel_seq);
+__s32 rgb2Ycbcr_709[12] = {
+	0x0bb, 0x0275, 0x03f, 0x4200, 0xFFFFFF99, 0xFFFFFEA6, 0x01c2, 0x20200,
+	0x01c2, 0xFFFFFE67, 0xFFFFFFD7, 0x20200, };
+__s32 Ycbcr2rgb_709[12] = {
+	0x04a8, 0x0, 0x072c, 0xFFFC1F7D, 0x04a8, 0xFFFFFF26, 0xFFFFFDDD,
+	0x133F8, 0x04a8, 0x0876, 0, 0xFFFB7AA0, };
+
+__s32 rgb2Ycbcr_601[12] = {
+	0x0107, 0x0204, 0x064, 0x4200,
+	0xFFFFFF68, 0xFFFFFED6, 0x01c2, 0x20200,
+	0x01c2, 0xFFFFFE87, 0xFFFFFFB7, 0x20200,};
+__s32 Ycbcr2rgb_601[12] = {
+	0x04a8, 0x0, 0x0662, 0xFFFC865A,
+	0x04a8, 0xFFFFFE70, 0xFFFFFCBF, 0x21FF4,
+	0x04a8, 0x0812, 0x0, 0xFFFBAE4A,};
+
+__s32 lan2coefftab32_full[512] = {
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc,
+	0x000a3bfb, 0xff0d39fb, 0xff0f37fb, 0xff1136fa, 0xfe1433fb,
+	0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,
+	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd,
+	0xfb3116fe, 0xfb3314fe, 0xfa3611ff, 0xfb370fff, 0xfb390dff,
+	0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400, 0xfe3f0300,
+	0xff400100,
+	/* counter = 1 */
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc,
+	0xff083dfc, 0x000a3bfb, 0xff0d39fb, 0xff0f37fb, 0xff1136fa,
+	0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb,
+	0xfc2127fc, 0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd,
+	0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff, 0xfb370fff,
+	0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400,
+	0xfe3f0300, 0xff400100,
+	/* counter = 2 */
+	0xff053804, 0xff063803, 0xff083801, 0xff093701, 0xff0a3700,
+	0xff0c3500, 0xff0e34ff, 0xff1033fe, 0xff1232fd, 0xfe1431fd,
+	0xfe162ffd, 0xfe182dfd, 0xfd1b2cfc, 0xfd1d2afc, 0xfd1f28fc,
+	0xfd2126fc, 0xfd2323fd, 0xfc2621fd, 0xfc281ffd, 0xfc2a1dfd,
+	0xfc2c1bfd, 0xfd2d18fe, 0xfd2f16fe, 0xfd3114fe, 0xfd3212ff,
+	0xfe3310ff, 0xff340eff, 0x00350cff, 0x00360a00, 0x01360900,
+	0x02370700, 0x03370600,
+	/* counter = 3 */
+	0xff083207, 0xff093206, 0xff0a3205, 0xff0c3203, 0xff0d3103,
+	0xff0e3102, 0xfe113001, 0xfe132f00, 0xfe142e00, 0xfe162dff,
+	0xfe182bff, 0xfe192aff, 0xfe1b29fe, 0xfe1d27fe, 0xfe1f25fe,
+	0xfd2124fe, 0xfe2222fe, 0xfe2421fd, 0xfe251ffe, 0xfe271dfe,
+	0xfe291bfe, 0xff2a19fe, 0xff2b18fe, 0xff2d16fe, 0x002e14fe,
+	0x002f12ff, 0x013010ff, 0x02300fff, 0x03310dff, 0x04310cff,
+	0x05310a00, 0x06310900,
+	/* counter = 4 */
+	0xff0a2e09, 0xff0b2e08, 0xff0c2e07, 0xff0e2d06, 0xff0f2d05,
+	0xff102d04, 0xff122c03, 0xfe142c02, 0xfe152b02, 0xfe172a01,
+	0xfe182901, 0xfe1a2800, 0xfe1b2700, 0xfe1d2500, 0xff1e24ff,
+	0xfe2023ff, 0xff2121ff, 0xff2320fe, 0xff241eff, 0x00251dfe,
+	0x00261bff, 0x00281afe, 0x012818ff, 0x012a16ff, 0x022a15ff,
+	0x032b13ff, 0x032c12ff, 0x052c10ff, 0x052d0fff, 0x062d0d00,
+	0x072d0c00, 0x082d0b00,
+	/* counter = 5 */
+	0xff0c2a0b, 0xff0d2a0a, 0xff0e2a09, 0xff0f2a08, 0xff102a07,
+	0xff112a06, 0xff132905, 0xff142904, 0xff162803, 0xff172703,
+	0xff182702, 0xff1a2601, 0xff1b2501, 0xff1c2401, 0xff1e2300,
+	0xff1f2200, 0x00202000, 0x00211f00, 0x01221d00, 0x01231c00,
+	0x01251bff, 0x02251aff, 0x032618ff, 0x032717ff, 0x042815ff,
+	0x052814ff, 0x052913ff, 0x06291100, 0x072a10ff, 0x082a0e00,
+	0x092a0d00, 0x0a2a0c00,
+	/* counter = 6 */
+	0xff0d280c, 0xff0e280b, 0xff0f280a, 0xff102809, 0xff112808,
+	0xff122708, 0xff142706, 0xff152705, 0xff162605, 0xff172604,
+	0xff192503, 0xff1a2403, 0x001b2302, 0x001c2202, 0x001d2201,
+	0x001e2101, 0x011f1f01, 0x01211e00, 0x01221d00, 0x02221c00,
+	0x02231b00, 0x03241900, 0x04241800, 0x04251700, 0x052616ff,
+	0x06261400, 0x072713ff, 0x08271100, 0x08271100, 0x09271000,
+	0x0a280e00, 0x0b280d00,
+	/* counter = 7 */
+	0xff0e260d, 0xff0f260c, 0xff10260b, 0xff11260a, 0xff122609,
+	0xff132608, 0xff142508, 0xff152507, 0x00152506, 0x00172405,
+	0x00182305, 0x00192304, 0x001b2203, 0x001c2103, 0x011d2002,
+	0x011d2002, 0x011f1f01, 0x021f1e01, 0x02201d01, 0x03211c00,
+	0x03221b00, 0x04221a00, 0x04231801, 0x05241700, 0x06241600,
+	0x07241500, 0x08251300, 0x09251200, 0x09261100, 0x0a261000,
+	0x0b260f00, 0x0c260e00,
+	/* counter = 8 */
+	0xff0e250e, 0xff0f250d, 0xff10250c, 0xff11250b, 0x0011250a,
+	0x00132409, 0x00142408, 0x00152407, 0x00162307, 0x00172306,
+	0x00182206, 0x00192205, 0x011a2104, 0x011b2004, 0x011c2003,
+	0x021c1f03, 0x021e1e02, 0x031e1d02, 0x03201c01, 0x04201b01,
+	0x04211a01, 0x05221900, 0x05221801, 0x06231700, 0x07231600,
+	0x07241500, 0x08241400, 0x09241300, 0x0a241200, 0x0b241100,
+	0x0c241000, 0x0d240f00,
+	/* counter = 9 */
+	0x000e240e, 0x000f240d, 0x0010240c, 0x0011240b, 0x0013230a,
+	0x0013230a, 0x00142309, 0x00152308, 0x00162208, 0x00172207,
+	0x01182106, 0x01192105, 0x011a2005, 0x021b1f04, 0x021b1f04,
+	0x021d1e03, 0x031d1d03, 0x031e1d02, 0x041e1c02, 0x041f1b02,
+	0x05201a01, 0x05211901, 0x06211801, 0x07221700, 0x07221601,
+	0x08231500, 0x09231400, 0x0a231300, 0x0a231300, 0x0b231200,
+	0x0c231100, 0x0d231000,
+	/* counter = 10 */
+	0x000f220f, 0x0010220e, 0x0011220d, 0x0012220c, 0x0013220b,
+	0x0013220b, 0x0015210a, 0x0015210a, 0x01162108, 0x01172008,
+	0x01182007, 0x02191f06, 0x02191f06, 0x021a1e06, 0x031a1e05,
+	0x031c1d04, 0x041c1c04, 0x041d1c03, 0x051d1b03, 0x051e1a03,
+	0x061f1902, 0x061f1902, 0x07201801, 0x08201701, 0x08211601,
+	0x09211501, 0x0a211500, 0x0b211400, 0x0b221300, 0x0c221200,
+	0x0d221100, 0x0e221000,
+	/* counter = 11 */
+	0x0010210f, 0x0011210e, 0x0011210e, 0x0012210d, 0x0013210c,
+	0x0014200c, 0x0114200b, 0x0115200a, 0x01161f0a, 0x01171f09,
+	0x02171f08, 0x02181e08, 0x03181e07, 0x031a1d06, 0x031a1d06,
+	0x041b1c05, 0x041c1c04, 0x051c1b04, 0x051d1a04, 0x061d1a03,
+	0x071d1903, 0x071e1803, 0x081e1802, 0x081f1702, 0x091f1602,
+	0x0a201501, 0x0b1f1501, 0x0b201401, 0x0c211300, 0x0d211200,
+	0x0e201200, 0x0e211100,
+	/* counter = 12 */
+	0x00102010, 0x0011200f, 0x0012200e, 0x0013200d, 0x0013200d,
+	0x01141f0c, 0x01151f0b, 0x01151f0b, 0x01161f0a, 0x02171e09,
+	0x02171e09, 0x03181d08, 0x03191d07, 0x03191d07, 0x041a1c06,
+	0x041b1c05, 0x051b1b05, 0x051c1b04, 0x061c1a04, 0x071d1903,
+	0x071d1903, 0x081d1803, 0x081e1703, 0x091e1702, 0x0a1f1601,
+	0x0a1f1502, 0x0b1f1501, 0x0c1f1401, 0x0d201300, 0x0d201300,
+	0x0e201200, 0x0f201100,
+	/* counter = 13 */
+	0x00102010, 0x0011200f, 0x00121f0f, 0x00131f0e, 0x00141f0d,
+	0x01141f0c, 0x01141f0c, 0x01151e0c, 0x02161e0a, 0x02171e09,
+	0x03171d09, 0x03181d08, 0x03181d08, 0x04191c07, 0x041a1c06,
+	0x051a1b06, 0x051b1b05, 0x061b1a05, 0x061c1a04, 0x071c1904,
+	0x081c1903, 0x081d1803, 0x091d1703, 0x091e1702, 0x0a1e1602,
+	0x0b1e1502, 0x0c1e1501, 0x0c1f1401, 0x0d1f1400, 0x0e1f1300,
+	0x0e1f1201, 0x0f1f1200,
+	/* counter = 14 */
+	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e,
+	0x01141d0e, 0x02151d0c, 0x02151d0c, 0x02161d0b, 0x03161c0b,
+	0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08, 0x05191b07,
+	0x06191a07, 0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805,
+	0x091b1804, 0x091c1704, 0x0a1c1703, 0x0a1c1604, 0x0b1d1602,
+	0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301,
+	0x0f1e1300, 0x101e1200,
+	/* counter = 15 */
+	0x00111e11, 0x00121e10, 0x00131d10, 0x01131d0f, 0x01141d0e,
+	0x01141d0e, 0x02151c0d, 0x02151c0d, 0x03161c0b, 0x03161c0b,
+	0x04171b0a, 0x04171b0a, 0x05171b09, 0x05181a09, 0x06181a08,
+	0x06191a07, 0x07191907, 0x071a1906, 0x081a1806, 0x081a1806,
+	0x091a1805, 0x0a1b1704, 0x0a1b1704, 0x0b1c1603, 0x0b1c1603,
+	0x0c1c1503, 0x0d1c1502, 0x0d1d1402, 0x0e1d1401, 0x0f1d1301,
+	0x0f1d1301, 0x101e1200,
+	/* counter = 16 */
+};
+
+__s32 linearcoefftab32[32] = {
+	0x00004000, 0x00023e00, 0x00043c00, 0x00063a00, 0x00083800,
+	0x000a3600, 0x000c3400, 0x000e3200, 0x00103000, 0x00122e00,
+	0x00142c00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400,
+	0x001e2200, 0x00202000, 0x00221e00, 0x00241c00, 0x00261a00,
+	0x00281800, 0x002a1600, 0x002c1400, 0x002e1200, 0x00301000,
+	0x00320e00, 0x00340c00, 0x00360a00, 0x00380800, 0x003a0600,
+	0x003c0400, 0x003e0200, };
+__s32 g2d_bsp_open(void)
+{
+	write_wvalue(G2D_SCLK_GATE, 0x3);
+	write_wvalue(G2D_HCLK_GATE, 0x3);
+	write_wvalue(G2D_AHB_RESET, 0x3);
+	return 0;
+}
+
+__s32 g2d_bsp_close(void)
+{
+	write_wvalue(G2D_AHB_RESET, 0x0);
+	write_wvalue(G2D_HCLK_GATE, 0x0);
+	write_wvalue(G2D_SCLK_GATE, 0x0);
+	return 0;
+}
+
+__s32 g2d_bsp_reset(void)
+{
+	write_wvalue(G2D_AHB_RESET, 0x0);
+	write_wvalue(G2D_AHB_RESET, 0x3);
+	return 0;
+}
+
+__s32 g2d_mixer_reset(void)
+{
+	__u32 reg_val;
+
+	reg_val = read_wvalue(G2D_AHB_RESET);
+	write_wvalue(G2D_AHB_RESET, reg_val & 0xfffffffe);
+	write_wvalue(G2D_AHB_RESET, reg_val & 0xffffffff);
+	return 0;
+}
+
+__s32 g2d_rot_reset(void)
+{
+	__u32 reg_val;
+
+	reg_val = read_wvalue(G2D_AHB_RESET);
+	write_wvalue(G2D_AHB_RESET, reg_val & 0xfffffffd);
+	write_wvalue(G2D_AHB_RESET, reg_val & 0xffffffff);
+	return 0;
+}
+
+__s32 g2d_scan_order_fun(__u32 scan_order)
+{
+	__u32 tmp;
+
+	tmp = read_wvalue(G2D_MIXER_CTL);
+	tmp |= ((scan_order >> 24) & 0xf0);
+	write_wvalue(G2D_MIXER_CTL, tmp);
+	return 0;
+}
+
+
+/**
+ * G2D IRQ query funct
+ * if the mission finish IRQ flag was set to 1, then clear the flag
+ * and return 1
+ * if the IRQ was set to 0, then return 0
+ */
+__s32 mixer_irq_query(void)
+{
+	__u32 tmp;
+
+	tmp = read_wvalue(G2D_MIXER_INT);
+	if (tmp & 0x1) {
+		write_wvalue(G2D_MIXER_INT, tmp);
+		return 0;
+	}
+	return -1;
+}
+
+
+/**
+ * G2D IRQ query funct
+ * if the mission finish IRQ flag was set to 1, then clear the flag
+ * and return 1
+ * if the IRQ was set to 0, then return 0
+ */
+__s32 rot_irq_query(void)
+{
+	__u32 tmp;
+
+	tmp = read_wvalue(ROT_INT);
+	if (tmp & 0x1) {
+		write_wvalue(ROT_INT, tmp);
+		return 0;
+	}
+	return -1;
+}
+
+__s32 mixer_irq_enable(void)
+{
+	write_wvalue(G2D_MIXER_INT, 0x10);
+	return 0;
+}
+
+__s32 rot_irq_enable(void)
+{
+	write_wvalue(ROT_INT, 0x10000);
+	return 0;
+}
+
+__s32 g2d_irq_disable(void)
+{
+	write_wvalue(G2D_MIXER_INT, 0x0);
+	return 0;
+}
+
+__s32 rot_irq_disable(void)
+{
+	write_wvalue(ROT_INT, 0x0);
+	return 0;
+}
+
+__s32 g2d_sclk_div(__u32 div)
+{
+	__u32 reg_val;
+
+	reg_val = read_wvalue(G2D_SCLK_DIV);
+	reg_val &= 0xfffffff0;
+	reg_val |= (div & 0xf);
+	write_wvalue(G2D_SCLK_DIV, reg_val);
+	return 0;
+}
+
+__s32 rot_sclk_div(__u32 div)
+{
+	__u32 reg_val;
+
+	reg_val = read_wvalue(G2D_SCLK_DIV);
+	reg_val &= 0xffffff0f;
+	reg_val |= (div & 0xf) << 4;
+	write_wvalue(G2D_SCLK_DIV, reg_val);
+	return 0;
+}
+
+__s32 porter_duff(__u32 cmd)
+{
+	switch (cmd) {
+	case G2D_BLD_CLEAR:
+		write_wvalue(BLD_CTL, 0x00000000);
+		break;
+	case G2D_BLD_COPY:
+		write_wvalue(BLD_CTL, 0x00010001);
+		break;
+	case G2D_BLD_DST:
+		write_wvalue(BLD_CTL, 0x01000100);
+		break;
+	case G2D_BLD_SRCOVER:
+		write_wvalue(BLD_CTL, 0x03010301);
+		break;
+	case G2D_BLD_DSTOVER:
+		write_wvalue(BLD_CTL, 0x01030103);
+		break;
+	case G2D_BLD_SRCIN:
+		write_wvalue(BLD_CTL, 0x00020002);
+		break;
+	case G2D_BLD_DSTIN:
+		write_wvalue(BLD_CTL, 0x02000200);
+		break;
+	case G2D_BLD_SRCOUT:
+		write_wvalue(BLD_CTL, 0x00030003);
+		break;
+	case G2D_BLD_DSTOUT:
+		write_wvalue(BLD_CTL, 0x03000300);
+		break;
+	case G2D_BLD_SRCATOP:
+		write_wvalue(BLD_CTL, 0x03020302);
+		break;
+	case G2D_BLD_DSTATOP:
+		write_wvalue(BLD_CTL, 0x02030203);
+		break;
+	case G2D_BLD_XOR:
+		write_wvalue(BLD_CTL, 0x03030303);
+		break;
+	default:
+		write_wvalue(BLD_CTL, 0x03010301);
+		}
+	return 0;
+}
+
+
+/**
+ * @csc_no: CSC ID, G2D support three CSC,
+ * -1 will return to indicate inappropriate CSC number.
+ * @csc_sel: CSC format, G2D support the ITU-R 601. ITU-R 709. standard trans-
+ *  form between RGB and YUV colorspace.
+ */
+__s32 g2d_csc_reg_set(__u32 csc_no, g2d_csc_sel csc_sel)
+{
+	__u32 i;
+	__u32 csc_base_addr;
+	__u32 tmp;
+
+	switch (csc_no) {
+	case 0:
+		csc_base_addr = G2D_BLD + 0x110;
+		tmp = read_wvalue(BLD_CSC_CTL);
+		tmp |= 0x1;
+		write_wvalue(BLD_CSC_CTL, tmp);
+		break;
+	case 1:
+		csc_base_addr = G2D_BLD + 0x140;
+		tmp = read_wvalue(BLD_CSC_CTL);
+		tmp |= 0x1 << 1;
+		write_wvalue(BLD_CSC_CTL, tmp);
+		break;
+	case 2:
+		csc_base_addr = G2D_BLD + 0x170;
+		tmp = read_wvalue(BLD_CSC_CTL);
+		tmp |= 0x1 << 2;
+		write_wvalue(BLD_CSC_CTL, tmp);
+		break;
+	default:
+
+/* __wrn("sel wrong csc no.\n"); */
+		    return -1;
+	}
+	switch (csc_sel) {
+	case G2D_RGB2YUV_709:
+		for (i = 0; i < 12; i++)
+			write_wvalue(csc_base_addr + (i << 2),
+				      rgb2Ycbcr_709[i]);
+		break;
+	case G2D_YUV2RGB_709:
+		for (i = 0; i < 12; i++)
+			write_wvalue(csc_base_addr + (i << 2),
+				      Ycbcr2rgb_709[i]);
+		break;
+	case G2D_RGB2YUV_601:
+		for (i = 0; i < 12; i++)
+			write_wvalue(csc_base_addr + (i << 2),
+				      rgb2Ycbcr_601[i]);
+
+/* write_wvalue(csc_base_addr + (i<<2), */
+/* rgb2Ycbcr_601[i]); */
+		    break;
+	case G2D_YUV2RGB_601:
+		for (i = 0; i < 12; i++)
+			write_wvalue(csc_base_addr + (i << 2),
+				      Ycbcr2rgb_601[i]);
+
+/* write_wvalue(csc_base_addr + (i<<2), */
+/* Ycbcr2rgb_601[i]); */
+		    break;
+	default:
+
+/* __wrn("wrong csc standard\n"); */
+		    return -2;
+	}
+	return 0;
+}
+
+
+/**
+ * set colorkey para.
+ */
+__s32 ck_para_set(g2d_ck *para)
+{
+	__u32 tmp = 0x0;
+
+	if (para->match_rule)
+		tmp = 0x7;
+	write_wvalue(BLD_KEY_CON, tmp);
+	write_wvalue(BLD_KEY_MAX, para->max_color & 0x00ffffff);
+	write_wvalue(BLD_KEY_MIN, para->min_color & 0x00ffffff);
+	return 0;
+}
+
+
+/**
+ */
+__s32 g2d_byte_cal(__u32 format, __u32 *ycnt, __u32 *ucnt, __u32 *vcnt)
+{
+	*ycnt = 0;
+	*ucnt = 0;
+	*vcnt = 0;
+	if (format <= G2D_FORMAT_BGRX8888)
+		*ycnt = 4;
+
+	else if (format <= G2D_FORMAT_BGR888)
+		*ycnt = 3;
+
+	else if (format <= G2D_FORMAT_BGRA5551)
+		*ycnt = 2;
+
+	else if (format <= G2D_FORMAT_BGRA1010102)
+		*ycnt = 4;
+
+	else if (format <= 0x23) {
+		*ycnt = 2;
+	}
+
+	else if (format <= 0x25) {
+		*ycnt = 1;
+		*ucnt = 2;
+	}
+
+	else if (format == 0x26) {
+		*ycnt = 1;
+		*ucnt = 1;
+		*vcnt = 1;
+	}
+
+	else if (format <= 0x29) {
+		*ycnt = 1;
+		*ucnt = 2;
+	}
+
+	else if (format == 0x2a) {
+		*ycnt = 1;
+		*ucnt = 1;
+		*vcnt = 1;
+	}
+
+	else if (format <= 0x2d) {
+		*ycnt = 1;
+		*ucnt = 2;
+	}
+
+	else if (format == 0x2e) {
+		*ycnt = 1;
+		*ucnt = 1;
+		*vcnt = 1;
+	}
+
+	else if (format == 0x30)
+		*ycnt = 1;
+
+	else if (format <= 0x36) {
+		*ycnt = 2;
+		*ucnt = 4;
+	}
+
+	else if (format <= 0x39)
+		*ycnt = 6;
+	return 0;
+}
+
+
+/**
+ */
+__u32 cal_align(__u32 width, __u32 align)
+{
+	switch (align) {
+	case 0:
+		return width;
+	case 4:
+		return (width + 3) >> 1 << 1;
+	case 8:
+		return (width + 7) >> 3 << 3;
+	case 16:
+		return (width + 15) >> 4 << 4;
+	case 32:
+		return (width + 31) >> 5 << 5;
+	case 64:
+		return (width + 63) >> 6 << 6;
+	case 128:
+		return (width + 127) >> 7 << 7;
+	default:
+		return (width + 31) >> 5 << 5;
+	}
+}
+
+
+/**
+ * @sel:layer no.
+ */
+__s32 g2d_vlayer_set(__u32 sel, g2d_image_enh *image)
+{
+	unsigned long long addr0, addr1, addr2;
+	__u32 tmp;
+	__u32 ycnt, ucnt, vcnt;
+	__u32 pitch0, pitch1, pitch2;
+	__u32 ch, cw, cy, cx;
+
+	switch (sel) {
+	case 0:
+
+		    /* base_addr = G2D_V0; */
+		    break;
+	default:
+		return -1;
+	}
+	tmp = ((image->alpha & 0xff) << 24);
+	if (image->bpremul)
+		tmp |= (0x1 << 17);
+	tmp |= (image->format << 8);
+	tmp |= (image->mode << 1);
+	tmp |= 1;
+	write_wvalue(V0_ATTCTL, tmp);
+	tmp =
+	    (((image->clip_rect.h ==
+	       0 ? 0 : image->clip_rect.h -
+	       1) & 0x1fff) << 16) | ((image->clip_rect.w ==
+					0 ? 0 : image->clip_rect.w -
+					1) & 0x1fff);
+	write_wvalue(V0_MBSIZE, tmp);
+
+	    /* offset is set to 0, ovl size is set to layer size */
+	    write_wvalue(V0_SIZE, tmp);
+	write_wvalue(V0_COOR, 0);
+	if ((image->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0)
+	      && (image->format <= G2D_FORMAT_YUV422_PLANAR)) {
+		cw = image->width >> 1;
+		ch = image->height;
+		cx = image->clip_rect.x >> 1;
+		cy = image->clip_rect.y;
+	}
+
+	else if ((image->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0)
+		 && (image->format <= G2D_FORMAT_YUV420_PLANAR)) {
+		cw = image->width >> 1;
+		ch = image->height >> 1;
+		cx = image->clip_rect.x >> 1;
+		cy = image->clip_rect.y >> 1;
+	}
+
+	else if ((image->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0)
+		 && (image->format <= G2D_FORMAT_YUV411_PLANAR)) {
+		cw = image->width >> 2;
+		ch = image->height;
+		cx = image->clip_rect.x >> 2;
+		cy = image->clip_rect.y;
+	}
+
+	else {
+		cw = 0;
+		ch = 0;
+		cx = 0;
+		cy = 0;
+	}
+	g2d_byte_cal(image->format, &ycnt, &ucnt, &vcnt);
+	pitch0 = cal_align(ycnt * image->width, image->align[0]);
+	write_wvalue(V0_PITCH0, pitch0);
+	pitch1 = cal_align(ucnt * cw, image->align[1]);
+	write_wvalue(V0_PITCH1, pitch1);
+	pitch2 = cal_align(vcnt * cw, image->align[2]);
+	write_wvalue(V0_PITCH2, pitch2);
+	G2D_INFO_MSG("VInPITCH: %d, %d, %d\n",
+				pitch0, pitch1, pitch2);
+	G2D_INFO_MSG("VInAddrB: 0x%x, 0x%x, 0x%x\n",
+			image->laddr[0], image->laddr[1], image->laddr[2]);
+	addr0 =
+	    image->laddr[0] + ((__u64) image->haddr[0] << 32) +
+	    pitch0 * image->clip_rect.y + ycnt * image->clip_rect.x;
+	write_wvalue(V0_LADD0, addr0 & 0xffffffff);
+	addr1 =
+	    image->laddr[1] + ((__u64) image->haddr[1] << 32) + pitch1 * cy +
+	    ucnt * cx;
+	write_wvalue(V0_LADD1, addr1 & 0xffffffff);
+	addr2 =
+	    image->laddr[2] + ((__u64) image->haddr[2] << 32) + pitch2 * cy +
+	    vcnt * cx;
+	write_wvalue(V0_LADD2, addr2 & 0xffffffff);
+	tmp = ((addr0 >> 32) & 0xff) | ((addr1 >> 32) & 0xff) << 8 |
+	    ((addr2 >> 32) & 0xff) << 16;
+	write_wvalue(V0_HADD, tmp);
+	G2D_INFO_MSG("VInAddrA: 0x%llx, 0x%llx, 0x%llx\n",
+							addr0, addr1, addr2);
+	if (image->bbuff == 0)
+		g2d_fc_set((sel + VI_LAYER_NUMBER), image->color);
+	return 0;
+}
+
+__s32 g2d_uilayer_set(__u32 sel, g2d_image_enh *img)
+{
+	__u64 addr0;
+	__u32 base_addr_u, tmp;
+	__u32 ycnt, ucnt, vcnt;
+	__u32 pitch0;
+
+	switch (sel) {
+	case 0:
+		base_addr_u = G2D_UI0;
+		break;
+	case 1:
+		base_addr_u = G2D_UI1;
+		break;
+	case 2:
+		base_addr_u = G2D_UI2;
+		break;
+	default:
+		return -1;
+	}
+	tmp = (img->alpha & 0xff) << 24;
+	if (img->bpremul)
+		tmp |= 0x1 << 17;
+	tmp |= img->format << 8;
+	tmp |= img->mode << 1;
+	tmp |= 1;
+	write_wvalue(base_addr_u, tmp);
+	tmp =
+	    (((img->clip_rect.h ==
+	       0 ? 0 : img->clip_rect.h -
+	       1) & 0x1fff) << 16) | ((img->clip_rect.w ==
+					0 ? 0 : img->clip_rect.w - 1) & 0x1fff);
+	write_wvalue(base_addr_u + 0x4, tmp);
+	write_wvalue(base_addr_u + 0x1C, tmp);
+	write_wvalue(base_addr_u + 0x8, 0);
+	g2d_byte_cal(img->format, &ycnt, &ucnt, &vcnt);
+	pitch0 = cal_align(ycnt * img->width, img->align[0]);
+	write_wvalue(base_addr_u + 0xC, pitch0);
+	addr0 =
+	    img->laddr[0] + ((__u64) img->haddr[0] << 32) +
+	    pitch0 * img->clip_rect.y + ycnt * img->clip_rect.x;
+	write_wvalue(base_addr_u + 0x10, addr0 & 0xffffffff);
+	write_wvalue(base_addr_u + 0x18, (addr0 >> 32) & 0xff);
+	if (img->bbuff == 0)
+		g2d_fc_set((sel + VI_LAYER_NUMBER), img->color);
+	return 0;
+}
+
+__s32 g2d_wb_set(g2d_image_enh *image)
+{
+	__u64 addr0, addr1, addr2;
+	__u32 tmp;
+	__u32 ycnt, ucnt, vcnt;
+	__u32 pitch0, pitch1, pitch2;
+	__u32 ch, cw, cy, cx;
+
+	write_wvalue(WB_ATT, image->format);
+	tmp =
+	    (((image->clip_rect.h ==
+	       0 ? 0 : image->clip_rect.h -
+	       1) & 0x1fff) << 16) | ((image->clip_rect.w ==
+					0 ? 0 : image->clip_rect.w -
+					1) & 0x1fff);
+	write_wvalue(WB_SIZE, tmp);
+	/*write to the bld out reg */
+	G2D_INFO_MSG("BLD_CH_OSIZE W:  0x%x\n", image->clip_rect.w);
+	G2D_INFO_MSG("BLD_CH_OSIZE H:  0x%x\n", image->clip_rect.h);
+	write_wvalue(BLD_SIZE, tmp);
+	/* set outdata premul */
+	tmp = read_wvalue(BLD_OUT_COLOR);
+
+	if (image->bpremul)
+		write_wvalue(BLD_OUT_COLOR, tmp | 0x1);
+
+	else
+		write_wvalue(BLD_OUT_COLOR, tmp & 0x2);
+	if ((image->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0)
+	      && (image->format <= G2D_FORMAT_YUV422_PLANAR)) {
+		cw = image->width >> 1;
+		ch = image->height;
+		cx = image->clip_rect.x >> 1;
+		cy = image->clip_rect.y;
+	}
+
+	else if ((image->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0)
+		 && (image->format <= G2D_FORMAT_YUV420_PLANAR)) {
+		cw = image->width >> 1;
+		ch = image->height >> 1;
+		cx = image->clip_rect.x >> 1;
+		cy = image->clip_rect.y >> 1;
+	}
+
+	else if ((image->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0)
+		 && (image->format <= G2D_FORMAT_YUV411_PLANAR)) {
+		cw = image->width >> 2;
+		ch = image->height;
+		cx = image->clip_rect.x >> 2;
+		cy = image->clip_rect.y;
+	}
+
+	else {
+		cw = 0;
+		ch = 0;
+		cx = 0;
+		cy = 0;
+	}
+	g2d_byte_cal(image->format, &ycnt, &ucnt, &vcnt);
+	pitch0 = cal_align(ycnt * image->width, image->align[0]);
+	write_wvalue(WB_PITCH0, pitch0);
+	pitch1 = cal_align(ucnt * cw, image->align[1]);
+	write_wvalue(WB_PITCH1, pitch1);
+	pitch2 = cal_align(vcnt * cw, image->align[2]);
+	write_wvalue(WB_PITCH2, pitch2);
+	G2D_INFO_MSG("OutputPitch: %d, %d, %d\n", pitch0, pitch1, pitch2);
+
+	addr0 =
+	    image->laddr[0] + ((__u64) image->haddr[0] << 32) +
+	    pitch0 * image->clip_rect.y + ycnt * image->clip_rect.x;
+	write_wvalue(WB_LADD0, addr0 & 0xffffffff);
+	write_wvalue(WB_HADD0, (addr0 >> 32) & 0xff);
+	addr1 =
+	    image->laddr[1] + ((__u64) image->haddr[1] << 32) + pitch1 * cy +
+	    ucnt * cx;
+	write_wvalue(WB_LADD1, addr1 & 0xffffffff);
+	write_wvalue(WB_HADD1, (addr1 >> 32) & 0xff);
+	addr2 =
+	    image->laddr[2] + ((__u64) image->haddr[2] << 32) + pitch2 * cy +
+	    vcnt * cx;
+	write_wvalue(WB_LADD2, addr2 & 0xffffffff);
+	write_wvalue(WB_HADD2, (addr2 >> 32) & 0xff);
+	G2D_INFO_MSG("WbAddr: 0x%llx, 0x%llx, 0x%llx\n", addr0, addr1, addr2);
+	return 0;
+}
+
+
+/**
+ * fillcolor set
+ * @sel:layer_no, 0--Layer Video,1--Layer UI0,2--Layer UI1,3--Layer UI2
+ * @color_value:fill color value
+ */
+__s32 g2d_fc_set(__u32 sel, __u32 color_value)
+{
+	__u32 tmp;
+
+	G2D_INFO_MSG("FILLCOLOR: sel: %d, color: 0x%x\n", sel, color_value);
+
+	if (sel == 0) {
+		/* Layer Video */
+		tmp = read_wvalue(V0_ATTCTL);
+		tmp |= (0x1 << 4);
+		write_wvalue(V0_ATTCTL, tmp);
+		write_wvalue(V0_FILLC, color_value);
+	}
+	if (sel == 1) {
+		/* Layer UI0 */
+		tmp = read_wvalue(UI0_ATTR);
+		tmp |= (0x1 << 4);
+		write_wvalue(UI0_ATTR, tmp);
+		write_wvalue(UI0_FILLC, color_value);
+	}
+	if (sel == 2) {
+		/* Layer UI1 */
+		tmp = read_wvalue(UI1_ATTR);
+		tmp |= (0x1 << 4);
+		write_wvalue(UI1_ATTR, tmp);
+		write_wvalue(UI1_FILLC, color_value);
+	}
+	if (sel == 3) {
+		/* Layer UI2 */
+		tmp = read_wvalue(UI2_ATTR);
+		tmp |= (0x1 << 4);
+		write_wvalue(UI2_ATTR, tmp);
+		write_wvalue(UI2_FILLC, color_value);
+	}
+	return 0;
+}
+
+
+/**
+ * ROP2 cmd register set
+ * Index0 is selected
+ * dst mapping ch0'
+ * src mapping ch1'
+ */
+__s32 g2d_rop2_set(__u32 rop_cmd)
+{
+	if (rop_cmd == G2D_BLT_BLACKNESS) {
+		/* blackness */
+		/* tmpue = 0x1<<18; */
+		write_wvalue(ROP_INDEX0, 0x40000);
+	} else if (rop_cmd == G2D_BLT_NOTMERGEPEN) {
+		/* ~(dst | src) */
+		/* tmpue = (0x1<<6) | (0x1<<10) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(ROP_INDEX0, 0x41440);
+	} else if (rop_cmd == G2D_BLT_MASKNOTPEN) {
+		/* ~src&dst */
+		/* tmpue = (0x1<<4) | (0x0<<10) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(ROP_INDEX0, 0x41010);
+	} else if (rop_cmd == G2D_BLT_NOTCOPYPEN) {
+		/* ~src */
+		/* tmpue = (0x1<<4) | (0x2<<6) | (0x2<<11) |
+		 * (0x1<<18) | (0x1<<17);
+		 */
+		write_wvalue(ROP_INDEX0, 0x61090);
+	} else if (rop_cmd == G2D_BLT_MASKPENNOT) {
+		/* src&~dst */
+		/* tmpue = (0x1<<3) | (0x0<<10) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(ROP_INDEX0, 0x41008);
+	} else if (rop_cmd == G2D_BLT_NOT) {
+		/* ~dst */
+		/* tmpue = (0x1<<3) | (0x2<<6) | (0x2<<11) |
+		 * (0x1<<18) | (0x1<<16);
+		 */
+		write_wvalue(ROP_INDEX0, 0x51088);
+	} else if (rop_cmd == G2D_BLT_XORPEN) {
+		/* src xor dst */
+		/* tmpue = (0x2<<6) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(ROP_INDEX0, 0x41080);
+	} else if (rop_cmd == G2D_BLT_NOTMASKPEN) {
+		/* ~(src & dst) */
+		/* tmpue = (0x0<<6) | (0x1<<10) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(ROP_INDEX0, 0x41400);
+	} else if (rop_cmd == G2D_BLT_MASKPEN) {
+		/* src&dst */
+		/* tmpue = (0x0<<6) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(ROP_INDEX0, 0x41000);
+	} else if (rop_cmd == G2D_BLT_NOTXORPEN) {
+		/* ~(src xor dst) */
+		/* tmpue = (0x2<<6) | (0x1<<10) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(ROP_INDEX0, 0x41480);
+	} else if (rop_cmd == G2D_BLT_NOP) {
+		/* dst */
+		/* tmpue = (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<16); */
+		write_wvalue(ROP_INDEX0, 0x51080);
+	} else if (rop_cmd == G2D_BLT_MERGENOTPEN) {
+		/* ~dst or src */
+		/* tmpue = (0x1<<3)| (0x1<<6) | (0x2<<11) | (0x1<<18) */
+		/* write_wvalue(ROP_INDEX0, 0x40A20); */
+		write_wvalue(ROP_INDEX0, 0x41048);
+	} else if (rop_cmd == G2D_BLT_COPYPEN) {
+		/* src */
+		/* tmpue = (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<17); */
+		write_wvalue(ROP_INDEX0, 0x61080);
+	} else if (rop_cmd == G2D_BLT_MERGEPENNOT) {
+		/* src or ~dst */
+		/* tmpue =  (0x1<<3)| (0x1<<6) | (0x2<<11) | (0x1<<18) */
+		write_wvalue(ROP_INDEX0, 0x41048);
+	} else if (rop_cmd == G2D_BLT_MERGEPEN) {
+		/* src or dst */
+		/* tmpue = (0x1<<6) | (0x1<<18) | (0x2<<11); */
+		write_wvalue(ROP_INDEX0, 0x41040);
+	} else if (rop_cmd == G2D_BLT_WHITENESS) {
+		/* whiteness */
+		/* tmpue = (0x1<<18) | (0x1<<15); */
+		write_wvalue(ROP_INDEX0, 0x48000);
+	} else
+		return -1;
+	return 0;
+}
+
+
+/**
+ * ROP3 cmd register set
+ * dst mapping ch0'
+ * src mapping ch1'
+ * ptn mapping ch2'
+ * -1 return meaning that the operate is not supported by now
+ */
+__s32 g2d_rop3_set(__u32 sel, __u32 rop3_cmd)
+{
+	__u32 addr;
+
+	if (sel == 0)
+		addr = ROP_INDEX0;
+	else if (sel == 1)
+		addr = ROP_INDEX1;
+
+	else
+		return -1;
+	if (rop3_cmd == G2D_ROP3_BLACKNESS) {
+		/* blackness */
+		/* 0x1<<18; */
+		write_wvalue(addr, 0x40000);
+	} else if (rop3_cmd == G2D_ROP3_NOTSRCERASE) {
+		/* (~src) AND (~dst) */
+		/* (0x1<<3) | (0x1<<4) | (0x1<<18) | (0x2<<11); */
+		write_wvalue(addr, 0x41018);
+	} else if (rop3_cmd == G2D_ROP3_NOTSRCCOPY) {
+
+		/* ~src */
+		/* (0x1<<4) | (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<16); */
+		write_wvalue(addr, 0x51090);
+	} else if (rop3_cmd == G2D_ROP3_SRCERASE) {
+		/* src AND ~dst */
+		/* (0x1<<3) | (0x0<<6) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(addr, 0x41008);
+	} else if (rop3_cmd == G2D_ROP3_DSTINVERT) {
+		/* ~dst */
+		/* (0x1<<3) | (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<17); */
+		write_wvalue(addr, 0x61088);
+	} else if (rop3_cmd == G2D_ROP3_PATINVERT) {
+		/* ptn XOR dst */
+		/* (0x2<<6) | (0x2<<11) | (0x1<<17) */
+		write_wvalue(addr, 0x21080);
+	} else if (rop3_cmd == G2D_ROP3_SRCINVERT) {
+		/* src XOR dst */
+		/* (0x2<<6) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(addr, 0x41080);
+	} else if (rop3_cmd == G2D_ROP3_SRCAND) {
+		/* src AND dst */
+		/* (0x0<<6) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(addr, 0x41000);
+	} else if (rop3_cmd == G2D_ROP3_MERGEPAINT) {
+		/* ~src OR dst */
+		/* (0x1<<4) | (0x1<<6) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(addr, 0x41050);
+	} else if (rop3_cmd == G2D_ROP3_MERGECOPY) {
+		/* src AND pattern */
+		/* (0x2<<6) | (0x1<<16) */
+		write_wvalue(addr, 0x10080);
+	} else if (rop3_cmd == G2D_ROP3_SRCCOPY) {
+		/* src */
+		/* (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<16); */
+		write_wvalue(addr, 0x51080);
+	} else if (rop3_cmd == G2D_ROP3_SRCPAINT) {
+		/* src OR dst */
+		/* (0x1<<6) | (0x2<<11) | (0x1<<18); */
+		write_wvalue(addr, 0x41040);
+	} else if (rop3_cmd == G2D_ROP3_PATCOPY) {
+		/* ptn */
+		/* (0x1<<16) | (0x1<<17) | (0x2)<<11 */
+		write_wvalue(addr, 0x31000);
+	} else if (rop3_cmd == G2D_ROP3_PATPAINT) {
+		/* DPSnoo */
+		/* (0x1<<3) | (0x1<<6) | (0x1<<11) */
+		write_wvalue(addr, 0x848);
+	} else if (rop3_cmd == G2D_ROP3_WHITENESS) {
+		/* whiteness */
+		write_wvalue(addr, 0x48000);
+	} else
+		return -1;
+	return 0;
+}
+
+/**
+ * background color set
+ */
+__s32 g2d_bk_set(__u32 color)
+{
+	write_wvalue(BLD_BK_COLOR, color & 0xffffffff);
+	return 0;
+}
+
+/**
+ * function       : g2d_vsu_calc_fir_coef(unsigned int step)
+ * description    : set fir coefficients
+ * parameters     :
+ *                  step		<horizontal scale ratio of vsu>
+ * return         :
+ *                  offset (in word) of coefficient table
+ */
+static __u32 g2d_vsu_calc_fir_coef(__u32 step)
+{
+	__u32 pt_coef;
+	__u32 scale_ratio, int_part, float_part, fir_coef_ofst;
+
+	scale_ratio = step >> (VSU_PHASE_FRAC_BITWIDTH - 3);
+	int_part = scale_ratio >> 3;
+	float_part = scale_ratio & 0x7;
+	fir_coef_ofst = (int_part == 0) ? VSU_ZOOM0_SIZE :
+	    (int_part == 1) ? VSU_ZOOM0_SIZE + float_part :
+	    (int_part ==
+	     2) ? VSU_ZOOM0_SIZE + VSU_ZOOM1_SIZE +
+	    (float_part >> 1) : (int_part ==
+				  3) ? VSU_ZOOM0_SIZE + VSU_ZOOM1_SIZE +
+	    VSU_ZOOM2_SIZE : (int_part ==
+			       4) ? VSU_ZOOM0_SIZE + VSU_ZOOM1_SIZE +
+	    VSU_ZOOM2_SIZE + VSU_ZOOM3_SIZE : VSU_ZOOM0_SIZE +
+	    VSU_ZOOM1_SIZE + VSU_ZOOM2_SIZE + VSU_ZOOM3_SIZE + VSU_ZOOM4_SIZE;
+	pt_coef = fir_coef_ofst * VSU_PHASE_NUM;
+	return pt_coef;
+}
+
+__s32 g2d_rop_by_pass(__u32 sel)
+{
+	if (sel == 0)
+		write_wvalue(ROP_CTL, 0xF0);
+
+	else if (sel == 1)
+		write_wvalue(ROP_CTL, 0x55F0);
+
+	else if (sel == 2)
+		write_wvalue(ROP_CTL, 0xAAF0);
+
+	else
+		return -1;
+	return 0;
+}
+
+__s32 g2d_vsu_para_set(__u32 fmt, __u32 in_w, __u32 in_h, __u32 out_w,
+			   __u32 out_h, __u8 alpha)
+{
+	__u32 i;
+	__u64 tmp, temp;
+	__u32 yhstep, yvstep;
+	__u32 incw, inch;
+	__u32 yhcoef_offset, yvcoef_offset, chcoef_offset;
+	__u32 format;
+
+	if (fmt > G2D_FORMAT_IYUV422_Y1U0Y0V0)
+		write_wvalue(VS_CTRL, 0x10101);
+
+	else
+		write_wvalue(VS_CTRL, 0x00000101);
+	tmp = ((out_h - 1) << 16) | (out_w - 1);
+	write_wvalue(VS_OUT_SIZE, tmp);
+	write_wvalue(VS_GLB_ALPHA, alpha & 0xff);
+	write_wvalue(VS_Y_SIZE, ((in_h - 1) << 16) | (in_w - 1));
+	temp = in_w << VSU_PHASE_FRAC_BITWIDTH;
+	if (out_w)
+		do_div(temp, out_w);
+
+	    /* temp = temp/out_w; */
+	else
+		temp = 0;
+	yhstep = temp;
+	write_wvalue(VS_Y_HSTEP, yhstep << 1);
+	temp = in_h << VSU_PHASE_FRAC_BITWIDTH;
+	if (out_h)
+		do_div(temp, out_h);
+	else
+		temp = 0;
+	yvstep = temp;
+	write_wvalue(VS_Y_VSTEP, yvstep << 1);
+	yhcoef_offset = g2d_vsu_calc_fir_coef(yhstep);
+	for (i = 0; i < VSU_PHASE_NUM; i++) {
+		write_wvalue(VS_Y_HCOEF0 + (i << 2),
+			      lan2coefftab32_full[yhcoef_offset + i]);
+	}
+	yvcoef_offset = g2d_vsu_calc_fir_coef(yvstep);
+	switch (fmt) {
+	case G2D_FORMAT_IYUV422_V0Y1U0Y0:
+	case G2D_FORMAT_IYUV422_Y1V0Y0U0:
+	case G2D_FORMAT_IYUV422_U0Y1V0Y0:
+	case G2D_FORMAT_IYUV422_Y1U0Y0V0:{
+			incw = (in_w + 1) >> 1;
+			inch = in_h;
+			format = VSU_FORMAT_YUV422;
+			write_wvalue(VS_C_SIZE,
+				      ((inch - 1) << 16) | (incw - 1));
+
+			    /* chstep = yhstep>>1 cvstep = yvstep */
+			    write_wvalue(VS_C_HSTEP, yhstep);
+			write_wvalue(VS_C_VSTEP, yvstep << 1);
+			chcoef_offset = g2d_vsu_calc_fir_coef(yhstep >> 1);
+			for (i = 0; i < VSU_PHASE_NUM; i++)
+				write_wvalue(VS_C_HCOEF0 + (i << 2),
+					      lan2coefftab32_full[chcoef_offset
+								  + i]);
+			for (i = 0; i < VSU_PHASE_NUM; i++)
+				write_wvalue(VS_Y_VCOEF0 + (i << 2),
+					      linearcoefftab32[i]);
+			break;
+		}
+	case G2D_FORMAT_YUV422UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV422UVC_U1V1U0V0:
+	case G2D_FORMAT_YUV422_PLANAR:{
+			incw = (in_w + 1) >> 1;
+			inch = in_h;
+			format = VSU_FORMAT_YUV422;
+			write_wvalue(VS_C_SIZE,
+				      ((inch - 1) << 16) | (incw - 1));
+
+			    /* chstep = yhstep>>1 cvstep = yvstep>>1 */
+			    write_wvalue(VS_C_HSTEP, yhstep);
+			write_wvalue(VS_C_VSTEP, yvstep << 1);
+			chcoef_offset = g2d_vsu_calc_fir_coef(yhstep >> 1);
+			for (i = 0; i < VSU_PHASE_NUM; i++)
+				write_wvalue(VS_C_HCOEF0 + (i << 2),
+					      lan2coefftab32_full[chcoef_offset
+								  + i]);
+			for (i = 0; i < VSU_PHASE_NUM; i++)
+				write_wvalue(VS_Y_VCOEF0 + (i << 2),
+					      lan2coefftab32_full[yvcoef_offset
+								  + i]);
+			break;
+		}
+	case G2D_FORMAT_YUV420_PLANAR:
+	case G2D_FORMAT_YUV420UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV420UVC_U1V1U0V0:{
+			incw = (in_w + 1) >> 1;
+			inch = (in_h + 1) >> 1;
+			format = VSU_FORMAT_YUV420;
+			write_wvalue(VS_C_SIZE,
+				      ((inch - 1) << 16) | (incw - 1));
+			write_wvalue(VS_C_HSTEP, yhstep);
+			write_wvalue(VS_C_VSTEP, yvstep);
+			chcoef_offset = g2d_vsu_calc_fir_coef(yhstep >> 1);
+			for (i = 0; i < VSU_PHASE_NUM; i++)
+				write_wvalue(VS_C_HCOEF0 + (i << 2),
+					      lan2coefftab32_full[chcoef_offset
+								  + i]);
+			for (i = 0; i < VSU_PHASE_NUM; i++)
+				write_wvalue(VS_Y_VCOEF0 + (i << 2),
+					      lan2coefftab32_full[yvcoef_offset
+								  + i]);
+			break;
+		}
+	case G2D_FORMAT_YUV411_PLANAR:
+	case G2D_FORMAT_YUV411UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV411UVC_U1V1U0V0:{
+			incw = (in_w + 3) >> 2;
+			inch = in_h;
+			format = VSU_FORMAT_YUV411;
+			write_wvalue(VS_C_SIZE,
+				      ((inch - 1) << 16) | (incw - 1));
+
+			    /* chstep = yhstep>>2 cvstep = yvstep */
+			    write_wvalue(VS_C_HSTEP, yhstep >> 1);
+			write_wvalue(VS_C_VSTEP, yvstep << 1);
+			chcoef_offset = g2d_vsu_calc_fir_coef(yhstep >> 2);
+			for (i = 0; i < VSU_PHASE_NUM; i++)
+				write_wvalue(VS_C_HCOEF0 + (i << 2),
+					      lan2coefftab32_full[chcoef_offset
+								  + i]);
+			for (i = 0; i < VSU_PHASE_NUM; i++)
+				write_wvalue(VS_Y_VCOEF0 + (i << 2),
+					      lan2coefftab32_full[yvcoef_offset
+								  + i]);
+			break;
+		}
+	default:
+		format = VSU_FORMAT_RGB;
+		incw = in_w;
+		inch = in_h;
+		write_wvalue(VS_C_SIZE, ((inch - 1) << 16) | (incw - 1));
+
+		    /* chstep = yhstep cvstep = yvstep */
+		    write_wvalue(VS_C_HSTEP, yhstep << 1);
+		write_wvalue(VS_C_VSTEP, yvstep << 1);
+		chcoef_offset = g2d_vsu_calc_fir_coef(yhstep);
+		for (i = 0; i < VSU_PHASE_NUM; i++)
+			write_wvalue(VS_C_HCOEF0 + (i << 2),
+				      lan2coefftab32_full[chcoef_offset + i]);
+		for (i = 0; i < VSU_PHASE_NUM; i++)
+			write_wvalue(VS_Y_VCOEF0 + (i << 2),
+				      linearcoefftab32[i]);
+		break;
+	}
+	if (format == VSU_FORMAT_YUV420) {
+
+		/**
+		 * yhphase = 0;
+		 * yvphase = 0;
+		 * chphase = 0xFFFE0000;
+		 * cvphase = 0xFFFE0000;
+		 */
+		write_wvalue(VS_Y_HPHASE, 0);
+		write_wvalue(VS_Y_VPHASE0, 0);
+		write_wvalue(VS_C_HPHASE, 0xFFFc0000);
+		write_wvalue(VS_C_VPHASE0, 0xFFFc0000);
+	}
+
+	else {
+		write_wvalue(VS_Y_HPHASE, 0);
+		write_wvalue(VS_Y_VPHASE0, 0);
+		write_wvalue(VS_C_HPHASE, 0);
+		write_wvalue(VS_C_VPHASE0, 0);
+	}
+	if (fmt >= G2D_FORMAT_IYUV422_Y1U0Y0V0)
+		write_wvalue(VS_CTRL, 0x10001);
+
+	else
+		write_wvalue(VS_CTRL, 0x00001);
+	return 0;
+}
+
+
+__s32 g2d_calc_coarse(__u32 format, __u32 inw, __u32 inh, __u32 outw,
+			  __u32 outh, __u32 *midw, __u32 *midh)
+{
+	__u32 tmp;
+
+	switch (format) {
+	case G2D_FORMAT_IYUV422_V0Y1U0Y0:
+	case G2D_FORMAT_IYUV422_Y1V0Y0U0:
+	case G2D_FORMAT_IYUV422_U0Y1V0Y0:
+	case G2D_FORMAT_IYUV422_Y1U0Y0V0:{
+		/* interleaved YUV422 format */
+		*midw = inw;
+		*midh = inh;
+		break;
+	}
+	case G2D_FORMAT_YUV422UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV422UVC_U1V1U0V0:
+	case G2D_FORMAT_YUV422_PLANAR:{
+		if (inw >= (outw << 3)) {
+			*midw = outw << 3;
+			tmp = (*midw << 16) | inw;
+			write_wvalue(V0_HDS_CTL0, tmp);
+			tmp = (*midw << 15) | ((inw + 1) >> 1);
+			write_wvalue(V0_HDS_CTL1, tmp);
+		} else
+			*midw = inw;
+		if (inh >= (outh << 2)) {
+			*midh = (outh << 2);
+			tmp = (*midh << 16) | inh;
+			write_wvalue(V0_VDS_CTL0, tmp);
+			write_wvalue(V0_VDS_CTL1, tmp);
+		} else
+			*midh = inh;
+		break;
+	}
+	case G2D_FORMAT_YUV420_PLANAR:
+	case G2D_FORMAT_YUV420UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV420UVC_U1V1U0V0:{
+		if (inw >= (outw << 3)) {
+			*midw = outw << 3;
+			tmp = (*midw << 16) | inw;
+			write_wvalue(V0_HDS_CTL0, tmp);
+			tmp = (*midw << 15) | ((inw + 1) >> 1);
+			write_wvalue(V0_HDS_CTL0, tmp);
+		} else
+			*midw = inw;
+		if (inh >= (outh << 2)) {
+			*midh = (outh << 2);
+			tmp = (*midh << 16) | inh;
+			write_wvalue(V0_VDS_CTL0, tmp);
+			tmp = (*midh << 15) | ((inh + 1) >> 1);
+			write_wvalue(V0_VDS_CTL1, tmp);
+		} else
+			*midh = inh;
+		break;
+	}
+	case G2D_FORMAT_YUV411_PLANAR:
+	case G2D_FORMAT_YUV411UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV411UVC_U1V1U0V0:{
+		if (inw >= (outw << 3)) {
+			*midw = outw << 3;
+			tmp = ((*midw) << 16) | inw;
+			write_wvalue(V0_HDS_CTL0, tmp);
+			tmp = ((*midw) << 14) | ((inw + 3) >> 2);
+			write_wvalue(V0_HDS_CTL1, tmp);
+		} else
+			*midw = inw;
+		if (inh >= (outh << 2)) {
+			*midh = (outh << 2);
+			tmp = ((*midh) << 16) | inh;
+			write_wvalue(V0_VDS_CTL0, tmp);
+			write_wvalue(V0_VDS_CTL1, tmp);
+		} else
+			*midh = inh;
+		break;
+	}
+	default:
+		if (inw >= (outw << 3)) {
+			*midw = outw << 3;
+			tmp = ((*midw) << 16) | inw;
+			write_wvalue(V0_HDS_CTL0, tmp);
+			write_wvalue(V0_HDS_CTL1, tmp);
+		} else
+			*midw = inw;
+		if (inh >= (outh << 2)) {
+			*midh = (outh << 2);
+			tmp = ((*midh) << 16) | inh;
+			write_wvalue(V0_VDS_CTL0, tmp);
+			write_wvalue(V0_VDS_CTL1, tmp);
+		} else
+			*midh = inh;
+		break;
+	}
+	return 0;
+}
+
+
+/*
+ * sel: 0-->pipe0 1-->pipe1 other:error
+ */
+__s32 g2d_bldin_set(__u32 sel, g2d_rect rect, int premul)
+{
+	__u32 tmp;
+	__u32 offset;
+
+	if (sel == 0) {
+		offset = 0;
+		tmp = read_wvalue(BLD_EN_CTL);
+		tmp |= 0x1 << 8;
+		write_wvalue(BLD_EN_CTL, tmp);
+		if (premul) {
+			tmp = read_wvalue(BLD_PREMUL_CTL);
+			tmp |= 0x1;
+			write_wvalue(BLD_PREMUL_CTL, tmp);
+		}
+	} else if (sel == 1) {
+		offset = 0x4;
+		tmp = read_wvalue(BLD_EN_CTL);
+		tmp |= 0x1 << 9;
+		write_wvalue(BLD_EN_CTL, tmp);
+		if (premul) {
+			tmp = read_wvalue(BLD_PREMUL_CTL);
+			tmp |= 0x1 << 1;
+			write_wvalue(BLD_PREMUL_CTL, tmp);
+		}
+	} else
+		return -1;
+	tmp = ((rect.h - 1) << 16) | (rect.w - 1);
+
+	G2D_INFO_MSG("BLD_CH_ISIZE W:  0x%x\n", rect.w);
+	G2D_INFO_MSG("BLD_CH_ISIZE H:  0x%x\n", rect.h);
+
+	write_wvalue(BLD_CH_ISIZE0 + offset, tmp);
+	tmp =
+	    ((rect.y <= 0 ? 0 : rect.y - 1) << 16) | (rect.x <=
+						      0 ? 0 : rect.x - 1);
+
+	G2D_INFO_MSG("BLD_CH_ISIZE X:  0x%x\n", rect.x);
+	G2D_INFO_MSG("BLD_CH_ISIZE Y:  0x%x\n", rect.y);
+
+	write_wvalue(BLD_CH_OFFSET0 + offset, tmp);
+	return 0;
+}
+
+/**
+ * set the bld color space based on the format
+ * if the format is UI, then set the bld in RGB color space
+ * if the format is Video, then set the bld in YUV color space
+ */
+__s32 g2d_bld_cs_set(__u32 format)
+{
+	__u32 tmp;
+
+	if (format <= G2D_FORMAT_BGRA1010102) {
+		tmp = read_wvalue(BLD_OUT_COLOR);
+		tmp &= 0xFFFFFFFD;
+		write_wvalue(BLD_OUT_COLOR, tmp);
+	} else if (format <= G2D_FORMAT_YUV411_PLANAR) {
+		tmp = read_wvalue(BLD_OUT_COLOR);
+		tmp |= 0x1 << 1;
+		write_wvalue(BLD_OUT_COLOR, tmp);
+	} else
+		return -1;
+	return 0;
+}
+
+__s32 mixer_fillrectangle(g2d_fillrect *para)
+{
+	g2d_image_enh src_tmp, dst_tmp;
+	g2d_image_enh *src = &src_tmp;
+	g2d_image_enh *dst = &dst_tmp;
+	__s32 result;
+
+	g2d_mixer_reset();
+	if (para->flag == G2D_FIL_NONE) {
+		pr_info("fc only!\n");
+		dst->bbuff = 1;
+		dst->color = para->color;
+		dst->format =
+			g2d_format_trans(para->dst_image.format,
+					para->dst_image.pixel_seq);
+		dst->laddr[0] = para->dst_image.addr[0];
+		dst->laddr[1] = para->dst_image.addr[1];
+		dst->laddr[2] = para->dst_image.addr[2];
+		dst->width = para->dst_image.w;
+		dst->height = para->dst_image.h;
+		dst->clip_rect.x = para->dst_rect.x;
+		dst->clip_rect.y = para->dst_rect.y;
+		dst->clip_rect.w = para->dst_rect.w;
+		dst->clip_rect.h = para->dst_rect.h;
+		dst->gamut = G2D_BT709;
+		dst->alpha = para->alpha;
+		dst->mode = 0;
+		result = g2d_fillrectangle(dst, dst->color);
+		return result;
+	}
+	dst->bbuff = 1;
+	dst->color = para->color;
+	dst->format =
+		g2d_format_trans(para->dst_image.format,
+				para->dst_image.pixel_seq);
+	dst->laddr[0] = para->dst_image.addr[0];
+	dst->laddr[1] = para->dst_image.addr[1];
+	dst->laddr[2] = para->dst_image.addr[2];
+	dst->width = para->dst_image.w;
+	dst->height = para->dst_image.h;
+	dst->clip_rect.x = para->dst_rect.x;
+	dst->clip_rect.y = para->dst_rect.y;
+	dst->clip_rect.w = para->dst_rect.w;
+	dst->clip_rect.h = para->dst_rect.h;
+	dst->gamut = G2D_BT709;
+	dst->alpha = para->alpha;
+	if (para->flag & G2D_FIL_PIXEL_ALPHA)
+		dst->mode = G2D_PIXEL_ALPHA;
+	if (para->flag & G2D_FIL_PLANE_ALPHA)
+		dst->mode = G2D_GLOBAL_ALPHA;
+	if (para->flag & G2D_FIL_MULTI_ALPHA)
+		dst->mode = G2D_MIXER_ALPHA;
+	src->bbuff = 0;
+	src->color = para->color;
+	src->format = dst->format;
+	src->gamut = G2D_BT709;
+	src->format = 0;
+	dst->laddr[0] = para->dst_image.addr[0];
+	src->width = para->dst_image.w;
+	src->height = para->dst_image.h;
+	src->clip_rect.x = para->dst_rect.x;
+	src->clip_rect.y = para->dst_rect.y;
+	src->clip_rect.w = para->dst_rect.w;
+	src->clip_rect.h = para->dst_rect.h;
+	result = g2d_bsp_bld(src, dst, G2D_BLD_DSTOVER, NULL);
+	return result;
+}
+
+__s32 g2d_fillrectangle(g2d_image_enh *dst, __u32 color_value)
+{
+	g2d_rect rect0;
+	__u32 tmp;
+	__s32 result;
+
+	g2d_bsp_reset();
+	/* set the input layer */
+	g2d_vlayer_set(0, dst);
+	/* set the fill color value */
+	g2d_fc_set(0, color_value);
+	if (dst->format >= G2D_FORMAT_IYUV422_V0Y1U0Y0) {
+		g2d_vsu_para_set(dst->format, dst->clip_rect.w,
+				  dst->clip_rect.h, dst->clip_rect.w,
+				  dst->clip_rect.h, 0xff);
+		g2d_csc_reg_set(1, G2D_RGB2YUV_709);
+	}
+
+	/* for interleaved test */
+	if ((dst->format >= G2D_FORMAT_IYUV422_V0Y1U0Y0)
+			&& (dst->format <= G2D_FORMAT_IYUV422_Y1U0Y0V0)) {
+		g2d_csc_reg_set(0, G2D_RGB2YUV_709);
+		g2d_csc_reg_set(2, G2D_RGB2YUV_709);
+		write_wvalue(BLD_CSC_CTL, 0x2);
+		g2d_bk_set(0xff123456);
+		porter_duff(G2D_BLD_SRCOVER);
+		write_wvalue(BLD_FILLC0, 0x00108080);
+		write_wvalue(BLD_FILLC1, 0x00108080);
+		write_wvalue(UI0_FILLC, 0xffffffff);
+		write_wvalue(UI1_FILLC, 0xffffffff);
+	}
+	rect0.x = 0;
+	rect0.y = 0;
+	rect0.w = dst->clip_rect.w;
+	rect0.h = dst->clip_rect.h;
+	g2d_bldin_set(0, rect0, dst->bpremul);
+	g2d_bld_cs_set(dst->format);
+
+	/* ROP sel ch0 pass */
+	write_wvalue(ROP_CTL, 0xf0);
+	g2d_wb_set(dst);
+
+	/* start the module */
+	mixer_irq_enable();
+	tmp = read_wvalue(G2D_MIXER_CTL);
+	tmp |= 0x80000000;
+	G2D_INFO_MSG("INIT_MODULE: 0x%x\n", tmp);
+	write_wvalue(G2D_MIXER_CTL, tmp);
+
+	result = g2d_wait_cmd_finish();
+	return result;
+}
+
+
+/**
+ * src:source
+ * ptn:pattern
+ * dst:destination
+ * mask:mask
+ * if mask is set to NULL, do ROP3 among src, ptn, and dst using the
+ * fore_flag
+ */
+__s32 g2d_bsp_maskblt(g2d_image_enh *src, g2d_image_enh *ptn,
+			  g2d_image_enh *mask, g2d_image_enh *dst,
+			  __u32 back_flag, __u32 fore_flag)
+{
+	__u32 tmp;
+	g2d_rect rect0;
+	bool b_pre;
+	__s32 result;
+
+	/* int b_pre; */
+	g2d_bsp_reset();
+	if (dst == NULL)
+		return -1;
+	if (dst->format > G2D_FORMAT_BGRA1010102)
+		return -2;
+	g2d_vlayer_set(0, dst);
+	if (src != NULL) {
+		src->clip_rect.w = dst->clip_rect.w;
+		src->clip_rect.h = dst->clip_rect.h;
+		g2d_uilayer_set(0, src);
+	}
+	if (ptn != NULL) {
+		ptn->clip_rect.w = dst->clip_rect.w;
+		ptn->clip_rect.h = dst->clip_rect.h;
+		g2d_uilayer_set(1, ptn);
+	}
+	if (mask != NULL) {
+		mask->clip_rect.w = dst->clip_rect.w;
+		mask->clip_rect.h = dst->clip_rect.h;
+		g2d_uilayer_set(2, mask);
+
+		/* set the ROP4 */
+		write_wvalue(ROP_CTL, 0x1);
+		g2d_rop3_set(0, back_flag & 0xff);
+		g2d_rop3_set(1, fore_flag & 0xff);
+	} else {
+		write_wvalue(ROP_CTL, 0x0);
+		g2d_rop3_set(0, back_flag);
+	}
+	b_pre = dst->bpremul;
+	if (src)
+		b_pre |= src->bpremul;
+	if (ptn)
+		b_pre |= ptn->bpremul;
+	if (b_pre) {
+		/* some layer is not premul */
+		if (!src->bpremul) {
+			tmp = read_wvalue(UI0_ATTR);
+			tmp |= 0x1 << 16;
+			write_wvalue(UI0_ATTR, tmp);
+		}
+		if (!dst->bpremul) {
+			tmp = read_wvalue(V0_ATTCTL);
+			tmp |= 0x1 << 16;
+			write_wvalue(V0_ATTCTL, tmp);
+		}
+		if (!ptn->bpremul) {
+			tmp = read_wvalue(UI1_ATTR);
+			tmp |= 0x1 << 16;
+			write_wvalue(UI1_ATTR, tmp);
+		}
+
+		    /* set bld in premul data */
+		    write_wvalue(BLD_PREMUL_CTL, 0x1);
+	}
+
+	/*set bld para */
+	rect0.x = 0;
+	rect0.y = 0;
+	rect0.w = dst->clip_rect.w;
+	rect0.h = dst->clip_rect.h;
+	g2d_bldin_set(0, rect0, dst->bpremul);
+	g2d_wb_set(dst);
+
+	/* start the module */
+	mixer_irq_enable();
+	tmp = read_wvalue(G2D_MIXER_CTL);
+	tmp |= 0x80000000;
+	G2D_INFO_MSG("INIT_MODULE: 0x%x\n", tmp);
+	write_wvalue(G2D_MIXER_CTL, tmp);
+
+	result = g2d_wait_cmd_finish();
+	return result;
+}
+
+__s32 g2d_format_trans(__s32 data_fmt, __s32 pixel_seq)
+{
+	/* transform the g2d format 2 enhance format */
+	switch (data_fmt) {
+	case G2D_FMT_ARGB_AYUV8888:
+		return G2D_FORMAT_ARGB8888;
+	case G2D_FMT_BGRA_VUYA8888:
+		return G2D_FORMAT_BGRA8888;
+	case G2D_FMT_ABGR_AVUY8888:
+		return G2D_FORMAT_ABGR8888;
+	case G2D_FMT_RGBA_YUVA8888:
+		return G2D_FORMAT_RGBA8888;
+	case G2D_FMT_XRGB8888:
+		return G2D_FORMAT_XRGB8888;
+	case G2D_FMT_BGRX8888:
+		return G2D_FORMAT_BGRX8888;
+	case G2D_FMT_XBGR8888:
+		return G2D_FORMAT_XBGR8888;
+	case G2D_FMT_RGBX8888:
+		return G2D_FORMAT_RGBX8888;
+	case G2D_FMT_ARGB4444:
+		return G2D_FORMAT_ARGB4444;
+	case G2D_FMT_ABGR4444:
+		return G2D_FORMAT_ABGR4444;
+	case G2D_FMT_RGBA4444:
+		return G2D_FORMAT_RGBA4444;
+	case G2D_FMT_BGRA4444:
+		return G2D_FORMAT_BGRA4444;
+	case G2D_FMT_ARGB1555:
+		return G2D_FORMAT_ARGB1555;
+	case G2D_FMT_ABGR1555:
+		return G2D_FORMAT_ABGR1555;
+	case G2D_FMT_RGBA5551:
+		return G2D_FORMAT_RGBA5551;
+	case G2D_FMT_BGRA5551:
+		return G2D_FORMAT_BGRA5551;
+	case G2D_FMT_RGB565:
+		return G2D_FORMAT_RGB565;
+	case G2D_FMT_BGR565:
+		return G2D_FORMAT_BGR565;
+	case G2D_FMT_IYUV422:
+		if (pixel_seq == G2D_SEQ_VYUY)
+			return G2D_FORMAT_IYUV422_V0Y1U0Y0;
+		if (pixel_seq == G2D_SEQ_YVYU)
+			return G2D_FORMAT_IYUV422_Y1V0Y0U0;
+		return -1;
+	case G2D_FMT_PYUV422UVC:
+		if (pixel_seq == G2D_SEQ_VUVU)
+			return G2D_FORMAT_YUV422UVC_V1U1V0U0;
+		return G2D_FORMAT_YUV422UVC_U1V1U0V0;
+	case G2D_FMT_PYUV420UVC:
+		if (pixel_seq == G2D_SEQ_VUVU)
+			return G2D_FORMAT_YUV420UVC_V1U1V0U0;
+		return G2D_FORMAT_YUV420UVC_U1V1U0V0;
+	case G2D_FMT_PYUV411UVC:
+		if (pixel_seq == G2D_SEQ_VUVU)
+			return G2D_FORMAT_YUV411UVC_V1U1V0U0;
+		return G2D_FORMAT_YUV411UVC_U1V1U0V0;
+	case G2D_FMT_PYUV422:
+		return G2D_FORMAT_YUV422_PLANAR;
+	case G2D_FMT_PYUV420:
+		return G2D_FORMAT_YUV420_PLANAR;
+	case G2D_FMT_PYUV411:
+		return G2D_FORMAT_YUV411_PLANAR;
+	default:
+		return -1;
+	}
+}
+
+__s32 mixer_stretchblt(g2d_stretchblt *para,
+			   enum g2d_scan_order scan_order)
+{
+	g2d_image_enh src_tmp, dst_tmp;
+	g2d_image_enh *src = &src_tmp, *dst = &dst_tmp;
+	g2d_ck ck_para_tmp;
+	g2d_ck *ck_para = &ck_para_tmp;
+	__s32 result;
+
+	memset(src, 0, sizeof(g2d_image_enh));
+	memset(dst, 0, sizeof(g2d_image_enh));
+	memset(ck_para, 0, sizeof(g2d_ck));
+
+	src->bbuff = 1;
+	src->color = para->color;
+	src->format =
+		g2d_format_trans(para->src_image.format,
+				para->src_image.pixel_seq);
+	src->laddr[0] = para->src_image.addr[0];
+	src->laddr[1] = para->src_image.addr[1];
+	src->laddr[2] = para->src_image.addr[2];
+	src->width = para->src_image.w;
+	src->height = para->src_image.h;
+	src->clip_rect.x = para->src_rect.x;
+	src->clip_rect.y = para->src_rect.y;
+	src->clip_rect.w = para->src_rect.w;
+	src->clip_rect.h = para->src_rect.h;
+	src->gamut = G2D_BT709;
+	src->alpha = para->alpha;
+	dst->bbuff = 1;
+	dst->color = para->color;
+	dst->format =
+		g2d_format_trans(para->dst_image.format,
+				para->dst_image.pixel_seq);
+	dst->laddr[0] = para->dst_image.addr[0];
+	dst->laddr[1] = para->dst_image.addr[1];
+	dst->laddr[2] = para->dst_image.addr[2];
+	dst->width = para->dst_image.w;
+	dst->height = para->dst_image.h;
+	dst->clip_rect.x = para->dst_rect.x;
+	dst->clip_rect.y = para->dst_rect.y;
+	dst->clip_rect.w = para->dst_rect.w;
+	dst->clip_rect.h = para->dst_rect.h;
+	dst->gamut = G2D_BT709;
+	dst->alpha = para->alpha;
+
+	if ((para->flag == G2D_BLT_NONE) ||
+	      (para->flag == G2D_BLT_FLIP_HORIZONTAL) ||
+	      (para->flag == G2D_BLT_FLIP_VERTICAL) ||
+	      (para->flag == G2D_BLT_ROTATE90) ||
+	      (para->flag == G2D_BLT_ROTATE180) ||
+	      (para->flag == G2D_BLT_ROTATE270) ||
+	      (para->flag == G2D_BLT_MIRROR45) ||
+	      (para->flag == G2D_BLT_MIRROR135)) {
+		/* ROT or scal case */
+		switch (para->flag) {
+		case G2D_BLT_NONE:
+			if ((dst->width == src->width) &&
+					(dst->height == src->height)) {
+				result = g2d_bsp_bitblt(src, dst, G2D_ROT_0);
+				return result;
+			}
+			if (scan_order == G2D_SM_DTLR)
+				result = g2d_bsp_bitblt(src, dst,
+						G2D_BLT_NONE | G2D_SM_DTLR_1);
+			else
+				result = g2d_bsp_bitblt(src, dst, G2D_BLT_NONE);
+			return result;
+		case G2D_BLT_FLIP_HORIZONTAL:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_H);
+			return result;
+		case G2D_BLT_FLIP_VERTICAL:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_V);
+			return result;
+		case G2D_BLT_ROTATE90:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_90);
+			return result;
+		case G2D_BLT_ROTATE180:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_180);
+			return result;
+		case G2D_BLT_ROTATE270:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_270);
+			return result;
+		case G2D_BLT_MIRROR45:
+			result = g2d_bsp_bitblt(src, dst,
+						G2D_ROT_90 | G2D_ROT_H);
+			return result;
+		case G2D_BLT_MIRROR135:
+			result = g2d_bsp_bitblt(src, dst,
+						G2D_ROT_90 | G2D_ROT_V);
+			return result;
+		default:
+			return -1;
+		}
+	} else {
+		if (para->flag & 0xfe0) {
+			pr_err("Wrong! mixer and rot cant use at same time!\n");
+			return -1;
+		}
+		if (para->flag & G2D_BLT_SRC_PREMULTIPLY)
+			src->bpremul = 1;
+		if (para->flag & G2D_BLT_DST_PREMULTIPLY)
+			dst->bpremul = 1;
+		if (para->flag & G2D_BLT_PIXEL_ALPHA) {
+			src->mode = G2D_PIXEL_ALPHA;
+			dst->mode = G2D_PIXEL_ALPHA;
+		}
+		if (para->flag & G2D_BLT_PLANE_ALPHA) {
+			src->mode = G2D_GLOBAL_ALPHA;
+			dst->mode = G2D_GLOBAL_ALPHA;
+		}
+		if (para->flag & G2D_BLT_MULTI_ALPHA) {
+			src->mode = G2D_MIXER_ALPHA;
+			dst->mode = G2D_MIXER_ALPHA;
+		}
+		ck_para->match_rule = 0;
+		ck_para->max_color = para->color;
+		ck_para->min_color = para->color;
+
+		result = g2d_bsp_bitblt(src, dst, G2D_BLT_NONE);
+
+		return result;
+	}
+}
+
+__s32 mixer_blt(g2d_blt *para, enum g2d_scan_order scan_order)
+{
+	g2d_image_enh src_tmp, dst_tmp;
+	g2d_image_enh *src = &src_tmp;
+	g2d_image_enh *dst = &dst_tmp;
+	g2d_ck ck_para_tmp;
+	g2d_ck *ck_para = &ck_para_tmp;
+	__s32 result;
+
+	memset(src, 0, sizeof(g2d_image_enh));
+	memset(dst, 0, sizeof(g2d_image_enh));
+	memset(ck_para, 0, sizeof(g2d_ck));
+
+	G2D_INFO_MSG("Input_G2D_Format:  0x%x\n", para->src_image.format);
+	G2D_INFO_MSG("BITBLT_flag:  0x%x\n", para->flag);
+	G2D_INFO_MSG("inPICWidth:  %d\n", para->src_image.w);
+	G2D_INFO_MSG("inPICHeight: %d\n", para->src_image.h);
+	G2D_INFO_MSG("inRectX:  %d\n", para->src_rect.x);
+	G2D_INFO_MSG("inRectY: %d\n", para->src_rect.y);
+	G2D_INFO_MSG("inRectW:  %d\n", para->src_rect.w);
+	G2D_INFO_MSG("inRectH: %d\n", para->src_rect.h);
+	G2D_INFO_MSG("Output_G2D_Format:  0x%x\n", para->dst_image.format);
+	G2D_INFO_MSG("outPICWidth:  %d\n", para->dst_image.w);
+	G2D_INFO_MSG("outPICHeight: %d\n", para->dst_image.h);
+	G2D_INFO_MSG("outRectX:  %d\n", para->dst_x);
+	G2D_INFO_MSG("outRectY: %d\n", para->dst_y);
+	src->bbuff = 1;
+	src->color = para->color;
+	src->format =
+			g2d_format_trans(para->src_image.format,
+					para->src_image.pixel_seq);
+	src->laddr[0] = para->src_image.addr[0];
+	src->laddr[1] = para->src_image.addr[1];
+	src->laddr[2] = para->src_image.addr[2];
+	src->width = para->src_image.w;
+	src->height = para->src_image.h;
+	src->clip_rect.x = para->src_rect.x;
+	src->clip_rect.y = para->src_rect.y;
+	src->clip_rect.w = para->src_rect.w;
+	src->clip_rect.h = para->src_rect.h;
+	src->gamut = G2D_BT709;
+	src->alpha = para->alpha;
+	dst->bbuff = 1;
+	dst->format =
+		g2d_format_trans(para->dst_image.format,
+						para->dst_image.pixel_seq);
+	dst->laddr[0] = para->dst_image.addr[0];
+	dst->laddr[1] = para->dst_image.addr[1];
+	dst->laddr[2] = para->dst_image.addr[2];
+	dst->width = para->dst_image.w;
+	dst->height = para->dst_image.h;
+	dst->clip_rect.x = para->dst_x;
+	dst->clip_rect.y = para->dst_y;
+	dst->clip_rect.w = src->clip_rect.w;
+	dst->clip_rect.h = src->clip_rect.h;
+	dst->gamut = G2D_BT709;
+	dst->alpha = para->alpha;
+
+	G2D_INFO_MSG("inPICaddr0: 0x%x\n", src->laddr[0]);
+	G2D_INFO_MSG("inPICaddr1: 0x%x\n", src->laddr[1]);
+	G2D_INFO_MSG("inPICaddr2: 0x%x\n", src->laddr[2]);
+	G2D_INFO_MSG("outPICaddr0: 0x%x\n", dst->laddr[0]);
+	G2D_INFO_MSG("outPICaddr1: 0x%x\n", dst->laddr[1]);
+	G2D_INFO_MSG("outPICaddr2: 0x%x\n", dst->laddr[2]);
+
+	if ((para->flag == G2D_BLT_NONE) ||
+	      (para->flag == G2D_BLT_FLIP_HORIZONTAL) ||
+	      (para->flag == G2D_BLT_FLIP_VERTICAL) ||
+	      (para->flag == G2D_BLT_ROTATE90) ||
+	      (para->flag == G2D_BLT_ROTATE180) ||
+	      (para->flag == G2D_BLT_ROTATE270) ||
+	      (para->flag == G2D_BLT_MIRROR45) ||
+	      (para->flag == G2D_BLT_MIRROR135)) {
+		/* ROT case */
+		switch (para->flag) {
+		case G2D_BLT_NONE:
+			if ((dst->width == src->width) &&
+					(dst->height == src->height)) {
+				result = g2d_bsp_bitblt(src, dst, G2D_ROT_0);
+				return result;
+			}
+			if (scan_order == G2D_SM_DTLR)
+				result = g2d_bsp_bitblt(src, dst,
+						G2D_BLT_NONE | G2D_SM_DTLR_1);
+			else
+				result = g2d_bsp_bitblt(src, dst, G2D_BLT_NONE);
+			return result;
+		case G2D_BLT_FLIP_HORIZONTAL:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_H);
+			return result;
+		case G2D_BLT_FLIP_VERTICAL:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_V);
+			return result;
+		case G2D_BLT_ROTATE90:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_90);
+			return result;
+		case G2D_BLT_ROTATE180:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_180);
+			return result;
+		case G2D_BLT_ROTATE270:
+			result = g2d_bsp_bitblt(src, dst, G2D_ROT_270);
+			return result;
+		case G2D_BLT_MIRROR45:
+			result = g2d_bsp_bitblt(src, dst,
+						G2D_ROT_90 | G2D_ROT_H);
+			return result;
+		case G2D_BLT_MIRROR135:
+			result = g2d_bsp_bitblt(src, dst,
+						G2D_ROT_90 | G2D_ROT_V);
+			return result;
+		default:
+			return -1;
+		}
+	} else {
+		if (para->flag & 0xfe0) {
+			pr_err("Wrong! mixer and rot cant use at same time!\n");
+			return -1;
+		}
+		if (para->flag & G2D_BLT_SRC_PREMULTIPLY)
+			src->bpremul = 1;
+		if (para->flag & G2D_BLT_DST_PREMULTIPLY)
+			dst->bpremul = 1;
+		if (para->flag & G2D_BLT_PIXEL_ALPHA) {
+			src->mode = G2D_PIXEL_ALPHA;
+			dst->mode = G2D_PIXEL_ALPHA;
+		}
+		if (para->flag & G2D_BLT_PLANE_ALPHA) {
+			src->mode = G2D_GLOBAL_ALPHA;
+			dst->mode = G2D_GLOBAL_ALPHA;
+		}
+		if (para->flag & G2D_BLT_MULTI_ALPHA) {
+			src->mode = G2D_MIXER_ALPHA;
+			dst->mode = G2D_MIXER_ALPHA;
+		}
+		ck_para->match_rule = 0;
+		ck_para->max_color = para->color;
+		ck_para->min_color = para->color;
+
+		result = g2d_bsp_bld(src, dst, G2D_BLD_DSTOVER, NULL);
+
+		return result;
+	}
+}
+
+__s32 g2d_bsp_bitblt(g2d_image_enh *src, g2d_image_enh *dst, __u32 flag)
+{
+	g2d_rect rect0, rect1;
+	bool bpre;
+	__u32 ycnt, ucnt, vcnt;
+	__u32 pitch0, pitch1, pitch2;
+	__u64 addr0, addr1, addr2;
+	__u32 midw, midh;
+	__u32 tmp;
+	__u32 ch, cw, cy, cx;
+	__s32 result;
+
+	g2d_bsp_reset();
+	if (dst == NULL) {
+		pr_err("[G2D]dst image is NULL!\n");
+		return -1;
+	}
+	if (src == NULL) {
+		pr_err("[G2D]src image is NULL!\n");
+		return -2;
+	}
+	G2D_INFO_MSG("BITBLT_flag:  0x%x\n", flag);
+	if (G2D_BLT_NONE == (flag & 0x0fffffff)) {
+		G2D_INFO_MSG("Input info:---------------------------------\n");
+		G2D_INFO_MSG("Src_fd:  %d\n", src->fd);
+		G2D_INFO_MSG("Format:  0x%x\n", src->format);
+		G2D_INFO_MSG("BITBLT_alpha_mode:  0x%x\n", src->mode);
+		G2D_INFO_MSG("BITBLT_alpha_val:  0x%x\n", src->alpha);
+		G2D_INFO_MSG("inClipRectX:  %d\n", src->clip_rect.x);
+		G2D_INFO_MSG("inClipRectY: %d\n", src->clip_rect.y);
+		G2D_INFO_MSG("inClipRectW:  %d\n", src->clip_rect.w);
+		G2D_INFO_MSG("inClipRectH: %d\n", src->clip_rect.h);
+
+		G2D_INFO_MSG("Output info:--------------------------------\n");
+		G2D_INFO_MSG("Dst_fd:  %d\n", dst->fd);
+		G2D_INFO_MSG("Format:  0x%x\n", dst->format);
+		G2D_INFO_MSG("outClipRectX:  %d\n", dst->clip_rect.x);
+		G2D_INFO_MSG("outClipRectY: %d\n", dst->clip_rect.y);
+		G2D_INFO_MSG("outClipRectW:  %d\n", dst->clip_rect.w);
+		G2D_INFO_MSG("outClipRectH: %d\n", dst->clip_rect.h);
+		/*single src opt */
+		g2d_vlayer_set(0, src);
+		if (src->mode) {
+			/* need abp process */
+			g2d_uilayer_set(2, dst);
+		}
+		if ((src->format >= G2D_FORMAT_IYUV422_V0Y1U0Y0) ||
+				(src->clip_rect.w != dst->clip_rect.w) ||
+				(src->clip_rect.h != dst->clip_rect.h)) {
+			g2d_calc_coarse(src->format, src->clip_rect.w,
+					src->clip_rect.h, dst->clip_rect.w,
+					dst->clip_rect.h, &midw, &midh);
+			g2d_vsu_para_set(src->format, midw, midh,
+					dst->clip_rect.w, dst->clip_rect.h,
+					0xff);
+		}
+		write_wvalue(ROP_CTL, 0xf0);
+		/*set bld para */
+		rect0.x = 0;
+		rect0.y = 0;
+		rect0.w = dst->clip_rect.w;
+		rect0.h = dst->clip_rect.h;
+		g2d_bldin_set(0, rect0, dst->bpremul);
+		g2d_bld_cs_set(src->format);
+		if (src->mode) {
+			/* need abp process */
+			rect1.x = 0;
+			rect1.y = 0;
+			rect1.w = dst->clip_rect.w;
+			rect1.h = dst->clip_rect.h;
+			g2d_bldin_set(1, rect1, dst->bpremul);
+		}
+		if ((src->format <= G2D_FORMAT_BGRA1010102) &&
+		      (dst->format > G2D_FORMAT_BGRA1010102)) {
+			if (dst->clip_rect.w <= 1280 && dst->clip_rect.h <= 720)
+				g2d_csc_reg_set(2, G2D_RGB2YUV_601);
+			else
+				g2d_csc_reg_set(2, G2D_RGB2YUV_709);
+		}
+		if ((src->format > G2D_FORMAT_BGRA1010102) &&
+		      (dst->format <= G2D_FORMAT_BGRA1010102)) {
+			if (dst->clip_rect.w <= 1280 && dst->clip_rect.h <= 720)
+				g2d_csc_reg_set(2, G2D_YUV2RGB_601);
+			else
+				g2d_csc_reg_set(2, G2D_YUV2RGB_709);
+		}
+		g2d_wb_set(dst);
+	}
+
+	else if (flag & 0xff) {
+		/* ROP2 operate */
+		if ((src->format > G2D_FORMAT_BGRA1010102) | (dst->format >
+					G2D_FORMAT_BGRA1010102))
+			return -3;
+		g2d_uilayer_set(0, dst);
+		g2d_vlayer_set(0, src);
+
+		/* bpre = 0; */
+		bpre = false;
+		if (src->bpremul || dst->bpremul) {
+			bpre = true;
+			/* bpre = 1; */
+			/* some layer is premul */
+			if (!src->bpremul) {
+				tmp = read_wvalue(V0_ATTCTL);
+				tmp |= 0x1 << 16;
+				write_wvalue(V0_ATTCTL, tmp);
+			}
+			if (!dst->bpremul) {
+				tmp = read_wvalue(UI0_ATTR);
+				tmp |= 0x1 << 16;
+				write_wvalue(UI0_ATTR, tmp);
+			}
+		}
+		if ((src->clip_rect.w != dst->clip_rect.w)
+		      || (src->clip_rect.h != dst->clip_rect.h)) {
+			g2d_calc_coarse(src->format, src->clip_rect.w,
+					 src->clip_rect.h, dst->clip_rect.w,
+					 dst->clip_rect.h, &midw, &midh);
+			g2d_vsu_para_set(src->format, midw, midh,
+					   dst->clip_rect.w, dst->clip_rect.h,
+					   0xff);
+		}
+		write_wvalue(ROP_CTL, 0x0);
+		g2d_rop2_set(flag & 0xff);
+		tmp = read_wvalue(ROP_INDEX0);
+		tmp |= 0x2;
+		write_wvalue(ROP_INDEX0, tmp);
+
+		/*set bld para */
+		rect0.x = 0;
+		rect0.y = 0;
+		rect0.w = dst->clip_rect.w;
+		rect0.h = dst->clip_rect.h;
+		g2d_bldin_set(0, rect0, bpre);
+		g2d_wb_set(dst);
+	}
+
+	else if (flag & 0xff00) {
+		/* ROT operate */
+		tmp = 1;
+		if (flag & G2D_ROT_H)
+			tmp |= 0x1 << 7;
+		if (flag & G2D_ROT_V)
+			tmp |= 0x1 << 6;
+		if ((flag & 0xf00) == G2D_ROT_90)
+			tmp |= 0x1 << 4;
+		if ((flag & 0xf00) == G2D_ROT_180)
+			tmp |= 0x2 << 4;
+		if ((flag & 0xf00) == G2D_ROT_270)
+			tmp |= 0x3 << 4;
+		if ((flag & 0xf00) == G2D_ROT_0)
+			tmp |= 0x0 << 4;
+
+		G2D_INFO_MSG("ROT input info: ----------------------------\n");
+		G2D_INFO_MSG("Src_fd:  %d\n", src->fd);
+		G2D_INFO_MSG("Format:  0x%x\n", src->format);
+		G2D_INFO_MSG("Flag:  0x%x\n", flag);
+		G2D_INFO_MSG("inClipRectX:  %d\n", src->clip_rect.x);
+		G2D_INFO_MSG("inClipRectY: %d\n", src->clip_rect.y);
+		G2D_INFO_MSG("inClipRectW:  %d\n", src->clip_rect.w);
+		G2D_INFO_MSG("inClipRectH: %d\n", src->clip_rect.h);
+
+		write_wvalue(ROT_CTL, tmp);
+		write_wvalue(ROT_IFMT, src->format & 0x3F);
+		write_wvalue(ROT_ISIZE,
+			      ((((src->clip_rect.h -
+				  1) & 0x1fff) << 16)) | ((src->clip_rect.w -
+							    1) & 0x1fff));
+
+		G2D_INFO_MSG("ROT_IFMT: 0x%x\n", read_wvalue(ROT_IFMT));
+		G2D_INFO_MSG("ROT_ISIZE: 0x%x\n", read_wvalue(ROT_ISIZE));
+		G2D_INFO_MSG("SRC_align: %d, %d, %d\n",
+				src->align[0], src->align[1], src->align[2]);
+		G2D_INFO_MSG("DST_align: %d, %d, %d\n",
+				dst->align[0], dst->align[1], dst->align[2]);
+
+		if ((src->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0)
+			&& (src->format <= G2D_FORMAT_YUV422_PLANAR)) {
+			cw = src->width >> 1;
+			ch = src->height;
+			cx = src->clip_rect.x >> 1;
+			cy = src->clip_rect.y;
+		}
+
+		else if ((src->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0)
+			&& (src->format <= G2D_FORMAT_YUV420_PLANAR)) {
+			cw = src->width >> 1;
+			ch = src->height >> 1;
+			cx = src->clip_rect.x >> 1;
+			cy = src->clip_rect.y >> 1;
+		}
+
+		else if ((src->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0)
+			&& (src->format <= G2D_FORMAT_YUV411_PLANAR)) {
+			cw = src->width >> 2;
+			ch = src->height;
+			cx = src->clip_rect.x >> 2;
+			cy = src->clip_rect.y;
+		}
+
+		else {
+			cw = 0;
+			ch = 0;
+			cx = 0;
+			cy = 0;
+		}
+
+		g2d_byte_cal(src->format, &ycnt, &ucnt, &vcnt);
+		pitch0 = cal_align(ycnt * src->width, src->align[0]);
+		write_wvalue(ROT_IPITCH0, pitch0);
+		pitch1 = cal_align(ucnt * cw, src->align[1]);
+		write_wvalue(ROT_IPITCH1, pitch1);
+		pitch2 = cal_align(vcnt * cw, src->align[2]);
+		write_wvalue(ROT_IPITCH2, pitch2);
+
+		G2D_INFO_MSG("ROT_InPITCH: %d, %d, %d\n",
+				pitch0, pitch1, pitch2);
+		G2D_INFO_MSG("SRC_ADDR0: 0x%x\n", src->laddr[0]);
+		G2D_INFO_MSG("SRC_ADDR1: 0x%x\n", src->laddr[1]);
+		G2D_INFO_MSG("SRC_ADDR2: 0x%x\n", src->laddr[2]);
+
+		addr0 =
+		    src->laddr[0] + ((__u64) src->haddr[0] << 32) +
+		    pitch0 * src->clip_rect.y + ycnt * src->clip_rect.x;
+		write_wvalue(ROT_ILADD0, addr0 & 0xffffffff);
+		write_wvalue(ROT_IHADD0, (addr0 >> 32) & 0xff);
+		addr1 =
+		    src->laddr[1] + ((__u64) src->haddr[1] << 32) +
+		    pitch1 * cy + ucnt * cx;
+		write_wvalue(ROT_ILADD1, addr1 & 0xffffffff);
+		write_wvalue(ROT_IHADD1, (addr1 >> 32) & 0xff);
+		addr2 =
+		    src->laddr[2] + ((__u64) src->haddr[2] << 32) +
+		    pitch2 * cy + vcnt * cx;
+		write_wvalue(ROT_ILADD2, addr2 & 0xffffffff);
+		write_wvalue(ROT_IHADD2, (addr2 >> 32) & 0xff);
+
+		if (((flag & 0xf00) == G2D_ROT_90) | ((flag & 0xf00) ==
+							G2D_ROT_270)) {
+			dst->clip_rect.w = src->clip_rect.h;
+			dst->clip_rect.h = src->clip_rect.w;
+		}
+
+		else {
+			dst->clip_rect.w = src->clip_rect.w;
+			dst->clip_rect.h = src->clip_rect.h;
+		}
+		write_wvalue(ROT_OSIZE,
+			       ((((dst->clip_rect.h -
+				   1) & 0x1fff) << 16)) | ((dst->clip_rect.w -
+							     1) & 0x1fff));
+		/* YUV output fmt only support 420 */
+		if (src->format == G2D_FORMAT_YUV422UVC_V1U1V0U0)
+			dst->format = G2D_FORMAT_YUV420UVC_V1U1V0U0;
+		else if (src->format == G2D_FORMAT_YUV422UVC_U1V1U0V0)
+			dst->format = G2D_FORMAT_YUV420UVC_U1V1U0V0;
+		else if (src->format == G2D_FORMAT_YUV422_PLANAR)
+			dst->format = G2D_FORMAT_YUV420_PLANAR;
+		else
+			dst->format = src->format;
+
+		if ((dst->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0)
+			&& (dst->format <= G2D_FORMAT_YUV422_PLANAR)) {
+			cw = dst->width >> 1;
+			ch = dst->height;
+			cx = dst->clip_rect.x >> 1;
+			cy = dst->clip_rect.y;
+		}
+
+		else if ((dst->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0)
+			&& (dst->format <= G2D_FORMAT_YUV420_PLANAR)) {
+			cw = dst->width >> 1;
+			ch = dst->height >> 1;
+			cx = dst->clip_rect.x >> 1;
+			cy = dst->clip_rect.y >> 1;
+		}
+
+		else if ((dst->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0)
+			&& (dst->format <= G2D_FORMAT_YUV411_PLANAR)) {
+			cw = dst->width >> 2;
+			ch = dst->height;
+			cx = dst->clip_rect.x >> 2;
+			cy = dst->clip_rect.y;
+		}
+
+		else {
+			cw = 0;
+			ch = 0;
+			cx = 0;
+			cy = 0;
+		}
+
+		g2d_byte_cal(dst->format, &ycnt, &ucnt, &vcnt);
+		G2D_INFO_MSG("ROT output info: ----------------------------\n");
+		G2D_INFO_MSG("Dst_fd:  %d\n", dst->fd);
+		G2D_INFO_MSG("Format:  0x%x\n", dst->format);
+
+		pitch0 = cal_align(ycnt * dst->width, dst->align[0]);
+		write_wvalue(ROT_OPITCH0, pitch0);
+		pitch1 = cal_align(ucnt * cw, dst->align[1]);
+		write_wvalue(ROT_OPITCH1, pitch1);
+		pitch2 = cal_align(vcnt * cw, dst->align[2]);
+		write_wvalue(ROT_OPITCH2, pitch2);
+
+		G2D_INFO_MSG("ROT_OutPITCH: %d, %d, %d\n",
+				pitch0, pitch1, pitch2);
+		G2D_INFO_MSG("outClipRectX:  %d\n", dst->clip_rect.x);
+		G2D_INFO_MSG("outClipRectY: %d\n", dst->clip_rect.y);
+		G2D_INFO_MSG("outClipRectW:  %d\n", dst->clip_rect.w);
+		G2D_INFO_MSG("outClipRectH: %d\n", dst->clip_rect.h);
+		addr0 =
+		    dst->laddr[0] + ((__u64) dst->haddr[0] << 32) +
+		    pitch0 * dst->clip_rect.y + ycnt * dst->clip_rect.x;
+		write_wvalue(ROT_OLADD0, addr0 & 0xffffffff);
+		write_wvalue(ROT_OHADD0, (addr0 >> 32) & 0xff);
+		addr1 =
+		    dst->laddr[1] + ((__u64) dst->haddr[1] << 32) +
+		    pitch1 * cy + ucnt * cx;
+		write_wvalue(ROT_OLADD1, addr1 & 0xffffffff);
+		write_wvalue(ROT_OHADD1, (addr1 >> 32) & 0xff);
+		addr2 =
+		    dst->laddr[2] + ((__u64) dst->haddr[2] << 32) +
+		    pitch2 * cy + vcnt * cx;
+		write_wvalue(ROT_OLADD2, addr2 & 0xffffffff);
+		write_wvalue(ROT_OHADD2, (addr2 >> 32) & 0xff);
+
+		G2D_INFO_MSG("DST_ADDR0: 0x%x\n", dst->laddr[0]);
+		G2D_INFO_MSG("DST_ADDR1: 0x%x\n", dst->laddr[1]);
+		G2D_INFO_MSG("DST_ADDR2: 0x%x\n", dst->laddr[2]);
+
+		/* start the module */
+		rot_irq_enable();
+		tmp = read_wvalue(ROT_CTL);
+		tmp |= (0x1 << 31);
+		G2D_INFO_MSG("init_module: 0x%x\n", tmp);
+		write_wvalue(ROT_CTL, tmp);
+
+		result = g2d_wait_cmd_finish();
+
+		return result;
+	}
+	g2d_scan_order_fun(flag & 0xf0000000);
+
+	/* start the module */
+	mixer_irq_enable();
+	tmp = read_wvalue(G2D_MIXER_CTL);
+	tmp |= 0x80000000;
+	G2D_INFO_MSG("INIT_MODULE: 0x%x\n", tmp);
+	write_wvalue(G2D_MIXER_CTL, tmp);
+
+	result = g2d_wait_cmd_finish();
+	return result;
+}
+
+__s32 g2d_bsp_bld(g2d_image_enh *src, g2d_image_enh *dst, __u32 flag,
+		    g2d_ck *ck_para)
+{
+	g2d_rect rect0, rect1;
+	__u32 tmp;
+	__s32 result;
+
+	if (dst == NULL)
+		return -1;
+	g2d_mixer_reset();
+	g2d_vlayer_set(0, dst);
+	g2d_uilayer_set(2, src);
+	if ((dst->format > G2D_FORMAT_BGRA1010102) &&
+			(src->format <= G2D_FORMAT_BGRA1010102))
+		g2d_csc_reg_set(1, G2D_RGB2YUV_709);
+	write_wvalue(ROP_CTL, 0xF0);
+
+	rect0.x = 0;
+	rect0.y = 0;
+	rect0.w = dst->clip_rect.w;
+	rect0.h = dst->clip_rect.h;
+
+	rect1.x = 0;
+	rect1.y = 0;
+	rect1.w = src->clip_rect.w;
+	rect1.h = src->clip_rect.h;
+	g2d_bldin_set(0, rect0, dst->bpremul);
+	g2d_bldin_set(1, rect1, src->bpremul);
+
+	G2D_INFO_MSG("BLD_FLAG:  0x%x\n", flag);
+
+	porter_duff(flag & 0xFFF);
+	if (flag & G2D_CK_SRC)
+		write_wvalue(BLD_KEY_CTL, 0x3);
+
+	else if (flag & G2D_CK_DST)
+		write_wvalue(BLD_KEY_CTL, 0x1);
+	if (ck_para != NULL)
+		ck_para_set(ck_para);
+	g2d_wb_set(dst);
+	g2d_bld_cs_set(dst->format);
+
+	/* start the modult */
+	mixer_irq_enable();
+	tmp = read_wvalue(G2D_MIXER_CTL);
+	tmp |= 0x80000000;
+	G2D_INFO_MSG("INIT_MODULE: 0x%x\n", tmp);
+	write_wvalue(G2D_MIXER_CTL, tmp);
+
+	result = g2d_wait_cmd_finish();
+	return result;
+}
+
+__s32 g2d_get_clk_cnt(__u32 *clk)
+{
+	__s32 ret;
+
+	ret = read_wvalue(G2D_MIXER_CLK);
+	if (ret != 0)
+		return -1;
+
+	    /* clear clk cnt */
+	    write_wvalue(G2D_MIXER_CLK, 0);
+	return 0;
+}
+
+__u32 mixer_set_reg_base(unsigned long addr)
+{
+	base_addr = addr;
+	return 0;
+}
+
diff --git a/drivers/char/sunxi_g2d/g2d_driver.c b/drivers/char/sunxi_g2d/g2d_driver.c
new file mode 100644
index 000000000..0b04cd413
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_driver.c
@@ -0,0 +1,1818 @@
+/*
+ * Allwinner SoCs g2d driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include "g2d_driver_i.h"
+#include <linux/g2d_driver.h>
+
+#define CREATE_TRACE_POINTS
+#include "g2d_trace.h"
+
+#if defined(CONFIG_SUNXI_SYNCFENCE)
+extern int syncfence_init(void);
+extern void syncfence_exit(void);
+#endif
+
+/* alloc based on 4K byte */
+#define G2D_BYTE_ALIGN(x) (((x + (4*1024-1)) >> 12) << 12)
+static struct info_mem g2d_mem[MAX_G2D_MEM_INDEX];
+static int g2d_mem_sel;
+static enum g2d_scan_order scan_order;
+static struct mutex global_lock;
+
+static struct class *g2d_class;
+static struct cdev *g2d_cdev;
+static dev_t devid;
+static struct device *g2d_dev;
+static struct device *dmabuf_dev;
+__g2d_drv_t g2d_ext_hd;
+__g2d_info_t para;
+
+u32 dbg_info;
+u32 time_info;
+
+struct dmabuf_item {
+	struct list_head list;
+	int fd;
+	struct dma_buf *buf;
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt;
+	dma_addr_t dma_addr;
+	unsigned long long id;
+};
+
+#if !defined(CONFIG_OF)
+static struct resource g2d_resource[2] = {
+
+	[0] = {
+	       .start = SUNXI_MP_PBASE,
+	       .end = SUNXI_MP_PBASE + 0x000fffff,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INTC_IRQNO_DE_MIX,
+	       .end = INTC_IRQNO_DE_MIX,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+#endif
+
+static ssize_t g2d_debug_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "debug=%d\n", dbg_info);
+}
+
+static ssize_t g2d_debug_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	if (strncasecmp(buf, "1", 1) == 0)
+		dbg_info = 1;
+	else if (strncasecmp(buf, "0", 1) == 0)
+		dbg_info = 0;
+	else
+		WARNING("Error input!\n");
+
+	return count;
+}
+
+static DEVICE_ATTR(debug, 0660,
+		   g2d_debug_show, g2d_debug_store);
+
+static ssize_t g2d_func_runtime_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "func_runtime=%d\n", time_info);
+}
+
+static ssize_t g2d_func_runtime_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	if (strncasecmp(buf, "1", 1) == 0)
+		time_info = 1;
+	else if (strncasecmp(buf, "0", 1) == 0)
+		time_info = 0;
+	else
+		WARNING("Error input!\n");
+
+	return count;
+}
+
+static DEVICE_ATTR(func_runtime, 0660,
+		   g2d_func_runtime_show, g2d_func_runtime_store);
+
+static ssize_t g2d_standby_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	if (strncasecmp(buf, "suspend", 7) == 0) {
+		pr_info("[G2D]:self suspend\n");
+		g2d_suspend(NULL);
+	} else if (strncasecmp(buf, "resume", 6) == 0) {
+		pr_info("[G2D]:self resume\n");
+		g2d_resume(NULL);
+	} else
+		WARNING("Error input!\n");
+
+	return count;
+}
+
+static DEVICE_ATTR(standby, 0660, NULL, g2d_standby_store);
+
+static struct attribute *g2d_attributes[] = {
+	&dev_attr_debug.attr,
+	&dev_attr_func_runtime.attr,
+	&dev_attr_standby.attr,
+	NULL
+};
+
+static struct attribute_group g2d_attribute_group = {
+	.name = "attr",
+	.attrs = g2d_attributes
+};
+
+static int g2d_clock_enable(const __g2d_info_t *info)
+{
+	int ret = 0;
+	if (info->reset) {
+		ret = reset_control_deassert(info->reset);
+		if (ret != 0) {
+			pr_err("[G2D] deassert error\n");
+			return ret;
+		}
+	}
+
+	if (info->bus_clk) {
+		ret |=  clk_prepare_enable(info->bus_clk);
+	}
+
+	if (info->clk) {
+		if (info->clk_parent) {
+			clk_set_parent(info->clk, info->clk_parent);
+		}
+		ret |= clk_prepare_enable(info->clk);
+	}
+	if (info->mbus_clk) {
+		ret |= clk_prepare_enable(info->mbus_clk);
+	}
+	if (ret != 0)
+		pr_err("[G2D] clock enable error\n");
+
+	return ret;
+}
+
+static int g2d_clock_disable(const __g2d_info_t *info)
+{
+	if (info->clk)
+		clk_disable(info->clk);
+	if (info->bus_clk)
+		clk_disable(info->bus_clk);
+	if (info->mbus_clk)
+		clk_disable(info->mbus_clk);
+	if (info->reset)
+		reset_control_assert(info->reset);
+	return 0;
+}
+
+#ifdef G2D_V2X_SUPPORT
+static int g2d_dma_map(int fd, struct dmabuf_item *item)
+{
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt;
+	int ret = -1;
+
+	G2D_TRACE_BEGIN("g2d_dma_map");
+	if (fd < 0) {
+		pr_err("[G2D]dma_buf_id(%d) is invalid\n", fd);
+		goto exit;
+	}
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		pr_err("[G2D]dma_buf_get failed, fd=%d\n", fd);
+		goto exit;
+	}
+
+	attachment = dma_buf_attach(dmabuf, dmabuf_dev);
+	if (IS_ERR(attachment)) {
+		pr_err("[G2D]dma_buf_attach failed\n");
+		goto err_buf_put;
+	}
+	sgt = dma_buf_map_attachment(attachment, DMA_TO_DEVICE);
+	if (IS_ERR_OR_NULL(sgt)) {
+		pr_err("[G2D]dma_buf_map_attachment failed\n");
+		goto err_buf_detach;
+	}
+
+	item->fd = fd;
+	item->buf = dmabuf;
+	item->sgt = sgt;
+	item->attachment = attachment;
+	item->dma_addr = sg_dma_address(sgt->sgl);
+	ret = 0;
+	goto exit;
+
+err_buf_detach:
+	dma_buf_detach(dmabuf, attachment);
+err_buf_put:
+	dma_buf_put(dmabuf);
+exit:
+	G2D_TRACE_END("");
+	return ret;
+}
+
+static void g2d_dma_unmap(struct dmabuf_item *item)
+{
+	G2D_TRACE_BEGIN("g2d_dma_unmap");
+	dma_buf_unmap_attachment(item->attachment, item->sgt, DMA_TO_DEVICE);
+	dma_buf_detach(item->buf, item->attachment);
+	dma_buf_put(item->buf);
+	G2D_TRACE_END("");
+}
+#endif
+
+static struct g2d_format_attr fmt_attr_tbl[] = {
+	/*
+	      format                            bits
+						   hor_rsample(u,v)
+							  ver_rsample(u,v)
+								uvc
+								   interleave
+								       factor
+									  div
+	 */
+	{ G2D_FORMAT_ARGB8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_ABGR8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_RGBA8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_BGRA8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_XRGB8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_XBGR8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_RGBX8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_BGRX8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_RGB888, 8,  1, 1, 1, 1, 0, 1, 3, 1},
+	{ G2D_FORMAT_BGR888, 8,  1, 1, 1, 1, 0, 1, 3, 1},
+	{ G2D_FORMAT_RGB565, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_BGR565, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ARGB4444, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ABGR4444, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_RGBA4444, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_BGRA4444, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ARGB1555, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ABGR1555, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_RGBA5551, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_BGRA5551, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ARGB2101010, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_ABGR2101010, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_RGBA1010102, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_BGRA1010102, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_IYUV422_V0Y1U0Y0, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_IYUV422_Y1V0Y0U0, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_IYUV422_U0Y1V0Y0, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_IYUV422_Y1U0Y0V0, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_YUV422_PLANAR, 8,  2, 2, 1, 1, 0, 0, 2, 1},
+	{ G2D_FORMAT_YUV420_PLANAR, 8,  2, 2, 2, 2, 0, 0, 3, 2},
+	{ G2D_FORMAT_YUV411_PLANAR, 8,  4, 4, 1, 1, 0, 0, 3, 2},
+	{ G2D_FORMAT_YUV422UVC_U1V1U0V0, 8,  2, 2, 1, 1, 1, 0, 2, 1},
+	{ G2D_FORMAT_YUV422UVC_V1U1V0U0, 8,  2, 2, 1, 1, 1, 0, 2, 1},
+	{ G2D_FORMAT_YUV420UVC_U1V1U0V0, 8,  2, 2, 2, 2, 1, 0, 3, 2},
+	{ G2D_FORMAT_YUV420UVC_V1U1V0U0, 8,  2, 2, 2, 2, 1, 0, 3, 2},
+	{ G2D_FORMAT_YUV411UVC_U1V1U0V0, 8,  4, 4, 1, 1, 1, 0, 3, 2},
+	{ G2D_FORMAT_YUV411UVC_V1U1V0U0, 8,  4, 4, 1, 1, 1, 0, 3, 2},
+	{ G2D_FORMAT_Y8, 8,  1, 1, 1, 1, 0, 0, 1, 1},
+	{ G2D_FORMAT_YVU10_444, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_YUV10_444, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_YVU10_P210, 10, 2, 2, 1, 1, 0, 0, 4, 1},
+	{ G2D_FORMAT_YVU10_P010, 10, 2, 2, 2, 2, 0, 0, 3, 1},
+};
+
+s32 g2d_set_info(g2d_image_enh *g2d_img, struct dmabuf_item *item)
+{
+	s32 ret = -1;
+	u32 i = 0;
+	u32 len = ARRAY_SIZE(fmt_attr_tbl);
+	u32 y_width, y_height, u_width, u_height;
+	u32 y_pitch, u_pitch;
+	u32 y_size, u_size;
+
+	g2d_img->laddr[0] = item->dma_addr;
+
+	if (g2d_img->format >= G2D_FORMAT_MAX) {
+		pr_err("%s, format 0x%x is out of range\n", __func__,
+			g2d_img->format);
+		goto exit;
+	}
+
+	for (i = 0; i < len; ++i) {
+
+		if (fmt_attr_tbl[i].format == g2d_img->format) {
+			y_width = g2d_img->width;
+			y_height = g2d_img->height;
+			u_width = y_width/fmt_attr_tbl[i].hor_rsample_u;
+			u_height = y_height/fmt_attr_tbl[i].ver_rsample_u;
+
+			y_pitch = G2DALIGN(y_width, g2d_img->align[0]);
+			u_pitch = G2DALIGN(u_width * (fmt_attr_tbl[i].uvc + 1),
+					g2d_img->align[1]);
+
+			y_size = y_pitch * y_height;
+			u_size = u_pitch * u_height;
+			g2d_img->laddr[1] = g2d_img->laddr[0] + y_size;
+			g2d_img->laddr[2] = g2d_img->laddr[0] + y_size + u_size;
+
+			if (g2d_img->format == G2D_FORMAT_YUV420_PLANAR) {
+				/* v */
+				g2d_img->laddr[1] = g2d_img->laddr[0] + y_size + u_size;
+				g2d_img->laddr[2] = g2d_img->laddr[0] + y_size; /* u */
+			}
+
+			ret = 0;
+			break;
+		}
+	}
+	if (ret != 0)
+		pr_err("%s, format 0x%x is invalid\n", __func__,
+			g2d_img->format);
+exit:
+	return ret;
+
+}
+
+__s32 drv_g2d_init(void)
+{
+	g2d_init_para init_para;
+
+	DBG("drv_g2d_init\n");
+	init_para.g2d_base = (unsigned long) para.io;
+	memset(&g2d_ext_hd, 0, sizeof(__g2d_drv_t));
+	init_waitqueue_head(&g2d_ext_hd.queue);
+	g2d_init(&init_para);
+
+	return 0;
+}
+
+void *g2d_malloc(__u32 bytes_num, uintptr_t *phy_addr)
+{
+	void *address = NULL;
+
+#if defined(CONFIG_ION_SUNXI) || defined(CONFIG_ION)
+	u32 actual_bytes;
+
+	if (bytes_num != 0) {
+		actual_bytes = G2D_BYTE_ALIGN(bytes_num);
+
+		address = dma_alloc_coherent(para.dev, actual_bytes,
+					     (dma_addr_t *) phy_addr,
+					     GFP_KERNEL);
+		if (address) {
+			DBG("dma_alloc_coherent ok, address=0x%p, size=0x%x\n",
+			    (void *)(*(unsigned long *)phy_addr), bytes_num);
+			return address;
+		}
+		ERR("dma_alloc_coherent fail, size=0x%x\n", bytes_num);
+		return NULL;
+	}
+	ERR("%s size is zero\n", __func__);
+#else
+	unsigned map_size = 0;
+	struct page *page;
+
+	if (bytes_num != 0) {
+		map_size = PAGE_ALIGN(bytes_num);
+		page = alloc_pages(GFP_KERNEL, get_order(map_size));
+		if (page != NULL) {
+			address = page_address(page);
+			if (address == NULL) {
+				free_pages((unsigned long)(page),
+					   get_order(map_size));
+				ERR("page_address fail!\n");
+				return NULL;
+			}
+			*phy_addr = virt_to_phys(address);
+			return address;
+		}
+		ERR("alloc_pages fail!\n");
+		return NULL;
+	}
+	ERR("%s size is zero\n", __func__);
+#endif
+
+	return NULL;
+}
+
+void g2d_free(void *virt_addr, void *phy_addr, unsigned int size)
+{
+#if defined(CONFIG_ION_SUNXI) || defined(CONFIG_ION)
+
+	u32 actual_bytes;
+
+	actual_bytes = PAGE_ALIGN(size);
+	if (phy_addr && virt_addr)
+		dma_free_coherent(para.dev, actual_bytes, virt_addr,
+				  (dma_addr_t) phy_addr);
+#else
+	unsigned map_size = PAGE_ALIGN(size);
+	unsigned page_size = map_size;
+
+	if (virt_addr == NULL)
+		return;
+
+	free_pages((unsigned long)virt_addr, get_order(page_size));
+#endif
+}
+
+__s32 g2d_get_free_mem_index(void)
+{
+	__u32 i = 0;
+
+	for (i = 0; i < MAX_G2D_MEM_INDEX; i++) {
+		if (g2d_mem[i].b_used == 0)
+			return i;
+	}
+	return -1;
+}
+
+int g2d_mem_request(__u32 size)
+{
+	__s32 sel;
+	unsigned long ret = 0;
+	uintptr_t phy_addr;
+
+	sel = g2d_get_free_mem_index();
+	if (sel < 0) {
+		ERR("g2d_get_free_mem_index fail!\n");
+		return -EINVAL;
+	}
+
+	ret = (unsigned long)g2d_malloc(size, &phy_addr);
+	if (ret != 0) {
+		g2d_mem[sel].virt_addr = (void *)ret;
+		memset(g2d_mem[sel].virt_addr, 0, size);
+		g2d_mem[sel].phy_addr = phy_addr;
+		g2d_mem[sel].mem_len = size;
+		g2d_mem[sel].b_used = 1;
+
+		INFO("map_g2d_memory[%d]: pa=%08lx va=%p size:%x\n", sel,
+		     g2d_mem[sel].phy_addr, g2d_mem[sel].virt_addr, size);
+		return sel;
+	}
+	ERR("fail to alloc reserved memory!\n");
+	return -ENOMEM;
+}
+
+int g2d_mem_release(__u32 sel)
+{
+	if (g2d_mem[sel].b_used == 0) {
+		ERR("mem not used in g2d_mem_release,%d\n", sel);
+		return -EINVAL;
+	}
+
+	g2d_free((void *)g2d_mem[sel].virt_addr, (void *)g2d_mem[sel].phy_addr,
+		 g2d_mem[sel].mem_len);
+	memset(&g2d_mem[sel], 0, sizeof(struct info_mem));
+
+	return 0;
+}
+
+int g2d_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long mypfn = vma->vm_pgoff;
+	unsigned long vmsize = vma->vm_end - vma->vm_start;
+
+	vma->vm_pgoff = 0;
+
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	if (remap_pfn_range(vma, vma->vm_start, mypfn,
+			    vmsize, vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+int g2d_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&para.mutex);
+	para.user_cnt++;
+	if (para.user_cnt == 1) {
+		g2d_clock_enable(&para);
+		para.opened = true;
+#ifdef G2D_V2X_SUPPORT
+		g2d_bsp_open();
+#endif
+	}
+
+	mutex_unlock(&para.mutex);
+	return 0;
+}
+
+int g2d_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&para.mutex);
+	para.user_cnt--;
+	if (para.user_cnt == 0) {
+		g2d_clock_disable(&para);
+		para.opened = false;
+#ifdef G2D_V2X_SUPPORT
+		g2d_bsp_close();
+#endif
+	}
+
+	mutex_unlock(&para.mutex);
+
+	mutex_lock(&global_lock);
+	scan_order = G2D_SM_TDLR;
+	mutex_unlock(&global_lock);
+
+	return 0;
+}
+
+irqreturn_t g2d_handle_irq(int irq, void *dev_id)
+{
+#ifdef G2D_V2X_SUPPORT
+	__u32 mixer_irq_flag, rot_irq_flag;
+
+	mixer_irq_flag = mixer_irq_query();
+	rot_irq_flag = rot_irq_query();
+
+	if (mixer_irq_flag == 0) {
+		g2d_mixer_reset();
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+	} else if (rot_irq_flag == 0) {
+		g2d_rot_reset();
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+	}
+#else
+	__u32 mod_irq_flag, cmd_irq_flag;
+
+	mod_irq_flag = mixer_get_irq();
+	cmd_irq_flag = mixer_get_irq0();
+	if (mod_irq_flag & G2D_FINISH_IRQ) {
+		mixer_clear_init();
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+	} else if (cmd_irq_flag & G2D_FINISH_IRQ) {
+		mixer_clear_init0();
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+	}
+#endif
+	return IRQ_HANDLED;
+}
+
+int g2d_init(g2d_init_para *para)
+{
+	mixer_set_reg_base(para->g2d_base);
+
+	return 0;
+}
+
+int g2d_exit(void)
+{
+	__u8 err = 0;
+
+	return err;
+}
+
+int g2d_wait_cmd_finish(void)
+{
+	long timeout = 100;	/* 100ms */
+
+	timeout = wait_event_timeout(g2d_ext_hd.queue,
+				     g2d_ext_hd.finish_flag == 1,
+				     msecs_to_jiffies(timeout));
+	if (timeout <= 0) {
+#ifdef G2D_V2X_SUPPORT
+		g2d_bsp_reset();
+#else
+		mixer_clear_init();
+		mixer_clear_init0();
+#endif
+		pr_warn("G2D irq pending flag timeout\n");
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+		return -1;
+	}
+	g2d_ext_hd.finish_flag = 0;
+
+	return 0;
+}
+
+int g2d_blit(g2d_blt *para)
+{
+	__s32 err = 0;
+	__u32 tmp_w, tmp_h;
+
+	if ((para->flag & G2D_BLT_ROTATE90) ||
+			(para->flag & G2D_BLT_ROTATE270)) {
+		tmp_w = para->src_rect.h;
+		tmp_h = para->src_rect.w;
+	} else {
+		tmp_w = para->src_rect.w;
+		tmp_h = para->src_rect.h;
+	}
+	/* check the parameter valid */
+	if (((para->src_rect.x < 0) &&
+	     ((-para->src_rect.x) > para->src_rect.w)) ||
+	    ((para->src_rect.y < 0) &&
+	     ((-para->src_rect.y) > para->src_rect.h)) ||
+	    ((para->dst_x < 0) &&
+	     ((-para->dst_x) > tmp_w)) ||
+	    ((para->dst_y < 0) &&
+	     ((-para->dst_y) > tmp_h)) ||
+	    ((para->src_rect.x > 0) &&
+	     (para->src_rect.x > para->src_image.w - 1)) ||
+	    ((para->src_rect.y > 0) &&
+	     (para->src_rect.y > para->src_image.h - 1)) ||
+	    ((para->dst_x > 0) &&
+	     (para->dst_x > para->dst_image.w - 1)) ||
+	    ((para->dst_y > 0) && (para->dst_y > para->dst_image.h - 1))) {
+		pr_warn("invalid blit parameter setting");
+		return -EINVAL;
+	}
+	if (((para->src_rect.x < 0) &&
+				((-para->src_rect.x) < para->src_rect.w))) {
+		para->src_rect.w = para->src_rect.w + para->src_rect.x;
+		para->src_rect.x = 0;
+	} else if ((para->src_rect.x + para->src_rect.w)
+			> para->src_image.w) {
+		para->src_rect.w = para->src_image.w - para->src_rect.x;
+	}
+	if (((para->src_rect.y < 0) &&
+				((-para->src_rect.y) < para->src_rect.h))) {
+		para->src_rect.h = para->src_rect.h + para->src_rect.y;
+		para->src_rect.y = 0;
+	} else if ((para->src_rect.y + para->src_rect.h)
+			> para->src_image.h) {
+		para->src_rect.h = para->src_image.h - para->src_rect.y;
+	}
+
+	if (((para->dst_x < 0) && ((-para->dst_x) < tmp_w))) {
+		para->src_rect.w = tmp_w + para->dst_x;
+		para->src_rect.x = (-para->dst_x);
+		para->dst_x = 0;
+	} else if ((para->dst_x + tmp_w) > para->dst_image.w) {
+		para->src_rect.w = para->dst_image.w - para->dst_x;
+	}
+	if (((para->dst_y < 0) && ((-para->dst_y) < tmp_h))) {
+		para->src_rect.h = tmp_h + para->dst_y;
+		para->src_rect.y = (-para->dst_y);
+		para->dst_y = 0;
+	} else if ((para->dst_y + tmp_h) > para->dst_image.h)
+		para->src_rect.h = para->dst_image.h - para->dst_y;
+
+	g2d_ext_hd.finish_flag = 0;
+
+	/* Add support inverted order copy, however,
+	 * hardware have a bug when reciving y coordinate,
+	 * it use (y + height) rather than (y) on inverted
+	 * order mode, so here adjust it before pass it to hardware.
+	 */
+	mutex_lock(&global_lock);
+	if (scan_order > G2D_SM_TDRL)
+		para->dst_y += para->src_rect.h;
+	mutex_unlock(&global_lock);
+
+	err = mixer_blt(para, scan_order);
+
+	return err;
+}
+
+int g2d_fill(g2d_fillrect *para)
+{
+	__s32 err = 0;
+
+	/* check the parameter valid */
+	if (((para->dst_rect.x < 0) &&
+	     ((-para->dst_rect.x) > para->dst_rect.w)) ||
+	    ((para->dst_rect.y < 0) &&
+	     ((-para->dst_rect.y) > para->dst_rect.h)) ||
+	    ((para->dst_rect.x > 0) &&
+	     (para->dst_rect.x > para->dst_image.w - 1)) ||
+	    ((para->dst_rect.y > 0) &&
+	     (para->dst_rect.y > para->dst_image.h - 1))) {
+		pr_warn("invalid fillrect parameter setting");
+		return -EINVAL;
+	}
+	if (((para->dst_rect.x < 0) &&
+				((-para->dst_rect.x) < para->dst_rect.w))) {
+		para->dst_rect.w = para->dst_rect.w + para->dst_rect.x;
+		para->dst_rect.x = 0;
+	} else if ((para->dst_rect.x + para->dst_rect.w)
+			> para->dst_image.w) {
+		para->dst_rect.w = para->dst_image.w - para->dst_rect.x;
+	}
+	if (((para->dst_rect.y < 0) &&
+				((-para->dst_rect.y) < para->dst_rect.h))) {
+		para->dst_rect.h = para->dst_rect.h + para->dst_rect.y;
+		para->dst_rect.y = 0;
+	} else if ((para->dst_rect.y + para->dst_rect.h)
+			> para->dst_image.h)
+		para->dst_rect.h = para->dst_image.h - para->dst_rect.y;
+
+	g2d_ext_hd.finish_flag = 0;
+	err = mixer_fillrectangle(para);
+
+	return err;
+}
+
+int g2d_stretchblit(g2d_stretchblt *para)
+{
+	__s32 err = 0;
+
+	/* check the parameter valid */
+	if (((para->src_rect.x < 0) &&
+	     ((-para->src_rect.x) > para->src_rect.w)) ||
+	    ((para->src_rect.y < 0) &&
+	     ((-para->src_rect.y) > para->src_rect.h)) ||
+	    ((para->dst_rect.x < 0) &&
+	     ((-para->dst_rect.x) > para->dst_rect.w)) ||
+	    ((para->dst_rect.y < 0) &&
+	     ((-para->dst_rect.y) > para->dst_rect.h)) ||
+	    ((para->src_rect.x > 0) &&
+	     (para->src_rect.x > para->src_image.w - 1)) ||
+	    ((para->src_rect.y > 0) &&
+	     (para->src_rect.y > para->src_image.h - 1)) ||
+	    ((para->dst_rect.x > 0) &&
+	     (para->dst_rect.x > para->dst_image.w - 1)) ||
+	    ((para->dst_rect.y > 0) &&
+	     (para->dst_rect.y > para->dst_image.h - 1))) {
+		pr_warn("invalid stretchblit parameter setting");
+		return -EINVAL;
+	}
+	if (((para->src_rect.x < 0) &&
+				((-para->src_rect.x) < para->src_rect.w))) {
+		para->src_rect.w = para->src_rect.w + para->src_rect.x;
+		para->src_rect.x = 0;
+	} else if ((para->src_rect.x + para->src_rect.w)
+			> para->src_image.w) {
+		para->src_rect.w = para->src_image.w - para->src_rect.x;
+	}
+	if (((para->src_rect.y < 0) &&
+				((-para->src_rect.y) < para->src_rect.h))) {
+		para->src_rect.h = para->src_rect.h + para->src_rect.y;
+		para->src_rect.y = 0;
+	} else if ((para->src_rect.y + para->src_rect.h)
+			> para->src_image.h) {
+		para->src_rect.h = para->src_image.h - para->src_rect.y;
+	}
+
+	if (((para->dst_rect.x < 0) &&
+				((-para->dst_rect.x) < para->dst_rect.w))) {
+		para->dst_rect.w = para->dst_rect.w + para->dst_rect.x;
+		para->dst_rect.x = 0;
+	} else if ((para->dst_rect.x + para->dst_rect.w)
+			> para->dst_image.w) {
+		para->dst_rect.w = para->dst_image.w - para->dst_rect.x;
+	}
+	if (((para->dst_rect.y < 0) &&
+				((-para->dst_rect.y) < para->dst_rect.h))) {
+		para->dst_rect.h = para->dst_rect.h + para->dst_rect.y;
+		para->dst_rect.y = 0;
+	} else if ((para->dst_rect.y + para->dst_rect.h)
+			> para->dst_image.h) {
+		para->dst_rect.h = para->dst_image.h - para->dst_rect.y;
+	}
+
+	g2d_ext_hd.finish_flag = 0;
+
+	/* Add support inverted order copy, however,
+	 * hardware have a bug when reciving y coordinate,
+	 * it use (y + height) rather than (y) on inverted
+	 * order mode, so here adjust it before pass it to hardware.
+	 */
+
+	mutex_lock(&global_lock);
+	if (scan_order > G2D_SM_TDRL)
+		para->dst_rect.y += para->src_rect.h;
+	mutex_unlock(&global_lock);
+
+	err = mixer_stretchblt(para, scan_order);
+
+	return err;
+}
+
+#ifdef G2D_V2X_SUPPORT
+int g2d_fill_h(g2d_fillrect_h *para)
+{
+	__s32 ret = 0;
+	struct dmabuf_item *dst_item = NULL;
+
+	if (!para->dst_image_h.use_phy_addr) {
+
+		dst_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (dst_item == NULL) {
+			pr_err("[G2D]malloc memory of size %u fail!\n",
+				(unsigned int)sizeof(struct dmabuf_item));
+			goto EXIT;
+		}
+	}
+	/* check the parameter valid */
+	if (((para->dst_image_h.clip_rect.x < 0) &&
+	     ((-para->dst_image_h.clip_rect.x) >
+	      para->dst_image_h.clip_rect.w)) ||
+	    ((para->dst_image_h.clip_rect.y < 0) &&
+	     ((-para->dst_image_h.clip_rect.y) >
+	      para->dst_image_h.clip_rect.h)) ||
+	    ((para->dst_image_h.clip_rect.x > 0) &&
+	     (para->dst_image_h.clip_rect.x > para->dst_image_h.width - 1))
+	    || ((para->dst_image_h.clip_rect.y > 0) &&
+		(para->dst_image_h.clip_rect.y >
+		 para->dst_image_h.height - 1))) {
+		pr_err("invalid fillrect parameter setting\n");
+		return -EINVAL;
+	}
+	if (((para->dst_image_h.clip_rect.x < 0) &&
+				((-para->dst_image_h.clip_rect.x) <
+				 para->dst_image_h.clip_rect.w))) {
+		para->dst_image_h.clip_rect.w =
+			para->dst_image_h.clip_rect.w +
+			para->dst_image_h.clip_rect.x;
+		para->dst_image_h.clip_rect.x = 0;
+	} else if ((para->dst_image_h.clip_rect.x +
+				para->dst_image_h.clip_rect.w)
+			> para->dst_image_h.width) {
+		para->dst_image_h.clip_rect.w =
+			para->dst_image_h.width -
+			para->dst_image_h.clip_rect.x;
+	}
+	if (((para->dst_image_h.clip_rect.y < 0) &&
+				((-para->dst_image_h.clip_rect.y) <
+				 para->dst_image_h.clip_rect.h))) {
+		para->dst_image_h.clip_rect.h =
+			para->dst_image_h.clip_rect.h +
+			para->dst_image_h.clip_rect.y;
+		para->dst_image_h.clip_rect.y = 0;
+	} else if ((para->dst_image_h.clip_rect.y +
+				para->dst_image_h.clip_rect.h)
+			> para->dst_image_h.height) {
+		para->dst_image_h.clip_rect.h =
+			para->dst_image_h.height -
+			para->dst_image_h.clip_rect.y;
+	}
+
+	para->dst_image_h.bbuff = 1;
+	para->dst_image_h.gamut = G2D_BT709;
+	para->dst_image_h.mode = 0;
+
+	g2d_ext_hd.finish_flag = 0;
+
+	if (!para->dst_image_h.use_phy_addr) {
+		ret = g2d_dma_map(para->dst_image_h.fd, dst_item);
+		if (ret != 0) {
+			pr_err("[G2D]map cur_item fail!\n");
+			goto FREE_DST;
+		}
+
+		g2d_set_info(&para->dst_image_h, dst_item);
+	}
+
+	ret = g2d_fillrectangle(&para->dst_image_h, para->dst_image_h.color);
+
+	if (ret)
+		pr_warn("G2D FILLRECTANGLE Failed!\n");
+	if (!para->dst_image_h.use_phy_addr)
+		g2d_dma_unmap(dst_item);
+FREE_DST:
+	if (!para->dst_image_h.use_phy_addr)
+		kfree(dst_item);
+EXIT:
+	return ret;
+}
+
+int g2d_blit_h(g2d_blt_h *para)
+{
+	__s32 ret = 0;
+	struct dmabuf_item *src_item = NULL;
+	struct dmabuf_item *dst_item = NULL;
+
+	if (!para->src_image_h.use_phy_addr) {
+
+		src_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (src_item == NULL) {
+			pr_err("[G2D]malloc memory of size %u fail!\n",
+			       (unsigned int)sizeof(struct dmabuf_item));
+			goto EXIT;
+		}
+	}
+
+	if (!para->dst_image_h.use_phy_addr) {
+		dst_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (dst_item == NULL) {
+			pr_err("[G2D]malloc memory of size %u fail!\n",
+			       (unsigned int)sizeof(struct dmabuf_item));
+			goto FREE_SRC;
+		}
+	}
+	/* check the parameter valid */
+	if (((para->src_image_h.clip_rect.x < 0) &&
+	     ((-para->src_image_h.clip_rect.x) >
+	      para->src_image_h.clip_rect.w)) ||
+	    ((para->src_image_h.clip_rect.y < 0) &&
+	     ((-para->src_image_h.clip_rect.y) >
+	      para->src_image_h.clip_rect.h)) ||
+	    ((para->src_image_h.clip_rect.x > 0) &&
+	     (para->src_image_h.clip_rect.x >
+	      para->src_image_h.width - 1)) ||
+	    ((para->src_image_h.clip_rect.y > 0) &&
+	     (para->src_image_h.clip_rect.y >
+	      para->src_image_h.height - 1)) ||
+	    ((para->dst_image_h.clip_rect.x > 0) &&
+	     (para->dst_image_h.clip_rect.x >
+	      para->dst_image_h.width - 1)) ||
+	    ((para->dst_image_h.clip_rect.y > 0) &&
+	     (para->dst_image_h.clip_rect.y > para->dst_image_h.height - 1))) {
+		pr_err("invalid bitblit parameter setting\n");
+		return -EINVAL;
+	}
+	if (((para->src_image_h.clip_rect.x < 0) &&
+				((-para->src_image_h.clip_rect.x) <
+				 para->src_image_h.clip_rect.w))) {
+		para->src_image_h.clip_rect.w =
+			para->src_image_h.clip_rect.w +
+			para->src_image_h.clip_rect.x;
+		para->src_image_h.clip_rect.x = 0;
+	} else if ((para->src_image_h.clip_rect.x +
+				para->src_image_h.clip_rect.w)
+			> para->src_image_h.width) {
+		para->src_image_h.clip_rect.w =
+			para->src_image_h.width -
+			para->src_image_h.clip_rect.x;
+	}
+	if (((para->src_image_h.clip_rect.y < 0) &&
+				((-para->src_image_h.clip_rect.y) <
+				 para->src_image_h.clip_rect.h))) {
+		para->src_image_h.clip_rect.h =
+			para->src_image_h.clip_rect.h +
+			para->src_image_h.clip_rect.y;
+		para->src_image_h.clip_rect.y = 0;
+	} else if ((para->src_image_h.clip_rect.y +
+				para->src_image_h.clip_rect.h)
+			> para->src_image_h.height) {
+		para->src_image_h.clip_rect.h =
+			para->src_image_h.height -
+			para->src_image_h.clip_rect.y;
+	}
+
+	if (((para->dst_image_h.clip_rect.x < 0) &&
+				((-para->dst_image_h.clip_rect.x) <
+				 para->dst_image_h.clip_rect.w))) {
+		para->dst_image_h.clip_rect.w =
+			para->dst_image_h.clip_rect.w +
+			para->dst_image_h.clip_rect.x;
+		para->dst_image_h.clip_rect.x = 0;
+	} else if ((para->dst_image_h.clip_rect.x +
+				para->dst_image_h.clip_rect.w)
+			> para->dst_image_h.width) {
+		para->dst_image_h.clip_rect.w =
+			para->dst_image_h.width -
+			para->dst_image_h.clip_rect.x;
+	}
+	if (((para->dst_image_h.clip_rect.y < 0) &&
+				((-para->dst_image_h.clip_rect.y) <
+				 para->dst_image_h.clip_rect.h))) {
+		para->dst_image_h.clip_rect.h =
+			para->dst_image_h.clip_rect.h +
+			para->dst_image_h.clip_rect.y;
+		para->dst_image_h.clip_rect.y = 0;
+	} else if ((para->dst_image_h.clip_rect.y +
+				para->dst_image_h.clip_rect.h)
+			> para->dst_image_h.height) {
+		para->dst_image_h.clip_rect.h =
+			para->dst_image_h.height -
+			para->dst_image_h.clip_rect.y;
+	}
+
+	g2d_ext_hd.finish_flag = 0;
+
+	/* Add support inverted order copy, however,
+	 * hardware have a bug when reciving y coordinate,
+	 * it use (y + height) rather than (y) on inverted
+	 * order mode, so here adjust it before pass it to hardware.
+	 */
+
+	para->src_image_h.bpremul = 0;
+	para->src_image_h.bbuff = 1;
+	para->src_image_h.gamut = G2D_BT709;
+
+	para->dst_image_h.bpremul = 0;
+	para->dst_image_h.bbuff = 1;
+	para->dst_image_h.gamut = G2D_BT709;
+
+	if (!para->src_image_h.use_phy_addr) {
+		ret = g2d_dma_map(para->src_image_h.fd, src_item);
+		if (ret != 0) {
+			pr_err("[G2D]map cur_item fail!\n");
+			goto FREE_DST;
+		}
+		g2d_set_info(&para->src_image_h, src_item);
+	}
+
+	if (!para->dst_image_h.use_phy_addr) {
+		ret = g2d_dma_map(para->dst_image_h.fd, dst_item);
+		if (ret != 0) {
+			pr_err("[G2D]map dst_item fail!\n");
+			goto SRC_DMA_UNMAP;
+		}
+		g2d_set_info(&para->dst_image_h, dst_item);
+	}
+
+	G2D_TRACE_BEGIN("g2d_bsp_bitblt");
+	ret = g2d_bsp_bitblt(&para->src_image_h,
+					&para->dst_image_h, para->flag_h);
+	G2D_TRACE_END("");
+
+	if (ret)
+		pr_warn("G2D BITBLT Failed!\n");
+
+	if (!para->dst_image_h.use_phy_addr)
+		g2d_dma_unmap(dst_item);
+SRC_DMA_UNMAP:
+	if (!para->src_image_h.use_phy_addr)
+		g2d_dma_unmap(src_item);
+FREE_DST:
+	if (!para->dst_image_h.use_phy_addr)
+		kfree(dst_item);
+FREE_SRC:
+	if (!para->src_image_h.use_phy_addr)
+		kfree(src_item);
+EXIT:
+	return ret;
+}
+
+int g2d_bld_h(g2d_bld *para)
+{
+	__s32 ret = 0;
+	struct dmabuf_item *src_item = NULL;
+	struct dmabuf_item *dst_item = NULL;
+
+	if (!para->src_image[0].use_phy_addr) {
+
+		src_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (src_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       (unsigned int)sizeof(struct dmabuf_item));
+			goto EXIT;
+		}
+	}
+
+	if (!para->dst_image.use_phy_addr) {
+		dst_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (dst_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       (unsigned int)sizeof(struct dmabuf_item));
+			goto FREE_SRC;
+		}
+	}
+
+	/* check the parameter valid */
+	if (((para->src_image[0].clip_rect.x < 0) &&
+	     ((-para->src_image[0].clip_rect.x) >
+	      para->src_image[0].clip_rect.w)) ||
+	    ((para->src_image[0].clip_rect.y < 0) &&
+	     ((-para->src_image[0].clip_rect.y) >
+	      para->src_image[0].clip_rect.h)) ||
+	    ((para->src_image[0].clip_rect.x > 0) &&
+	     (para->src_image[0].clip_rect.x >
+	      para->src_image[0].width - 1)) ||
+	    ((para->src_image[0].clip_rect.y > 0) &&
+	     (para->src_image[0].clip_rect.y >
+	      para->src_image[0].height - 1)) ||
+	    ((para->dst_image.clip_rect.x > 0) &&
+	     (para->dst_image.clip_rect.x > para->dst_image.width - 1))
+	    || ((para->dst_image.clip_rect.y > 0) &&
+		(para->dst_image.clip_rect.y >
+		 para->dst_image.height - 1))) {
+		pr_err("invalid blit parameter setting\n");
+		return -EINVAL;
+	}
+	if (((para->src_image[0].clip_rect.x < 0) &&
+				((-para->src_image[0].clip_rect.x) <
+				 para->src_image[0].clip_rect.w))) {
+		para->src_image[0].clip_rect.w =
+			para->src_image[0].clip_rect.w +
+			para->src_image[0].clip_rect.x;
+		para->src_image[0].clip_rect.x = 0;
+	} else if ((para->src_image[0].clip_rect.x +
+				para->src_image[0].clip_rect.w)
+			> para->src_image[0].width) {
+		para->src_image[0].clip_rect.w =
+			para->src_image[0].width -
+			para->src_image[0].clip_rect.x;
+	}
+	if (((para->src_image[0].clip_rect.y < 0) &&
+				((-para->src_image[0].clip_rect.y) <
+				 para->src_image[0].clip_rect.h))) {
+		para->src_image[0].clip_rect.h =
+			para->src_image[0].clip_rect.h +
+			para->src_image[0].clip_rect.y;
+		para->src_image[0].clip_rect.y = 0;
+	} else if ((para->src_image[0].clip_rect.y +
+				para->src_image[0].clip_rect.h)
+			> para->src_image[0].height) {
+		para->src_image[0].clip_rect.h =
+			para->src_image[0].height -
+			para->src_image[0].clip_rect.y;
+	}
+
+	para->src_image[0].bpremul = 0;
+	para->src_image[0].bbuff = 1;
+	para->src_image[0].gamut = G2D_BT709;
+
+	para->dst_image.bpremul = 0;
+	para->dst_image.bbuff = 1;
+	para->dst_image.gamut = G2D_BT709;
+
+	g2d_ext_hd.finish_flag = 0;
+
+	if (!para->src_image[0].use_phy_addr) {
+		ret = g2d_dma_map(para->src_image[0].fd, src_item);
+		if (ret != 0) {
+			pr_err("[G2D]map src_item fail!\n");
+			goto FREE_DST;
+		}
+		g2d_set_info(&para->src_image[0], src_item);
+	}
+	if (!para->dst_image.use_phy_addr) {
+		ret = g2d_dma_map(para->dst_image.fd, dst_item);
+		if (ret != 0) {
+			pr_err("[G2D]map dst_item fail!\n");
+			goto SRC_DMA_UNMAP;
+		}
+		g2d_set_info(&para->dst_image, dst_item);
+	}
+	ret = g2d_bsp_bld(&para->src_image[0], &para->dst_image,
+						para->bld_cmd, &para->ck_para);
+
+	if (ret)
+		pr_warn("G2D BITBLT Failed!\n");
+
+	if (!para->dst_image.use_phy_addr)
+		g2d_dma_unmap(dst_item);
+SRC_DMA_UNMAP:
+	if (!para->src_image[0].use_phy_addr)
+		g2d_dma_unmap(src_item);
+FREE_DST:
+	if (!para->dst_image.use_phy_addr)
+		kfree(dst_item);
+FREE_SRC:
+	if (!para->src_image[0].use_phy_addr)
+		kfree(src_item);
+EXIT:
+	return ret;
+}
+
+int g2d_maskblt_h(g2d_maskblt *para)
+{
+	__s32 ret = 0;
+	struct dmabuf_item *src_item = NULL;
+	struct dmabuf_item *ptn_item = NULL;
+	struct dmabuf_item *mask_item = NULL;
+	struct dmabuf_item *dst_item = NULL;
+
+	if (!para->src_image_h.use_phy_addr) {
+
+		src_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (src_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       (unsigned int)sizeof(struct dmabuf_item));
+			goto EXIT;
+		}
+		ptn_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (ptn_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       (unsigned int)sizeof(struct dmabuf_item));
+			goto FREE_SRC;
+		}
+
+		mask_item = kmalloc(sizeof(struct dmabuf_item),
+				    GFP_KERNEL | __GFP_ZERO);
+		if (mask_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       (unsigned int)sizeof(struct dmabuf_item));
+			goto FREE_PTN;
+		}
+		dst_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (dst_item == NULL) {
+			pr_err("malloc memory of size %u fail!\n",
+			       (unsigned int)(unsigned int)sizeof(
+				   struct dmabuf_item));
+			goto FREE_MASK;
+		}
+	}
+	/* check the parameter valid */
+	if (((para->dst_image_h.clip_rect.x < 0) &&
+	     ((-para->dst_image_h.clip_rect.x) >
+	      para->dst_image_h.clip_rect.w)) ||
+	    ((para->dst_image_h.clip_rect.y < 0) &&
+	     ((-para->dst_image_h.clip_rect.y) >
+	      para->dst_image_h.clip_rect.h)) ||
+	    ((para->dst_image_h.clip_rect.x > 0) &&
+	     (para->dst_image_h.clip_rect.x >
+	      para->dst_image_h.width - 1)) ||
+	    ((para->dst_image_h.clip_rect.y > 0) &&
+	     (para->dst_image_h.clip_rect.y > para->dst_image_h.height - 1))) {
+		pr_err("invalid maskblt parameter setting\n");
+		return -EINVAL;
+	}
+	if (((para->dst_image_h.clip_rect.x < 0) &&
+				((-para->dst_image_h.clip_rect.x) <
+				 para->dst_image_h.clip_rect.w))) {
+		para->dst_image_h.clip_rect.w =
+			para->dst_image_h.clip_rect.w +
+			para->dst_image_h.clip_rect.x;
+		para->dst_image_h.clip_rect.x = 0;
+	} else if ((para->dst_image_h.clip_rect.x +
+				para->dst_image_h.clip_rect.w)
+			> para->dst_image_h.width) {
+		para->dst_image_h.clip_rect.w =
+			para->dst_image_h.width -
+			para->dst_image_h.clip_rect.x;
+	}
+	if (((para->dst_image_h.clip_rect.y < 0) &&
+				((-para->dst_image_h.clip_rect.y) <
+				 para->dst_image_h.clip_rect.h))) {
+		para->dst_image_h.clip_rect.h =
+			para->dst_image_h.clip_rect.h +
+			para->dst_image_h.clip_rect.y;
+		para->dst_image_h.clip_rect.y = 0;
+	} else if ((para->dst_image_h.clip_rect.y +
+				para->dst_image_h.clip_rect.h)
+			> para->dst_image_h.height) {
+		para->dst_image_h.clip_rect.h =
+			para->dst_image_h.height -
+			para->dst_image_h.clip_rect.y;
+	}
+
+	if (!para->src_image_h.use_phy_addr) {
+		ret = g2d_dma_map(para->src_image_h.fd, src_item);
+		if (ret != 0) {
+			pr_err("[G2D]map src_item fail!\n");
+			goto FREE_DST;
+		}
+		ret = g2d_dma_map(para->ptn_image_h.fd, ptn_item);
+		if (ret != 0) {
+			pr_err("[G2D]map ptn_item fail!\n");
+			goto SRC_DMA_UNMAP;
+		}
+		ret = g2d_dma_map(para->mask_image_h.fd, mask_item);
+		if (ret != 0) {
+			pr_err("[G2D]map mask_item fail!\n");
+			goto PTN_DMA_UNMAP;
+		}
+		ret = g2d_dma_map(para->dst_image_h.fd, dst_item);
+		if (ret != 0) {
+			pr_err("[G2D]map dst_item fail!\n");
+			goto MASK_DMA_UNMAP;
+		}
+
+		g2d_set_info(&para->src_image_h, src_item);
+		g2d_set_info(&para->ptn_image_h, ptn_item);
+		g2d_set_info(&para->mask_image_h, mask_item);
+		g2d_set_info(&para->dst_image_h, dst_item);
+	}
+
+	para->src_image_h.bbuff = 1;
+	para->src_image_h.gamut = G2D_BT709;
+
+	para->ptn_image_h.bbuff = 1;
+	para->ptn_image_h.gamut = G2D_BT709;
+
+	para->mask_image_h.bbuff = 1;
+	para->mask_image_h.gamut = G2D_BT709;
+
+	para->dst_image_h.bbuff = 1;
+	para->dst_image_h.gamut = G2D_BT709;
+
+	g2d_ext_hd.finish_flag = 0;
+
+	ret =
+	    g2d_bsp_maskblt(&para->src_image_h, &para->ptn_image_h,
+			    &para->mask_image_h, &para->dst_image_h,
+			    para->back_flag, para->fore_flag);
+
+	if (ret)
+		pr_warn("G2D MASKBLT Failed!\n");
+	if (!para->src_image_h.use_phy_addr)
+		g2d_dma_unmap(dst_item);
+MASK_DMA_UNMAP:
+	if (!para->src_image_h.use_phy_addr)
+		g2d_dma_unmap(mask_item);
+PTN_DMA_UNMAP:
+	if (!para->src_image_h.use_phy_addr)
+		g2d_dma_unmap(ptn_item);
+SRC_DMA_UNMAP:
+	if (!para->src_image_h.use_phy_addr)
+		g2d_dma_unmap(src_item);
+FREE_DST:
+	if (!para->src_image_h.use_phy_addr)
+		kfree(dst_item);
+FREE_MASK:
+	if (!para->src_image_h.use_phy_addr)
+		kfree(mask_item);
+FREE_PTN:
+	if (!para->src_image_h.use_phy_addr)
+		kfree(ptn_item);
+FREE_SRC:
+	if (!para->src_image_h.use_phy_addr)
+		kfree(src_item);
+EXIT:
+	return ret;
+}
+#endif
+
+/*
+int g2d_set_palette_table(g2d_palette *para)
+{
+
+	if ((para->pbuffer == NULL) || (para->size < 0) ||
+			(para->size > 1024)) {
+		pr_warn("para invalid in mixer_set_palette\n");
+		return -1;
+	}
+
+	mixer_set_palette(para);
+
+	return 0;
+}
+*/
+
+/*
+int g2d_cmdq(unsigned int para)
+{
+	__s32 err = 0;
+
+	g2d_ext_hd.finish_flag = 0;
+	err = mixer_cmdq(para);
+
+	return err;
+}
+*/
+
+void g2d_ioctl_mutex_lock(void)
+{
+	if (!mutex_trylock(&para.mutex))
+		mutex_lock(&para.mutex);
+}
+
+void g2d_ioctl_mutex_unlock(void)
+{
+	mutex_unlock(&para.mutex);
+}
+
+long g2d_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	__s32 ret = 0;
+	unsigned int size;
+	unsigned int sel;
+	struct timespec64 test_start, test_end;
+	unsigned int runtime;
+
+	if (time_info == 1)
+		ktime_get_real_ts64(&test_start);
+
+	if (!mutex_trylock(&para.mutex))
+		mutex_lock(&para.mutex);
+	switch (cmd) {
+
+		/* Proceed to the operation */
+	case G2D_CMD_BITBLT:{
+			g2d_blt blit_para;
+
+			if (copy_from_user(&blit_para, (g2d_blt *) arg,
+					   sizeof(g2d_blt))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = g2d_blit(&blit_para);
+			break;
+		}
+	case G2D_CMD_FILLRECT:{
+			g2d_fillrect fill_para;
+
+			if (copy_from_user(&fill_para, (g2d_fillrect *) arg,
+					   sizeof(g2d_fillrect))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = g2d_fill(&fill_para);
+			break;
+		}
+	case G2D_CMD_STRETCHBLT:{
+			g2d_stretchblt stre_para;
+
+			if (copy_from_user(&stre_para, (g2d_stretchblt *) arg,
+					   sizeof(g2d_stretchblt))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = g2d_stretchblit(&stre_para);
+			break;
+		}
+/*	case G2D_CMD_PALETTE_TBL:{
+		g2d_palette pale_para;
+
+		if (copy_from_user(&pale_para, (g2d_palette *)arg,
+					sizeof(g2d_palette))) {
+			ret = -EFAULT;
+			goto err_noput;
+		}
+		ret = g2d_set_palette_table(&pale_para);
+		break;
+	}
+	case G2D_CMD_QUEUE:{
+		unsigned int cmdq_addr;
+
+		if (copy_from_user(&cmdq_addr,
+				(unsigned int *)arg, sizeof(unsigned int))) {
+			ret = -EFAULT;
+			goto err_noput;
+		}
+		ret = g2d_cmdq(cmdq_addr);
+		break;
+	}
+*/
+#ifdef G2D_V2X_SUPPORT
+	case G2D_CMD_BITBLT_H:{
+			g2d_blt_h blit_para;
+			if (copy_from_user(&blit_para, (g2d_blt_h *) arg,
+					   sizeof(g2d_blt_h))) {
+				pr_err("[G2D]BITBLT copy from user failed!\n");
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = g2d_blit_h(&blit_para);
+			break;
+		}
+	case G2D_CMD_FILLRECT_H:{
+			g2d_fillrect_h fill_para;
+
+			if (copy_from_user(&fill_para, (g2d_fillrect_h *) arg,
+					   sizeof(g2d_fillrect_h))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = g2d_fill_h(&fill_para);
+			break;
+		}
+	case G2D_CMD_BLD_H:{
+			g2d_bld bld_para;
+
+			if (copy_from_user(&bld_para, (g2d_bld *) arg,
+					   sizeof(g2d_bld))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = g2d_bld_h(&bld_para);
+			break;
+		}
+	case G2D_CMD_MASK_H:{
+			g2d_maskblt mask_para;
+
+			if (copy_from_user(&mask_para, (g2d_maskblt *) arg,
+					   sizeof(g2d_maskblt))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = g2d_maskblt_h(&mask_para);
+			break;
+		}
+#endif
+		/* just management memory for test */
+	case G2D_CMD_MEM_REQUEST:
+		get_user(size, (unsigned int __user *)arg);
+		ret = g2d_mem_request(size);
+		break;
+
+	case G2D_CMD_MEM_RELEASE:
+		get_user(sel, (unsigned int __user *)arg);
+		ret = g2d_mem_release(sel);
+		break;
+
+	case G2D_CMD_MEM_SELIDX:
+		get_user(sel, (unsigned int __user *)arg);
+		g2d_mem_sel = sel;
+		break;
+
+	case G2D_CMD_MEM_GETADR:
+		get_user(sel, (unsigned int __user *)arg);
+		if (g2d_mem[sel].b_used) {
+			ret = g2d_mem[sel].phy_addr;
+		} else {
+			ERR("mem not used in G2D_CMD_MEM_GETADR\n");
+			ret = -1;
+		}
+		break;
+
+	case G2D_CMD_INVERTED_ORDER:
+		{
+			if (arg > G2D_SM_DTRL) {
+				ERR("scan mode is err.\n");
+				ret = -EINVAL;
+				goto err_noput;
+			}
+
+			mutex_lock(&global_lock);
+			scan_order = arg;
+			mutex_unlock(&global_lock);
+			break;
+		}
+
+		/* Invalid IOCTL call */
+	default:
+		return -EINVAL;
+	}
+
+err_noput:
+	mutex_unlock(&para.mutex);
+
+	if (time_info == 1) {
+		ktime_get_real_ts64(&test_end);
+		runtime = (test_end.tv_sec - test_start.tv_sec) * 1000000 +
+			(test_end.tv_nsec - test_start.tv_nsec) / NSEC_PER_USEC;
+		pr_info("%s:use %u us!\n", __func__, runtime);
+	}
+	return ret;
+}
+
+static const struct file_operations g2d_fops = {
+	.owner = THIS_MODULE,
+	.open = g2d_open,
+	.release = g2d_release,
+	.unlocked_ioctl = g2d_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = g2d_ioctl,
+#endif
+	.mmap = g2d_mmap,
+};
+
+static u64 sunxi_g2d_dma_mask = DMA_BIT_MASK(32);
+static int g2d_probe(struct platform_device *pdev)
+{
+#if !defined(CONFIG_OF)
+	int size;
+	struct resource *res;
+#endif
+	int ret = 0;
+	__g2d_info_t *info = NULL;
+
+	info = &para;
+	info->dev = &pdev->dev;
+	dmabuf_dev = &pdev->dev;
+	dmabuf_dev->dma_mask = &sunxi_g2d_dma_mask;
+	dmabuf_dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	platform_set_drvdata(pdev, info);
+
+#if !defined(CONFIG_OF)
+	/* get the memory region */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		ERR("failed to get memory register\n");
+		ret = -ENXIO;
+		goto dealloc_fb;
+	}
+
+	size = (res->end - res->start) + 1;
+	/* map the memory */
+	info->io = ioremap(res->start, size);
+	if (info->io == NULL) {
+		ERR("iorGmap() of register failed\n");
+		ret = -ENXIO;
+		goto dealloc_fb;
+	}
+#else
+	info->io = of_iomap(pdev->dev.of_node, 0);
+	if (info->io == NULL) {
+		ERR("iormap() of register failed\n");
+		ret = -ENXIO;
+		goto dealloc_fb;
+	}
+#endif
+
+#if !defined(CONFIG_OF)
+	/* get the irq */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL) {
+		ERR("failed to get irq resource\n");
+		ret = -ENXIO;
+		goto release_regs;
+	}
+	info->irq = res->start;
+#else
+	info->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (!info->irq) {
+		ERR("irq_of_parse_and_map irq fail for transform\n");
+		ret = -ENXIO;
+		goto release_regs;
+	}
+#endif
+
+	/* request the irq */
+	ret = request_irq(info->irq, g2d_handle_irq, 0,
+			  dev_name(&pdev->dev), NULL);
+	if (ret) {
+		ERR("failed to install irq resource\n");
+		goto release_regs;
+	}
+#if defined(CONFIG_OF)
+	/* clk init */
+	info->clk = devm_clk_get(&pdev->dev, "g2d");
+	if (IS_ERR(info->clk)) {
+		ERR("fail to get clk\n");
+		ret = PTR_ERR(info->clk);
+		goto out_dispose_mapping;
+
+	} else {
+		info->clk_parent = clk_get_parent(info->clk);
+		info->bus_clk = devm_clk_get(&pdev->dev, "bus");
+		info->mbus_clk = devm_clk_get(&pdev->dev, "mbus_g2d");
+		info->reset = devm_reset_control_get(&pdev->dev, NULL);
+	}
+#endif
+
+	drv_g2d_init();
+	mutex_init(&info->mutex);
+	mutex_init(&global_lock);
+
+	ret = sysfs_create_group(&g2d_dev->kobj, &g2d_attribute_group);
+	if (ret < 0)
+		WARNING("sysfs_create_file fail!\n");
+
+	return 0;
+
+out_dispose_mapping:
+#if !defined(CONFIG_OF)
+	irq_dispose_mapping(info->irq);
+#endif
+release_regs:
+#if !defined(CONFIG_OF)
+	iounmap(info->io);
+#endif
+dealloc_fb:
+	platform_set_drvdata(pdev, NULL);
+
+	return ret;
+}
+
+static int g2d_remove(struct platform_device *pdev)
+{
+	__g2d_info_t *info = platform_get_drvdata(pdev);
+
+	free_irq(info->irq, NULL);
+#if !defined(CONFIG_OF)
+	iounmap(info->io);
+#endif
+	platform_set_drvdata(pdev, NULL);
+
+	sysfs_remove_group(&g2d_dev->kobj, &g2d_attribute_group);
+
+	INFO("Driver unloaded succesfully.\n");
+	return 0;
+}
+
+static int g2d_suspend(struct device *dev)
+{
+	INFO("%s.\n", __func__);
+	mutex_lock(&para.mutex);
+	if (para.opened) {
+		g2d_clock_disable(&para);
+#ifdef G2D_V2X_SUPPORT
+		g2d_bsp_close();
+#endif
+	}
+	mutex_unlock(&para.mutex);
+	INFO("g2d_suspend succesfully.\n");
+
+	return 0;
+}
+
+static int g2d_resume(struct device *dev)
+{
+	INFO("%s.\n", __func__);
+	mutex_lock(&para.mutex);
+	if (para.opened) {
+		g2d_clock_enable(&para);
+#ifdef G2D_V2X_SUPPORT
+		g2d_bsp_open();
+#endif
+	}
+	mutex_unlock(&para.mutex);
+	INFO("g2d_resume succesfully.\n");
+
+	return 0;
+}
+
+static const struct dev_pm_ops g2d_pm_ops = {
+	.suspend = g2d_suspend,
+	.resume = g2d_resume,
+};
+#if !defined(CONFIG_OF)
+struct platform_device g2d_device = {
+
+	.name = "g2d",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(g2d_resource),
+	.resource = g2d_resource,
+	.dev = {
+
+		},
+};
+#else
+static const struct of_device_id sunxi_g2d_match[] = {
+	{.compatible = "allwinner,sunxi-g2d",},
+	{},
+};
+#endif
+
+static struct platform_driver g2d_driver = {
+	.probe = g2d_probe,
+	.remove = g2d_remove,
+	.driver = {
+
+		   .owner = THIS_MODULE,
+		   .name = "g2d",
+		   .pm   = &g2d_pm_ops,
+		   .of_match_table = sunxi_g2d_match,
+		   },
+};
+
+int __init g2d_module_init(void)
+{
+	int ret = 0, err;
+
+	alloc_chrdev_region(&devid, 0, 1, "g2d_chrdev");
+	g2d_cdev = cdev_alloc();
+	cdev_init(g2d_cdev, &g2d_fops);
+	g2d_cdev->owner = THIS_MODULE;
+	err = cdev_add(g2d_cdev, devid, 1);
+	if (err) {
+		ERR("I was assigned major number %d.\n", MAJOR(devid));
+		return -1;
+	}
+
+	g2d_class = class_create(THIS_MODULE, "g2d");
+	if (IS_ERR(g2d_class)) {
+		ERR("create class error\n");
+		return -1;
+	}
+
+	g2d_dev = device_create(g2d_class, NULL, devid, NULL, "g2d");
+#if !defined(CONFIG_OF)
+	ret = platform_device_register(&g2d_device);
+#endif
+	if (ret == 0)
+		ret = platform_driver_register(&g2d_driver);
+
+#if defined(CONFIG_SUNXI_SYNCFENCE)
+	syncfence_init();
+#endif
+
+	INFO("Module initialized.major:%d\n", MAJOR(devid));
+	return ret;
+}
+
+static void __exit g2d_module_exit(void)
+{
+	INFO("g2d_module_exit\n");
+	/* kfree(g2d_ext_hd.g2d_finished_sem); */
+
+#if defined(CONFIG_SUNXI_SYNCFENCE)
+	syncfence_exit();
+#endif
+
+	platform_driver_unregister(&g2d_driver);
+#if !defined(CONFIG_OF)
+	platform_device_unregister(&g2d_device);
+#endif
+	device_destroy(g2d_class, devid);
+	class_destroy(g2d_class);
+
+	cdev_del(g2d_cdev);
+}
+#ifdef CONFIG_ARCH_SUN8IW11P1
+subsys_initcall(g2d_module_init);
+#else
+module_init(g2d_module_init);
+#endif
+module_exit(g2d_module_exit);
+
+MODULE_AUTHOR("yupu_tang");
+MODULE_AUTHOR("tyle <tyle@allwinnertech.com>");
+MODULE_DESCRIPTION("g2d driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/sunxi_g2d/g2d_driver_i.h b/drivers/char/sunxi_g2d/g2d_driver_i.h
new file mode 100644
index 000000000..b340702e3
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_driver_i.h
@@ -0,0 +1,130 @@
+/* g2d_driver_i.h
+ *
+ * Copyright (c)	2011 Allwinnertech Co., Ltd.
+ *					2011 Yupu Tang
+ *
+ * @ G2D driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __G2D_DRIVER_I_H
+#define __G2D_DRIVER_I_H
+
+#include "g2d_bsp.h"
+
+/* #include "g2d_bsp_v2.h" */
+
+#define G2D_DEBUG	1
+#ifdef	G2D_DEBUG
+#define	DBG(format, args...) pr_debug("%s: " format, "G2D", ## args)
+#else
+#define	DBG(format, args...)
+#endif
+#define ERR(format, args...) pr_err("%s: " format, "G2D", ## args)
+#define WARNING(format, args...) \
+	pr_warn("%s: " format, "G2D", ## args)
+#define INFO(format, args...) pr_info("%s: " format, "G2D", ## args)
+
+#define MAX_G2D_MEM_INDEX	10
+#define	INTC_IRQNO_DE_MIX	SUNXI_IRQ_MP
+
+#define G2DALIGN(value, align) ((align == 0) ? \
+				value : \
+				(((value) + ((align) - 1)) & ~((align) - 1)))
+
+#if ((defined CONFIG_ARCH_SUN8IW12P1) || (defined CONFIG_ARCH_SUN8IW15P1) || \
+					(defined CONFIG_ARCH_SUN8IW17P1) || \
+					(defined CONFIG_ARCH_SUN50IW9) || \
+					(defined CONFIG_ARCH_SUN8IW16P1) || \
+					(defined CONFIG_ARCH_SUN50IW10P1))
+#define G2D_V2X_SUPPORT
+#endif
+
+struct info_mem {
+	unsigned long phy_addr;
+	void *virt_addr;
+	__u32 b_used;
+	__u32 mem_len;
+};
+
+typedef struct {
+	struct device *dev;
+	struct resource *mem;
+	void __iomem *io;
+	__u32 irq;
+	struct mutex mutex;
+	struct clk *clk;
+	bool opened;
+	__u32 user_cnt;
+	struct clk *clk_parent;
+	struct clk *bus_clk;
+	struct clk *mbus_clk;
+	struct reset_control *reset;
+} __g2d_info_t;
+
+typedef struct {
+	__u32 mid;
+	__u32 used;
+	__u32 status;
+	struct semaphore *g2d_finished_sem;
+	struct semaphore *event_sem;
+	wait_queue_head_t queue;
+	__u32 finish_flag;
+} __g2d_drv_t;
+
+struct g2d_alloc_struct {
+	__u32 address;
+	__u32 size;
+	__u32 u_size;
+	struct g2d_alloc_struct *next;
+};
+
+/* g2d_format_attr - g2d format attribute
+ *
+ * @format: pixel format
+ * @bits: bits of each component
+ * @hor_rsample_u: reciprocal of horizontal sample rate
+ * @hor_rsample_v: reciprocal of horizontal sample rate
+ * @ver_rsample_u: reciprocal of vertical sample rate
+ * @hor_rsample_v: reciprocal of vertical sample rate
+ * @uvc: 1: u & v component combined
+ * @interleave: 0: progressive, 1: interleave
+ * @factor & div: bytes of pixel = factor / div (bytes)
+ * @addr[out]: address for each plane
+ * @trd_addr[out]: address for each plane of right eye buffer
+ */
+struct g2d_format_attr {
+	g2d_fmt_enh format;
+	unsigned int bits;
+	unsigned int hor_rsample_u;
+	unsigned int hor_rsample_v;
+	unsigned int ver_rsample_u;
+	unsigned int ver_rsample_v;
+	unsigned int uvc;
+	unsigned int interleave;
+	unsigned int factor;
+	unsigned int div;
+};
+
+
+irqreturn_t g2d_handle_irq(int irq, void *dev_id);
+int g2d_init(g2d_init_para *para);
+int g2d_blit(g2d_blt *para);
+int g2d_fill(g2d_fillrect *para);
+int g2d_stretchblit(g2d_stretchblt *para);
+/* int g2d_set_palette_table(g2d_palette *para); */
+int g2d_wait_cmd_finish(void);
+int g2d_cmdq(unsigned int para);
+static int g2d_suspend(struct device *dev);
+static int g2d_resume(struct device *dev);
+
+#endif /* __G2D_DRIVER_I_H */
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/Makefile b/drivers/char/sunxi_g2d/g2d_rcq/Makefile
new file mode 100644
index 000000000..a53c8a591
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/Makefile
@@ -0,0 +1,11 @@
+
+rcq_dir = g2d_rcq
+rcq_obj = ${rcq_dir}/g2d.o ${rcq_dir}/g2d_top.o
+
+ifeq (${CONFIG_SUNXI_G2D_MIXER},y)
+rcq_obj += ${rcq_dir}/g2d_mixer.o ${rcq_dir}/g2d_ovl_v.o ${rcq_dir}/g2d_ovl_u.o ${rcq_dir}/g2d_rcq.o ${rcq_dir}/g2d_scal.o  ${rcq_dir}/g2d_wb.o ${rcq_dir}/g2d_bld.o
+endif
+
+ifeq (${CONFIG_SUNXI_G2D_ROTATE},y)
+rcq_obj += ${rcq_dir}/g2d_rotate.o
+endif
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d.c
new file mode 100644
index 000000000..acd1fb315
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d.c
@@ -0,0 +1,1153 @@
+/*
+ * g2d_rcq/g2d_driver/g2d.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "g2d_driver_i.h"
+#include "g2d_top.h"
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+#include "g2d_mixer.h"
+#endif
+#if defined(CONFIG_SUNXI_G2D_ROTATE)
+#include "g2d_rotate.h"
+#endif
+
+/* alloc based on 4K byte */
+#define G2D_BYTE_ALIGN(x) (((x + (4*1024-1)) >> 12) << 12)
+static enum g2d_scan_order scan_order;
+static struct mutex global_lock;
+
+static struct class *g2d_class;
+static struct cdev *g2d_cdev;
+static dev_t devid;
+static struct device *g2d_dev;
+static struct device *dmabuf_dev;
+u32 g_time_info;
+u32 g_func_runtime;
+
+__g2d_drv_t g2d_ext_hd;
+__g2d_info_t para;
+
+__u32 dbg_info;
+
+static struct g2d_format_attr fmt_attr_tbl[] = {
+/*
+format  bits hor_rsample(u,v) ver_rsample(u,v) uvc interleave factor div
+*/
+	{ G2D_FORMAT_ARGB8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_ABGR8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_RGBA8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_BGRA8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_XRGB8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_XBGR8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_RGBX8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_BGRX8888, 8,  1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_RGB888, 8,  1, 1, 1, 1, 0, 1, 3, 1},
+	{ G2D_FORMAT_BGR888, 8,  1, 1, 1, 1, 0, 1, 3, 1},
+	{ G2D_FORMAT_RGB565, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_BGR565, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ARGB4444, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ABGR4444, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_RGBA4444, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_BGRA4444, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ARGB1555, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ABGR1555, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_RGBA5551, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_BGRA5551, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_ARGB2101010, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_ABGR2101010, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_RGBA1010102, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_BGRA1010102, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_IYUV422_V0Y1U0Y0, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_IYUV422_Y1V0Y0U0, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_IYUV422_U0Y1V0Y0, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_IYUV422_Y1U0Y0V0, 8,  1, 1, 1, 1, 0, 1, 2, 1},
+	{ G2D_FORMAT_YUV422_PLANAR, 8,  2, 2, 1, 1, 0, 0, 2, 1},
+	{ G2D_FORMAT_YUV420_PLANAR, 8,  2, 2, 2, 2, 0, 0, 3, 2},
+	{ G2D_FORMAT_YUV411_PLANAR, 8,  4, 4, 1, 1, 0, 0, 3, 2},
+	{ G2D_FORMAT_YUV422UVC_U1V1U0V0, 8,  2, 2, 1, 1, 1, 0, 2, 1},
+	{ G2D_FORMAT_YUV422UVC_V1U1V0U0, 8,  2, 2, 1, 1, 1, 0, 2, 1},
+	{ G2D_FORMAT_YUV420UVC_U1V1U0V0, 8,  2, 2, 2, 2, 1, 0, 3, 2},
+	{ G2D_FORMAT_YUV420UVC_V1U1V0U0, 8,  2, 2, 2, 2, 1, 0, 3, 2},
+	{ G2D_FORMAT_YUV411UVC_U1V1U0V0, 8,  4, 4, 1, 1, 1, 0, 3, 2},
+	{ G2D_FORMAT_YUV411UVC_V1U1V0U0, 8,  4, 4, 1, 1, 1, 0, 3, 2},
+	{ G2D_FORMAT_Y8, 8,  1, 1, 1, 1, 0, 0, 1, 1},
+	{ G2D_FORMAT_YVU10_444, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_YUV10_444, 10, 1, 1, 1, 1, 0, 1, 4, 1},
+	{ G2D_FORMAT_YVU10_P210, 10, 2, 2, 1, 1, 0, 0, 4, 1},
+	{ G2D_FORMAT_YVU10_P010, 10, 2, 2, 2, 2, 0, 0, 3, 1},
+};
+
+void *g2d_malloc(__u32 bytes_num, __u32 *phy_addr)
+{
+	void *address = NULL;
+
+#if defined(CONFIG_ION)
+	u32 actual_bytes;
+
+	if (bytes_num != 0) {
+		actual_bytes = G2D_BYTE_ALIGN(bytes_num);
+
+		address = dma_alloc_coherent(para.dev, actual_bytes,
+					     (dma_addr_t *) phy_addr,
+					     GFP_KERNEL);
+		if (address) {
+			return address;
+		}
+		G2D_ERR_MSG("dma_alloc_coherent fail, size=0x%x\n", bytes_num);
+		return NULL;
+	}
+	G2D_ERR_MSG("size is zero\n");
+#else
+	unsigned int map_size = 0;
+	struct page *page;
+
+	if (bytes_num != 0) {
+		map_size = PAGE_ALIGN(bytes_num);
+		page = alloc_pages(GFP_KERNEL, get_order(map_size));
+		if (page != NULL) {
+			address = page_address(page);
+			if (address == NULL) {
+				free_pages((unsigned long)(page),
+					   get_order(map_size));
+				G2D_ERR_MSG("page_address fail!\n");
+				return NULL;
+			}
+			*phy_addr = virt_to_phys(address);
+			return address;
+		}
+		G2D_ERR_MSG("alloc_pages fail!\n");
+		return NULL;
+	}
+	G2D_ERR_MSG("size is zero\n");
+#endif
+
+	return NULL;
+}
+
+void g2d_free(void *virt_addr, void *phy_addr, unsigned int size)
+{
+#if defined(CONFIG_ION)
+	u32 actual_bytes;
+
+	actual_bytes = PAGE_ALIGN(size);
+	if (phy_addr && virt_addr)
+		dma_free_coherent(para.dev, actual_bytes, virt_addr,
+				  (dma_addr_t) phy_addr);
+#else
+	unsigned int map_size = PAGE_ALIGN(size);
+	unsigned int page_size = map_size;
+
+	if (virt_addr == NULL)
+		return;
+
+	free_pages((unsigned long)virt_addr, get_order(page_size));
+#endif
+}
+
+int g2d_dma_map(int fd, struct dmabuf_item *item)
+{
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt;
+	int ret = -1;
+
+	if (fd < 0) {
+		pr_err("[G2D]dma_buf_id(%d) is invalid\n", fd);
+		goto exit;
+	}
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		pr_err("[G2D]dma_buf_get failed, fd=%d\n", fd);
+		goto exit;
+	}
+
+	attachment = dma_buf_attach(dmabuf, dmabuf_dev);
+	if (IS_ERR(attachment)) {
+		pr_err("[G2D]dma_buf_attach failed\n");
+		goto err_buf_put;
+	}
+	sgt = dma_buf_map_attachment(attachment, DMA_TO_DEVICE);
+	if (IS_ERR_OR_NULL(sgt)) {
+		pr_err("[G2D]dma_buf_map_attachment failed\n");
+		goto err_buf_detach;
+	}
+
+	item->fd = fd;
+	item->buf = dmabuf;
+	item->sgt = sgt;
+	item->attachment = attachment;
+	item->dma_addr = sg_dma_address(sgt->sgl);
+	ret = 0;
+	goto exit;
+
+err_buf_detach:
+	dma_buf_detach(dmabuf, attachment);
+err_buf_put:
+	dma_buf_put(dmabuf);
+exit:
+	return ret;
+}
+
+void g2d_dma_unmap(struct dmabuf_item *item)
+{
+	dma_buf_unmap_attachment(item->attachment, item->sgt, DMA_TO_DEVICE);
+	dma_buf_detach(item->buf, item->attachment);
+	dma_buf_put(item->buf);
+}
+
+__s32 g2d_set_info(g2d_image_enh *g2d_img, struct dmabuf_item *item)
+{
+	__s32 ret = -1;
+	__u32 i = 0;
+	__u32 len = ARRAY_SIZE(fmt_attr_tbl);
+	__u32 y_width, y_height, u_width, u_height;
+	__u32 y_pitch, u_pitch;
+	__u32 y_size, u_size;
+
+	g2d_img->laddr[0] = item->dma_addr;
+
+	if (g2d_img->format >= G2D_FORMAT_MAX) {
+		G2D_ERR_MSG("format 0x%x is out of range\n", g2d_img->format);
+		goto exit;
+	}
+
+	for (i = 0; i < len; ++i) {
+
+		if (fmt_attr_tbl[i].format == g2d_img->format) {
+			y_width = g2d_img->width;
+			y_height = g2d_img->height;
+			u_width = y_width/fmt_attr_tbl[i].hor_rsample_u;
+			u_height = y_height/fmt_attr_tbl[i].ver_rsample_u;
+
+			y_pitch = G2DALIGN(y_width, g2d_img->align[0]);
+			u_pitch = G2DALIGN(u_width * (fmt_attr_tbl[i].uvc + 1),
+					g2d_img->align[1]);
+
+			y_size = y_pitch * y_height;
+			u_size = u_pitch * u_height;
+			g2d_img->laddr[1] = g2d_img->laddr[0] + y_size;
+			g2d_img->laddr[2] = g2d_img->laddr[0] + y_size + u_size;
+
+			if (g2d_img->format == G2D_FORMAT_YUV420_PLANAR) {
+				/* v */
+				g2d_img->laddr[1] = g2d_img->laddr[0] + y_size + u_size;
+				g2d_img->laddr[2] = g2d_img->laddr[0] + y_size; /* u */
+			}
+
+			ret = 0;
+			break;
+		}
+	}
+	if (ret != 0)
+		G2D_ERR_MSG("format 0x%x is invalid\n", g2d_img->format);
+exit:
+	return ret;
+
+}
+
+__s32 g2d_byte_cal(__u32 format, __u32 *ycnt, __u32 *ucnt, __u32 *vcnt)
+{
+	*ycnt = 0;
+	*ucnt = 0;
+	*vcnt = 0;
+	if (format <= G2D_FORMAT_BGRX8888)
+		*ycnt = 4;
+
+	else if (format <= G2D_FORMAT_BGR888)
+		*ycnt = 3;
+
+	else if (format <= G2D_FORMAT_BGRA5551)
+		*ycnt = 2;
+
+	else if (format <= G2D_FORMAT_BGRA1010102)
+		*ycnt = 4;
+
+	else if (format <= 0x23) {
+		*ycnt = 2;
+	}
+
+	else if (format <= 0x25) {
+		*ycnt = 1;
+		*ucnt = 2;
+	}
+
+	else if (format == 0x26) {
+		*ycnt = 1;
+		*ucnt = 1;
+		*vcnt = 1;
+	}
+
+	else if (format <= 0x29) {
+		*ycnt = 1;
+		*ucnt = 2;
+	}
+
+	else if (format == 0x2a) {
+		*ycnt = 1;
+		*ucnt = 1;
+		*vcnt = 1;
+	}
+
+	else if (format <= 0x2d) {
+		*ycnt = 1;
+		*ucnt = 2;
+	}
+
+	else if (format == 0x2e) {
+		*ycnt = 1;
+		*ucnt = 1;
+		*vcnt = 1;
+	}
+
+	else if (format == 0x30)
+		*ycnt = 1;
+
+	else if (format <= 0x36) {
+		*ycnt = 2;
+		*ucnt = 4;
+	}
+
+	else if (format <= 0x39)
+		*ycnt = 6;
+	return 0;
+}
+
+
+/**
+ */
+__u32 cal_align(__u32 width, __u32 align)
+{
+	switch (align) {
+	case 0:
+		return width;
+	case 4:
+		return (width + 3) >> 2 << 2;
+	case 8:
+		return (width + 7) >> 3 << 3;
+	case 16:
+		return (width + 15) >> 4 << 4;
+	case 32:
+		return (width + 31) >> 5 << 5;
+	case 64:
+		return (width + 63) >> 6 << 6;
+	case 128:
+		return (width + 127) >> 7 << 7;
+	default:
+		return (width + 31) >> 5 << 5;
+	}
+}
+
+
+__s32 g2d_image_check(g2d_image_enh *p_image)
+{
+	__s32 ret = -EINVAL;
+
+	if (!p_image) {
+		G2D_ERR_MSG("NUll pointer!\n");
+		goto OUT;
+	}
+
+	if (((p_image->clip_rect.x < 0) &&
+	     ((-p_image->clip_rect.x) > p_image->clip_rect.w)) ||
+	    ((p_image->clip_rect.y < 0) &&
+	     ((-p_image->clip_rect.y) > p_image->clip_rect.h)) ||
+	    ((p_image->clip_rect.x > 0) &&
+	     (p_image->clip_rect.x > p_image->width - 1)) ||
+	    ((p_image->clip_rect.y > 0) &&
+	     (p_image->clip_rect.y > p_image->height - 1))) {
+		G2D_ERR_MSG("Invalid imager parameter setting\n");
+		goto OUT;
+	}
+
+	if (((p_image->clip_rect.x < 0) &&
+				((-p_image->clip_rect.x) <
+				 p_image->clip_rect.w))) {
+		p_image->clip_rect.w =
+			p_image->clip_rect.w +
+			p_image->clip_rect.x;
+		p_image->clip_rect.x = 0;
+	} else if ((p_image->clip_rect.x +
+				p_image->clip_rect.w)
+			> p_image->width) {
+		p_image->clip_rect.w =
+			p_image->width -
+			p_image->clip_rect.x;
+	}
+	if (((p_image->clip_rect.y < 0) &&
+				((-p_image->clip_rect.y) <
+				 p_image->clip_rect.h))) {
+		p_image->clip_rect.h =
+			p_image->clip_rect.h +
+			p_image->clip_rect.y;
+		p_image->clip_rect.y = 0;
+	} else if ((p_image->clip_rect.y +
+				p_image->clip_rect.h)
+			> p_image->height) {
+		p_image->clip_rect.h =
+			p_image->height -
+			p_image->clip_rect.y;
+	}
+
+	p_image->bpremul = 0;
+	p_image->bbuff = 1;
+	ret = 0;
+OUT:
+	return ret;
+
+}
+
+static int g2d_clock_enable(__g2d_info_t *info)
+{
+	int ret = 0;
+
+	if (info->reset) {
+		ret = reset_control_deassert(info->reset);
+		if (ret != 0) {
+			pr_err("[G2D] deassert error\n");
+			return ret;
+		}
+	}
+
+	if (info->bus_clk) {
+		ret |=  clk_prepare_enable(info->bus_clk);
+	}
+
+	if (info->clk) {
+		if (info->clk_parent) {
+			clk_set_parent(info->clk, info->clk_parent);
+		}
+		clk_set_rate(info->clk, 300000000);
+		ret |= clk_prepare_enable(info->clk);
+	}
+	if (info->mbus_clk) {
+		ret |= clk_prepare_enable(info->mbus_clk);
+	}
+	if (ret != 0)
+		pr_err("[G2D] clock enable error\n");
+
+	return ret;
+}
+
+static int g2d_clock_disable(const __g2d_info_t *info)
+{
+	if (info->clk)
+		clk_disable(info->clk);
+	if (info->bus_clk)
+		clk_disable(info->bus_clk);
+	if (info->mbus_clk)
+		clk_disable(info->mbus_clk);
+	if (info->reset)
+		reset_control_assert(info->reset);
+	return 0;
+}
+
+int g2d_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&para.mutex);
+	para.user_cnt++;
+	if (para.user_cnt == 1) {
+		g2d_clock_enable(&para);
+		para.opened = true;
+		g2d_bsp_open();
+	}
+
+	mutex_unlock(&para.mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(g2d_open);
+
+int g2d_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&para.mutex);
+	para.user_cnt--;
+	if (para.user_cnt == 0) {
+		g2d_clock_disable(&para);
+		para.opened = false;
+		g2d_bsp_close();
+	}
+
+	mutex_unlock(&para.mutex);
+
+	mutex_lock(&global_lock);
+	scan_order = G2D_SM_TDLR;
+	mutex_unlock(&global_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(g2d_release);
+
+int g2d_blit_h(g2d_blt_h *para)
+{
+	int ret = -1;
+#if defined(CONFIG_SUNXI_G2D_ROTATE)
+	ret = g2d_rotate_set_para(&para->src_image_h,
+			    &para->dst_image_h,
+			    para->flag_h);
+#else
+	G2D_ERR_MSG("Please enable CONFIG_SUNXI_G2D_ROTATE\n");
+#endif
+	return ret;
+}
+EXPORT_SYMBOL_GPL(g2d_blit_h);
+
+int g2d_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long mypfn = vma->vm_pgoff;
+	unsigned long vmsize = vma->vm_end - vma->vm_start;
+
+	vma->vm_pgoff = 0;
+
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	if (remap_pfn_range(vma, vma->vm_start, mypfn,
+			    vmsize, vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+#if defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+extern void sunxi_reset_device_iommu(unsigned int master_id);
+#endif
+
+int g2d_wait_cmd_finish(unsigned int timeout)
+{
+	timeout = wait_event_timeout(g2d_ext_hd.queue,
+				     g2d_ext_hd.finish_flag == 1,
+				     msecs_to_jiffies(timeout));
+	if (timeout == 0) {
+		g2d_bsp_reset();
+		G2D_ERR_MSG("G2D irq pending flag timeout\n");
+
+		/* reset iommu */
+#if defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+		sunxi_reset_device_iommu(G2D_IOMMU_MASTER_ID);
+#endif
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+		return -1;
+	}
+	g2d_ext_hd.finish_flag = 0;
+
+	return 0;
+}
+
+irqreturn_t g2d_handle_irq(int irq, void *dev_id)
+{
+
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+#if G2D_MIXER_RCQ_USED == 1
+	if (g2d_top_rcq_task_irq_query()) {
+		g2d_top_mixer_reset();
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+		return IRQ_HANDLED;
+	}
+#else
+	if (g2d_mixer_irq_query()) {
+		g2d_top_mixer_reset();
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+		return IRQ_HANDLED;
+	}
+#endif
+#endif
+
+
+
+#if defined(CONFIG_SUNXI_G2D_ROTATE)
+	if (g2d_rot_irq_query()) {
+		g2d_ext_hd.finish_flag = 1;
+		wake_up(&g2d_ext_hd.queue);
+		return IRQ_HANDLED;
+	}
+#endif
+
+	return IRQ_HANDLED;
+}
+void g2d_ioctl_mutex_lock(void)
+{
+	if (!mutex_trylock(&para.mutex))
+		mutex_lock(&para.mutex);
+}
+EXPORT_SYMBOL_GPL(g2d_ioctl_mutex_lock);
+
+void g2d_ioctl_mutex_unlock(void)
+{
+	mutex_unlock(&para.mutex);
+}
+EXPORT_SYMBOL_GPL(g2d_ioctl_mutex_unlock);
+
+long g2d_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = -1;
+	struct timespec64 test_start, test_end;
+
+
+	if (g_time_info == 1)
+		ktime_get_real_ts64(&test_start);
+
+	if (!mutex_trylock(&para.mutex))
+		mutex_lock(&para.mutex);
+
+	g2d_ext_hd.finish_flag = 0;
+	switch (cmd) {
+	case G2D_CMD_MIXER_TASK:
+		{
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+		struct mixer_para *p_mixer_para = NULL;
+		unsigned long karg[2];
+		unsigned long ubuffer[2] = { 0 };
+
+		if (copy_from_user((void *)karg, (void __user *)arg,
+				   sizeof(unsigned long) * 2)) {
+			ret = -EFAULT;
+			goto err_noput;
+		}
+		ubuffer[0] = *(unsigned long *)karg;
+		ubuffer[1] = (*(unsigned long *)(karg + 1));
+
+		p_mixer_para = kmalloc(sizeof(struct mixer_para) * ubuffer[1],
+			       GFP_KERNEL | __GFP_ZERO);
+		if (!p_mixer_para)
+			goto err_noput;
+		if (copy_from_user(p_mixer_para, (void __user *)ubuffer[0],
+				   sizeof(struct mixer_para) * ubuffer[1])) {
+			ret = -EFAULT;
+			goto err_noput;
+		}
+		ret  = mixer_task_process(&para, p_mixer_para, ubuffer[1]);
+		kfree(p_mixer_para);
+#endif
+		break;
+		}
+	case G2D_CMD_CREATE_TASK:
+		{
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+			struct mixer_para *p_mixer_para = NULL;
+			unsigned long karg[2];
+			unsigned long ubuffer[2] = { 0 };
+
+			if (copy_from_user((void *)karg, (void __user *)arg,
+					   sizeof(unsigned long) * 2)) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ubuffer[0] = *(unsigned long *)karg;
+			ubuffer[1] = (*(unsigned long *)(karg + 1));
+			p_mixer_para = kmalloc(sizeof(struct mixer_para) * ubuffer[1],
+					       GFP_KERNEL | __GFP_ZERO);
+			if (!p_mixer_para)
+				goto err_noput;
+			if (copy_from_user(p_mixer_para, (void __user *)ubuffer[0],
+					   sizeof(struct mixer_para) * ubuffer[1])) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = create_mixer_task(&para, p_mixer_para, ubuffer[1]);
+			if (copy_to_user((void __user *)ubuffer[0], p_mixer_para,
+					 sizeof(struct mixer_para) * ubuffer[1])) {
+				G2D_ERR_MSG("copy_to_user fail\n");
+				return  -EFAULT;
+			}
+			kfree(p_mixer_para);
+#endif
+			break;
+		}
+	case G2D_CMD_TASK_APPLY:
+		{
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+			unsigned long karg[2];
+			unsigned long ubuffer[2] = { 0 };
+			struct mixer_para *p_mixer_para = NULL;
+			struct g2d_mixer_task *p_task = NULL;
+
+			if (copy_from_user((void *)karg, (void __user *)arg,
+					   sizeof(unsigned long) * 2)) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ubuffer[0] = *(unsigned long *)karg;
+			ubuffer[1] = (*(unsigned long *)(karg + 1));
+			p_task = g2d_mixer_get_inst(ubuffer[0]);
+			if (!p_task) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			p_mixer_para = kmalloc(sizeof(struct mixer_para) * p_task->frame_cnt,
+					       GFP_KERNEL | __GFP_ZERO);
+			if (!p_mixer_para)
+				goto err_noput;
+			if (copy_from_user(p_mixer_para, (void __user *)ubuffer[1],
+					   sizeof(struct mixer_para) * p_task->frame_cnt)) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ret = p_task->apply(p_task, p_mixer_para);
+			kfree(p_mixer_para);
+#endif
+			break;
+		}
+	case G2D_CMD_TASK_DESTROY:
+		{
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+			unsigned long karg[1];
+			unsigned long ubuffer[1] = { 0 };
+			struct g2d_mixer_task *p_task = NULL;
+
+			if (copy_from_user((void *)karg, (void __user *)arg,
+					   sizeof(unsigned long))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ubuffer[0] = *(unsigned long *)karg;
+			p_task = g2d_mixer_get_inst(ubuffer[0]);
+
+			if (!p_task) {
+				ret = -EFAULT;
+				G2D_ERR_MSG("Fail to find mixer task inst:%lu\n", ubuffer[0]);
+				goto err_noput;
+			}
+
+			ret = p_task->destory(p_task);
+#endif
+			break;
+		}
+	case G2D_CMD_TASK_GET_PARA:
+		{
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+			struct g2d_mixer_task *p_task = NULL;
+			unsigned long karg[2];
+			unsigned long ubuffer[2] = { 0 };
+
+			if (copy_from_user((void *)karg, (void __user *)arg,
+					   sizeof(unsigned long) * 2)) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			ubuffer[0] = *(unsigned long *)karg;
+			ubuffer[1] = (*(unsigned long *)(karg + 1));
+
+			p_task = g2d_mixer_get_inst(ubuffer[0]);
+			if (!p_task || !ubuffer[1]) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+
+			ret = copy_to_user(
+			    (void __user *)ubuffer[1], p_task->p_para,
+			    sizeof(struct mixer_para) * p_task->frame_cnt);
+#endif
+			break;
+		}
+	case G2D_CMD_BITBLT_H:
+		{
+		g2d_blt_h blit_para;
+
+		if (copy_from_user(&blit_para, (g2d_blt_h *) arg,
+				   sizeof(g2d_blt_h))) {
+			ret = -EFAULT;
+			goto err_noput;
+		}
+
+		if (blit_para.flag_h & 0xff00) {
+			ret = g2d_blit_h(&blit_para);
+		}
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+		else {
+			struct mixer_para mixer_blit_para;
+			/*mixer module*/
+			memset(&mixer_blit_para, 0, sizeof(struct mixer_para));
+			memcpy(&mixer_blit_para.dst_image_h,
+			       &blit_para.dst_image_h, sizeof(g2d_image_enh));
+			memcpy(&mixer_blit_para.src_image_h,
+			       &blit_para.src_image_h, sizeof(g2d_image_enh));
+			mixer_blit_para.flag_h = blit_para.flag_h;
+			mixer_blit_para.op_flag = OP_BITBLT;
+			ret = mixer_task_process(&para, &mixer_blit_para, 1);
+		}
+
+#endif
+		break;
+		}
+	case G2D_CMD_LBC_ROT:
+		{
+			g2d_lbc_rot lbc_para;
+
+			if (copy_from_user(&lbc_para, (g2d_lbc_rot *)arg,
+						sizeof(g2d_lbc_rot))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+
+			ret = g2d_lbc_rot_set_para(&lbc_para);
+			break;
+		}
+
+	case G2D_CMD_BLD_H:{
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+			g2d_bld bld_para;
+			struct mixer_para mixer_bld_para;
+
+			if (copy_from_user(&bld_para, (g2d_bld *) arg,
+					   sizeof(g2d_bld))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			memset(&mixer_bld_para, 0, sizeof(struct mixer_para));
+			memcpy(&mixer_bld_para.dst_image_h,
+			       &bld_para.dst_image, sizeof(g2d_image_enh));
+			memcpy(&mixer_bld_para.src_image_h,
+			       &bld_para.src_image[0], sizeof(g2d_image_enh));
+			/* ptn use as src  */
+			memcpy(&mixer_bld_para.ptn_image_h,
+			       &bld_para.src_image[1], sizeof(g2d_image_enh));
+			memcpy(&mixer_bld_para.ck_para, &bld_para.ck_para,
+			       sizeof(g2d_ck));
+			mixer_bld_para.bld_cmd = bld_para.bld_cmd;
+			mixer_bld_para.op_flag = OP_BLEND;
+
+			ret  = mixer_task_process(&para, &mixer_bld_para, 1);
+#endif
+			break;
+		}
+	case G2D_CMD_FILLRECT_H:{
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+		g2d_fillrect_h fill_para;
+		struct mixer_para mixer_fill_para;
+
+		if (copy_from_user(&fill_para, (g2d_fillrect_h *) arg,
+				   sizeof(g2d_fillrect_h))) {
+			ret = -EFAULT;
+			goto err_noput;
+		}
+		memset(&mixer_fill_para, 0, sizeof(struct mixer_para));
+		memcpy(&mixer_fill_para.dst_image_h,
+		       &fill_para.dst_image_h, sizeof(g2d_image_enh));
+		mixer_fill_para.op_flag = OP_FILLRECT;
+
+		ret  = mixer_task_process(&para, &mixer_fill_para, 1);
+#endif
+		break;
+	}
+	case G2D_CMD_MASK_H:{
+#if defined(CONFIG_SUNXI_G2D_MIXER)
+			g2d_maskblt mask_para;
+			struct mixer_para mixer_mask_para;
+
+			if (copy_from_user(&mask_para, (g2d_maskblt *) arg,
+					   sizeof(g2d_maskblt))) {
+				ret = -EFAULT;
+				goto err_noput;
+			}
+			memset(&mixer_mask_para, 0, sizeof(struct mixer_para));
+			memcpy(&mixer_mask_para.ptn_image_h,
+			       &mask_para.ptn_image_h, sizeof(g2d_image_enh));
+			memcpy(&mixer_mask_para.mask_image_h,
+			       &mask_para.mask_image_h, sizeof(g2d_image_enh));
+			memcpy(&mixer_mask_para.dst_image_h,
+			       &mask_para.dst_image_h, sizeof(g2d_image_enh));
+			memcpy(&mixer_mask_para.src_image_h,
+			       &mask_para.src_image_h, sizeof(g2d_image_enh));
+			mixer_mask_para.back_flag = mask_para.back_flag;
+			mixer_mask_para.fore_flag = mask_para.fore_flag;
+			mixer_mask_para.op_flag = OP_MASK;
+
+			ret  = mixer_task_process(&para, &mixer_mask_para, 1);
+#endif
+			break;
+		}
+	case G2D_CMD_INVERTED_ORDER:
+		{
+			if (arg > G2D_SM_DTRL) {
+				G2D_ERR_MSG("scan mode is err.\n");
+				ret = -EINVAL;
+				goto err_noput;
+			}
+
+			mutex_lock(&global_lock);
+			scan_order = arg;
+			mutex_unlock(&global_lock);
+			break;
+		}
+
+	default:
+		goto err_noput;
+		break;
+	}
+
+err_noput:
+	mutex_unlock(&para.mutex);
+	if (g_time_info == 1) {
+		ktime_get_real_ts64(&test_end);
+		g_func_runtime += (test_end.tv_sec - test_start.tv_sec) * 1000000 +
+			(test_end.tv_nsec - test_start.tv_nsec) / NSEC_PER_USEC;
+	}
+	return ret;
+}
+
+__s32 drv_g2d_init(void)
+{
+	memset(&g2d_ext_hd, 0, sizeof(__g2d_drv_t));
+	init_waitqueue_head(&g2d_ext_hd.queue);
+	g2d_top_set_base((unsigned long) para.io);
+
+#if defined(CONFIG_SUNXI_G2D_ROTATE)
+	g2d_rot_set_base((unsigned long) para.io);
+#endif
+	return 0;
+}
+
+static ssize_t g2d_debug_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "debug=%d\n", dbg_info);
+}
+
+static ssize_t g2d_debug_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	if (strncasecmp(buf, "1", 1) == 0)
+		dbg_info = 1;
+	else if (strncasecmp(buf, "0", 1) == 0)
+		dbg_info = 0;
+	else if (strncasecmp(buf, "2", 1) == 0)
+		dbg_info = 2;
+	else
+		G2D_ERR_MSG("Error input!\n");
+
+	return count;
+}
+
+static DEVICE_ATTR(debug, 0660,
+		   g2d_debug_show, g2d_debug_store);
+
+static ssize_t g2d_func_runtime_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "func_runtime = %d us\n", g_func_runtime);
+}
+
+static ssize_t g2d_func_runtime_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	g_func_runtime = 0;
+	if (strncasecmp(buf, "1", 1) == 0)
+		g_time_info = 1;
+	else if (strncasecmp(buf, "0", 1) == 0)
+		g_time_info = 0;
+	else
+		G2D_ERR_MSG("Error input!\n");
+
+	return count;
+}
+
+static DEVICE_ATTR(func_runtime, 0660,
+		   g2d_func_runtime_show, g2d_func_runtime_store);
+
+static struct attribute *g2d_attributes[] = {
+	&dev_attr_debug.attr,
+	&dev_attr_func_runtime.attr,
+	NULL
+};
+
+static struct attribute_group g2d_attribute_group = {
+	.name = "attr",
+	.attrs = g2d_attributes
+};
+
+static u64 sunxi_g2d_dma_mask = DMA_BIT_MASK(32);
+static int g2d_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	__g2d_info_t *info = NULL;
+
+	info = &para;
+	info->dev = &pdev->dev;
+	dmabuf_dev = &pdev->dev;
+	dmabuf_dev->dma_mask = &sunxi_g2d_dma_mask;
+	dmabuf_dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	platform_set_drvdata(pdev, info);
+
+	info->io = of_iomap(pdev->dev.of_node, 0);
+	if (info->io == NULL) {
+		G2D_ERR_MSG("iormap() of register failed\n");
+		ret = -ENXIO;
+		goto dealloc_fb;
+	}
+
+	info->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (!info->irq) {
+		G2D_ERR_MSG("irq_of_parse_and_map irq fail for transform\n");
+		ret = -ENXIO;
+		goto release_regs;
+	}
+
+	/* request the irq */
+	ret = request_irq(info->irq, g2d_handle_irq, 0,
+			  dev_name(&pdev->dev), NULL);
+	if (ret) {
+		G2D_ERR_MSG("failed to install irq resource\n");
+		goto release_regs;
+	}
+	/* clk init */
+	info->clk = devm_clk_get(&pdev->dev, "g2d");
+	if (IS_ERR(info->clk)) {
+		G2D_ERR_MSG("fail to get clk\n");
+		ret = -ENXIO;
+		goto out_dispose_mapping;
+	} else {
+		info->clk_parent = clk_get_parent(info->clk);
+		info->bus_clk = devm_clk_get(&pdev->dev, "bus");
+		info->mbus_clk = devm_clk_get(&pdev->dev, "mbus_g2d");
+		info->reset = devm_reset_control_get(&pdev->dev, NULL);
+	}
+
+	drv_g2d_init();
+	mutex_init(&info->mutex);
+	mutex_init(&global_lock);
+
+	ret = sysfs_create_group(&g2d_dev->kobj, &g2d_attribute_group);
+	if (ret < 0)
+		G2D_ERR_MSG("sysfs_create_file fail!\n");
+
+	return 0;
+
+out_dispose_mapping:
+	irq_dispose_mapping(info->irq);
+release_regs:
+	iounmap(info->io);
+dealloc_fb:
+	platform_set_drvdata(pdev, NULL);
+
+	return ret;
+}
+
+
+static const struct file_operations g2d_fops = {
+	.owner = THIS_MODULE,
+	.open = g2d_open,
+	.release = g2d_release,
+	.unlocked_ioctl = g2d_ioctl,
+	.mmap = g2d_mmap,
+};
+
+static int g2d_remove(struct platform_device *pdev)
+{
+	__g2d_info_t *info = platform_get_drvdata(pdev);
+
+	free_irq(info->irq, NULL);
+
+	platform_set_drvdata(pdev, NULL);
+
+	sysfs_remove_group(&g2d_dev->kobj, &g2d_attribute_group);
+
+	INFO("Driver unloaded succesfully.\n");
+	return 0;
+}
+
+static int g2d_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	INFO("%s.\n", __func__);
+	mutex_lock(&para.mutex);
+	if (para.opened) {
+		g2d_clock_disable(&para);
+		g2d_bsp_close();
+	}
+	mutex_unlock(&para.mutex);
+	INFO("g2d_suspend succesfully.\n");
+
+	return 0;
+}
+
+static int g2d_resume(struct platform_device *pdev)
+{
+	INFO("%s.\n", __func__);
+	mutex_lock(&para.mutex);
+	if (para.opened) {
+		g2d_clock_enable(&para);
+		g2d_bsp_open();
+	}
+	mutex_unlock(&para.mutex);
+	INFO("g2d_resume succesfully.\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_g2d_match[] = {
+	{.compatible = "allwinner,sunxi-g2d",},
+	{},
+};
+
+static struct platform_driver g2d_driver = {
+	.probe = g2d_probe,
+	.remove = g2d_remove,
+	.suspend = g2d_suspend,
+	.resume = g2d_resume,
+	.driver = {
+
+		   .owner = THIS_MODULE,
+		   .name = "g2d",
+		   .of_match_table = sunxi_g2d_match,
+		   },
+};
+
+int __init g2d_module_init(void)
+{
+	int ret = 0, err;
+
+	alloc_chrdev_region(&devid, 0, 1, "g2d_chrdev");
+	g2d_cdev = cdev_alloc();
+	cdev_init(g2d_cdev, &g2d_fops);
+	g2d_cdev->owner = THIS_MODULE;
+	err = cdev_add(g2d_cdev, devid, 1);
+	if (err) {
+		G2D_ERR_MSG("I was assigned major number %d.\n", MAJOR(devid));
+		return -1;
+	}
+
+	g2d_class = class_create(THIS_MODULE, "g2d");
+	if (IS_ERR(g2d_class)) {
+		G2D_ERR_MSG("create class error\n");
+		return -1;
+	}
+
+	g2d_dev = device_create(g2d_class, NULL, devid, NULL, "g2d");
+	if (ret == 0)
+		ret = platform_driver_register(&g2d_driver);
+
+	INFO("rcq version initialized.major:%d\n", MAJOR(devid));
+	return ret;
+}
+
+static void __exit g2d_module_exit(void)
+{
+	INFO("g2d_module_exit\n");
+
+	platform_driver_unregister(&g2d_driver);
+	device_destroy(g2d_class, devid);
+	class_destroy(g2d_class);
+
+	cdev_del(g2d_cdev);
+}
+
+subsys_initcall_sync(g2d_module_init);
+module_exit(g2d_module_exit);
+
+MODULE_AUTHOR("zxb <zhengxiaobin@allwinnertech.com>");
+MODULE_DESCRIPTION("g2d(rcq) driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.c
new file mode 100644
index 000000000..dc9822dec
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.c
@@ -0,0 +1,740 @@
+/*
+ * g2d_bld/g2d_bld.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "g2d_bld.h"
+
+__s32 rgb2Ycbcr_601[48] = {
+	/* full to limit */
+	/* (0.2568, 0.5041, 0.0979, 16) * 1024
+	 * (-0.1482, -0.291, 0.4392, 128) * 1024
+	 * (0.4392, -0.3678, -0.0714, 128) * 1024
+	 * */
+	0x107, 0x204, 0x064, 0x4000, 0xFFFFFF68, 0xFFFFFED6, 0x01c2, 0x20000,
+	0x01c2, 0xFFFFFE87, 0xFFFFFFB7, 0x20000,
+	/* limit to limit */
+	0x132, 0x259, 0x075, 0x0, 0xFFFFFF4F, 0xFFFFFEA5, 0x020c, 0x20000,
+	0x020c, 0xFFFFFE49, 0xFFFFFFAB, 0x20000,
+	/* full to full */
+	0x132, 0x0259, 0x075, 0x0, 0xFFFFFF53, 0xFFFFFEAD, 0x0200, 0x20000,
+	0x0200, 0xFFFFFE53, 0xFFFFFFAD, 0x20000,
+	/* limit to full */
+	0x0165, 0x02BC, 0x088, 0xFFFFF570, 0xFFFFFF37, 0xFFFFFE75, 0x0254, 0x20000,
+	0x0254, 0xFFFFFE0D, 0xFFFFFF9F, 0x20000,
+};
+__s32 Ycbcr2rgb_601[48] = {
+	/* full to limit */
+	0x04a8, 0x0, 0x0662, 0xFFFC8480, 0x04a8, 0xFFFFFE6F, 0xFFFFFCC0,
+	0x21E00, 0x04a8, 0x0812, 0x0, 0xFFFBAC80,
+	/* limit to limit */
+	0x0400, 0x0, 0x057c, 0xFFFD0200, 0x0400, 0xFFFFFEA7, 0xFFFFFD35, 0x1D200,
+	0x0400, 0x06EE, 0x0, 0xFFFC4900,
+	/* full to full */
+	0x0400, 0x0, 0x059c, 0xFFFCF200, 0x0400, 0xFFFFFEA0, 0xFFFFFD25, 0x1DD80,
+	0x0400, 0x0717, 0x0, 0xFFFC3480,
+	/* limit to full */
+	0x036F, 0x0, 0x04D1, 0xFFFDA090, 0x36F, 0xFFFFFED1, 0xFFFFFD8C, 0x1DA90,
+	0x036F, 0x0616, 0x0, 0xFFFCFE10,
+};
+__s32 rgb2Ycbcr_709[48] = {
+	/* full to limit */
+	0x0bb, 0x0275, 0x03f, 0x4000, 0xFFFFFF99, 0xFFFFFEA5, 0x01c2, 0x20000,
+	0x01c2, 0xFFFFFE67, 0xFFFFFFD7, 0x20000,
+	/* limit to limit */
+	0x0DA, 0x02DC, 0x04A, 0x0, 0xFFFFFF88, 0xFFFFFE6C, 0x020c, 0x20000,
+	0x020c, 0xFFFFFE24, 0xFFFFFFD0, 0x20000,
+	/* full to full */
+	0x0DA, 0x02DC, 0x04a, 0x0, 0xFFFFFF8B, 0xFFFFFE75, 0x0200, 0x20000,
+	0x0200, 0xFFFFFE2F, 0xFFFFFFD1, 0x20000,
+	/* limit to full */
+	0x0FD, 0x0355, 0x056, 0xFFFFF580, 0xFFFFFF77, 0xFFFFFE34, 0x0254, 0x20010,
+	0x0254, 0xFFFFFDE3, 0xFFFFFFC9, 0x20000,
+};
+
+__s32 Ycbcr2rgb_709[48] = {
+	/* full to limit */
+	0x04a8, 0x0, 0x072c, 0xFFFC1F80, 0x04a8, 0xFFFFFF26, 0xFFFFFDDE,
+	0x13380, 0x04a8, 0x0873, 0, 0xFFFB7C00,
+	/* limit to limit */
+	0x0400, 0x0, 0x0629, 0xFFFCAB80, 0x0400, 0xFFFFFF44, 0xFFFFE2B, 0x10880,
+	0x0400, 0x0742, 0x0, 0xFFFC1F00,
+	/* full to full */
+	0x0400, 0x0, 0x64D, 0xFFFC9980, 0x0400, 0xFFFFFF40, 0xFFFFFE21, 0x10F80,
+	0x0400, 0x076C, 0x0, 0xFFFC0A00,
+	/* limit to full */
+	0x36f, 0x0, 0x0569, 0xFFFD5490, 0x36f, 0xFFFFFF5B, 0xFFFFFE64, 0x12990,
+	0x36f, 0x0660, 0x0, 0xFFFCD910,
+};
+
+/*
+ * sel: 0-->pipe0 1-->pipe1 other:error
+ */
+__s32 bld_in_set(struct blender_submodule *p_bld, __u32 sel, g2d_rect rect,
+		    int premul)
+{
+	__s32 ret = -1;
+
+	struct g2d_mixer_bld_reg *p_reg = NULL;
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	if (sel == 0) {
+		p_reg->bld_en_ctrl.bits.p0_en = 1;
+		/* we best use p0 as bottom layer */
+		p_reg->bld_en_ctrl.bits.p0_fcen = 1;
+		if (premul)
+			p_reg->premulti_ctrl.bits.p0_alpha_mode = 1;
+	} else if (sel == 1) {
+		p_reg->bld_en_ctrl.bits.p1_en = 1;
+		if (premul)
+			p_reg->premulti_ctrl.bits.p1_alpha_mode = 1;
+	} else
+		goto OUT;
+
+	p_reg->mem_size[sel].bits.width = rect.w - 1;
+	p_reg->mem_size[sel].bits.height = rect.h - 1;
+
+	p_reg->mem_coor[sel].bits.xcoor = rect.x <= 0 ? 0 : rect.x - 1;
+	p_reg->mem_coor[sel].bits.ycoor = rect.y <= 0 ? 0 : rect.y - 1;
+
+	ret = 0;
+
+	p_bld->set_block_dirty(p_bld, 0, 1);
+
+OUT:
+	return ret;
+}
+
+/**
+ * set colorkey para.
+ */
+__s32 bld_ck_para_set(struct blender_submodule *p_bld, g2d_ck *para, __u32 flag)
+{
+	__u32 tmp = 0x0;
+	__s32 ret = -1;
+
+	struct g2d_mixer_bld_reg *p_reg = NULL;
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg || !para)
+		goto OUT;
+
+	if (para->match_rule)
+		tmp = 0x7;
+
+	p_reg->color_key_cfg.dwval = tmp;
+	p_reg->color_key_max.dwval = para->max_color & 0x00ffffff;
+	p_reg->color_key_min.dwval = para->min_color & 0x00ffffff;
+
+	if (flag & G2D_CK_SRC) {
+		p_reg->color_key.bits.key0_en = 1;
+		p_reg->color_key.bits.key0_match_dir = 0;
+	} else if (flag & G2D_CK_DST) {
+		p_reg->color_key.bits.key0_en = 1;
+		p_reg->color_key.bits.key0_match_dir = 1;
+	}
+
+	p_bld->set_block_dirty(p_bld, 0, 1);
+OUT:
+	return ret;
+}
+
+/**
+ * background color set
+ */
+__s32 bld_bk_set(struct blender_submodule *p_bld, __u32 color)
+{
+	__s32 ret = -1;
+
+	struct g2d_mixer_bld_reg *p_reg = NULL;
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->bld_backgroud_color = color & 0xffffffff;
+	ret = 0;
+	p_bld->set_block_dirty(p_bld, 0, 1);
+OUT:
+	return ret;
+}
+
+__s32 bld_out_setting(struct blender_submodule *p_bld, g2d_image_enh *p_image)
+{
+	__s32 ret = -1;
+
+	struct g2d_mixer_bld_reg *p_reg = NULL;
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	if (p_image->bpremul)
+		p_reg->out_color.bits.premul_en = 1;
+	else
+		p_reg->out_color.bits.premul_en = 0;
+	p_reg->out_size.bits.width =
+	    p_image->clip_rect.w == 0 ? 0 : p_image->clip_rect.w - 1;
+	p_reg->out_size.bits.height =
+	    p_image->clip_rect.h == 0 ? 0 : p_image->clip_rect.h - 1;
+	p_bld->set_block_dirty(p_bld, 0, 1);
+	ret = 0;
+OUT:
+	return ret;
+}
+
+__s32 bld_set_rop_ctrl(struct blender_submodule *p_bld, __u32 value)
+{
+	__s32 ret = -1;
+
+	struct g2d_mixer_bld_reg *p_reg = NULL;
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->rop_ctrl.dwval = value;
+	p_reg->ch3_index0.dwval = 0x41000;
+	ret = 0;
+	p_bld->set_block_dirty(p_bld, 0, 1);
+OUT:
+	return ret;
+}
+
+/**
+ * set the bld color space based on the format
+ * if the format is UI, then set the bld in RGB color space
+ * if the format is Video, then set the bld in YUV color space
+ */
+__s32 bld_cs_set(struct blender_submodule *p_bld, __u32 format)
+{
+	__s32 ret = -1;
+
+	struct g2d_mixer_bld_reg *p_reg = NULL;
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	if (format <= G2D_FORMAT_BGRA1010102) {
+		p_reg->out_color.bits.alpha_mode = 0;
+	} else if (format <= G2D_FORMAT_YUV411_PLANAR) {
+		p_reg->out_color.bits.alpha_mode = 1;
+	} else
+		goto OUT;
+
+	p_bld->set_block_dirty(p_bld, 0, 1);
+	ret = 0;
+OUT:
+	return ret;
+}
+
+/**
+ * @csc_no: CSC ID, G2D support three CSC,
+ * -1 will return to indicate inappropriate CSC number.
+ * @csc_sel: CSC format, G2D support the ITU-R 601. ITU-R 709. standard trans-
+ *  form between RGB and YUV colorspace.
+ */
+__s32 bld_csc_reg_set(struct blender_submodule *p_bld, __u32 csc_no,
+		g2d_csc_sel csc_sel, enum color_range src_cr, enum color_range dst_cr)
+{
+	void *csc_base_addr;
+	__s32 ret = -1;
+
+	struct g2d_mixer_bld_reg *p_reg = NULL;
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->bld_fill_color[0] = 0x00108080;
+	p_reg->bld_fill_color[1] = 0x00108080;
+
+	switch (csc_no) {
+	case 0:
+		csc_base_addr = &p_reg->csc0_coeff0_reg0;
+		p_reg->cs_ctrl.bits.cs0_en = 1;
+		break;
+	case 1:
+		csc_base_addr = &p_reg->csc1_coeff0_reg0;
+		p_reg->cs_ctrl.bits.cs1_en = 1;
+		break;
+	case 2:
+		csc_base_addr = &p_reg->csc2_coeff0_reg0;
+		p_reg->cs_ctrl.bits.cs2_en = 1;
+		break;
+	default:
+		goto OUT;
+	}
+	switch (csc_sel) {
+	case G2D_RGB2YUV_709:
+		if (src_cr == COLOR_RANGE_0_255) {
+			if (dst_cr == COLOR_RANGE_0_255)
+				/* full to full */
+				memcpy(csc_base_addr, (rgb2Ycbcr_709 + 0x18), 12 * sizeof(unsigned int));
+			else
+				/* full to limit */
+				memcpy(csc_base_addr, rgb2Ycbcr_709, 12 * sizeof(unsigned int));
+		} else {
+			if (dst_cr == COLOR_RANGE_0_255)
+				/* limit to full */
+				memcpy(csc_base_addr, (rgb2Ycbcr_709 + 0x24), 12 * sizeof(unsigned int));
+			else
+				/* limit to limit */
+				memcpy(csc_base_addr, (rgb2Ycbcr_709 + 0xc), 12 * sizeof(unsigned int));
+		}
+		break;
+	case G2D_YUV2RGB_709:
+		if (src_cr == COLOR_RANGE_0_255) {
+			if (dst_cr == COLOR_RANGE_0_255)
+				/* full to full */
+				memcpy(csc_base_addr, (Ycbcr2rgb_709 + 0x18), 12 * sizeof(unsigned int));
+			else
+				/* full to limit */
+				memcpy(csc_base_addr, Ycbcr2rgb_709, 12 * sizeof(unsigned int));
+		} else {
+			if (dst_cr == COLOR_RANGE_0_255)
+				/* limit to full */
+				memcpy(csc_base_addr, (Ycbcr2rgb_709 + 0x24), 12 * sizeof(unsigned int));
+			else
+				/* limit to limit */
+				memcpy(csc_base_addr, (Ycbcr2rgb_709 + 0xc), 12 * sizeof(unsigned int));
+		}
+		break;
+	case G2D_RGB2YUV_601:
+		if (src_cr == COLOR_RANGE_0_255) {
+			if (dst_cr == COLOR_RANGE_0_255)
+				/* full to full */
+				memcpy(csc_base_addr, (rgb2Ycbcr_601 + 0x18), 12 * sizeof(unsigned int));
+			else
+				/* full to limit */
+				memcpy(csc_base_addr, rgb2Ycbcr_601, 12 * sizeof(unsigned int));
+		} else {
+			if (dst_cr == COLOR_RANGE_0_255)
+				/* limit to full */
+				memcpy(csc_base_addr, (rgb2Ycbcr_601 + 0x24), 12 * sizeof(unsigned int));
+			else
+				/* limit to limit */
+				memcpy(csc_base_addr, (rgb2Ycbcr_601 + 0xc), 12 * sizeof(unsigned int));
+		}
+		break;
+	case G2D_YUV2RGB_601:
+		if (src_cr == COLOR_RANGE_0_255) {
+			if (dst_cr == COLOR_RANGE_0_255)
+				/* full to full */
+				memcpy(csc_base_addr, (Ycbcr2rgb_601 + 0x18), 12 * sizeof(unsigned int));
+			else
+				/* full to limit */
+				memcpy(csc_base_addr, Ycbcr2rgb_601, 12 * sizeof(unsigned int));
+		} else {
+			if (dst_cr == COLOR_RANGE_0_255)
+				/* limit to full */
+				memcpy(csc_base_addr, (Ycbcr2rgb_601 + 0x24), 12 * sizeof(unsigned int));
+			else
+				/* limit to limit */
+				memcpy(csc_base_addr, (Ycbcr2rgb_601 + 0xc), 12 * sizeof(unsigned int));
+		}
+		break;
+	default:
+		G2D_ERR_MSG("No implement standard:%d!\n", csc_sel);
+		goto OUT;
+	}
+
+	p_bld->set_block_dirty(p_bld, 0, 1);
+	ret = 0;
+OUT:
+	return ret;
+}
+
+__s32 bld_porter_duff(struct blender_submodule *p_bld, __u32 cmd)
+{
+	struct g2d_mixer_bld_reg *p_reg = NULL;
+	__s32 ret = -1;
+
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	switch (cmd) {
+	case G2D_BLD_CLEAR:
+		p_reg->bld_ctrl.dwval = 0x00000000;
+		break;
+	case G2D_BLD_COPY:
+		p_reg->bld_ctrl.dwval = 0x00010001;
+		break;
+	case G2D_BLD_DST:
+		p_reg->bld_ctrl.dwval = 0x01000100;
+		break;
+	case G2D_BLD_SRCOVER:
+		p_reg->bld_ctrl.dwval = 0x03010301;
+		break;
+	case G2D_BLD_DSTOVER:
+		p_reg->bld_ctrl.dwval = 0x01030103;
+		break;
+	case G2D_BLD_SRCIN:
+		p_reg->bld_ctrl.dwval = 0x00020002;
+		break;
+	case G2D_BLD_DSTIN:
+		p_reg->bld_ctrl.dwval = 0x02000200;
+		break;
+	case G2D_BLD_SRCOUT:
+		p_reg->bld_ctrl.dwval = 0x00030003;
+		break;
+	case G2D_BLD_DSTOUT:
+		p_reg->bld_ctrl.dwval = 0x03000300;
+		break;
+	case G2D_BLD_SRCATOP:
+		p_reg->bld_ctrl.dwval = 0x03020302;
+		break;
+	case G2D_BLD_DSTATOP:
+		p_reg->bld_ctrl.dwval = 0x02030203;
+		break;
+	case G2D_BLD_XOR:
+		p_reg->bld_ctrl.dwval = 0x03030303;
+		break;
+	default:
+		p_reg->bld_ctrl.dwval = 0x03010301;
+	}
+	p_bld->set_block_dirty(p_bld, 0, 1);
+	ret = 0;
+OUT:
+	return ret;
+}
+
+int bld_rcq_setup(struct blender_submodule *p_bld, u8 __iomem *base,
+		  struct g2d_rcq_mem_info *p_rcq_info)
+{
+	u8 __iomem *reg_base = base + G2D_BLD;
+	int ret = -1;
+
+	if (!p_bld) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	p_bld->reg_info->size = sizeof(struct g2d_mixer_bld_reg);
+	p_bld->reg_info->vir_addr = (u8 *)g2d_top_reg_memory_alloc(
+	    p_bld->reg_info->size, (void *)&(p_bld->reg_info->phy_addr),
+	    p_rcq_info);
+
+	if (!p_bld->reg_info->vir_addr) {
+		G2D_ERR_MSG("Malloc blender reg rcq memory fail!\n");
+		goto OUT;
+	}
+
+	p_bld->reg_blks->vir_addr = p_bld->reg_info->vir_addr;
+	p_bld->reg_blks->phy_addr = p_bld->reg_info->phy_addr;
+	p_bld->reg_blks->size = p_bld->reg_info->size;
+	p_bld->reg_blks->reg_addr = reg_base;
+	ret = 0;
+OUT:
+	return ret;
+}
+
+/**
+ * ROP2 cmd register set
+ * Index0 is selected
+ * dst mapping ch0'
+ * src mapping ch1'
+ */
+__s32 bld_rop2_set(struct blender_submodule *p_bld, __u32 rop_cmd)
+{
+	__s32 ret = -1;
+	struct g2d_mixer_bld_reg *p_reg = p_bld->get_reg(p_bld);
+
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	if (rop_cmd == G2D_BLT_BLACKNESS) {
+		/* blackness */
+		/* tmpue = 0x1<<18; */
+		p_reg->ch3_index0.dwval = 0x40000;
+	} else if (rop_cmd == G2D_BLT_NOTMERGEPEN) {
+		/* ~(dst | src) */
+		/* tmpue = (0x1<<6) | (0x1<<10) | (0x2<<11) | (0x1<<18); */
+		p_reg->ch3_index0.dwval = 0x41440;
+	} else if (rop_cmd == G2D_BLT_MASKNOTPEN) {
+		/* ~src&dst */
+		/* tmpue = (0x1<<4) | (0x0<<10) | (0x2<<11) | (0x1<<18); */
+		p_reg->ch3_index0.dwval = 0x41010;
+	} else if (rop_cmd == G2D_BLT_NOTCOPYPEN) {
+		/* ~src */
+		/* tmpue = (0x1<<4) | (0x2<<6) | (0x2<<11) |
+		 * (0x1<<18) | (0x1<<17);
+		 */
+		p_reg->ch3_index0.dwval = 0x61090;
+	} else if (rop_cmd == G2D_BLT_MASKPENNOT) {
+		/* src&~dst */
+		/* tmpue = (0x1<<3) | (0x0<<10) | (0x2<<11) | (0x1<<18); */
+		p_reg->ch3_index0.dwval = 0x41008;
+	} else if (rop_cmd == G2D_BLT_NOT) {
+		/* ~dst */
+		/* tmpue = (0x1<<3) | (0x2<<6) | (0x2<<11) |
+		 * (0x1<<18) | (0x1<<16);
+		 */
+		p_reg->ch3_index0.dwval = 0x51088;
+	} else if (rop_cmd == G2D_BLT_XORPEN) {
+		/* src xor dst */
+		/* tmpue = (0x2<<6) | (0x2<<11) | (0x1<<18); */
+		p_reg->ch3_index0.dwval = 0x41080;
+	} else if (rop_cmd == G2D_BLT_NOTMASKPEN) {
+		/* ~(src & dst) */
+		/* tmpue = (0x0<<6) | (0x1<<10) | (0x2<<11) | (0x1<<18); */
+		p_reg->ch3_index0.dwval = 0x41400;
+	} else if (rop_cmd == G2D_BLT_MASKPEN) {
+		/* src&dst */
+		/* tmpue = (0x0<<6) | (0x2<<11) | (0x1<<18); */
+		p_reg->ch3_index0.dwval = 0x41000;
+	} else if (rop_cmd == G2D_BLT_NOTXORPEN) {
+		/* ~(src xor dst) */
+		/* tmpue = (0x2<<6) | (0x1<<10) | (0x2<<11) | (0x1<<18); */
+		p_reg->ch3_index0.dwval = 0x41480;
+	} else if (rop_cmd == G2D_BLT_NOP) {
+		/* dst */
+		/* tmpue = (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<16); */
+		p_reg->ch3_index0.dwval = 0x51080;
+	} else if (rop_cmd == G2D_BLT_MERGENOTPEN) {
+		/* ~dst or src */
+		/* tmpue = (0x1<<3)| (0x1<<6) | (0x2<<11) | (0x1<<18) */
+		/* write_wvalue(ROP_INDEX0, 0x40A20); */
+		p_reg->ch3_index0.dwval = 0x41048;
+	} else if (rop_cmd == G2D_BLT_COPYPEN) {
+		/* src */
+		/* tmpue = (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<17); */
+		p_reg->ch3_index0.dwval = 0x61080;
+	} else if (rop_cmd == G2D_BLT_MERGEPENNOT) {
+		/* src or ~dst */
+		/* tmpue =  (0x1<<3)| (0x1<<6) | (0x2<<11) | (0x1<<18) */
+		p_reg->ch3_index0.dwval = 0x41048;
+	} else if (rop_cmd == G2D_BLT_MERGEPEN) {
+		/* src or dst */
+		/* tmpue = (0x1<<6) | (0x1<<18) | (0x2<<11); */
+		p_reg->ch3_index0.dwval = 0x41040;
+	} else if (rop_cmd == G2D_BLT_WHITENESS) {
+		/* whiteness */
+		/* tmpue = (0x1<<18) | (0x1<<15); */
+		p_reg->ch3_index0.dwval = 0x48000;
+	} else
+		goto OUT;
+
+	p_reg->ch3_index0.bits.index0node0 = 2; /*TODO:different with source*/
+	p_bld->set_block_dirty(p_bld, 0, 1);
+
+	ret = 0;
+OUT:
+	return ret;
+}
+
+/**
+ * ROP3 cmd register set
+ * dst mapping ch0'
+ * src mapping ch1'
+ * ptn mapping ch2'
+ * -1 return meaning that the operate is not supported by now
+ */
+__s32 bld_rop3_set(struct blender_submodule *p_bld, __u32 sel, __u32 rop3_cmd)
+{
+	__s32 ret = -1;
+	union g2d_mixer_rop_ch3_index0 *p_addr = NULL;
+	struct g2d_mixer_bld_reg *p_reg = p_bld->get_reg(p_bld);
+
+	p_reg = p_bld->get_reg(p_bld);
+	if (!p_reg)
+		goto OUT;
+
+	if (sel == 0)
+		p_addr = &p_reg->ch3_index0;
+	else if (sel == 1)
+		p_addr = &p_reg->ch3_index1;
+	else
+		goto OUT;
+
+	if (rop3_cmd == G2D_ROP3_BLACKNESS) {
+		/* blackness */
+		/* 0x1<<18; */
+		p_addr->dwval = 0x40000;
+	} else if (rop3_cmd == G2D_ROP3_NOTSRCERASE) {
+		/* (~src) AND (~dst) */
+		/* (0x1<<3) | (0x1<<4) | (0x1<<18) | (0x2<<11); */
+		p_addr->dwval = 0x41018;
+	} else if (rop3_cmd == G2D_ROP3_NOTSRCCOPY) {
+
+		/* ~src */
+		/* (0x1<<4) | (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<16); */
+		p_addr->dwval = 0x51090;
+	} else if (rop3_cmd == G2D_ROP3_SRCERASE) {
+		/* src AND ~dst */
+		/* (0x1<<3) | (0x0<<6) | (0x2<<11) | (0x1<<18); */
+		p_addr->dwval = 0x41008;
+	} else if (rop3_cmd == G2D_ROP3_DSTINVERT) {
+		/* ~dst */
+		/* (0x1<<3) | (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<17); */
+		p_addr->dwval = 0x61088;
+	} else if (rop3_cmd == G2D_ROP3_PATINVERT) {
+		/* ptn XOR dst */
+		/* (0x2<<6) | (0x2<<11) | (0x1<<17) */
+		p_addr->dwval = 0x21080;
+	} else if (rop3_cmd == G2D_ROP3_SRCINVERT) {
+		/* src XOR dst */
+		/* (0x2<<6) | (0x2<<11) | (0x1<<18); */
+		p_addr->dwval = 0x41080;
+	} else if (rop3_cmd == G2D_ROP3_SRCAND) {
+		/* src AND dst */
+		/* (0x0<<6) | (0x2<<11) | (0x1<<18); */
+		p_addr->dwval = 0x41000;
+	} else if (rop3_cmd == G2D_ROP3_MERGEPAINT) {
+		/* ~src OR dst */
+		/* (0x1<<4) | (0x1<<6) | (0x2<<11) | (0x1<<18); */
+		p_addr->dwval = 0x41050;
+	} else if (rop3_cmd == G2D_ROP3_MERGECOPY) {
+		/* src AND pattern */
+		/* (0x2<<6) | (0x1<<16) */
+		p_addr->dwval = 0x10080;
+	} else if (rop3_cmd == G2D_ROP3_SRCCOPY) {
+		/* src */
+		/* (0x2<<6) | (0x2<<11) | (0x1<<18) | (0x1<<16); */
+		p_addr->dwval = 0x51080;
+	} else if (rop3_cmd == G2D_ROP3_SRCPAINT) {
+		/* src OR dst */
+		/* (0x1<<6) | (0x2<<11) | (0x1<<18); */
+		p_addr->dwval = 0x41040;
+	} else if (rop3_cmd == G2D_ROP3_PATCOPY) {
+		/* ptn */
+		/* (0x1<<16) | (0x1<<17) | (0x2)<<11 */
+		p_addr->dwval = 0x31000;
+	} else if (rop3_cmd == G2D_ROP3_PATPAINT) {
+		/* DPSnoo */
+		/* (0x1<<3) | (0x1<<6) | (0x1<<11) */
+		p_addr->dwval = 0x848;
+	} else if (rop3_cmd == G2D_ROP3_WHITENESS) {
+		/* whiteness */
+		p_addr->dwval = 0x48000;
+	} else
+		goto OUT;
+
+	p_bld->set_block_dirty(p_bld, 0, 1);
+
+	ret = 0;
+OUT:
+	return ret;
+}
+
+static __u32 bld_get_reg_block_num(struct blender_submodule *p_bld)
+{
+	if (p_bld)
+		return p_bld->reg_blk_num;
+	return 0;
+}
+
+static __s32 bld_get_reg_block(struct blender_submodule *p_bld,
+			    struct g2d_reg_block **blks)
+{
+	__s32 i = 0, ret = -1;
+
+	if (p_bld) {
+		for (i = 0; i < p_bld->reg_blk_num; ++i)
+			blks[i] = p_bld->reg_blks + i;
+	}
+
+	return ret;
+}
+
+static struct g2d_mixer_bld_reg *bld_get_reg(struct blender_submodule *p_bld)
+{
+#if G2D_MIXER_RCQ_USED == 1
+	return (struct g2d_mixer_bld_reg *)(p_bld->reg_blks
+					    ->vir_addr);
+#else
+	return (struct g2d_mixer_bld_reg *)(p_bld->reg_blks
+					    ->reg_addr);
+#endif
+	return NULL;
+}
+
+static void bld_set_block_dirty(struct blender_submodule *p_bld, __u32 blk_id, __u32 dirty)
+{
+#if G2D_MIXER_RCQ_USED == 1
+	if (p_bld && p_bld->reg_blks->rcq_hd)
+		p_bld->reg_blks->rcq_hd->dirty.bits.dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#else
+
+	if (p_bld)
+		p_bld->reg_blks->dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#endif
+}
+
+static __u32 bld_get_rcq_mem_size(struct blender_submodule *p_bld)
+{
+	return G2D_RCQ_BYTE_ALIGN(sizeof(struct g2d_mixer_bld_reg));
+}
+
+static __s32 bld_destory(struct blender_submodule *p_bld)
+{
+	__s32 ret = -1;
+
+	if (p_bld) {
+		kfree(p_bld->reg_blks);
+		p_bld->reg_blks = NULL;
+
+		kfree(p_bld->reg_info);
+		p_bld->reg_info = NULL;
+		kfree(p_bld);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+struct blender_submodule *
+g2d_bld_submodule_setup(struct g2d_mixer_frame *p_frame)
+{
+	struct blender_submodule *p_bld = NULL;
+
+	p_bld = kmalloc(sizeof(struct blender_submodule), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_bld) {
+		G2D_ERR_MSG("Kmalloc wb submodule fail!\n");
+		return NULL;
+	}
+
+	p_bld->rcq_setup = bld_rcq_setup;
+	p_bld->reg_blk_num = 1;
+	p_bld->get_reg_block_num = bld_get_reg_block_num;
+	p_bld->get_reg_block = bld_get_reg_block;
+	p_bld->get_reg = bld_get_reg;
+	p_bld->set_block_dirty = bld_set_block_dirty;
+	p_bld->get_rcq_mem_size = bld_get_rcq_mem_size;
+	p_bld->destory = bld_destory;
+
+	p_bld->reg_blks =
+	    kmalloc(sizeof(struct g2d_reg_block) * p_bld->reg_blk_num,
+		    GFP_KERNEL | __GFP_ZERO);
+	p_bld->reg_info =
+	    kmalloc(sizeof(struct g2d_reg_mem_info), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_bld->reg_blks || !p_bld->reg_info) {
+		G2D_ERR_MSG("Kmalloc wb reg info fail!\n");
+		goto FREE_WB;
+	}
+
+
+	return p_bld;
+FREE_WB:
+	kfree(p_bld->reg_blks);
+	kfree(p_bld->reg_info);
+	kfree(p_bld);
+
+	return NULL;
+}
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.h
new file mode 100644
index 000000000..1084df8d3
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_bld.h
@@ -0,0 +1,54 @@
+/*
+ * g2d_bld/g2d_bld.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_BLD_H
+#define _G2D_BLD_H
+#include "g2d_rcq.h"
+#include "g2d_mixer_type.h"
+#include "g2d_mixer.h"
+
+struct g2d_mixer_frame;
+struct blender_submodule {
+	struct g2d_reg_block *reg_blks;
+	__u32 reg_blk_num;
+	struct g2d_reg_mem_info *reg_info;
+	__s32 (*destory)(struct blender_submodule *p_bld);
+	__s32 (*rcq_setup)(struct blender_submodule *p_bld, u8 __iomem *base,
+		  struct g2d_rcq_mem_info *p_rcq_info);
+	__u32 (*get_reg_block_num)(struct blender_submodule *p_bld);
+	__u32 (*get_rcq_mem_size)(struct blender_submodule *p_bld);
+	__s32 (*get_reg_block)(struct blender_submodule *p_bld, struct g2d_reg_block **blks);
+	struct g2d_mixer_bld_reg  *(*get_reg)(struct blender_submodule *p_bld);
+	void (*set_block_dirty)(struct blender_submodule *p_bld, __u32 blk_id, __u32 dirty);
+};
+
+__s32 bld_in_set(struct blender_submodule *p_bld, __u32 sel, g2d_rect rect,
+		 int premul);
+__s32 bld_ck_para_set(struct blender_submodule *p_bld, g2d_ck *para,
+		      __u32 flag);
+__s32 bld_bk_set(struct blender_submodule *p_bld, __u32 color);
+__s32 bld_out_setting(struct blender_submodule *p_bld, g2d_image_enh *p_image);
+__s32 bld_cs_set(struct blender_submodule *p_bld, __u32 format);
+__s32 bld_csc_reg_set(struct blender_submodule *p_bld, __u32 csc_no,
+		      g2d_csc_sel csc_sel, enum color_range src_cr, enum color_range dst_cr);
+__s32 bld_rop3_set(struct blender_submodule *p_bld, __u32 sel, __u32 rop3_cmd);
+__s32 bld_set_rop_ctrl(struct blender_submodule *p_bld, __u32 value);
+__s32 bld_rop2_set(struct blender_submodule *p_bld, __u32 rop_cmd);
+struct blender_submodule *
+g2d_bld_submodule_setup(struct g2d_mixer_frame *p_frame);
+__s32 bld_porter_duff(struct blender_submodule *p_bld, __u32 cmd);
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_bsp.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_bsp.h
new file mode 100644
index 000000000..30b20615a
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_bsp.h
@@ -0,0 +1,117 @@
+/*
+ * g2d_bsp/g2d_bsp.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __G2D_BSP_H
+#define __G2D_BSP_H
+
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include <asm/uaccess.h>
+/*#include <asm/memory.h>*/
+#include <linux/uaccess.h>
+#include <asm/unistd.h>
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_iommu.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/string.h>
+#include <linux/g2d_driver.h>
+#include <linux/dma-buf.h>
+#include <linux/reset.h>
+
+#define G2D_FINISH_IRQ		(1<<8)
+#define G2D_ERROR_IRQ			(1<<9)
+
+extern __u32 dbg_info;
+
+#define G2D_INFO_MSG(fmt, args...) \
+	do {\
+		if (dbg_info)\
+		pr_info("[G2D] (%s) line:%d: " fmt, __func__, __LINE__, ##args);\
+	} while (0)
+
+#define G2D_ERR_MSG(fmt, args...) \
+	do {\
+		pr_warn("[G2D] (%s) line:%d: " fmt, __func__, __LINE__, ##args);\
+	} while (0)
+
+typedef struct {
+	unsigned long g2d_base;
+} g2d_init_para;
+
+typedef struct {
+	g2d_init_para init_para;
+} g2d_dev_t;
+
+typedef enum {
+	G2D_RGB2YUV_709,
+	G2D_YUV2RGB_709,
+	G2D_RGB2YUV_601,
+	G2D_YUV2RGB_601,
+	G2D_RGB2YUV_2020,
+	G2D_YUV2RGB_2020,
+} g2d_csc_sel;
+
+typedef enum {
+	VSU_FORMAT_YUV422 = 0x00,
+	VSU_FORMAT_YUV420 = 0x01,
+	VSU_FORMAT_YUV411 = 0x02,
+	VSU_FORMAT_RGB = 0x03,
+	VSU_FORMAT_BUTT = 0x04,
+} vsu_pixel_format;
+
+#define VSU_ZOOM0_SIZE	1
+#define VSU_ZOOM1_SIZE	8
+#define VSU_ZOOM2_SIZE	4
+#define VSU_ZOOM3_SIZE	1
+#define VSU_ZOOM4_SIZE	1
+#define VSU_ZOOM5_SIZE	1
+
+#define VSU_PHASE_NUM            32
+#define VSU_PHASE_FRAC_BITWIDTH  19
+#define VSU_PHASE_FRAC_REG_SHIFT 1
+#define VSU_FB_FRAC_BITWIDTH     32
+
+#define VI_LAYER_NUMBER 1
+#define UI_LAYER_NUMBER 3
+
+
+#endif	/* __G2D_BSP_H */
+
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_driver_i.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_driver_i.h
new file mode 100644
index 000000000..f1f6c3386
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_driver_i.h
@@ -0,0 +1,127 @@
+/*
+ * g2d_driver_i/g2d_driver_i.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __G2D_DRIVER_I_H
+#define __G2D_DRIVER_I_H
+
+#include "g2d_bsp.h"
+
+/* #include "g2d_bsp_v2.h" */
+
+#define INFO(format, args...) pr_info("%s: " format, "G2D", ## args)
+
+#if defined(CONFIG_FPGA_V4_PLATFORM) || defined(CONFIG_FPGA_V7_PLATFORM)
+#define WAIT_CMD_TIME_MS 500
+#else
+#define WAIT_CMD_TIME_MS 100
+#endif
+
+
+#define G2DALIGN(value, align) ((align == 0) ? \
+				value : \
+				(((value) + ((align) - 1)) & ~((align) - 1)))
+#if defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+#define G2D_IOMMU_MASTER_ID 3
+#endif
+
+struct dmabuf_item {
+	struct list_head list;
+	int fd;
+	struct dma_buf *buf;
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt;
+	dma_addr_t dma_addr;
+	unsigned long long id;
+};
+
+struct info_mem {
+	unsigned long phy_addr;
+	void *virt_addr;
+	__u32 b_used;
+	__u32 mem_len;
+};
+
+typedef struct {
+	struct device *dev;
+	struct resource *mem;
+	void __iomem *io;
+	__u32 irq;
+	struct mutex mutex;
+	struct clk *clk;
+	bool opened;
+	__u32 user_cnt;
+	struct clk *clk_parent;
+	struct clk *bus_clk;
+	struct clk *mbus_clk;
+	struct reset_control *reset;
+} __g2d_info_t;
+
+typedef struct {
+	__u32 mid;
+	__u32 used;
+	__u32 status;
+	struct semaphore *g2d_finished_sem;
+	struct semaphore *event_sem;
+	wait_queue_head_t queue;
+	__u32 finish_flag;
+} __g2d_drv_t;
+
+struct g2d_alloc_struct {
+	__u32 address;
+	__u32 size;
+	__u32 u_size;
+	struct g2d_alloc_struct *next;
+};
+
+/* g2d_format_attr - g2d format attribute
+ *
+ * @format: pixel format
+ * @bits: bits of each component
+ * @hor_rsample_u: reciprocal of horizontal sample rate
+ * @hor_rsample_v: reciprocal of horizontal sample rate
+ * @ver_rsample_u: reciprocal of vertical sample rate
+ * @hor_rsample_v: reciprocal of vertical sample rate
+ * @uvc: 1: u & v component combined
+ * @interleave: 0: progressive, 1: interleave
+ * @factor & div: bytes of pixel = factor / div (bytes)
+ * @addr[out]: address for each plane
+ * @trd_addr[out]: address for each plane of right eye buffer
+ */
+struct g2d_format_attr {
+	g2d_fmt_enh format;
+	unsigned int bits;
+	unsigned int hor_rsample_u;
+	unsigned int hor_rsample_v;
+	unsigned int ver_rsample_u;
+	unsigned int ver_rsample_v;
+	unsigned int uvc;
+	unsigned int interleave;
+	unsigned int factor;
+	unsigned int div;
+};
+
+
+int g2d_wait_cmd_finish(unsigned int timeout);
+int g2d_dma_map(int fd, struct dmabuf_item *item);
+void g2d_dma_unmap(struct dmabuf_item *item);
+__s32 g2d_set_info(g2d_image_enh *g2d_img, struct dmabuf_item *item);
+void *g2d_malloc(__u32 bytes_num, __u32 *phy_addr);
+void g2d_free(void *virt_addr, void *phy_addr, unsigned int size);
+__s32 g2d_image_check(g2d_image_enh *p_image);
+__s32 g2d_byte_cal(__u32 format, __u32 *ycnt, __u32 *ucnt, __u32 *vcnt);
+__u32 cal_align(__u32 width, __u32 align);
+
+#endif /* __G2D_DRIVER_I_H */
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.c
new file mode 100644
index 000000000..a072a402d
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.c
@@ -0,0 +1,1050 @@
+/*
+ * g2d_mixer/g2d_mixer.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "g2d_mixer.h"
+#include <linux/idr.h>
+
+static LIST_HEAD(g2d_task_list);
+static DEFINE_IDA(g2d_task_ida);
+
+
+static __s32 g2d_bsp_maskblt(struct g2d_mixer_frame *p_frame,
+			     g2d_image_enh *src, g2d_image_enh *ptn,
+			     g2d_image_enh *mask, g2d_image_enh *dst,
+			     __u32 back_flag, __u32 fore_flag)
+{
+	g2d_rect rect0;
+	__s32 ret = -1;
+
+	if (!dst) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	if (dst->format > G2D_FORMAT_BGRA1010102) {
+		G2D_ERR_MSG("Un support out format:%d\n", dst->format);
+		goto OUT;
+	}
+	g2d_vlayer_set(p_frame->ovl_v, 0, dst);
+
+	if (src) {
+		src->clip_rect.w = dst->clip_rect.w;
+		src->clip_rect.h = dst->clip_rect.h;
+		g2d_uilayer_set(p_frame->ovl_u, 0, src);
+	}
+	if (ptn) {
+		ptn->clip_rect.w = dst->clip_rect.w;
+		ptn->clip_rect.h = dst->clip_rect.h;
+		g2d_uilayer_set(p_frame->ovl_u, 1, ptn);
+	}
+
+	if (mask != NULL) {
+		mask->clip_rect.w = dst->clip_rect.w;
+		mask->clip_rect.h = dst->clip_rect.h;
+		g2d_uilayer_set(p_frame->ovl_u, 2, mask);
+
+		/* set the ROP4 */
+		bld_set_rop_ctrl(p_frame->bld, 0x1);
+		bld_rop3_set(p_frame->bld, 0, back_flag & 0xff);
+		bld_rop3_set(p_frame->bld, 1, fore_flag & 0xff);
+	} else {
+		bld_set_rop_ctrl(p_frame->bld, 0x0);
+		bld_rop3_set(p_frame->bld, 0, back_flag);
+	}
+
+	rect0.x = 0;
+	rect0.y = 0;
+	rect0.w = dst->clip_rect.w;
+	rect0.h = dst->clip_rect.h;
+	bld_in_set(p_frame->bld, 0, rect0, dst->bpremul);
+	bld_out_setting(p_frame->bld, dst);
+	g2d_wb_set(p_frame->wb, dst);
+	ret = 0;
+OUT:
+	return ret;
+
+}
+
+    static __s32 g2d_fillrectangle(struct g2d_mixer_frame *p_frame,
+				   g2d_image_enh *dst, __u32 color_value)
+{
+	g2d_rect rect0;
+	__s32 ret = -1;
+
+	if (!dst || !p_frame) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	/* set the input layer */
+	g2d_vlayer_set(p_frame->ovl_v, 0, dst);
+	/* set the fill color value */
+	g2d_ovl_v_fc_set(p_frame->ovl_v, color_value);
+
+	if (dst->format >= G2D_FORMAT_IYUV422_V0Y1U0Y0) {
+		g2d_vsu_para_set(p_frame->scal, dst->format, dst->clip_rect.w,
+				  dst->clip_rect.h, dst->clip_rect.w,
+				  dst->clip_rect.h, 0xff);
+		if (dst->gamut == G2D_BT601)
+			bld_csc_reg_set(p_frame->bld, 1, G2D_RGB2YUV_601, 0, dst->color_range);
+		else
+			bld_csc_reg_set(p_frame->bld, 1, G2D_RGB2YUV_709, 0, dst->color_range);
+	}
+
+	/* for interleaved test */
+	if ((dst->format >= G2D_FORMAT_IYUV422_V0Y1U0Y0)
+			&& (dst->format <= G2D_FORMAT_IYUV422_Y1U0Y0V0)) {
+		if (dst->gamut == G2D_BT601) {
+			bld_csc_reg_set(p_frame->bld, 0, G2D_RGB2YUV_601, 0, dst->color_range);
+			bld_csc_reg_set(p_frame->bld, 1, G2D_RGB2YUV_601, 0, dst->color_range);
+			bld_csc_reg_set(p_frame->bld, 2, G2D_RGB2YUV_601, 0, dst->color_range);
+		} else {
+			bld_csc_reg_set(p_frame->bld, 0, G2D_RGB2YUV_709, 0, dst->color_range);
+			bld_csc_reg_set(p_frame->bld, 1, G2D_RGB2YUV_709, 0, dst->color_range);
+			bld_csc_reg_set(p_frame->bld, 2, G2D_RGB2YUV_709, 0, dst->color_range);
+		}
+
+		bld_bk_set(p_frame->bld, 0xff123456);
+		bld_porter_duff(p_frame->bld, G2D_BLD_SRCOVER);
+
+		g2d_ovl_u_fc_set(p_frame->ovl_u, 0, 0xffffffff);
+		g2d_ovl_u_fc_set(p_frame->ovl_u, 1, 0xffffffff);
+	}
+
+	rect0.x = 0;
+	rect0.y = 0;
+	rect0.w = dst->clip_rect.w;
+	rect0.h = dst->clip_rect.h;
+	bld_in_set(p_frame->bld, 0, rect0, dst->bpremul);
+	bld_cs_set(p_frame->bld, dst->format);
+
+	/* ROP sel ch0 pass */
+	bld_set_rop_ctrl(p_frame->bld, 0xf0);
+	bld_out_setting(p_frame->bld, dst);
+	g2d_wb_set(p_frame->wb, dst);
+
+	ret = 0;
+OUT:
+	return ret;
+}
+
+/* fix add */
+static bool g2d_bld_check_coor(g2d_image_enh *src,
+		g2d_image_enh *src2, g2d_image_enh *dst)
+{
+	if (dst->width < src->clip_rect.w || dst->width < src2->clip_rect.w
+			|| dst->height < src->clip_rect.h ||
+			dst->height < src2->clip_rect.h)
+		return false;
+
+	return true;
+}
+
+static __s32 g2d_bsp_bld(struct g2d_mixer_frame *p_frame, g2d_image_enh *src,
+				g2d_image_enh *src2, g2d_image_enh *dst,
+				__u32 flag, g2d_ck *ck_para)
+{
+	g2d_rect rect0, rect1;
+	__s32 ret = -1;
+	__u32 midw, midh;
+
+	if (!dst || !src || !p_frame || !ck_para) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	if (g2d_bld_check_coor(src, src2, dst) == false) {
+		pr_err("[BLD] size is not suitable!");
+		goto OUT;
+	}
+
+	g2d_vlayer_set(p_frame->ovl_v, 0, src);
+	g2d_vlayer_overlay_set(p_frame->ovl_v, 0, &src->coor,
+			dst->clip_rect.w, dst->clip_rect.h);
+
+	g2d_uilayer_set(p_frame->ovl_u, 2, src2);
+	g2d_uilayer_overlay_set(p_frame->ovl_u, 2, &src2->coor,
+			dst->clip_rect.w, dst->clip_rect.h);
+
+	if (src->format > G2D_FORMAT_BGRA1010102) {
+		if (src2->format > G2D_FORMAT_BGRA1010102) {
+			pr_err("[BLD] not support two yuv layer!\n");
+			goto OUT;
+		} else {
+			/* YUV_XXX->YUV444->RGB overlay size */
+			g2d_ovl_v_calc_coarse(p_frame->ovl_v, src->format, dst->clip_rect.w,
+						dst->clip_rect.h, dst->clip_rect.w,
+						dst->clip_rect.h, &midw, &midh);
+			g2d_vsu_para_set(p_frame->scal, src->format, midw, midh,
+					dst->clip_rect.w, dst->clip_rect.h, dst->alpha);
+
+			if (dst->gamut == G2D_BT601)
+				bld_csc_reg_set(p_frame->bld, 0, G2D_RGB2YUV_601, src->color_range, dst->color_range);
+			else
+				bld_csc_reg_set(p_frame->bld, 0, G2D_RGB2YUV_709, src->color_range, dst->color_range);
+		}
+	} else {
+		if (src2->format > G2D_FORMAT_BGRA1010102) {
+			pr_err("[BLD] please use ch0(src0) to set YUV layer!\n");
+			goto OUT;
+		}
+	}
+
+	if (dst->format > G2D_FORMAT_BGRA1010102) {
+		if (dst->gamut == G2D_BT601)
+			bld_csc_reg_set(p_frame->bld, 2, G2D_RGB2YUV_601, src->color_range, dst->color_range);
+		else
+			bld_csc_reg_set(p_frame->bld, 2, G2D_RGB2YUV_709, src->color_range, dst->color_range);
+	}
+
+	bld_set_rop_ctrl(p_frame->bld, 0xf0);
+
+	rect0.x = 0;
+	rect0.y = 0;
+	rect0.w = dst->clip_rect.w;/* overlay size */
+	rect0.h = dst->clip_rect.h;
+
+	rect1.x = 0;
+	rect1.y = 0;
+	rect1.w = dst->clip_rect.w;
+	rect1.h = dst->clip_rect.h;
+
+	bld_in_set(p_frame->bld, 0, rect0, src->bpremul);
+	bld_in_set(p_frame->bld, 1, rect1, src2->bpremul);
+
+	if (flag == 0) {
+		/* flag not set use default */
+		flag = G2D_BLD_SRCOVER;
+	}
+
+	bld_porter_duff(p_frame->bld, flag & 0xFFF);
+
+	bld_ck_para_set(p_frame->bld, ck_para, flag);
+
+	bld_cs_set(p_frame->bld, dst->format);
+	bld_out_setting(p_frame->bld, dst);
+	g2d_wb_set(p_frame->wb, dst);
+
+	ret = 0;
+OUT:
+	return ret;
+}
+
+static __s32 g2d_bsp_bitblt(struct g2d_mixer_frame *p_frame, g2d_image_enh *src,
+			   g2d_image_enh *dst, __u32 flag)
+{
+	g2d_rect rect0, rect1;
+	bool bpre;
+	__u32 midw, midh;
+	__s32 ret = -1;
+
+	if (!p_frame || !src || !dst)
+		goto OUT;
+
+	if ((flag & 0x0fffffff) == G2D_BLT_NONE) {
+		g2d_vlayer_set(p_frame->ovl_v, 0, src);
+		/* need abp process */
+		if (src->mode)
+			g2d_uilayer_set(p_frame->ovl_u, 2,
+					dst);
+		if ((src->format >= G2D_FORMAT_IYUV422_V0Y1U0Y0) ||
+		    (src->clip_rect.w != dst->clip_rect.w) ||
+		    (src->clip_rect.h != dst->clip_rect.h)) {
+			g2d_ovl_v_calc_coarse(
+			    p_frame->ovl_v, src->format, src->clip_rect.w,
+			    src->clip_rect.h, dst->clip_rect.w,
+			    dst->clip_rect.h, &midw, &midh);
+			g2d_vsu_para_set(p_frame->scal, src->format, midw, midh,
+					 dst->clip_rect.w, dst->clip_rect.h,
+					 0xff);
+		}
+		bld_porter_duff(p_frame->bld, G2D_BLD_SRCOVER);
+		/*Default value*/
+		bld_set_rop_ctrl(p_frame->bld, 0xf0);
+		rect0.x = 0;
+		rect0.y = 0;
+		rect0.w = dst->clip_rect.w;
+		rect0.h = dst->clip_rect.h;
+		bld_in_set(p_frame->bld, 0, rect0, dst->bpremul);
+		bld_cs_set(p_frame->bld, src->format);
+		if (src->mode) {
+			/* need abp process */
+			rect1.x = 0;
+			rect1.y = 0;
+			rect1.w = dst->clip_rect.w;
+			rect1.h = dst->clip_rect.h;
+			bld_in_set(p_frame->bld, 1, rect1, dst->bpremul);
+		}
+		if ((src->format <= G2D_FORMAT_BGRA1010102) &&
+				(dst->format > G2D_FORMAT_BGRA1010102)) {
+			if (dst->gamut == G2D_BT601) {
+				bld_csc_reg_set(p_frame->bld, 2, G2D_RGB2YUV_601,
+						src->color_range, dst->color_range);
+			} else {
+				bld_csc_reg_set(p_frame->bld, 2, G2D_RGB2YUV_709,
+						src->color_range, dst->color_range);
+			}
+		}
+		if ((src->format > G2D_FORMAT_BGRA1010102) &&
+				(dst->format <= G2D_FORMAT_BGRA1010102)) {
+			if (dst->gamut == G2D_BT601) {
+				bld_csc_reg_set(p_frame->bld, 2, G2D_YUV2RGB_601,
+						src->color_range, dst->color_range);
+			} else {
+				bld_csc_reg_set(p_frame->bld, 2, G2D_YUV2RGB_709,
+						src->color_range, dst->color_range);
+			}
+		}
+
+		bld_out_setting(p_frame->bld, dst);
+		g2d_wb_set(p_frame->wb, dst);
+	} else if (flag & 0xff) {
+		if ((src->format > G2D_FORMAT_BGRA1010102) |
+		    (dst->format > G2D_FORMAT_BGRA1010102)) {
+			G2D_ERR_MSG("Only support rgb format!\n");
+			goto OUT;
+		}
+		g2d_uilayer_set(p_frame->ovl_u, 0, dst);
+		g2d_vlayer_set(p_frame->ovl_v, 0, src);
+		bpre = false;
+		if (src->bpremul || dst->bpremul)
+			bpre = true;
+		if ((src->clip_rect.w != dst->clip_rect.w)
+		    || (src->clip_rect.h != dst->clip_rect.h)) {
+			g2d_ovl_v_calc_coarse(
+			    p_frame->ovl_v, src->format, src->clip_rect.w,
+			    src->clip_rect.h, dst->clip_rect.w,
+			    dst->clip_rect.h, &midw, &midh);
+			g2d_vsu_para_set(p_frame->scal, src->format, midw, midh,
+					 dst->clip_rect.w, dst->clip_rect.h,
+					 0xff);
+		}
+		/*Default value*/
+		bld_porter_duff(p_frame->bld, G2D_BLD_SRCOVER);
+		bld_set_rop_ctrl(p_frame->bld, 0x00);
+		bld_rop2_set(p_frame->bld, flag & 0xff);
+
+		/*set bld para */
+		rect0.x = 0;
+		rect0.y = 0;
+		rect0.w = dst->clip_rect.w;
+		rect0.h = dst->clip_rect.h;
+		bld_in_set(p_frame->bld, 0, rect0, bpre);
+		bld_out_setting(p_frame->bld, dst);
+		g2d_wb_set(p_frame->wb, dst);
+	}
+
+	ret = 0;
+OUT:
+	return ret;
+
+}
+
+static int g2d_set_image_addr(struct dmabuf_item **p_item, g2d_image_enh *p_img)
+{
+	int ret = -1;
+
+	if (!p_item || !p_img)
+		goto OUT;
+
+	if (!p_img->use_phy_addr) {
+		*p_item = kmalloc(sizeof(struct dmabuf_item),
+				  GFP_KERNEL | __GFP_ZERO);
+		if (!*p_item)
+			goto OUT;
+		if (g2d_dma_map(p_img->fd, *p_item)) {
+			kfree(*p_item);
+			*p_item = NULL;
+			G2D_ERR_MSG("map dst fail!\n");
+			goto OUT;
+		}
+		ret = g2d_set_info(p_img, *p_item);
+	} else
+		ret = 0;
+OUT:
+	return ret;
+}
+
+
+/**
+ * @name       :g2d_split_mem
+ * @brief      :split memory from a big memory, only support y8
+ * @param[IN]  :
+ * @param[IN]  :
+ * @return     :0 if success, -1 else
+ */
+static __s32 g2d_split_mem(struct g2d_mixer_task *p_task,
+				 struct mixer_para *p_para)
+{
+
+	__s32 ret = 0, i = 0;
+	dma_addr_t src_addr = 0, dst_addr = 0;
+
+	if (p_para[0].op_flag & OP_SPLIT_MEM) {
+		p_task->en_split_mem = 1;
+		ret = g2d_set_image_addr(&p_task->frame[0].dst_item, &p_para[0].dst_image_h);
+		if (ret)
+			goto OUT;
+		dst_addr = p_para[0].dst_image_h.laddr[0];
+
+		ret = g2d_set_image_addr(&p_task->frame[0].src_item,
+					 &p_para[0].src_image_h);
+		if (ret)
+			goto OUT;
+		src_addr = p_para[0].src_image_h.laddr[0];
+
+		for (i = 0; i < p_task->frame_cnt; ++i) {
+			p_para[i].src_image_h.laddr[0] = src_addr;
+			p_para[i].dst_image_h.laddr[0] = dst_addr;
+			src_addr += p_para[i].src_image_h.width * p_para[i].src_image_h.height;
+			dst_addr += p_para[i].dst_image_h.width * p_para[i].dst_image_h.height;
+		}
+	}
+
+OUT:
+	return ret;
+}
+
+static __s32 g2d_mixer_mem_setup(struct g2d_mixer_task *p_task,
+				 struct mixer_para *p_para)
+{
+	__u32 i = 0, frame_index = 0;
+	__u32 rcq_reg_mem_size = 0;
+	__s32 ret = -1;
+	struct g2d_reg_block **p_reg_blks;
+	struct g2d_rcq_head *rcq_hd = NULL;
+
+	if (!p_task->p_rcq_info)
+		goto OUT;
+
+	p_task->p_rcq_info->block_num_per_frame =
+	    p_task->frame[0].frame_get_reg_block_num(&p_task->frame[0]);
+
+	p_task->p_rcq_info->alloc_num_per_frame =
+	    G2D_RCQ_HEADER_ALIGN(p_task->p_rcq_info->block_num_per_frame);
+	/*header length after 32 BYTE algin*/
+
+	p_task->p_rcq_info->rcq_header_len =
+	    p_task->p_rcq_info->alloc_num_per_frame *
+	    sizeof(*(p_task->p_rcq_info->vir_addr));
+
+	/*real block num*/
+	p_task->p_rcq_info->cur_num =
+	    p_task->p_rcq_info->block_num_per_frame * p_task->frame_cnt;
+
+	/*block num that need to be alloced*/
+	p_task->p_rcq_info->alloc_num =
+	    p_task->p_rcq_info->alloc_num_per_frame * p_task->frame_cnt;
+
+	/*regblocks + rcq header*/
+	rcq_reg_mem_size =
+	    p_task->frame[0].frame_get_rcq_mem_size(&p_task->frame[0]) *
+	    p_task->frame_cnt;
+
+	rcq_reg_mem_size += sizeof(*(p_task->p_rcq_info->vir_addr)) *
+			    p_task->p_rcq_info->alloc_num;
+
+	p_task->p_rcq_info->rcq_reg_mem_size = rcq_reg_mem_size;
+	if (g2d_top_mem_pool_alloc(p_task->p_rcq_info)) {
+		G2D_ERR_MSG("g2d_top_mem_pool_alloc fail!\n");
+		goto OUT;
+	}
+
+	/*malloc memory for rcq queue*/
+
+	if (!p_task->p_rcq_info->vir_addr) {
+		G2D_ERR_MSG("Malloc rcq queue memory fail!\n");
+		goto OUT;
+	}
+
+	p_task->p_rcq_info->reg_blk =
+	    kmalloc(sizeof(*(p_task->p_rcq_info->reg_blk)) *
+			p_task->p_rcq_info->cur_num,
+		    GFP_KERNEL | __GFP_ZERO);
+
+	if (p_task->p_rcq_info->reg_blk == NULL) {
+		G2D_ERR_MSG("kalloc for g2d_reg_block failed\n");
+		goto OUT;
+	}
+	p_reg_blks = p_task->p_rcq_info->reg_blk;
+
+	g2d_split_mem(p_task, p_para);
+
+	for (i = 0; i < p_task->frame_cnt; ++i) {
+
+		if (p_task->frame[i].frame_mem_setup(
+			&p_task->frame[i], &p_para[i], p_task)) {
+			G2D_ERR_MSG("Frame:%d setupt fail!\n", i);
+			goto OUT;
+		}
+		/*overlay video*/
+		p_task->frame[i].ovl_v->get_reg_block(p_task->frame[i].ovl_v,
+						      p_reg_blks);
+		p_reg_blks += p_task->frame[i].ovl_v->get_reg_block_num(
+		    p_task->frame[i].ovl_v);
+
+		/*overlay ui*/
+		p_task->frame[i].ovl_u->get_reg_block(p_task->frame[i].ovl_u,
+						      p_reg_blks);
+
+		p_reg_blks += p_task->frame[i].ovl_u->get_reg_block_num(
+		    p_task->frame[i].ovl_u);
+
+		/*scaler*/
+		p_task->frame[i].scal->get_reg_block(p_task->frame[i].scal,
+						     p_reg_blks);
+		p_reg_blks += p_task->frame[i].scal->get_reg_block_num(
+		    p_task->frame[i].scal);
+
+		/*blender*/
+		p_task->frame[i].bld->get_reg_block(p_task->frame[i].bld,
+						    p_reg_blks);
+		p_reg_blks += p_task->frame[i].bld->get_reg_block_num(
+		    p_task->frame[i].bld);
+
+		/*write back*/
+		p_task->frame[i].wb->get_reg_block(p_task->frame[i].wb,
+						   p_reg_blks);
+		p_reg_blks +=
+		    p_task->frame[i].wb->get_reg_block_num(p_task->frame[i].wb);
+	}
+
+	p_reg_blks = p_task->p_rcq_info->reg_blk;
+	rcq_hd = p_task->p_rcq_info->vir_addr;
+
+	for (frame_index = 0; frame_index < p_task->frame_cnt; ++frame_index) {
+		for (i = 0; i < p_task->p_rcq_info->alloc_num_per_frame; ++i) {
+			struct g2d_reg_block *reg_blk = *p_reg_blks;
+
+			if (p_task->p_rcq_info->alloc_num_per_frame >
+				p_task->p_rcq_info->block_num_per_frame &&
+			    i == p_task->p_rcq_info->block_num_per_frame) {
+				if (frame_index == p_task->frame_cnt - 1)
+					rcq_hd->dirty.bits.n_header_len = 0;
+				else
+					rcq_hd->dirty.bits.n_header_len =
+					    p_task->p_rcq_info->rcq_header_len;
+				++rcq_hd;
+			} else {
+				rcq_hd->low_addr =
+				    (__u32)((__u32)(reg_blk->phy_addr));
+#if defined(CONFIG_ARM64)
+				rcq_hd->dw0.bits.high_addr =
+				    (u8)((__u64)(reg_blk->phy_addr) >> 32);
+#else
+				rcq_hd->dw0.bits.high_addr =
+				    (u8)((__u64)(__u32)(reg_blk->phy_addr) >> 32);
+#endif
+				rcq_hd->dw0.bits.len = reg_blk->size;
+				rcq_hd->dirty.bits.dirty = reg_blk->dirty;
+				rcq_hd->reg_offset = (__u32)(__u64)(
+				    reg_blk->reg_addr -
+				    (u8 __iomem *)p_task->p_g2d_info->io);
+				reg_blk->rcq_hd = rcq_hd;
+
+				/*last frame's next frame len should be zero*/
+				if (frame_index == p_task->frame_cnt - 1)
+					rcq_hd->dirty.bits.n_header_len = 0;
+				else
+					rcq_hd->dirty.bits.n_header_len =
+					    p_task->p_rcq_info->rcq_header_len;
+
+				++rcq_hd;
+				++p_reg_blks;
+			}
+		}
+	}
+
+	ret = 0;
+OUT:
+	return ret;
+}
+
+static __u32 frame_get_rcq_mem_size(struct g2d_mixer_frame *p_frame)
+{
+	int rcq_mem_size = 0;
+
+	rcq_mem_size += p_frame->wb->get_rcq_mem_size(p_frame->wb);
+	rcq_mem_size += p_frame->ovl_v->get_rcq_mem_size(p_frame->ovl_v);
+	rcq_mem_size += p_frame->ovl_u->get_rcq_mem_size(p_frame->ovl_u);
+	rcq_mem_size += p_frame->scal->get_rcq_mem_size(p_frame->scal);
+	rcq_mem_size += p_frame->bld->get_rcq_mem_size(p_frame->bld);
+
+	return rcq_mem_size;
+}
+
+
+static __s32 frame_mem_setup(struct g2d_mixer_frame *p_frame,
+				 struct mixer_para *p_para,
+				 struct g2d_mixer_task *p_task)
+{
+	__s32 ret = -1;
+
+	ret = p_frame->wb->rcq_setup(p_frame->wb, p_frame->g2d_base,
+				     p_task->p_rcq_info);
+	if (ret)
+		goto OUT;
+	ret = p_frame->ovl_v->rcq_setup(p_frame->ovl_v, p_frame->g2d_base,
+					p_task->p_rcq_info);
+	if (ret)
+		goto OUT;
+	ret = p_frame->ovl_u->rcq_setup(p_frame->ovl_u, p_frame->g2d_base,
+					p_task->p_rcq_info);
+	if (ret)
+		goto OUT;
+	ret = p_frame->bld->rcq_setup(p_frame->bld, p_frame->g2d_base,
+				      p_task->p_rcq_info);
+	if (ret)
+		goto OUT;
+	ret = p_frame->scal->rcq_setup(p_frame->scal, p_frame->g2d_base,
+				      p_task->p_rcq_info);
+	if (ret)
+		goto OUT;
+
+	if (p_task->en_split_mem)
+		goto OUT;
+
+	/*we will free & dma unmap them in frame->destory function*/
+	ret = g2d_set_image_addr(&p_frame->dst_item, &p_para->dst_image_h);
+	if (ret)
+		goto OUT;
+
+	if (p_para->op_flag > OP_FILLRECT) {
+		ret = g2d_set_image_addr(&p_frame->src_item,
+					 &p_para->src_image_h);
+		if (ret)
+			goto OUT;
+	}
+
+	if (p_para->op_flag & OP_BLEND) {
+		ret = g2d_set_image_addr(&p_frame->ptn_item,
+					 &p_para->ptn_image_h);
+		if (ret)
+			goto OUT;
+	}
+
+	if (p_para->op_flag & OP_MASK) {
+		ret = g2d_set_image_addr(&p_frame->ptn_item,
+					 &p_para->ptn_image_h);
+		if (ret)
+			goto OUT;
+		ret = g2d_set_image_addr(&p_frame->mask_item,
+					 &p_para->mask_image_h);
+		if (ret)
+			goto OUT;
+	}
+
+OUT:
+	return ret;
+}
+
+__s32 g2d_mixer_frame_apply(struct g2d_mixer_frame *p_frame,
+			    struct mixer_para *p_para)
+{
+	__s32 ret = -1;
+
+	if (g2d_image_check(&p_para->dst_image_h))
+		goto OUT;
+	if ((p_para->op_flag & OP_BITBLT) || (p_para->op_flag & OP_BLEND)) {
+		if (g2d_image_check(&p_para->src_image_h))
+			goto OUT;
+		if (p_para->op_flag & OP_BLEND) {
+			/* actually is use as src2 */
+			if (g2d_image_check(&p_para->ptn_image_h))
+				goto OUT;
+		}
+	} else if ((p_para->op_flag & OP_MASK)) {
+		p_para->dst_image_h.bbuff = 1;
+		p_para->src_image_h.bbuff = 1;
+		p_para->ptn_image_h.bbuff = 1;
+		p_para->mask_image_h.bbuff = 1;
+	}
+
+
+	ret = 0;
+	if (p_para->op_flag & OP_BITBLT) {
+		ret = g2d_bsp_bitblt(p_frame, &p_para->src_image_h,
+				     &p_para->dst_image_h, p_para->flag_h);
+	} else if (p_para->op_flag & OP_BLEND) {
+		ret = g2d_bsp_bld(p_frame, &p_para->src_image_h, &p_para->ptn_image_h,
+				  &p_para->dst_image_h, p_para->bld_cmd,
+				  &p_para->ck_para);
+	} else if (p_para->op_flag & OP_FILLRECT) {
+		ret = g2d_fillrectangle(p_frame, &p_para->dst_image_h,
+					p_para->dst_image_h.color);
+	} else if (p_para->op_flag & OP_MASK) {
+		ret = g2d_bsp_maskblt(
+		    p_frame, &p_para->src_image_h, &p_para->ptn_image_h,
+		    &p_para->mask_image_h, &p_para->dst_image_h,
+		    p_para->back_flag, p_para->fore_flag);
+	}
+
+OUT:
+	return ret;
+}
+
+static __s32 g2d_mixer_frame_destory(struct g2d_mixer_frame *p_frame)
+{
+	__s32 ret = 0;
+
+	ret += p_frame->wb->destory(p_frame->wb);
+	ret += p_frame->ovl_v->destory(p_frame->ovl_v);
+	ret += p_frame->ovl_u->destory(p_frame->ovl_u);
+	ret += p_frame->bld->destory(p_frame->bld);
+	ret += p_frame->scal->destory(p_frame->scal);
+
+	if (p_frame->dst_item) {
+		g2d_dma_unmap(p_frame->dst_item);
+		kfree(p_frame->dst_item);
+		p_frame->dst_item = NULL;
+	}
+	if (p_frame->src_item) {
+		g2d_dma_unmap(p_frame->src_item);
+		kfree(p_frame->src_item);
+		p_frame->src_item = NULL;
+	}
+	if (p_frame->ptn_item) {
+		g2d_dma_unmap(p_frame->ptn_item);
+		kfree(p_frame->ptn_item);
+		p_frame->ptn_item = NULL;
+	}
+	if (p_frame->mask_item) {
+		g2d_dma_unmap(p_frame->mask_item);
+		kfree(p_frame->mask_item);
+		p_frame->mask_item = NULL;
+	}
+
+
+	return ret;
+}
+
+static __u32 frame_get_reg_block_num(struct g2d_mixer_frame *p_frame)
+{
+	__u32 block_num = 0;
+
+	block_num += p_frame->ovl_u->get_reg_block_num(p_frame->ovl_u);
+	block_num += p_frame->ovl_v->get_reg_block_num(p_frame->ovl_v);
+	block_num += p_frame->scal->get_reg_block_num(p_frame->scal);
+	block_num += p_frame->bld->get_reg_block_num(p_frame->bld);
+	block_num += p_frame->wb->get_reg_block_num(p_frame->wb);
+	return block_num;
+}
+
+static int g2d_mixer_frame_setup(struct g2d_mixer_frame *p_frame, unsigned int index)
+{
+	int ret = -1;
+
+	if (!p_frame) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	p_frame->apply = g2d_mixer_frame_apply;
+	p_frame->frame_id = index;
+	p_frame->destory = g2d_mixer_frame_destory;
+	p_frame->frame_get_reg_block_num = frame_get_reg_block_num;
+	p_frame->frame_mem_setup = frame_mem_setup;
+	p_frame->frame_get_rcq_mem_size = frame_get_rcq_mem_size;
+
+	p_frame->wb = g2d_wb_submodule_setup(p_frame);
+	if (!p_frame->wb) {
+		G2D_ERR_MSG("Write back submodule setup fail!\n");
+		goto FREE;
+	}
+
+	p_frame->ovl_v = g2d_ovl_v_submodule_setup(p_frame);
+	if (!p_frame->ovl_v) {
+		G2D_ERR_MSG("ovl v submodule setup fail!\n");
+		goto FREE;
+	}
+
+	p_frame->ovl_u = g2d_ovl_u_submodule_setup(p_frame);
+	if (!p_frame->ovl_u) {
+		G2D_ERR_MSG("ovl u submodule setup fail!\n");
+		goto FREE;
+	}
+
+	p_frame->bld = g2d_bld_submodule_setup(p_frame);
+	if (!p_frame->bld) {
+		G2D_ERR_MSG("bld submodule setup fail!\n");
+		goto FREE;
+	}
+
+	p_frame->scal = g2d_scaler_submodule_setup(p_frame);
+	if (!p_frame->scal) {
+		G2D_ERR_MSG("scaler submodule setup fail!\n");
+		goto FREE;
+	}
+
+	ret = 0;
+	goto OUT;
+
+FREE:
+	kfree(p_frame->wb);
+	kfree(p_frame->ovl_v);
+	kfree(p_frame->ovl_u);
+	kfree(p_frame->bld);
+	kfree(p_frame->scal);
+OUT:
+	return ret;
+}
+
+static __s32 g2d_mixer_rcq_debug(struct g2d_mixer_task *p_task)
+{
+	struct g2d_reg_block **p_reg_blks;
+	struct g2d_reg_block *reg_blk = NULL;
+	__u32 frame_index = 0, size = 0, i = 0;
+	__s32 ret = -1;
+	struct file *pfile = NULL, *regblk_file = NULL;
+	mm_segment_t old_fs;
+	ssize_t bw;
+	loff_t pos = 0;
+	char regblk_name[100];
+
+	if (!p_task)
+		goto OUT;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	pfile = filp_open("/tmp/g2d_rcq_header", O_RDWR | O_CREAT | O_EXCL, 0755);
+	set_fs(old_fs);
+	if (IS_ERR(pfile)) {
+		G2D_ERR_MSG("%s, open /tmp/g2d_rcq_header err\n", __func__);
+		goto OUT;
+	}
+
+	size = p_task->p_rcq_info->alloc_num * sizeof(*(p_task->p_rcq_info->vir_addr));
+	bw = kernel_write(pfile, (char *)p_task->p_rcq_info->vir_addr, size, &pos);
+
+	p_reg_blks = p_task->p_rcq_info->reg_blk;
+	for (frame_index = 0; frame_index < p_task->frame_cnt; ++frame_index) {
+		for (i = 0; i < p_task->p_rcq_info->block_num_per_frame; ++i) {
+			reg_blk = *p_reg_blks;
+			snprintf(regblk_name, 100,
+				 "/tmp/g2d_regblk_frame%d_0x%px", frame_index,
+				 reg_blk->reg_addr);
+			old_fs = get_fs();
+			set_fs(KERNEL_DS);
+			regblk_file = filp_open(
+			    regblk_name, O_RDWR | O_CREAT | O_EXCL, 0755);
+			set_fs(old_fs);
+			if (IS_ERR(regblk_file)) {
+				G2D_ERR_MSG("%s, open %s err\n", __func__,
+					    regblk_name);
+				continue;
+			}
+
+			size = reg_blk->size;
+			pos = 0;
+			bw = kernel_write(regblk_file, (char *)reg_blk->vir_addr,
+				       size, &pos);
+			filp_close(regblk_file, NULL);
+
+			++p_reg_blks;
+		}
+	}
+
+	ret = 0;
+
+	filp_close(pfile, NULL);
+OUT:
+	return ret;
+}
+
+static __s32 g2d_mixer_apply(struct g2d_mixer_task *p_task,
+			   struct mixer_para *p_para)
+{
+	__s32 i = 0, ret = -1;
+
+#if G2D_MIXER_RCQ_USED == 1
+	g2d_top_rcq_update_en(0);
+	g2d_top_rcq_irq_en(0);
+#if defined(CONFIG_ARM64)
+	g2d_top_set_rcq_head((__u64)p_task->p_rcq_info->phy_addr,
+			     p_task->p_rcq_info->rcq_header_len);
+#else
+	g2d_top_set_rcq_head((__u64)(__u32)p_task->p_rcq_info->phy_addr,
+			     p_task->p_rcq_info->rcq_header_len);
+#endif
+#else
+	g2d_mixer_irq_en(0);
+	g2d_mixer_start(0);
+#endif
+
+	for (i = 0; i < p_task->frame_cnt; ++i) {
+		ret = p_task->frame[i].apply(&p_task->frame[i],
+						 &p_para[i]);
+		if (ret)
+			G2D_ERR_MSG("Frame%d apply fail!\n", i);
+	}
+	if (dbg_info > 1)
+		g2d_mixer_rcq_debug(p_task);
+
+#if G2D_MIXER_RCQ_USED == 1
+	g2d_top_rcq_irq_en(1);
+	g2d_top_rcq_update_en(1);
+#else
+	g2d_mixer_irq_en(1);
+	g2d_mixer_start(1);
+#endif
+	ret = g2d_wait_cmd_finish(WAIT_CMD_TIME_MS*p_task->frame_cnt);
+	memcpy(p_task->p_para, p_para,
+	       sizeof(struct mixer_para) * p_task->frame_cnt);
+
+	return ret;
+}
+
+static __s32 g2d_mixer_task_destory(struct g2d_mixer_task *p_task)
+{
+	__s32 i = 0;
+
+	for (i = 0; i < p_task->frame_cnt; ++i) {
+		if (p_task->frame[i].destory(&p_task->frame[i]))
+			G2D_ERR_MSG("Frame:%d destory fail!\n", i);
+	}
+	g2d_top_mem_pool_free(p_task->p_rcq_info);
+
+	if (p_task->p_rcq_info) {
+		kfree(p_task->p_rcq_info->reg_blk);
+		kfree(p_task->p_rcq_info);
+	}
+
+	kfree(p_task->p_para);
+
+	list_del(&p_task->list);
+	ida_simple_remove(&g2d_task_ida, p_task->task_id);
+	kfree(p_task->frame);
+	kfree(p_task);
+
+	return 0;
+}
+
+/**
+ * @name       :create_mixer_task
+ * @brief      :create mixer task instance include memory allocate
+ * @param[IN]  :p_g2d_info:pointer of hardware resource
+ * @param[IN]  :p_para:mixer task parameter
+ * @param[IN]  :frame_len:number of frame
+ * @return     :task_id >= 1, else fail
+ */
+__u32 create_mixer_task(__g2d_info_t *p_g2d_info, struct mixer_para *p_para,
+			 unsigned int frame_len)
+{
+	__s32 i = 0;
+	struct g2d_mixer_task *task = NULL;
+
+	if (!p_g2d_info || !frame_len) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	task = kmalloc(sizeof(struct g2d_mixer_task), GFP_KERNEL | __GFP_ZERO);
+	if (!task) {
+		G2D_ERR_MSG("kmalloc g2d_mixer_task fail!\n");
+		goto OUT;
+	}
+
+	task->frame_cnt = frame_len;
+	task->frame = kmalloc_array(frame_len, sizeof(struct g2d_mixer_frame),
+				    GFP_KERNEL | __GFP_ZERO);
+
+	task->p_rcq_info =
+	    kmalloc(sizeof(struct g2d_rcq_mem_info), GFP_KERNEL | __GFP_ZERO);
+
+	if (!task->frame || !task->p_rcq_info) {
+		G2D_ERR_MSG("Kmalloc fail!\n");
+		goto FREE;
+	}
+
+	task->destory = g2d_mixer_task_destory;
+	task->apply = g2d_mixer_apply;
+	task->mixer_mem_setup = g2d_mixer_mem_setup;
+	task->p_g2d_info = p_g2d_info;
+	task->task_id = ida_simple_get(&g2d_task_ida, 1, 0, GFP_KERNEL);
+	if (task->task_id < 0) {
+		goto FREE;
+	}
+
+	for (i = 0; i < frame_len; ++i) {
+		if (g2d_mixer_frame_setup(&task->frame[i], i)) {
+			G2D_ERR_MSG("frame %d g2d_mixer_frame_setup fail\n", i);
+			goto IDA_REMOVE;
+		}
+		task->frame[i].g2d_base = (u8 __iomem *)p_g2d_info->io;
+	}
+
+	if (task->mixer_mem_setup(task, p_para)) {
+		task->destory(task);
+		goto OUT;
+	}
+	task->p_para = kmalloc(sizeof(struct mixer_para) * task->frame_cnt,
+			       GFP_KERNEL | __GFP_ZERO);
+	if (!task->p_para) {
+		task->destory(task);
+		goto OUT;
+	}
+	memcpy(task->p_para, p_para, sizeof(struct mixer_para) * task->frame_cnt);
+
+	list_add_tail(&task->list, &g2d_task_list);
+
+	return task->task_id;
+IDA_REMOVE:
+	ida_simple_remove(&g2d_task_ida, task->task_id);
+FREE:
+	kfree(task->frame);
+	kfree(task->p_rcq_info);
+	kfree(task);
+OUT:
+	return 0;
+}
+
+/**
+ * @name       :g2d_mixer_get_inst
+ * @brief      :get task instance of specified task id
+ * @param[IN]  :id: task id
+ * @return     :pointer of mixer task or NULL if fail
+ */
+struct g2d_mixer_task *g2d_mixer_get_inst(__u32 id)
+{
+	struct g2d_mixer_task *p_task = NULL;
+
+	list_for_each_entry(p_task, &g2d_task_list, list) {
+		if (p_task->task_id == id)
+			return p_task;
+	}
+	return NULL;
+}
+
+
+__s32 mixer_task_process(__g2d_info_t *p_g2d_info, struct mixer_para *p_para,
+			 unsigned int frame_len)
+{
+	__s32 ret = -1;
+	struct g2d_mixer_task *p_task = NULL;
+	__u32 id = 0;
+
+	id = create_mixer_task(p_g2d_info, p_para, frame_len);
+	p_task = g2d_mixer_get_inst(id);
+	if (!p_task)
+		goto OUT;
+
+	ret = p_task->apply(p_task, p_para);
+
+	p_task->destory(p_task);
+
+OUT:
+	return ret;
+}
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.h
new file mode 100644
index 000000000..9a444b4b3
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer.h
@@ -0,0 +1,105 @@
+/*
+ * g2d_mixer/g2d_mixer.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_MIXER_H
+#define _G2D_MIXER_H
+
+#include "g2d_driver_i.h"
+#include "g2d_ovl_v.h"
+#include "g2d_ovl_u.h"
+#include "g2d_wb.h"
+#include "g2d_bld.h"
+#include "g2d_scal.h"
+#include "g2d_top.h"
+
+struct g2d_mixer_task;
+
+/**
+ * mixer frame
+ */
+struct g2d_mixer_frame {
+	struct ovl_v_submodule *ovl_v;
+	struct ovl_u_submodule *ovl_u;
+	struct blender_submodule *bld;
+	struct scaler_submodule *scal;
+	struct wb_submodule *wb;
+	__u32 frame_id;
+	u8 __iomem *g2d_base;
+	struct dmabuf_item *src_item;
+	struct dmabuf_item *dst_item;
+	struct dmabuf_item *ptn_item;
+	struct dmabuf_item *mask_item;
+	__s32 (*destory)(struct g2d_mixer_frame *p_frame);
+	__s32 (*apply)(struct g2d_mixer_frame *p_frame,
+		     struct mixer_para *p_para);
+	__s32 (*frame_mem_setup)(struct g2d_mixer_frame *p_frame,
+				 struct mixer_para *p_para,
+				 struct g2d_mixer_task *p_task);
+	__u32 (*frame_get_reg_block_num)(struct g2d_mixer_frame *p_frame);
+	__u32 (*frame_get_rcq_mem_size)(struct g2d_mixer_frame *p_frame);
+};
+
+/**
+ * mixer task
+ */
+struct g2d_mixer_task {
+	struct list_head list;
+	__u32 task_id;
+	__u32 frame_cnt;
+	bool en_split_mem;
+	struct g2d_mixer_frame *frame;
+	struct g2d_rcq_mem_info *p_rcq_info;
+	struct mixer_para *p_para;
+	__g2d_info_t *p_g2d_info;
+	__s32 (*mixer_mem_setup)(struct g2d_mixer_task *p_task,
+				 struct mixer_para *p_para);
+	__s32 (*apply)(struct g2d_mixer_task *p_task,
+		     struct mixer_para *p_para);
+	__s32 (*destory)(struct g2d_mixer_task *p_task);
+};
+
+
+/**
+ * @name       :mixer_task_process
+ * @brief      :mixer task process
+ * @param[IN]  :p_g2d_info:pointer of hardware resource
+ * @param[IN]  :p_para:mixer task parameter
+ * @param[IN]  :frame_len:number of frame
+ * @return     :0 if success, -1 else
+ */
+__s32 mixer_task_process(__g2d_info_t *p_g2d_info, struct mixer_para *p_para,
+			 unsigned int frame_len);
+
+/**
+ * @name       :create_mixer_task
+ * @brief      :create mixer task instance include memory allocate
+ * @param[IN]  :p_g2d_info:pointer of hardware resource
+ * @param[IN]  :p_para:mixer task parameter
+ * @param[IN]  :frame_len:number of frame
+ * @return     :task_id >= 1, else fail
+ */
+__u32 create_mixer_task(__g2d_info_t *p_g2d_info, struct mixer_para *p_para,
+			 unsigned int frame_len);
+
+/**
+ * @name       :g2d_mixer_get_inst
+ * @brief      :get task instance of specified task id
+ * @param[IN]  :id: task id
+ * @return     :pointer of mixer task or NULL if fail
+ */
+struct g2d_mixer_task *g2d_mixer_get_inst(__u32 id);
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer_type.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer_type.h
new file mode 100644
index 000000000..9c09081eb
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_mixer_type.h
@@ -0,0 +1,541 @@
+/*
+ * g2d_mixer_type/g2d_mixer_type.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_MIXER_TYPE_H
+#define _G2D_MIXER_TYPE_H
+
+#define G2D_TOP        (0x00000)
+#define G2D_MIXER      (0x00100)
+#define G2D_BLD        (0x00400)
+#define G2D_V0         (0x00800)
+#define G2D_UI0        (0x01000)
+#define G2D_UI1        (0x01800)
+#define G2D_UI2        (0x02000)
+#define G2D_WB         (0x03000)
+#define G2D_VSU        (0x08000)
+#define G2D_ROT        (0x28000)
+#define G2D_GSU        (0x30000)
+
+
+/*mixer overlay for video data define start*/
+union g2d_mixer_ovl_attr {
+	unsigned int dwval;
+	struct {
+		unsigned int lay_en:1;
+		unsigned int alpha_mode:2;
+		unsigned int res0:1;
+		unsigned int lay_fillcolor_en:1;
+		unsigned int res1:3;
+		unsigned int lay_fbfmt:6;
+		unsigned int res2:2;
+		unsigned int lay_premul_ctl:2;
+		unsigned int res3:6;
+		unsigned int lay_glbalpha:8;
+	} bits;
+};
+
+union g2d_mixer_ovl_mem {
+	unsigned int dwval;
+	struct {
+		unsigned int lay_width:13;
+		unsigned int res0:3;
+		unsigned int lay_height:13;
+		unsigned int res1:3;
+	} bits;
+};
+
+union g2d_mixer_ovl_mem_coor {
+	unsigned int dwval;
+	struct {
+		unsigned int lay_ycoor:16;
+		unsigned int lay_xcoor:16;
+	} bits;
+};
+
+union g2d_mixer_ovl_mem_high_addr {
+	unsigned int dwval;
+	struct {
+		unsigned int lay_y_hadd:8;
+		unsigned int lay_u_hadd:8;
+		unsigned int lay_v_hadd:8;
+		unsigned int res0:8;
+	} bits;
+};
+
+union g2d_mixer_ovl_winsize {
+	unsigned int dwval;
+	struct {
+		unsigned int width:13;
+		unsigned int res0:3;
+		unsigned int height:13;
+		unsigned int res1:3;
+	} bits;
+};
+
+union g2d_mixer_ovl_down_sample {
+	unsigned int dwval;
+	struct {
+		unsigned int M:14;
+		unsigned int res0:2;
+		unsigned int N:14;
+		unsigned int res1:2;
+	} bits;
+};
+
+struct g2d_mixer_ovl_v_reg {
+	/*0x00*/
+	union g2d_mixer_ovl_attr ovl_attr;
+	union g2d_mixer_ovl_mem ovl_mem;
+	union g2d_mixer_ovl_mem_coor ovl_mem_coor;
+	unsigned int ovl_mem_pitch0;
+	/*0x10*/
+	unsigned int ovl_mem_pitch1;
+	unsigned int ovl_mem_pitch2;
+	unsigned int ovl_mem_low_addr0;
+	unsigned int ovl_mem_low_addr1;
+	/*0x20*/
+	unsigned int ovl_mem_low_addr2;
+	unsigned int ovl_fill_color;
+	union g2d_mixer_ovl_mem_high_addr ovl_mem_high_addr;
+	union g2d_mixer_ovl_winsize ovl_winsize;
+	/*0x30*/
+	union g2d_mixer_ovl_down_sample hor_down_sample0;
+	union g2d_mixer_ovl_down_sample hor_down_sample1;
+	union g2d_mixer_ovl_down_sample ver_down_sample0;
+	union g2d_mixer_ovl_down_sample ver_down_sample1;
+};
+/*mixer overlay for video data define end*/
+
+/*mixer overlay for UI data define start*/
+
+union g2d_mixer_ovl_u_attr {
+	unsigned int dwval;
+	struct {
+		unsigned int lay_en:1;
+		unsigned int alpha_mode:2;
+		unsigned int res0:1;
+		unsigned int lay_fillcolor_en:1;
+		unsigned int res1:3;
+		unsigned int lay_fbfmt:5;
+		unsigned int res2:3;
+		unsigned int lay_premul_ctl:2;
+		unsigned int res3:6;
+		unsigned int lay_glbalpha:8;
+	} bits;
+};
+struct g2d_mixer_ovl_u_reg {
+	/*0x00*/
+	union g2d_mixer_ovl_u_attr ovl_attr;
+	union g2d_mixer_ovl_mem ovl_mem;
+	union g2d_mixer_ovl_mem_coor ovl_mem_coor;
+	unsigned int ovl_mem_pitch0;
+	/*0x10*/
+	unsigned int ovl_mem_low_addr0;
+	unsigned int ovl_fill_color;
+	unsigned int ovl_mem_high_addr;
+	union g2d_mixer_ovl_winsize ovl_winsize;
+};
+/*mixer overlay for UI data define end*/
+
+
+/*mixer video scaler define start*/
+union g2d_mixer_vs_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int en:1;
+		unsigned int res0:7;
+		unsigned int coef_access_sel:1;
+		unsigned int res1:7;
+		unsigned int filter_type:1;
+		unsigned int res2:13;
+		unsigned int core_rst:1;
+		unsigned int bist_en:1;
+	} bits;
+};
+
+union g2d_mixer_vs_out_size {
+	unsigned int dwval;
+	struct {
+		unsigned int out_width:13;
+		unsigned int res0:3;
+		unsigned int out_height:13;
+		unsigned int res1:3;
+	} bits;
+};
+
+union g2d_mixer_vs_glb_alpha {
+	unsigned int dwval;
+	struct {
+		unsigned int glb_alpha:8;
+		unsigned int res0:24;
+	} bits;
+};
+
+union g2d_mixer_vs_ch_size {
+	unsigned int dwval;
+	struct {
+		unsigned int y_width:13;
+		unsigned int res0:3;
+		unsigned int y_height:13;
+		unsigned int res1:3;
+	} bits;
+};
+
+union g2d_mixer_vs_step {
+	unsigned int dwval;
+	struct {
+		unsigned int res0:1;
+		unsigned int frac:19;
+		unsigned int integer:4;
+		unsigned int res1:8;
+	} bits;
+};
+
+union g2d_mixer_vs_filter_coeff {
+	unsigned int dwval;
+	struct {
+		unsigned int coff0:8;
+		unsigned int coff1:8;
+		unsigned int coff2:8;
+		unsigned int coff3:8;
+	} bits;
+};
+
+struct g2d_mixer_video_scaler_reg {
+	/*0x00*/
+	union g2d_mixer_vs_ctrl vs_ctrl;
+	unsigned int res0[15];
+	/*0x40*/
+	union g2d_mixer_vs_out_size out_size;
+	union g2d_mixer_vs_glb_alpha glb_alpha;
+	unsigned int res1[14];
+	/*0x80*/
+	union g2d_mixer_vs_ch_size y_ch_size;
+	unsigned int res2;
+	union g2d_mixer_vs_step y_hor_step;
+	union g2d_mixer_vs_step y_ver_step;
+	/*0x90*/
+	union g2d_mixer_vs_step y_hor_phase;
+	unsigned int res3;
+	union g2d_mixer_vs_step y_ver_phase;
+	unsigned int res4[9];
+	/*0xc0*/
+	union g2d_mixer_vs_ch_size c_ch_size;
+	unsigned int res5;
+	union g2d_mixer_vs_step c_hor_step;
+	union g2d_mixer_vs_step c_ver_step;
+	/*0xd0*/
+	union g2d_mixer_vs_step c_hor_phase;
+	unsigned int res6;
+	union g2d_mixer_vs_step c_ver_phase;
+	unsigned int res7[73];
+	union g2d_mixer_vs_filter_coeff vs_y_ch_hor_filter_coef[32];
+	unsigned int res8[32];
+	union g2d_mixer_vs_filter_coeff vs_y_ch_ver_filter_coef[32];
+	unsigned int res9[32];
+	union g2d_mixer_vs_filter_coeff vs_c_ch_hor_filter_coef[32];
+};
+/*mixer video scaler define end*/
+
+/*mixer video blender define start*/
+union g2d_mixer_bld_en_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int p0_fcen:1;
+		unsigned int p1_fcen:1;
+		unsigned int res0:6;
+		unsigned int p0_en:1;
+		unsigned int p1_en:1;
+		unsigned int res1:22;
+	} bits;
+};
+
+union g2d_mixer_bld_mem_size {
+	unsigned int dwval;
+	struct {
+		unsigned int width:13;
+		unsigned int res0:3;
+		unsigned int height:13;
+		unsigned int res1:3;
+	} bits;
+};
+
+union g2d_mixer_bld_mem_coor {
+	unsigned int dwval;
+	struct {
+		unsigned int xcoor:16;
+		unsigned int ycoor:16;
+	} bits;
+};
+
+union g2d_mixer_bld_premulti_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int p0_alpha_mode:1;
+		unsigned int p1_alpha_mode:1;
+		unsigned int res0:30;
+	} bits;
+};
+
+union g2d_mixer_bld_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int blend_pfs:4;
+		unsigned int res0:4;
+		unsigned int blend_pfd:4;
+		unsigned int res1:4;
+		unsigned int blend_afs:4;
+		unsigned int res2:4;
+		unsigned int blend_afd:4;
+		unsigned int res3:4;
+	} bits;
+};
+
+union g2d_mixer_bld_color_key {
+	unsigned int dwval;
+	struct {
+		unsigned int key0_en:1;
+		unsigned int key0_match_dir:2;
+		unsigned int res0:29;
+	} bits;
+};
+
+union g2d_mixer_bld_color_key_cfg {
+	unsigned int dwval;
+	struct {
+		unsigned int key0b_match:1;
+		unsigned int key0g_match:1;
+		unsigned int key0y_match:1;
+		unsigned int res0:29;
+	} bits;
+};
+
+
+union g2d_mixer_bld_color_key_max {
+	unsigned int dwval;
+	struct {
+		unsigned int max_b:8;
+		unsigned int max_g:8;
+		unsigned int max_r:8;
+		unsigned int res0:8;
+	} bits;
+};
+
+union g2d_mixer_bld_color_key_min {
+	unsigned int dwval;
+	struct {
+		unsigned int min_b:8;
+		unsigned int min_g:8;
+		unsigned int min_r:8;
+		unsigned int res0:8;
+	} bits;
+};
+
+union g2d_mixer_bld_output_color {
+	unsigned int dwval;
+	struct {
+		unsigned int premul_en:1;
+		unsigned int alpha_mode:1;
+		unsigned int res0:30;
+	} bits;
+};
+
+
+
+union g2d_mixer_rop_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int type:1;
+		unsigned int res0:3;
+		unsigned int blue_bypass_en:1;
+		unsigned int green_bypass_en:1;
+		unsigned int red_bypass_en:1;
+		unsigned int alpha_bypass_en:1;
+		unsigned int blue_ch_sel:2;
+		unsigned int green_ch_sel:2;
+		unsigned int red_ch_sel:2;
+		unsigned int alpha_ch_sel:2;
+		unsigned int res1:16;
+	} bits;
+};
+
+union g2d_mixer_rop_ch3_index0 {
+	unsigned int dwval;
+	struct {
+		unsigned int index0node0:3;
+		unsigned int index0node1:1;
+		unsigned int index0node2:1;
+		unsigned int index0node3:1;
+		unsigned int index0node4:4;
+		unsigned int index0node5:1;
+		unsigned int index0node6:4;
+		unsigned int index0node7:1;
+		unsigned int ch0ign_en:1;
+		unsigned int ch1ign_en:1;
+		unsigned int ch2ign_en:1;
+		unsigned int res0:13;
+	} bits;
+};
+
+union g2d_mixer_bld_cs_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int cs0_en:1;
+		unsigned int cs1_en:1;
+		unsigned int cs2_en:1;
+		unsigned int res0:29;
+	} bits;
+};
+
+union g2d_mixer_bld_cs_coeff {
+	unsigned int dwval;
+	struct {
+		unsigned int coeff:13;
+		unsigned int res0:19;
+	} bits;
+};
+
+union g2d_mixer_bld_cs_const {
+	unsigned int dwval;
+	struct {
+		unsigned int const:20;
+		unsigned int res0:12;
+	} bits;
+};
+
+
+struct g2d_mixer_bld_reg {
+	/*0x00*/
+	union g2d_mixer_bld_en_ctrl bld_en_ctrl;
+	unsigned int res0[3];
+	/*0x10*/
+	unsigned int bld_fill_color[2];
+	unsigned int res1[2];
+	/*0x20*/
+	union g2d_mixer_bld_mem_size mem_size[2];
+	unsigned int res2[2];
+	/*0x30*/
+	union g2d_mixer_bld_mem_coor mem_coor[2];
+	unsigned int res3[2];
+	/*0x40*/
+	union g2d_mixer_bld_premulti_ctrl premulti_ctrl;
+	unsigned int bld_backgroud_color;
+	union g2d_mixer_bld_mem_size out_size;
+	union g2d_mixer_bld_ctrl bld_ctrl;
+	/*0x50*/
+	union g2d_mixer_bld_color_key color_key;
+	union g2d_mixer_bld_color_key_cfg color_key_cfg;
+	union g2d_mixer_bld_color_key_max color_key_max;
+	union g2d_mixer_bld_color_key_min color_key_min;
+	/*0x60*/
+	union g2d_mixer_bld_output_color out_color;
+	unsigned int res4[7];
+	/*0x80*/
+	union g2d_mixer_rop_ctrl rop_ctrl;
+	union g2d_mixer_rop_ch3_index0 ch3_index0;
+	union g2d_mixer_rop_ch3_index0 ch3_index1;
+	unsigned int res5[29];
+	/*0x100*/
+	union g2d_mixer_bld_cs_ctrl cs_ctrl;
+	unsigned int res6[3];
+	/*0x110*/
+	union g2d_mixer_bld_cs_coeff csc0_coeff0_reg0;
+	union g2d_mixer_bld_cs_coeff csc0_coeff0_reg1;
+	union g2d_mixer_bld_cs_coeff csc0_coeff0_reg2;
+	union g2d_mixer_bld_cs_const csc0_const0;
+	/*0x120*/
+	union g2d_mixer_bld_cs_coeff csc0_coeff1_reg0;
+	union g2d_mixer_bld_cs_coeff csc0_coeff1_reg1;
+	union g2d_mixer_bld_cs_coeff csc0_coeff1_reg2;
+	union g2d_mixer_bld_cs_const csc0_const1;
+	/*0x130*/
+	union g2d_mixer_bld_cs_coeff csc0_coeff2_reg0;
+	union g2d_mixer_bld_cs_coeff csc0_coeff2_reg1;
+	union g2d_mixer_bld_cs_coeff csc0_coeff2_reg2;
+	union g2d_mixer_bld_cs_const csc0_const2;
+	/*0x140*/
+	union g2d_mixer_bld_cs_coeff csc1_coeff0_reg0;
+	union g2d_mixer_bld_cs_coeff csc1_coeff0_reg1;
+	union g2d_mixer_bld_cs_coeff csc1_coeff0_reg2;
+	union g2d_mixer_bld_cs_const csc1_const0;
+	/*0x150*/
+	union g2d_mixer_bld_cs_coeff csc1_coeff1_reg0;
+	union g2d_mixer_bld_cs_coeff csc1_coeff1_reg1;
+	union g2d_mixer_bld_cs_coeff csc1_coeff1_reg2;
+	union g2d_mixer_bld_cs_const csc1_const1;
+	/*0x160*/
+	union g2d_mixer_bld_cs_coeff csc1_coeff2_reg0;
+	union g2d_mixer_bld_cs_coeff csc1_coeff2_reg1;
+	union g2d_mixer_bld_cs_coeff csc1_coeff2_reg2;
+	union g2d_mixer_bld_cs_const csc1_const2;
+	/*0x170*/
+	union g2d_mixer_bld_cs_coeff csc2_coeff0_reg0;
+	union g2d_mixer_bld_cs_coeff csc2_coeff0_reg1;
+	union g2d_mixer_bld_cs_coeff csc2_coeff0_reg2;
+	union g2d_mixer_bld_cs_const csc2_const0;
+	/*0x180*/
+	union g2d_mixer_bld_cs_coeff csc2_coeff1_reg0;
+	union g2d_mixer_bld_cs_coeff csc2_coeff1_reg1;
+	union g2d_mixer_bld_cs_coeff csc2_coeff1_reg2;
+	union g2d_mixer_bld_cs_const csc2_const1;
+	/*0x190*/
+	union g2d_mixer_bld_cs_coeff csc2_coeff2_reg0;
+	union g2d_mixer_bld_cs_coeff csc2_coeff2_reg1;
+	union g2d_mixer_bld_cs_coeff csc2_coeff2_reg2;
+	union g2d_mixer_bld_cs_const csc2_const2;
+};
+/*mixer video blender define end*/
+
+/*mixer write back start*/
+union g2d_mxier_wb_attr {
+	unsigned int dwval;
+	struct {
+		unsigned int fmt:6;
+		unsigned int res0:2;
+		unsigned int round_en:1;
+		unsigned int res1:23;
+	} bits;
+};
+
+union g2d_mxier_wb_data_size {
+	unsigned int dwval;
+	struct {
+		unsigned int width:13;
+		unsigned int res0:3;
+		unsigned int height:13;
+		unsigned int res1:3;
+	} bits;
+};
+
+struct g2d_mixer_write_back_reg {
+	/*0x00*/
+	union g2d_mxier_wb_attr wb_attr;
+	union g2d_mxier_wb_data_size data_size;
+	unsigned int pitch0;
+	unsigned int pitch1;
+	/*0x10*/
+	unsigned int pitch2;
+	unsigned int laddr0;
+	unsigned int haddr0;
+	unsigned int laddr1;
+	/*0x20*/
+	unsigned int haddr1;
+	unsigned int laddr2;
+	unsigned int haddr2;
+};
+/*mixer write back end*/
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.c
new file mode 100644
index 000000000..4144d1d58
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.c
@@ -0,0 +1,285 @@
+/*
+ * g2d_ovl_u.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "g2d_ovl_u.h"
+
+__s32 g2d_ovl_u_fc_set(struct ovl_u_submodule *p_ovl_u, __u32 sel,
+		       __u32 color_value)
+{
+	__s32 ret = -1;
+	struct g2d_mixer_ovl_u_reg *p_reg = p_ovl_u->get_reg(p_ovl_u, sel);
+
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->ovl_attr.bits.lay_fillcolor_en = 1;
+	p_reg->ovl_fill_color = color_value;
+
+	p_ovl_u->set_block_dirty(p_ovl_u, sel, 1);
+
+	ret = 0;
+OUT:
+	return ret;
+}
+
+__s32 g2d_uilayer_set(struct ovl_u_submodule *p_ovl_u, __u32 sel,
+		      g2d_image_enh *p_img)
+{
+	__u64 addr0;
+	__u32 ycnt, ucnt, vcnt;
+	__u32 pitch0;
+	__s32 ret = -1;
+	struct g2d_mixer_ovl_u_reg *p_reg = p_ovl_u->get_reg(p_ovl_u, sel);
+
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->ovl_attr.bits.lay_glbalpha = p_img->alpha & 0xff;
+	if (p_img->bpremul)
+		p_reg->ovl_attr.bits.lay_premul_ctl = 1;
+	p_reg->ovl_attr.bits.lay_fbfmt = p_img->format;
+	p_reg->ovl_attr.bits.alpha_mode = p_img->mode;
+	p_reg->ovl_attr.bits.lay_en = 1;
+
+	p_reg->ovl_mem.bits.lay_width =
+	    (p_img->clip_rect.w == 0 ? 0 : p_img->clip_rect.w - 1) & 0x1fff;
+	p_reg->ovl_mem.bits.lay_height =
+	    (p_img->clip_rect.h == 0 ? 0 : p_img->clip_rect.h - 1) & 0x1fff;
+	p_reg->ovl_winsize.bits.width =
+	    (p_img->clip_rect.w == 0 ? 0 : p_img->clip_rect.w - 1) & 0x1fff;
+	p_reg->ovl_winsize.bits.height =
+	    (p_img->clip_rect.h == 0 ? 0 : p_img->clip_rect.h - 1) & 0x1fff;
+
+	p_reg->ovl_mem_coor.dwval = 0;
+	g2d_byte_cal(p_img->format, &ycnt, &ucnt, &vcnt);
+	pitch0 = cal_align(ycnt * p_img->width, p_img->align[0]);
+	p_reg->ovl_mem_pitch0 = pitch0;
+
+	addr0 =
+	    p_img->laddr[0] + ((__u64) p_img->haddr[0] << 32) +
+	    pitch0 * p_img->clip_rect.y + ycnt * p_img->clip_rect.x;
+	p_reg->ovl_mem_low_addr0 = addr0 & 0xffffffff;
+	p_reg->ovl_mem_high_addr = (addr0 >> 32) & 0xff;
+
+	if (p_img->bbuff == 0)
+		g2d_ovl_u_fc_set(p_ovl_u, sel, p_img->color);
+
+	p_ovl_u->set_block_dirty(p_ovl_u, sel, 1);
+	ret = 0;
+OUT:
+	return ret;
+}
+
+__s32 g2d_uilayer_overlay_set(struct ovl_u_submodule *p_ovl_u, __u32 sel,
+					g2d_coor *coor,  __u32 w, __u32 h)
+{
+	__s32 ret = -1;
+	struct g2d_mixer_ovl_u_reg *p_reg = p_ovl_u->get_reg(p_ovl_u, sel);
+
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->ovl_winsize.bits.width = (w - 1) & 0x1fff;
+	p_reg->ovl_winsize.bits.height = (h - 1) & 0x1fff;
+
+	p_reg->ovl_mem_coor.bits.lay_xcoor = coor->x;
+	p_reg->ovl_mem_coor.bits.lay_ycoor = coor->y;
+	ret = 0;
+OUT:
+	return ret;
+}
+static int ovl_u_rcq_setup(struct ovl_u_submodule *p_ovl_u, u8 __iomem *base,
+			   struct g2d_rcq_mem_info *p_rcq_info)
+{
+	u8 __iomem *reg_base = base + G2D_UI0;
+	__s32 ret = -1;
+
+	if (!p_ovl_u) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	p_ovl_u->reg_info->size = sizeof(struct g2d_mixer_ovl_v_reg);
+	p_ovl_u->reg_info->vir_addr = (u8 *)g2d_top_reg_memory_alloc(
+	    p_ovl_u->reg_info->size,
+	    (void *)&(p_ovl_u->reg_info->phy_addr), p_rcq_info);
+
+	if (!p_ovl_u->reg_info->vir_addr) {
+		G2D_ERR_MSG("Malloc writeback reg rcq memory fail!\n");
+		goto OUT;
+	}
+	p_ovl_u->reg_blks[0].vir_addr = p_ovl_u->reg_info->vir_addr;
+	p_ovl_u->reg_blks[0].phy_addr = p_ovl_u->reg_info->phy_addr;
+	p_ovl_u->reg_blks[0].size = p_ovl_u->reg_info->size;
+	p_ovl_u->reg_blks[0].reg_addr = reg_base;
+
+	p_ovl_u->reg_info->size = sizeof(struct g2d_mixer_ovl_v_reg);
+	p_ovl_u->reg_info->vir_addr = (u8 *)g2d_top_reg_memory_alloc(
+	    p_ovl_u->reg_info->size,
+	    (void *)&(p_ovl_u->reg_info->phy_addr), p_rcq_info);
+
+	if (!p_ovl_u->reg_info->vir_addr) {
+		G2D_ERR_MSG("Malloc writeback reg rcq memory fail!\n");
+		goto OUT;
+	}
+	p_ovl_u->reg_blks[1].vir_addr = p_ovl_u->reg_info->vir_addr;
+	p_ovl_u->reg_blks[1].phy_addr = p_ovl_u->reg_info->phy_addr;
+	p_ovl_u->reg_blks[1].size = p_ovl_u->reg_info->size;
+	p_ovl_u->reg_blks[1].reg_addr = base + G2D_UI1;
+
+	p_ovl_u->reg_info->size = sizeof(struct g2d_mixer_ovl_v_reg);
+	p_ovl_u->reg_info->vir_addr = (u8 *)g2d_top_reg_memory_alloc(
+	    p_ovl_u->reg_info->size,
+	    (void *)&(p_ovl_u->reg_info->phy_addr), p_rcq_info);
+
+	if (!p_ovl_u->reg_info->vir_addr) {
+		G2D_ERR_MSG("Malloc writeback reg rcq memory fail!\n");
+		goto OUT;
+	}
+	p_ovl_u->reg_blks[2].vir_addr = p_ovl_u->reg_info->vir_addr;
+	p_ovl_u->reg_blks[2].phy_addr = p_ovl_u->reg_info->phy_addr;
+	p_ovl_u->reg_blks[2].size = p_ovl_u->reg_info->size;
+	p_ovl_u->reg_blks[2].reg_addr = base + G2D_UI2;
+	ret = 0;
+
+OUT:
+	return ret;
+}
+
+static __u32 ovl_v_get_reg_block_num(struct ovl_u_submodule *p_ovl_u)
+{
+	if (p_ovl_u)
+		return p_ovl_u->reg_blk_num;
+	return 0;
+}
+
+static __s32 ovl_v_get_reg_block(struct ovl_u_submodule *p_ovl_u,
+			    struct g2d_reg_block **blks)
+{
+	__s32 i = 0, ret = -1;
+
+	if (p_ovl_u) {
+		for (i = 0; i < p_ovl_u->reg_blk_num; ++i)
+			blks[i] = p_ovl_u->reg_blks + i;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static struct g2d_mixer_ovl_u_reg *ovl_v_get_reg(struct ovl_u_submodule *p_ovl_u, __u32 sel)
+{
+	if (sel > p_ovl_u->reg_blk_num - 1)
+		goto OUT;
+
+#if G2D_MIXER_RCQ_USED == 1
+	return (struct g2d_mixer_ovl_u_reg *)(p_ovl_u->reg_blks[sel]
+						   .vir_addr);
+#else
+	return (struct g2d_mixer_ovl_u_reg *)(p_ovl_u->reg_blks[sel]
+						   .reg_addr);
+#endif
+OUT:
+	return NULL;
+}
+
+
+static void ovl_v_set_block_dirty(struct ovl_u_submodule *p_ovl_u, __u32 blk_id, __u32 dirty)
+{
+
+	if (blk_id > p_ovl_u->reg_blk_num - 1)
+		return;
+
+#if G2D_MIXER_RCQ_USED == 1
+	if (p_ovl_u && p_ovl_u->reg_blks->rcq_hd)
+		p_ovl_u->reg_blks[blk_id].rcq_hd->dirty.bits.dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#else
+
+	if (p_ovl_u)
+		p_ovl_u->reg_blks[blk_id].dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#endif
+}
+
+static __u32 ovl_v_get_rcq_mem_size(struct ovl_u_submodule *p_ovl_u)
+{
+	return G2D_RCQ_BYTE_ALIGN(sizeof(struct g2d_mixer_ovl_v_reg)) *
+	       p_ovl_u->reg_blk_num;
+}
+
+static __s32 ovl_u_destory(struct ovl_u_submodule *p_ovl_u)
+{
+	__s32 ret = -1;
+
+	if (p_ovl_u) {
+		kfree(p_ovl_u->reg_blks);
+		p_ovl_u->reg_blks = NULL;
+
+		kfree(p_ovl_u->reg_info);
+		p_ovl_u->reg_info = NULL;
+		ret = 0;
+		kfree(p_ovl_u);
+	}
+
+	return ret;
+}
+
+struct ovl_u_submodule *
+g2d_ovl_u_submodule_setup(struct g2d_mixer_frame *p_frame)
+{
+	struct ovl_u_submodule *p_ovl_u = NULL;
+
+	p_ovl_u = kmalloc(sizeof(struct ovl_u_submodule), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_ovl_u) {
+		G2D_ERR_MSG("Kmalloc wb submodule fail!\n");
+		return NULL;
+	}
+
+	p_ovl_u->rcq_setup = ovl_u_rcq_setup;
+	p_ovl_u->reg_blk_num = UI_LAYER_NUMBER;
+	p_ovl_u->get_reg_block_num = ovl_v_get_reg_block_num;
+	p_ovl_u->get_reg_block = ovl_v_get_reg_block;
+	p_ovl_u->get_reg = ovl_v_get_reg;
+	p_ovl_u->set_block_dirty = ovl_v_set_block_dirty;
+	p_ovl_u->get_rcq_mem_size = ovl_v_get_rcq_mem_size;
+	p_ovl_u->destory = ovl_u_destory;
+
+	p_ovl_u->reg_blks =
+	    kmalloc(sizeof(struct g2d_reg_block) * p_ovl_u->reg_blk_num,
+		    GFP_KERNEL | __GFP_ZERO);
+	p_ovl_u->reg_info =
+	    kmalloc(sizeof(struct g2d_reg_mem_info), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_ovl_u->reg_blks || !p_ovl_u->reg_info) {
+		G2D_ERR_MSG("Kmalloc wb reg info fail!\n");
+		goto FREE_WB;
+	}
+
+
+	return p_ovl_u;
+FREE_WB:
+	kfree(p_ovl_u->reg_blks);
+	kfree(p_ovl_u->reg_info);
+	kfree(p_ovl_u);
+
+	return NULL;
+}
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.h
new file mode 100644
index 000000000..281a217de
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_u.h
@@ -0,0 +1,50 @@
+/*
+ * g2d_ovl_u/g2d_ovl_u.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_OVL_U_H
+#define _G2D_OVL_U_H
+
+#include "g2d_rcq.h"
+#include "g2d_mixer_type.h"
+#include "g2d_mixer.h"
+
+struct g2d_mixer_frame;
+struct ovl_u_submodule {
+	struct g2d_reg_block *reg_blks;
+	__u32 reg_blk_num;
+	struct g2d_reg_mem_info *reg_info;
+	__s32 (*destory)(struct ovl_u_submodule *p_ovl_u);
+	__s32 (*rcq_setup)(struct ovl_u_submodule *p_ovl_u, u8 __iomem *base,
+			   struct g2d_rcq_mem_info *p_rcq_info);
+	__u32 (*get_reg_block_num)(struct ovl_u_submodule *p_ovl_u);
+	__u32 (*get_rcq_mem_size)(struct ovl_u_submodule *p_ovl_u);
+	__s32 (*get_reg_block)(struct ovl_u_submodule *p_ovl_u, struct g2d_reg_block **blks);
+	struct g2d_mixer_ovl_u_reg  *(*get_reg)(struct ovl_u_submodule *p_ovl_u, __u32 sel);
+	void (*set_block_dirty)(struct ovl_u_submodule *p_ovl_u, __u32 blk_id, __u32 dirty);
+};
+
+__s32 g2d_ovl_u_fc_set(struct ovl_u_submodule *p_ovl_u, __u32 sel,
+		       __u32 color_value);
+__s32 g2d_uilayer_set(struct ovl_u_submodule *p_ovl_u, __u32 sel,
+		      g2d_image_enh *img);
+
+__s32 g2d_uilayer_overlay_set(struct ovl_u_submodule *p_ovl_u, __u32 sel,
+					g2d_coor *coor,  __u32 w, __u32 h);
+
+struct ovl_u_submodule *
+g2d_ovl_u_submodule_setup(struct g2d_mixer_frame *p_frame);
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.c
new file mode 100644
index 000000000..87bf69e55
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.c
@@ -0,0 +1,395 @@
+/*
+ * g2d_ovl_v.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "g2d_ovl_v.h"
+
+__s32 g2d_ovl_v_calc_coarse(struct ovl_v_submodule *p_ovl_v, __u32 format, __u32 inw,
+		      __u32 inh, __u32 outw, __u32 outh, __u32 *midw,
+		      __u32 *midh)
+{
+	__u32 tmp;
+	__s32 ret = -1;
+	struct g2d_mixer_ovl_v_reg *p_reg = p_ovl_v->get_reg(p_ovl_v);
+
+	if (!p_reg)
+		goto OUT;
+
+	switch (format) {
+	case G2D_FORMAT_IYUV422_V0Y1U0Y0:
+	case G2D_FORMAT_IYUV422_Y1V0Y0U0:
+	case G2D_FORMAT_IYUV422_U0Y1V0Y0:
+	case G2D_FORMAT_IYUV422_Y1U0Y0V0: {
+		/* interleaved YUV422 format */
+		*midw = inw;
+		*midh = inh;
+		break;
+	}
+	case G2D_FORMAT_YUV422UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV422UVC_U1V1U0V0:
+	case G2D_FORMAT_YUV422_PLANAR: {
+		if (inw >= (outw << 3)) {
+			*midw = outw << 3;
+			tmp = (*midw << 16) | inw;
+			p_reg->hor_down_sample0.dwval = tmp;
+			tmp = (*midw << 15) | ((inw + 1) >> 1);
+			p_reg->hor_down_sample1.dwval = tmp;
+		} else
+			*midw = inw;
+		if (inh >= (outh << 2)) {
+			*midh = (outh << 2);
+			tmp = (*midh << 16) | inh;
+			p_reg->ver_down_sample0.dwval = tmp;
+			p_reg->ver_down_sample1.dwval = tmp;
+		} else
+			*midh = inh;
+		break;
+	}
+	case G2D_FORMAT_Y8:
+	case G2D_FORMAT_YUV420_PLANAR:
+	case G2D_FORMAT_YUV420UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV420UVC_U1V1U0V0: {
+		if (inw >= (outw << 3)) {
+			*midw = outw << 3;
+			tmp = (*midw << 16) | inw;
+			p_reg->hor_down_sample0.dwval = tmp;
+			tmp = (*midw << 15) | ((inw + 1) >> 1);
+			p_reg->hor_down_sample1.dwval = tmp;
+		} else
+			*midw = inw;
+		if (inh >= (outh << 2)) {
+			*midh = (outh << 2);
+			tmp = (*midh << 16) | inh;
+			p_reg->ver_down_sample0.dwval = tmp;
+			tmp = (*midh << 15) | ((inh + 1) >> 1);
+			p_reg->ver_down_sample1.dwval = tmp;
+		} else
+			*midh = inh;
+		break;
+	}
+	case G2D_FORMAT_YUV411_PLANAR:
+	case G2D_FORMAT_YUV411UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV411UVC_U1V1U0V0: {
+		if (inw >= (outw << 3)) {
+			*midw = outw << 3;
+			tmp = ((*midw) << 16) | inw;
+			p_reg->hor_down_sample0.dwval = tmp;
+			tmp = ((*midw) << 14) | ((inw + 3) >> 2);
+			p_reg->hor_down_sample1.dwval = tmp;
+		} else
+			*midw = inw;
+		if (inh >= (outh << 2)) {
+			*midh = (outh << 2);
+			tmp = ((*midh) << 16) | inh;
+			p_reg->ver_down_sample0.dwval = tmp;
+			p_reg->ver_down_sample1.dwval = tmp;
+		} else
+			*midh = inh;
+		break;
+	}
+	default:
+		if (inw >= (outw << 3)) {
+			*midw = outw << 3;
+			tmp = ((*midw) << 16) | inw;
+			p_reg->hor_down_sample0.dwval = tmp;
+			p_reg->hor_down_sample1.dwval = tmp;
+		} else
+			*midw = inw;
+		if (inh >= (outh << 2)) {
+			*midh = (outh << 2);
+			tmp = ((*midh) << 16) | inh;
+			p_reg->ver_down_sample0.dwval = tmp;
+			p_reg->ver_down_sample1.dwval = tmp;
+		} else
+			*midh = inh;
+		break;
+	}
+	p_ovl_v->set_block_dirty(p_ovl_v, 0, 1);
+	ret = 0;
+OUT:
+	return ret;
+}
+
+/**
+ * fillcolor set
+ * @color_value:fill color value
+ */
+__s32 g2d_ovl_v_fc_set(struct ovl_v_submodule *p_ovl_v, __u32 color_value)
+{
+	__s32 ret = -1;
+	struct g2d_mixer_ovl_v_reg *p_reg = p_ovl_v->get_reg(p_ovl_v);
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->ovl_attr.bits.lay_fillcolor_en = 1;
+	p_reg->ovl_fill_color = color_value;
+	p_ovl_v->set_block_dirty(p_ovl_v, 0, 1);
+	ret = 0;
+
+OUT:
+	return ret;
+}
+
+/**
+ * @sel:layer no.
+ */
+__s32 g2d_vlayer_set(struct ovl_v_submodule *p_ovl_v, __u32 sel, g2d_image_enh *p_image)
+{
+	unsigned long long addr0, addr1, addr2;
+	__u32 tmp;
+	__u32 ycnt, ucnt, vcnt;
+	__u32 pitch0, pitch1, pitch2;
+	__u32 ch, cw, cy, cx;
+	__s32 ret = -1;
+	struct g2d_mixer_ovl_v_reg *p_reg = p_ovl_v->get_reg(p_ovl_v);
+
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->ovl_attr.bits.lay_fbfmt = p_image->format;
+	p_reg->ovl_attr.bits.alpha_mode = p_image->mode;
+	if (p_image->bpremul)
+		p_reg->ovl_attr.bits.lay_premul_ctl = 1;
+	p_reg->ovl_attr.bits.lay_glbalpha = p_image->alpha & 0xff;
+	p_reg->ovl_attr.bits.lay_en = 1;
+
+	p_reg->ovl_mem.bits.lay_width =
+	    (p_image->clip_rect.w == 0 ? 0 : p_image->clip_rect.w - 1) & 0x1fff;
+	p_reg->ovl_mem.bits.lay_height =
+	    (p_image->clip_rect.h == 0 ? 0 : p_image->clip_rect.h - 1) & 0x1fff;
+
+	p_reg->ovl_winsize.bits.width =
+	    (p_image->clip_rect.w == 0 ? 0 : p_image->clip_rect.w - 1) & 0x1fff;
+	p_reg->ovl_winsize.bits.height =
+	    (p_image->clip_rect.h == 0 ? 0 : p_image->clip_rect.h - 1) & 0x1fff;
+
+	/* offset is set to 0, ovl size is set to layer size */
+	p_reg->ovl_mem_coor.dwval = 0;
+	if ((p_image->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0)
+	      && (p_image->format <= G2D_FORMAT_YUV422_PLANAR)) {
+		cw = p_image->width >> 1;
+		ch = p_image->height;
+		cx = p_image->clip_rect.x >> 1;
+		cy = p_image->clip_rect.y;
+	}
+
+	else if ((p_image->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0)
+		 && (p_image->format <= G2D_FORMAT_YUV420_PLANAR)) {
+		cw = p_image->width >> 1;
+		ch = p_image->height >> 1;
+		cx = p_image->clip_rect.x >> 1;
+		cy = p_image->clip_rect.y >> 1;
+	}
+
+	else if ((p_image->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0)
+		 && (p_image->format <= G2D_FORMAT_YUV411_PLANAR)) {
+		cw = p_image->width >> 2;
+		ch = p_image->height;
+		cx = p_image->clip_rect.x >> 2;
+		cy = p_image->clip_rect.y;
+	}
+
+	else {
+		cw = 0;
+		ch = 0;
+		cx = 0;
+		cy = 0;
+	}
+	g2d_byte_cal(p_image->format, &ycnt, &ucnt, &vcnt);
+	pitch0 = cal_align(ycnt * p_image->width, p_image->align[0]);
+	p_reg->ovl_mem_pitch0 = pitch0;
+	pitch1 = cal_align(ucnt * cw, p_image->align[1]);
+	p_reg->ovl_mem_pitch1 = pitch1;
+	pitch2 = cal_align(vcnt * cw, p_image->align[2]);
+	p_reg->ovl_mem_pitch2 = pitch2;
+	addr0 =
+	    p_image->laddr[0] + ((__u64) p_image->haddr[0] << 32) +
+	    pitch0 * p_image->clip_rect.y + ycnt * p_image->clip_rect.x;
+	p_reg->ovl_mem_low_addr0 = addr0 & 0xffffffff;
+	addr1 =
+	    p_image->laddr[1] + ((__u64) p_image->haddr[1] << 32) + pitch1 * cy +
+	    ucnt * cx;
+	p_reg->ovl_mem_low_addr1 = addr1 & 0xffffffff;
+	addr2 =
+	    p_image->laddr[2] + ((__u64) p_image->haddr[2] << 32) + pitch2 * cy +
+	    vcnt * cx;
+	p_reg->ovl_mem_low_addr2 = addr2 & 0xffffffff;
+	tmp = ((addr0 >> 32) & 0xff) | ((addr1 >> 32) & 0xff) << 8 |
+	    ((addr2 >> 32) & 0xff) << 16;
+	p_reg->ovl_mem_high_addr.dwval = tmp;
+	if (p_image->bbuff == 0)
+		g2d_ovl_v_fc_set(p_ovl_v, p_image->color);
+	p_ovl_v->set_block_dirty(p_ovl_v, 0, 1);
+	ret = 0;
+OUT:
+	return ret;
+}
+
+__s32 g2d_vlayer_overlay_set(struct ovl_v_submodule *p_ovl_v, __u32 sel,
+					g2d_coor *coor,  __u32 w, __u32 h)
+{
+	__s32 ret = -1;
+	struct g2d_mixer_ovl_v_reg *p_reg = p_ovl_v->get_reg(p_ovl_v);
+
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->ovl_winsize.bits.width = (w - 1) & 0x1fff;
+	p_reg->ovl_winsize.bits.height = (h - 1) & 0x1fff;
+
+	p_reg->ovl_mem_coor.bits.lay_xcoor = coor->x;
+	p_reg->ovl_mem_coor.bits.lay_ycoor = coor->y;
+	ret = 0;
+OUT:
+	return ret;
+}
+static int ovl_v_rcq_setup(struct ovl_v_submodule *p_ovl_v, u8 __iomem *base,
+			   struct g2d_rcq_mem_info *p_rcq_info)
+{
+	u8 __iomem *reg_base = base + G2D_V0;
+	int ret = -1;
+
+	if (!p_ovl_v) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	p_ovl_v->reg_info->size = sizeof(struct g2d_mixer_ovl_v_reg);
+	p_ovl_v->reg_info->vir_addr = (u8 *)g2d_top_reg_memory_alloc(
+	    p_ovl_v->reg_info->size, (void *)&(p_ovl_v->reg_info->phy_addr),
+	    p_rcq_info);
+
+	if (!p_ovl_v->reg_info->vir_addr) {
+		G2D_ERR_MSG("Malloc writeback reg rcq memory fail!\n");
+		goto OUT;
+	}
+
+	p_ovl_v->reg_blks->vir_addr = p_ovl_v->reg_info->vir_addr;
+	p_ovl_v->reg_blks->phy_addr = p_ovl_v->reg_info->phy_addr;
+	p_ovl_v->reg_blks->size = p_ovl_v->reg_info->size;
+	p_ovl_v->reg_blks->reg_addr = reg_base;
+	ret = 0;
+
+OUT:
+	return ret;
+}
+
+static __u32 ovl_v_get_reg_block_num(struct ovl_v_submodule *p_ovl_v)
+{
+	if (p_ovl_v)
+		return p_ovl_v->reg_blk_num;
+	return 0;
+}
+
+static __s32 ovl_v_get_reg_block(struct ovl_v_submodule *p_ovl_v,
+			    struct g2d_reg_block **blks)
+{
+	int i = 0;
+	if (p_ovl_v) {
+		for (i = 0; i < p_ovl_v->reg_blk_num; ++i)
+			blks[i] = p_ovl_v->reg_blks + i;
+	}
+	return 0;
+}
+
+static struct g2d_mixer_ovl_v_reg *ovl_v_get_reg(struct ovl_v_submodule *p_ovl_v)
+{
+#if G2D_MIXER_RCQ_USED == 1
+	return (struct g2d_mixer_ovl_v_reg *)(p_ovl_v->reg_blks
+						   ->vir_addr);
+#else
+	return (struct g2d_mixer_ovl_v_reg *)(p_ovl_v->reg_blks
+						   ->reg_addr);
+#endif
+	return NULL;
+}
+
+static void ovl_v_set_block_dirty(struct ovl_v_submodule *p_ovl_v, __u32 blk_id, __u32 dirty)
+{
+#if G2D_MIXER_RCQ_USED == 1
+	if (p_ovl_v && p_ovl_v->reg_blks->rcq_hd)
+		p_ovl_v->reg_blks->rcq_hd->dirty.bits.dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#else
+
+	if (p_ovl_v)
+		p_ovl_v->reg_blks->dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#endif
+}
+
+
+static __u32 ovl_v_get_rcq_mem_size(struct ovl_v_submodule *p_ovl_v)
+{
+	return G2D_RCQ_BYTE_ALIGN(sizeof(struct g2d_mixer_ovl_v_reg));
+}
+
+static __s32 ovl_v_destory(struct ovl_v_submodule *p_ovl_v)
+{
+	if (p_ovl_v) {
+		kfree(p_ovl_v->reg_blks);
+		p_ovl_v->reg_blks = NULL;
+
+		kfree(p_ovl_v->reg_info);
+		p_ovl_v->reg_info = NULL;
+		kfree(p_ovl_v);
+	}
+
+	return 0;
+}
+
+struct ovl_v_submodule *
+g2d_ovl_v_submodule_setup(struct g2d_mixer_frame *p_frame)
+{
+	struct ovl_v_submodule *p_ovl_v = NULL;
+
+	p_ovl_v = kmalloc(sizeof(struct ovl_v_submodule), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_ovl_v) {
+		G2D_ERR_MSG("Kmalloc wb submodule fail!\n");
+		return NULL;
+	}
+
+	p_ovl_v->rcq_setup = ovl_v_rcq_setup;
+	p_ovl_v->reg_blk_num = VI_LAYER_NUMBER;
+	p_ovl_v->get_reg_block_num = ovl_v_get_reg_block_num;
+	p_ovl_v->get_reg_block = ovl_v_get_reg_block;
+	p_ovl_v->get_reg = ovl_v_get_reg;
+	p_ovl_v->set_block_dirty = ovl_v_set_block_dirty;
+	p_ovl_v->get_rcq_mem_size = ovl_v_get_rcq_mem_size;
+	p_ovl_v->destory = ovl_v_destory;
+
+	p_ovl_v->reg_blks =
+	    kmalloc(sizeof(struct g2d_reg_block) * p_ovl_v->reg_blk_num,
+		    GFP_KERNEL | __GFP_ZERO);
+	p_ovl_v->reg_info =
+	    kmalloc(sizeof(struct g2d_reg_mem_info), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_ovl_v->reg_blks || !p_ovl_v->reg_info) {
+		G2D_ERR_MSG("Kmalloc wb reg info fail!\n");
+		goto FREE_WB;
+	}
+
+
+	return p_ovl_v;
+FREE_WB:
+	kfree(p_ovl_v->reg_blks);
+	kfree(p_ovl_v->reg_info);
+	kfree(p_ovl_v);
+
+	return NULL;
+}
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.h
new file mode 100644
index 000000000..f46b89c6d
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_ovl_v.h
@@ -0,0 +1,50 @@
+/*
+ * g2d_ovl_v.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_OVL_H
+#define _G2D_OVL_H
+#include "g2d_rcq.h"
+#include "g2d_mixer_type.h"
+#include "g2d_mixer.h"
+
+struct g2d_mixer_frame;
+struct ovl_v_submodule {
+	struct g2d_reg_block *reg_blks;
+	__u32 reg_blk_num;
+	struct g2d_reg_mem_info *reg_info;
+	__s32 (*destory)(struct ovl_v_submodule *p_ovl_v);
+	__s32 (*apply)(struct ovl_v_submodule *p_ovl_v, g2d_image_enh *p_image);
+	__s32 (*rcq_setup)(struct ovl_v_submodule *p_ovl_v, u8 __iomem *base,
+			   struct g2d_rcq_mem_info *p_rcq_info);
+	__u32 (*get_reg_block_num)(struct ovl_v_submodule *p_ovl_v);
+	__u32 (*get_rcq_mem_size)(struct ovl_v_submodule *p_ovl_v);
+	__s32 (*get_reg_block)(struct ovl_v_submodule *p_ovl_v, struct g2d_reg_block **blks);
+	struct g2d_mixer_ovl_v_reg  *(*get_reg)(struct ovl_v_submodule *p_ovl_v);
+	void (*set_block_dirty)(struct ovl_v_submodule *p_ovl_v, __u32 blk_id, __u32 dirty);
+};
+__s32 g2d_ovl_v_fc_set(struct ovl_v_submodule *p_ovl_v, __u32 color_value);
+__s32 g2d_vlayer_set(struct ovl_v_submodule *p_ovl_v, __u32 sel,
+		     g2d_image_enh *p_image);
+
+__s32 g2d_vlayer_overlay_set(struct ovl_v_submodule *p_ovl_v, __u32 sel,
+					g2d_coor *coor,  __u32 w, __u32 h);
+struct ovl_v_submodule *
+g2d_ovl_v_submodule_setup(struct g2d_mixer_frame *p_frame);
+__s32 g2d_ovl_v_calc_coarse(struct ovl_v_submodule *p_ovl_v, __u32 format, __u32 inw,
+		      __u32 inh, __u32 outw, __u32 outh, __u32 *midw,
+		      __u32 *midh);
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.c
new file mode 100644
index 000000000..49f4bda57
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.c
@@ -0,0 +1,73 @@
+/*
+ * g2d_rcq/g2d_rcq.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "g2d_rcq.h"
+#include "g2d_driver_i.h"
+
+__s32 g2d_top_mem_pool_alloc(struct g2d_rcq_mem_info *p_rcq_info)
+{
+	int ret = 0;
+
+	p_rcq_info->rcq_byte_used =
+	    p_rcq_info->alloc_num * sizeof(*(p_rcq_info->vir_addr));
+	p_rcq_info->vir_addr = g2d_malloc(p_rcq_info->rcq_reg_mem_size,
+					  (__u32 *)&p_rcq_info->phy_addr);
+	if (!p_rcq_info->vir_addr)
+		ret = -1;
+
+	return ret;
+}
+
+void *g2d_top_reg_memory_alloc(__u32 size, void *phy_addr,
+			       struct g2d_rcq_mem_info *p_rcq_info)
+{
+	void *viraddr = NULL;
+	if (p_rcq_info->vir_addr) {
+
+		*(dma_addr_t *)phy_addr = (dma_addr_t)p_rcq_info->phy_addr +
+					  p_rcq_info->rcq_byte_used;
+
+		viraddr =
+		    (void *)p_rcq_info->vir_addr + p_rcq_info->rcq_byte_used;
+
+		p_rcq_info->rcq_byte_used += G2D_RCQ_BYTE_ALIGN(size);
+
+		if (p_rcq_info->rcq_byte_used > p_rcq_info->rcq_reg_mem_size) {
+			G2D_ERR_MSG("Malloc %d byte fail, out of total "
+				    "memory %d bytes, current used byte:%d\n",
+				    G2D_RCQ_BYTE_ALIGN(size),
+				    p_rcq_info->rcq_reg_mem_size,
+				    p_rcq_info->rcq_byte_used);
+			viraddr = NULL;
+			*(dma_addr_t *)phy_addr = (dma_addr_t)NULL;
+		}
+		return viraddr;
+	} else {
+		G2D_ERR_MSG("Null pointer!\n");
+		*(dma_addr_t *)phy_addr = (dma_addr_t)NULL;
+		return NULL;
+	}
+}
+
+void g2d_top_mem_pool_free(struct g2d_rcq_mem_info *p_rcq_info)
+{
+	if (p_rcq_info->vir_addr) {
+		g2d_free((void *)p_rcq_info->vir_addr,
+			 (void *)p_rcq_info->phy_addr,
+			 p_rcq_info->rcq_reg_mem_size);
+	}
+}
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.h
new file mode 100644
index 000000000..135ee6b68
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rcq.h
@@ -0,0 +1,96 @@
+/*
+ * g2d_rcq/g2d_rcq.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_RCQ_H
+#define _G2D_RCQ_H
+
+#include "g2d_bsp.h"
+
+/*32 byte align required by rcq*/
+#define G2D_RCQ_BYTE_ALIGN(x) (((x + (32 - 1)) >> 5) << 5)
+/* 2 align */
+#define G2D_RCQ_HEADER_ALIGN(x) (((x + 1) >> 1) << 1)
+
+
+#define G2D_MIXER_RCQ_USED 1
+
+union rcq_hd_dw0 {
+	__u32 dwval;
+	struct {
+		__u32 len:24;
+		__u32 high_addr:8;
+	} bits;
+};
+
+union rcq_hd_dirty {
+	__u32 dwval;
+	struct {
+		__u32 dirty:1;
+		__u32 res0:15;
+		__u32 n_header_len : 16; /*next frame header length*/
+	} bits;
+};
+
+struct g2d_rcq_head {
+	__u32 low_addr; /* 32 bytes align */
+	union rcq_hd_dw0 dw0;
+	union rcq_hd_dirty dirty;
+	__u32 reg_offset; /* offset_addr based on g2d_reg_base */
+};
+
+/*
+* @phy_addr: must be 32 bytes align, can not be accessed by cpu.
+* @vir_addr: for cpu access.
+* @size: unit: byte. must be 2 bytes align.
+* @reg_addr: reg base addr of this block.
+* @dirty: this block need be updated to hw reg if @dirty is true.
+* @rcq_hd: pointer to rcq head of this dma_reg block at rcq mode.
+* @block_id: unique id for current block
+*/
+struct g2d_reg_block {
+	u8 __iomem *phy_addr;
+	u8 *vir_addr;
+	__u32 size;
+	u8 __iomem *reg_addr;
+	__u32 dirty;
+	struct g2d_rcq_head *rcq_hd;
+	__u32 block_id;
+};
+
+struct g2d_reg_mem_info {
+	u8 __iomem *phy_addr; /* it is non-null at rcq mode */
+	u8 *vir_addr;
+	__u32 size;
+};
+
+struct g2d_rcq_mem_info {
+	u8 __iomem *phy_addr;
+	struct g2d_rcq_head *vir_addr;
+	struct g2d_reg_block **reg_blk;
+	__u32 alloc_num;
+	__u32 cur_num;
+	__u32 block_num_per_frame;
+	__u32 alloc_num_per_frame;
+	__u32 rcq_header_len;
+	__u32 rcq_byte_used;
+	__u32 rcq_reg_mem_size;
+};
+__s32 g2d_top_mem_pool_alloc(struct g2d_rcq_mem_info *p_rcq_info);
+void *g2d_top_reg_memory_alloc(__u32 size, void *phy_addr,
+			       struct g2d_rcq_mem_info *p_rcq_info);
+void g2d_top_mem_pool_free(struct g2d_rcq_mem_info *p_rcq_info);
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.c
new file mode 100644
index 000000000..4d2c9a785
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.c
@@ -0,0 +1,605 @@
+/*
+ * drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "g2d_rotate.h"
+#include "g2d_top.h"
+#include "g2d_driver_i.h"
+
+/* Rotate register */
+#define G2D_ROT        (0x28000)
+#define ROT_CTL            (0x00 + G2D_ROT)
+#define ROT_INT            (0x04 + G2D_ROT)
+#define ROT_TIMEOUT        (0x08 + G2D_ROT)
+#define ROT_IFMT           (0x20 + G2D_ROT)
+#define ROT_ISIZE          (0x24 + G2D_ROT)
+#define ROT_IPITCH0        (0x30 + G2D_ROT)
+#define ROT_IPITCH1        (0x34 + G2D_ROT)
+#define ROT_IPITCH2        (0x38 + G2D_ROT)
+#define ROT_ILADD0         (0x40 + G2D_ROT)
+#define ROT_IHADD0         (0x44 + G2D_ROT)
+#define ROT_ILADD1         (0x48 + G2D_ROT)
+#define ROT_IHADD1         (0x4C + G2D_ROT)
+#define ROT_ILADD2         (0x50 + G2D_ROT)
+#define ROT_IHADD2         (0x54 + G2D_ROT)
+#define ROT_OSIZE          (0x84 + G2D_ROT)
+#define ROT_OPITCH0        (0x90 + G2D_ROT)
+#define ROT_OPITCH1        (0x94 + G2D_ROT)
+#define ROT_OPITCH2        (0x98 + G2D_ROT)
+#define ROT_OLADD0         (0xA0 + G2D_ROT)
+#define ROT_OHADD0         (0xA4 + G2D_ROT)
+#define ROT_OLADD1         (0xA8 + G2D_ROT)
+#define ROT_OHADD1         (0xAC + G2D_ROT)
+#define ROT_OLADD2         (0xB0 + G2D_ROT)
+#define ROT_OHADD2         (0xB4 + G2D_ROT)
+#define LBC_ENC_CTL	   (0xC8 + G2D_ROT)
+#define LBC_CTL		   (0xCC + G2D_ROT)
+#define LBC_DEC_CTL	   (0xD0 + G2D_ROT)
+#define G2D_AHB_RESET  (0x08)
+
+static unsigned long base_addr;
+/* #define write_wvalue(addr, data) m_usbwordwrite32(  addr, data ) */
+/* #define write_wvalue(addr, v) put_wvalue(addr, v) */
+/* #define read_wvalue(addr) get_wvalue(addr) */
+
+/* byte input */
+#define get_bvalue(n)	(*((volatile __u8 *)(n)))
+/* byte output */
+#define put_bvalue(n, c)	(*((volatile __u8 *)(n)) = (c))
+/* half word input */
+#define get_hvalue(n)	(*((volatile __u16 *)(n)))
+/* half word output */
+#define put_hvalue(n, c)	(*((volatile __u16 *)(n)) = (c))
+/* word input */
+#define get_wvalue(n)	(*((volatile __u32 *)(n)))
+/* word output */
+#define put_wvalue(n, c)	(*((volatile __u32 *)(n)) = (c))
+
+/* byte input */
+#define read_bvalue(offset)		get_bvalue(base_addr + offset)
+/* byte output */
+#define write_bvalue(offset, value)	put_bvalue(base_addr + offset, value)
+/* half word input */
+#define read_hvalue(offset)		get_hvalue(base_addr + offset)
+/* half word output */
+#define write_hvalue(offset, value)	put_hvalue(base_addr + offset, value)
+/* word input */
+#define read_wvalue(offset)		get_wvalue(base_addr + offset)
+/* word output */
+#define write_wvalue(offset, value)	put_wvalue(base_addr + offset, value)
+
+void g2d_rot_set_base(unsigned long base)
+{
+	base_addr = base;
+}
+
+/**
+ * G2D IRQ query funct
+ * if the mission finish IRQ flag was set to 1, then clear the flag
+ * and return 1
+ * if the IRQ was set to 0, then return 0
+ */
+__s32 g2d_rot_irq_query(void)
+{
+	__u32 tmp;
+
+	tmp = read_wvalue(ROT_INT);
+	if (tmp & 0x1) {
+		write_wvalue(ROT_INT, tmp);
+		return 1;
+	}
+	return 0;
+}
+
+__s32 g2d_rotate_set_para(g2d_image_enh *src, g2d_image_enh *dst, __u32 flag)
+{
+	__u32 tmp;
+	__u32 ch, cw, cy, cx;
+	__u32 ycnt, ucnt, vcnt;
+	__s32 ret = -1;
+	__u32 pitch0, pitch1, pitch2;
+	__u64 addr0, addr1, addr2;
+	struct dmabuf_item *src_item = NULL;
+	struct dmabuf_item *dst_item = NULL;
+
+	if (!dst || g2d_image_check(dst))
+		goto OUT;
+	if (!src || g2d_image_check(src))
+		goto OUT;
+
+	if (!src->use_phy_addr || !dst->use_phy_addr) {
+		src_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (src_item == NULL) {
+			G2D_ERR_MSG("malloc memory of size %u fail!\n",
+				    (unsigned int)sizeof(struct dmabuf_item));
+			goto OUT;
+		}
+		dst_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (dst_item == NULL) {
+			G2D_ERR_MSG("malloc memory of size %u fail!\n",
+				    (unsigned int)sizeof(struct dmabuf_item));
+			goto FREE_SRC;
+		}
+		ret = g2d_dma_map(src->fd, src_item);
+		if (ret != 0) {
+			G2D_ERR_MSG("map src_item fail!\n");
+			goto FREE_DST;
+		}
+		g2d_set_info(src, src_item);
+
+		ret = g2d_dma_map(dst->fd, dst_item);
+		if (ret != 0) {
+			G2D_ERR_MSG("map dst_item fail!\n");
+			goto SRC_DMA_UNMAP;
+		}
+		g2d_set_info(dst, dst_item);
+	}
+
+	tmp = 1;
+	if (flag & G2D_ROT_H)
+		tmp |= 0x1 << 7;
+	if (flag & G2D_ROT_V)
+		tmp |= 0x1 << 6;
+	if ((flag & 0xf00) == G2D_ROT_90)
+		tmp |= 0x1 << 4;
+	if ((flag & 0xf00) == G2D_ROT_180)
+		tmp |= 0x2 << 4;
+	if ((flag & 0xf00) == G2D_ROT_270)
+		tmp |= 0x3 << 4;
+	if ((flag & 0xf00) == G2D_ROT_0)
+		tmp |= 0x0 << 4;
+
+	write_wvalue(ROT_CTL, tmp);
+	write_wvalue(ROT_IFMT, src->format & 0x3F);
+	write_wvalue(ROT_ISIZE, ((((src->clip_rect.h - 1) & 0x1fff) << 16)) |
+				    ((src->clip_rect.w - 1) & 0x1fff));
+
+	if ((src->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0) &&
+	    (src->format <= G2D_FORMAT_YUV422_PLANAR)) {
+		cw = src->width >> 1;
+		ch = src->height;
+		cx = src->clip_rect.x >> 1;
+		cy = src->clip_rect.y;
+	}
+
+	else if ((src->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0) &&
+		 (src->format <= G2D_FORMAT_YUV420_PLANAR)) {
+		cw = src->width >> 1;
+		ch = src->height >> 1;
+		cx = src->clip_rect.x >> 1;
+		cy = src->clip_rect.y >> 1;
+	}
+
+	else if ((src->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0) &&
+		 (src->format <= G2D_FORMAT_YUV411_PLANAR)) {
+		cw = src->width >> 2;
+		ch = src->height;
+		cx = src->clip_rect.x >> 2;
+		cy = src->clip_rect.y;
+	}
+
+	else {
+		cw = 0;
+		ch = 0;
+		cx = 0;
+		cy = 0;
+	}
+
+	g2d_byte_cal(src->format, &ycnt, &ucnt, &vcnt);
+	pitch0 = cal_align(ycnt * src->width, src->align[0]);
+	write_wvalue(ROT_IPITCH0, pitch0);
+	pitch1 = cal_align(ucnt * cw, src->align[1]);
+	write_wvalue(ROT_IPITCH1, pitch1);
+	pitch2 = cal_align(vcnt * cw, src->align[2]);
+	write_wvalue(ROT_IPITCH2, pitch2);
+
+	addr0 = src->laddr[0] + ((__u64)src->haddr[0] << 32) +
+		pitch0 * src->clip_rect.y + ycnt * src->clip_rect.x;
+	write_wvalue(ROT_ILADD0, addr0 & 0xffffffff);
+	write_wvalue(ROT_IHADD0, (addr0 >> 32) & 0xff);
+	addr1 = src->laddr[1] + ((__u64)src->haddr[1] << 32) + pitch1 * cy +
+		ucnt * cx;
+	write_wvalue(ROT_ILADD1, addr1 & 0xffffffff);
+	write_wvalue(ROT_IHADD1, (addr1 >> 32) & 0xff);
+	addr2 = src->laddr[2] + ((__u64)src->haddr[2] << 32) + pitch2 * cy +
+		vcnt * cx;
+	write_wvalue(ROT_ILADD2, addr2 & 0xffffffff);
+	write_wvalue(ROT_IHADD2, (addr2 >> 32) & 0xff);
+
+	if (((flag & 0xf00) == G2D_ROT_90) | ((flag & 0xf00) == G2D_ROT_270)) {
+		dst->clip_rect.w = src->clip_rect.h;
+		dst->clip_rect.h = src->clip_rect.w;
+	}
+
+	else {
+		dst->clip_rect.w = src->clip_rect.w;
+		dst->clip_rect.h = src->clip_rect.h;
+	}
+	write_wvalue(ROT_OSIZE, ((((dst->clip_rect.h - 1) & 0x1fff) << 16)) |
+				    ((dst->clip_rect.w - 1) & 0x1fff));
+	/* YUV output fmt only support 420 */
+	if (src->format == G2D_FORMAT_YUV422UVC_V1U1V0U0)
+		dst->format = G2D_FORMAT_YUV420UVC_V1U1V0U0;
+	else if (src->format == G2D_FORMAT_YUV422UVC_U1V1U0V0)
+		dst->format = G2D_FORMAT_YUV420UVC_U1V1U0V0;
+	else if (src->format == G2D_FORMAT_YUV422_PLANAR)
+		dst->format = G2D_FORMAT_YUV420_PLANAR;
+	else
+		dst->format = src->format;
+
+	if ((dst->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0) &&
+	    (dst->format <= G2D_FORMAT_YUV422_PLANAR)) {
+		cw = dst->width >> 1;
+		ch = dst->height;
+		cx = dst->clip_rect.x >> 1;
+		cy = dst->clip_rect.y;
+	}
+
+	else if ((dst->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0) &&
+		 (dst->format <= G2D_FORMAT_YUV420_PLANAR)) {
+		cw = dst->width >> 1;
+		ch = dst->height >> 1;
+		cx = dst->clip_rect.x >> 1;
+		cy = dst->clip_rect.y >> 1;
+	}
+
+	else if ((dst->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0) &&
+		 (dst->format <= G2D_FORMAT_YUV411_PLANAR)) {
+		cw = dst->width >> 2;
+		ch = dst->height;
+		cx = dst->clip_rect.x >> 2;
+		cy = dst->clip_rect.y;
+	}
+
+	else {
+		cw = 0;
+		ch = 0;
+		cx = 0;
+		cy = 0;
+	}
+
+	g2d_byte_cal(dst->format, &ycnt, &ucnt, &vcnt);
+
+	pitch0 = cal_align(ycnt * dst->width, dst->align[0]);
+	write_wvalue(ROT_OPITCH0, pitch0);
+	pitch1 = cal_align(ucnt * cw, dst->align[1]);
+	write_wvalue(ROT_OPITCH1, pitch1);
+	pitch2 = cal_align(vcnt * cw, dst->align[2]);
+	write_wvalue(ROT_OPITCH2, pitch2);
+
+	addr0 = dst->laddr[0] + ((__u64)dst->haddr[0] << 32) +
+		pitch0 * dst->clip_rect.y + ycnt * dst->clip_rect.x;
+	write_wvalue(ROT_OLADD0, addr0 & 0xffffffff);
+	write_wvalue(ROT_OHADD0, (addr0 >> 32) & 0xff);
+	addr1 = dst->laddr[1] + ((__u64)dst->haddr[1] << 32) + pitch1 * cy +
+		ucnt * cx;
+	write_wvalue(ROT_OLADD1, addr1 & 0xffffffff);
+	write_wvalue(ROT_OHADD1, (addr1 >> 32) & 0xff);
+	addr2 = dst->laddr[2] + ((__u64)dst->haddr[2] << 32) + pitch2 * cy +
+		vcnt * cx;
+	write_wvalue(ROT_OLADD2, addr2 & 0xffffffff);
+	write_wvalue(ROT_OHADD2, (addr2 >> 32) & 0xff);
+
+	/* start the module */
+	write_wvalue(ROT_INT, 0x10000);
+	tmp = read_wvalue(ROT_CTL);
+	tmp |= (0x1 << 31);
+	write_wvalue(ROT_CTL, tmp);
+
+	ret = g2d_wait_cmd_finish(WAIT_CMD_TIME_MS);
+
+	if (!src->use_phy_addr || !dst->use_phy_addr)
+		g2d_dma_unmap(dst_item);
+SRC_DMA_UNMAP:
+	if (!src->use_phy_addr || !dst->use_phy_addr)
+		g2d_dma_unmap(src_item);
+FREE_DST:
+	kfree(dst_item);
+FREE_SRC:
+	kfree(src_item);
+OUT:
+	return ret;
+}
+
+__s32 g2d_lbc_calc_ctrl(u32 flag, u32 frm_width, u32 frm_height,
+			u32 cmp_ratio, u32 enc_is_lossy, u32 dec_is_lossy)
+{
+	u32 tmp = 0;
+	u32 seg_width = 16, seg_height = 4;
+	u32 bit_depth = 8;
+	u32 enc_c_ratio = 333;
+	u32 ALIGN = 128;
+	u32 seg_tar_bits, seg_tar_bits_y, seg_tar_bits_c, dec_segline_tar_bits, enc_segline_tar_bits;
+	u32 y_mode_bits, c_mode_bits, y_data_bits, c_data_bits;
+
+	if (enc_is_lossy) {
+		seg_tar_bits = ((seg_width * seg_height * bit_depth * cmp_ratio * 3 / 2000) / ALIGN) * ALIGN;
+		seg_tar_bits_y = seg_tar_bits * (1024 - enc_c_ratio) / 1024;
+		seg_tar_bits_c = seg_tar_bits - seg_tar_bits_y;
+		dec_segline_tar_bits = ((frm_width + seg_width - 1) / seg_width) * seg_tar_bits;
+		if (((flag & 0xf00) == G2D_ROT_90) || ((flag & 0xf00) == G2D_ROT_270))
+			enc_segline_tar_bits = ((frm_height + seg_width - 1) / seg_width) * seg_tar_bits;
+		else
+			enc_segline_tar_bits = dec_segline_tar_bits;
+	} else {
+		y_mode_bits = seg_width / 8 * (3 * 2 + 2);
+		c_mode_bits = 2 * (seg_width / 2 / 8 * 2);
+		y_data_bits = seg_width * seg_height * bit_depth;
+		c_data_bits = seg_width * seg_height * bit_depth / 2 + 2 * (seg_width / 2 / 8) * 4;
+		seg_tar_bits = (y_data_bits + c_data_bits + y_mode_bits + c_mode_bits + ALIGN - 1) / ALIGN * ALIGN;
+		seg_tar_bits_y = seg_tar_bits;
+		seg_tar_bits_c = 0;
+		dec_segline_tar_bits = ((frm_width + seg_width - 1) / seg_width) * seg_tar_bits;
+		if (((flag & 0xf00) == G2D_ROT_90) || ((flag & 0xf00) == G2D_ROT_270))
+			enc_segline_tar_bits = ((frm_height + seg_width - 1) / seg_width) * seg_tar_bits;
+		else
+			enc_segline_tar_bits = dec_segline_tar_bits;
+	}
+	tmp |= (enc_is_lossy << 31);
+	/*tmp |= (0x1 << 30);*///fix me
+	tmp |= (0x1 << 29);/*only 1 frame not care use even */
+	tmp |= ((enc_c_ratio & 0x3ff) << 19);
+	tmp |= ((enc_segline_tar_bits & 0x1ffff) << 2);
+	tmp |= (0x1 << 1);
+	write_wvalue(LBC_ENC_CTL, tmp);
+
+	tmp = read_wvalue(LBC_CTL);
+	tmp |= ((seg_tar_bits_y & 0x7ff) << 21);
+	tmp |= ((seg_tar_bits_c & 0x7ff) << 10);
+	write_wvalue(LBC_CTL, tmp);
+
+	tmp = 0;
+	tmp |= ((dec_segline_tar_bits & 0x1ffff) << 2);
+	tmp |= (dec_is_lossy << 31);
+	write_wvalue(LBC_DEC_CTL, tmp);
+
+	return 0;
+}
+__s32 g2d_lbc_rot_set_para(g2d_lbc_rot *para)
+{
+	__u32 tmp = 0;
+	__u32 lbc = 0;
+	__u32 ch, cw, cy, cx;
+	__u32 ycnt, ucnt, vcnt;
+	__s32 ret = -1;
+	__u32 pitch0, pitch1, pitch2;
+	__u64 addr0, addr1, addr2;
+	struct dmabuf_item *src_item = NULL;
+	struct dmabuf_item *dst_item = NULL;
+	/* lbc para */
+	u32 frm_width = 0, frm_height = 0;
+	u32 cmp_ratio = 500;
+	u32 enc_is_lossy = 1, dec_is_lossy = 1;
+
+	__u32 flag = para->blt.flag_h;
+	g2d_image_enh *src = &para->blt.src_image_h;
+	g2d_image_enh *dst = &para->blt.dst_image_h;
+
+	if (!dst || g2d_image_check(dst))
+		goto OUT;
+	if (!src || g2d_image_check(src))
+		goto OUT;
+
+	if ((src->format != G2D_FORMAT_YUV420_PLANAR) ||
+			(dst->format != G2D_FORMAT_YUV420_PLANAR)) {
+		G2D_ERR_MSG("LBC only support YUV420 plannar fmt!\n");
+		goto OUT;
+	}
+
+	if (((flag & 0xf00) == G2D_ROT_180) || ((flag & 0xf00) == G2D_ROT_V)) {
+		G2D_ERR_MSG("LBC not support 180 and V flip!\n");
+		goto OUT;
+	}
+
+	if (!src->use_phy_addr || !dst->use_phy_addr) {
+		src_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (src_item == NULL) {
+			G2D_ERR_MSG("malloc memory of size %u fail!\n",
+				    (unsigned int)sizeof(struct dmabuf_item));
+			goto OUT;
+		}
+		dst_item = kmalloc(sizeof(struct dmabuf_item),
+				   GFP_KERNEL | __GFP_ZERO);
+		if (dst_item == NULL) {
+			G2D_ERR_MSG("malloc memory of size %u fail!\n",
+				    (unsigned int)sizeof(struct dmabuf_item));
+			goto FREE_SRC;
+		}
+		ret = g2d_dma_map(src->fd, src_item);
+		if (ret != 0) {
+			G2D_ERR_MSG("map src_item fail!\n");
+			goto FREE_DST;
+		}
+		g2d_set_info(src, src_item);
+
+		ret = g2d_dma_map(dst->fd, dst_item);
+		if (ret != 0) {
+			G2D_ERR_MSG("map dst_item fail!\n");
+			goto SRC_DMA_UNMAP;
+		}
+		g2d_set_info(dst, dst_item);
+	}
+
+	/* rotate use same format */
+	dst->format = src->format;
+
+	tmp = 1;
+	write_wvalue(ROT_CTL, tmp);
+
+	if ((flag & 0xf00) == G2D_ROT_0)
+		lbc |= 0x0 << 7;
+	if ((flag & 0xf00) == G2D_ROT_90)
+		lbc |= 0x1 << 7;
+	if ((flag & 0xf00) == G2D_ROT_270)
+		lbc |= 0x2 << 7;
+	if (flag & G2D_ROT_H)
+		lbc |= 0x3 << 7;
+	write_wvalue(LBC_CTL, lbc);
+
+	write_wvalue(ROT_IFMT, src->format & 0x3F);
+	write_wvalue(ROT_ISIZE, ((((src->clip_rect.h - 1) & 0x1fff) << 16)) |
+				    ((src->clip_rect.w - 1) & 0x1fff));
+
+	if ((src->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0) &&
+	    (src->format <= G2D_FORMAT_YUV422_PLANAR)) {
+		cw = src->width >> 1;
+		ch = src->height;
+		cx = src->clip_rect.x >> 1;
+		cy = src->clip_rect.y;
+	}
+
+	else if ((src->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0) &&
+		 (src->format <= G2D_FORMAT_YUV420_PLANAR)) {
+		cw = src->width >> 1;
+		ch = src->height >> 1;
+		cx = src->clip_rect.x >> 1;
+		cy = src->clip_rect.y >> 1;
+	}
+
+	else if ((src->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0) &&
+		 (src->format <= G2D_FORMAT_YUV411_PLANAR)) {
+		cw = src->width >> 2;
+		ch = src->height;
+		cx = src->clip_rect.x >> 2;
+		cy = src->clip_rect.y;
+	}
+
+	else {
+		cw = 0;
+		ch = 0;
+		cx = 0;
+		cy = 0;
+	}
+
+	g2d_byte_cal(src->format, &ycnt, &ucnt, &vcnt);
+	pitch0 = cal_align(ycnt * src->width, src->align[0]);
+	write_wvalue(ROT_IPITCH0, pitch0);
+	pitch1 = cal_align(ucnt * cw, src->align[1]);
+	write_wvalue(ROT_IPITCH1, pitch1);
+	pitch2 = cal_align(vcnt * cw, src->align[2]);
+	write_wvalue(ROT_IPITCH2, pitch2);
+
+	addr0 = src->laddr[0] + ((__u64)src->haddr[0] << 32) +
+		pitch0 * src->clip_rect.y + ycnt * src->clip_rect.x;
+	write_wvalue(ROT_ILADD0, addr0 & 0xffffffff);
+	write_wvalue(ROT_IHADD0, (addr0 >> 32) & 0xff);
+	addr1 = src->laddr[1] + ((__u64)src->haddr[1] << 32) + pitch1 * cy +
+		ucnt * cx;
+	write_wvalue(ROT_ILADD1, addr1 & 0xffffffff);
+	write_wvalue(ROT_IHADD1, (addr1 >> 32) & 0xff);
+	addr2 = src->laddr[2] + ((__u64)src->haddr[2] << 32) + pitch2 * cy +
+		vcnt * cx;
+	write_wvalue(ROT_ILADD2, addr2 & 0xffffffff);
+	write_wvalue(ROT_IHADD2, (addr2 >> 32) & 0xff);
+
+	if (((flag & 0xf00) == G2D_ROT_90) || ((flag & 0xf00) == G2D_ROT_270)) {
+		dst->clip_rect.w = src->clip_rect.h;
+		dst->clip_rect.h = src->clip_rect.w;
+	}
+
+	else {
+		dst->clip_rect.w = src->clip_rect.w;
+		dst->clip_rect.h = src->clip_rect.h;
+	}
+	write_wvalue(ROT_OSIZE, ((((dst->clip_rect.h - 1) & 0x1fff) << 16)) |
+				    ((dst->clip_rect.w - 1) & 0x1fff));
+
+
+	if ((dst->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0) &&
+	    (dst->format <= G2D_FORMAT_YUV422_PLANAR)) {
+		cw = dst->width >> 1;
+		ch = dst->height;
+		cx = dst->clip_rect.x >> 1;
+		cy = dst->clip_rect.y;
+	}
+
+	else if ((dst->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0) &&
+		 (dst->format <= G2D_FORMAT_YUV420_PLANAR)) {
+		cw = dst->width >> 1;
+		ch = dst->height >> 1;
+		cx = dst->clip_rect.x >> 1;
+		cy = dst->clip_rect.y >> 1;
+	}
+
+	else if ((dst->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0) &&
+		 (dst->format <= G2D_FORMAT_YUV411_PLANAR)) {
+		cw = dst->width >> 2;
+		ch = dst->height;
+		cx = dst->clip_rect.x >> 2;
+		cy = dst->clip_rect.y;
+	}
+
+	else {
+		cw = 0;
+		ch = 0;
+		cx = 0;
+		cy = 0;
+	}
+
+	g2d_byte_cal(dst->format, &ycnt, &ucnt, &vcnt);
+
+	pitch0 = cal_align(ycnt * dst->width, dst->align[0]);
+	write_wvalue(ROT_OPITCH0, pitch0);
+	pitch1 = cal_align(ucnt * cw, dst->align[1]);
+	write_wvalue(ROT_OPITCH1, pitch1);
+	pitch2 = cal_align(vcnt * cw, dst->align[2]);
+	write_wvalue(ROT_OPITCH2, pitch2);
+
+	addr0 = dst->laddr[0] + ((__u64)dst->haddr[0] << 32) +
+		pitch0 * dst->clip_rect.y + ycnt * dst->clip_rect.x;
+	write_wvalue(ROT_OLADD0, addr0 & 0xffffffff);
+	write_wvalue(ROT_OHADD0, (addr0 >> 32) & 0xff);
+	addr1 = dst->laddr[1] + ((__u64)dst->haddr[1] << 32) + pitch1 * cy +
+		ucnt * cx;
+	write_wvalue(ROT_OLADD1, addr1 & 0xffffffff);
+	write_wvalue(ROT_OHADD1, (addr1 >> 32) & 0xff);
+	addr2 = dst->laddr[2] + ((__u64)dst->haddr[2] << 32) + pitch2 * cy +
+		vcnt * cx;
+	write_wvalue(ROT_OLADD2, addr2 & 0xffffffff);
+	write_wvalue(ROT_OHADD2, (addr2 >> 32) & 0xff);
+
+
+	/* lbc */
+
+	frm_width = src->width;
+	frm_height = src->height;
+	cmp_ratio = para->lbc_cmp_ratio;
+	enc_is_lossy = para->enc_is_lossy;
+	dec_is_lossy = para->dec_is_lossy;
+	g2d_lbc_calc_ctrl(flag, frm_width, frm_height, cmp_ratio, enc_is_lossy, dec_is_lossy);
+
+	/* start the module */
+	write_wvalue(ROT_INT, 0x10000);
+	tmp = read_wvalue(ROT_CTL);
+	tmp |= (0x1 << 31);
+	write_wvalue(ROT_CTL, tmp);
+
+	ret = g2d_wait_cmd_finish(WAIT_CMD_TIME_MS);
+
+	if (!src->use_phy_addr || !dst->use_phy_addr)
+		g2d_dma_unmap(dst_item);
+SRC_DMA_UNMAP:
+	if (!src->use_phy_addr || !dst->use_phy_addr)
+		g2d_dma_unmap(src_item);
+FREE_DST:
+	kfree(dst_item);
+FREE_SRC:
+	kfree(src_item);
+OUT:
+	return ret;
+}
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.h
new file mode 100644
index 000000000..66ad8ba94
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.h
@@ -0,0 +1,28 @@
+/*
+ * drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_ROTATE_H
+#define _G2D_ROTATE_H
+#include <linux/types.h>
+#include <linux/g2d_driver.h>
+
+__s32 g2d_rotate_set_para(g2d_image_enh *src, g2d_image_enh *dst, __u32 flag);
+__s32 g2d_lbc_rot_set_para(g2d_lbc_rot *para);
+void g2d_rot_set_base(unsigned long base);
+__s32 g2d_rot_irq_query(void);
+
+#endif /*End of file*/
+
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate_type.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate_type.h
new file mode 100644
index 000000000..4280fb23b
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_rotate_type.h
@@ -0,0 +1,139 @@
+/*
+ * g2d_rotate_type/g2d_rotate_type.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_ROTATE_TYPE_H
+#define _G2D_ROTATE_TYPE_H
+
+union g2d_rot_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int mode_sel:2;
+		unsigned int res0:2;
+		unsigned int degreee:2;
+		unsigned int vflip_en:1;
+		unsigned int hflip_en:1;
+		unsigned int res1:22;
+		unsigned int bist_en:1;
+		unsigned int start:1;
+	} bits;
+};
+
+union g2d_rot_interrupt {
+	unsigned int dwval;
+	struct {
+		unsigned int rot_irq:1;
+		unsigned int res0:15;
+		unsigned int finish_irq:1;
+		unsigned int res1:15;
+	} bits;
+};
+
+union g2d_rot_time_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int timeout_st:1;
+		unsigned int res0:29;
+		unsigned int timeout_rst_en:1;
+		unsigned int timeout_rst:1;
+	} bits;
+};
+
+union g2d_rot_in_fmt {
+	unsigned int dwval;
+	struct {
+		unsigned int fmt:6;
+		unsigned int res0:26;
+	} bits;
+};
+
+union g2d_rot_size {
+	unsigned int dwval;
+	struct {
+		unsigned int width:13;
+		unsigned int res0:3;
+		unsigned int height:13;
+		unsigned int res1:3;
+	} bits;
+};
+
+union g2d_rot_rand_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int rand_en:1;
+		unsigned int res0:3;
+		unsigned int mode:2;
+		unsigned int res1:2;
+		unsigned int seed:24;
+	} bits;
+};
+
+union g2d_rot_rand_clk {
+	unsigned int dwval;
+	struct {
+		unsigned int neg_num:16;
+		unsigned int pos_num:16;
+	};
+};
+
+
+struct g2d_rot_reg {
+	/*0x00*/
+	union g2d_rot_ctrl rot_ctrl;
+	union g2d_rot_interrupt rot_int;
+	union g2d_rot_time_ctrl time_ctrl;
+	unsigned int res0[5];
+	/*0x20*/
+	union g2d_rot_in_fmt infmt;
+	union g2d_rot_size insize;
+	unsigned int res1[2];
+	/*0x30*/
+	unsigned int pitch0;
+	unsigned int pitch1;
+	unsigned int pitch2;
+	unsigned int res2;
+	/*0x40*/
+	unsigned int laddr0;
+	unsigned int haddr0;
+	unsigned int laddr1;
+	unsigned int haddr1;
+	/*0x50*/
+	unsigned int laddr2;
+	unsigned int haddr2;
+	unsigned int res3[11];
+	/*0x84*/
+	union g2d_rot_size outsize;
+	unsigned int res4[2];
+	/*0x90*/
+	unsigned int out_pitch0;
+	unsigned int out_pitch1;
+	unsigned int out_pitch2;
+	unsigned int res5;
+	/*0xa0*/
+	unsigned int out_laddr0;
+	unsigned int out_haddr0;
+	unsigned int out_laddr1;
+	unsigned int out_haddr1;
+	/*0xb0*/
+	unsigned int out_laddr2;
+	unsigned int out_haddr2;
+	union g2d_rot_rand_ctrl rand_in_ctrl;
+	union g2d_rot_rand_clk rand_in_clk;
+	/*0xc0*/
+	union g2d_rot_rand_ctrl rand_out_ctrl;
+	union g2d_rot_rand_clk rand_out_clk;
+};
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.c
new file mode 100644
index 000000000..0d330d51e
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.c
@@ -0,0 +1,538 @@
+/*
+ * g2d_scal.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "g2d_scal.h"
+
+static __s32 linearcoefftab32[32] = {
+	0x00004000, 0x00023e00, 0x00043c00, 0x00063a00, 0x00083800,
+	0x000a3600, 0x000c3400, 0x000e3200, 0x00103000, 0x00122e00,
+	0x00142c00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400,
+	0x001e2200, 0x00202000, 0x00221e00, 0x00241c00, 0x00261a00,
+	0x00281800, 0x002a1600, 0x002c1400, 0x002e1200, 0x00301000,
+	0x00320e00, 0x00340c00, 0x00360a00, 0x00380800, 0x003a0600,
+	0x003c0400, 0x003e0200, };
+
+static __s32 lan2coefftab32_full[512] = {
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc,
+	0x000a3bfb, 0xff0d39fb, 0xff0f37fb, 0xff1136fa, 0xfe1433fb,
+	0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,
+	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd,
+	0xfb3116fe, 0xfb3314fe, 0xfa3611ff, 0xfb370fff, 0xfb390dff,
+	0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400, 0xfe3f0300,
+	0xff400100,
+	/* counter = 1 */
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc,
+	0xff083dfc, 0x000a3bfb, 0xff0d39fb, 0xff0f37fb, 0xff1136fa,
+	0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb,
+	0xfc2127fc, 0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd,
+	0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff, 0xfb370fff,
+	0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400,
+	0xfe3f0300, 0xff400100,
+	/* counter = 2 */
+	0xff053804, 0xff063803, 0xff083801, 0xff093701, 0xff0a3700,
+	0xff0c3500, 0xff0e34ff, 0xff1033fe, 0xff1232fd, 0xfe1431fd,
+	0xfe162ffd, 0xfe182dfd, 0xfd1b2cfc, 0xfd1d2afc, 0xfd1f28fc,
+	0xfd2126fc, 0xfd2323fd, 0xfc2621fd, 0xfc281ffd, 0xfc2a1dfd,
+	0xfc2c1bfd, 0xfd2d18fe, 0xfd2f16fe, 0xfd3114fe, 0xfd3212ff,
+	0xfe3310ff, 0xff340eff, 0x00350cff, 0x00360a00, 0x01360900,
+	0x02370700, 0x03370600,
+	/* counter = 3 */
+	0xff083207, 0xff093206, 0xff0a3205, 0xff0c3203, 0xff0d3103,
+	0xff0e3102, 0xfe113001, 0xfe132f00, 0xfe142e00, 0xfe162dff,
+	0xfe182bff, 0xfe192aff, 0xfe1b29fe, 0xfe1d27fe, 0xfe1f25fe,
+	0xfd2124fe, 0xfe2222fe, 0xfe2421fd, 0xfe251ffe, 0xfe271dfe,
+	0xfe291bfe, 0xff2a19fe, 0xff2b18fe, 0xff2d16fe, 0x002e14fe,
+	0x002f12ff, 0x013010ff, 0x02300fff, 0x03310dff, 0x04310cff,
+	0x05310a00, 0x06310900,
+	/* counter = 4 */
+	0xff0a2e09, 0xff0b2e08, 0xff0c2e07, 0xff0e2d06, 0xff0f2d05,
+	0xff102d04, 0xff122c03, 0xfe142c02, 0xfe152b02, 0xfe172a01,
+	0xfe182901, 0xfe1a2800, 0xfe1b2700, 0xfe1d2500, 0xff1e24ff,
+	0xfe2023ff, 0xff2121ff, 0xff2320fe, 0xff241eff, 0x00251dfe,
+	0x00261bff, 0x00281afe, 0x012818ff, 0x012a16ff, 0x022a15ff,
+	0x032b13ff, 0x032c12ff, 0x052c10ff, 0x052d0fff, 0x062d0d00,
+	0x072d0c00, 0x082d0b00,
+	/* counter = 5 */
+	0xff0c2a0b, 0xff0d2a0a, 0xff0e2a09, 0xff0f2a08, 0xff102a07,
+	0xff112a06, 0xff132905, 0xff142904, 0xff162803, 0xff172703,
+	0xff182702, 0xff1a2601, 0xff1b2501, 0xff1c2401, 0xff1e2300,
+	0xff1f2200, 0x00202000, 0x00211f00, 0x01221d00, 0x01231c00,
+	0x01251bff, 0x02251aff, 0x032618ff, 0x032717ff, 0x042815ff,
+	0x052814ff, 0x052913ff, 0x06291100, 0x072a10ff, 0x082a0e00,
+	0x092a0d00, 0x0a2a0c00,
+	/* counter = 6 */
+	0xff0d280c, 0xff0e280b, 0xff0f280a, 0xff102809, 0xff112808,
+	0xff122708, 0xff142706, 0xff152705, 0xff162605, 0xff172604,
+	0xff192503, 0xff1a2403, 0x001b2302, 0x001c2202, 0x001d2201,
+	0x001e2101, 0x011f1f01, 0x01211e00, 0x01221d00, 0x02221c00,
+	0x02231b00, 0x03241900, 0x04241800, 0x04251700, 0x052616ff,
+	0x06261400, 0x072713ff, 0x08271100, 0x08271100, 0x09271000,
+	0x0a280e00, 0x0b280d00,
+	/* counter = 7 */
+	0xff0e260d, 0xff0f260c, 0xff10260b, 0xff11260a, 0xff122609,
+	0xff132608, 0xff142508, 0xff152507, 0x00152506, 0x00172405,
+	0x00182305, 0x00192304, 0x001b2203, 0x001c2103, 0x011d2002,
+	0x011d2002, 0x011f1f01, 0x021f1e01, 0x02201d01, 0x03211c00,
+	0x03221b00, 0x04221a00, 0x04231801, 0x05241700, 0x06241600,
+	0x07241500, 0x08251300, 0x09251200, 0x09261100, 0x0a261000,
+	0x0b260f00, 0x0c260e00,
+	/* counter = 8 */
+	0xff0e250e, 0xff0f250d, 0xff10250c, 0xff11250b, 0x0011250a,
+	0x00132409, 0x00142408, 0x00152407, 0x00162307, 0x00172306,
+	0x00182206, 0x00192205, 0x011a2104, 0x011b2004, 0x011c2003,
+	0x021c1f03, 0x021e1e02, 0x031e1d02, 0x03201c01, 0x04201b01,
+	0x04211a01, 0x05221900, 0x05221801, 0x06231700, 0x07231600,
+	0x07241500, 0x08241400, 0x09241300, 0x0a241200, 0x0b241100,
+	0x0c241000, 0x0d240f00,
+	/* counter = 9 */
+	0x000e240e, 0x000f240d, 0x0010240c, 0x0011240b, 0x0013230a,
+	0x0013230a, 0x00142309, 0x00152308, 0x00162208, 0x00172207,
+	0x01182106, 0x01192105, 0x011a2005, 0x021b1f04, 0x021b1f04,
+	0x021d1e03, 0x031d1d03, 0x031e1d02, 0x041e1c02, 0x041f1b02,
+	0x05201a01, 0x05211901, 0x06211801, 0x07221700, 0x07221601,
+	0x08231500, 0x09231400, 0x0a231300, 0x0a231300, 0x0b231200,
+	0x0c231100, 0x0d231000,
+	/* counter = 10 */
+	0x000f220f, 0x0010220e, 0x0011220d, 0x0012220c, 0x0013220b,
+	0x0013220b, 0x0015210a, 0x0015210a, 0x01162108, 0x01172008,
+	0x01182007, 0x02191f06, 0x02191f06, 0x021a1e06, 0x031a1e05,
+	0x031c1d04, 0x041c1c04, 0x041d1c03, 0x051d1b03, 0x051e1a03,
+	0x061f1902, 0x061f1902, 0x07201801, 0x08201701, 0x08211601,
+	0x09211501, 0x0a211500, 0x0b211400, 0x0b221300, 0x0c221200,
+	0x0d221100, 0x0e221000,
+	/* counter = 11 */
+	0x0010210f, 0x0011210e, 0x0011210e, 0x0012210d, 0x0013210c,
+	0x0014200c, 0x0114200b, 0x0115200a, 0x01161f0a, 0x01171f09,
+	0x02171f08, 0x02181e08, 0x03181e07, 0x031a1d06, 0x031a1d06,
+	0x041b1c05, 0x041c1c04, 0x051c1b04, 0x051d1a04, 0x061d1a03,
+	0x071d1903, 0x071e1803, 0x081e1802, 0x081f1702, 0x091f1602,
+	0x0a201501, 0x0b1f1501, 0x0b201401, 0x0c211300, 0x0d211200,
+	0x0e201200, 0x0e211100,
+	/* counter = 12 */
+	0x00102010, 0x0011200f, 0x0012200e, 0x0013200d, 0x0013200d,
+	0x01141f0c, 0x01151f0b, 0x01151f0b, 0x01161f0a, 0x02171e09,
+	0x02171e09, 0x03181d08, 0x03191d07, 0x03191d07, 0x041a1c06,
+	0x041b1c05, 0x051b1b05, 0x051c1b04, 0x061c1a04, 0x071d1903,
+	0x071d1903, 0x081d1803, 0x081e1703, 0x091e1702, 0x0a1f1601,
+	0x0a1f1502, 0x0b1f1501, 0x0c1f1401, 0x0d201300, 0x0d201300,
+	0x0e201200, 0x0f201100,
+	/* counter = 13 */
+	0x00102010, 0x0011200f, 0x00121f0f, 0x00131f0e, 0x00141f0d,
+	0x01141f0c, 0x01141f0c, 0x01151e0c, 0x02161e0a, 0x02171e09,
+	0x03171d09, 0x03181d08, 0x03181d08, 0x04191c07, 0x041a1c06,
+	0x051a1b06, 0x051b1b05, 0x061b1a05, 0x061c1a04, 0x071c1904,
+	0x081c1903, 0x081d1803, 0x091d1703, 0x091e1702, 0x0a1e1602,
+	0x0b1e1502, 0x0c1e1501, 0x0c1f1401, 0x0d1f1400, 0x0e1f1300,
+	0x0e1f1201, 0x0f1f1200,
+	/* counter = 14 */
+	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e,
+	0x01141d0e, 0x02151d0c, 0x02151d0c, 0x02161d0b, 0x03161c0b,
+	0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08, 0x05191b07,
+	0x06191a07, 0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805,
+	0x091b1804, 0x091c1704, 0x0a1c1703, 0x0a1c1604, 0x0b1d1602,
+	0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301,
+	0x0f1e1300, 0x101e1200,
+	/* counter = 15 */
+	0x00111e11, 0x00121e10, 0x00131d10, 0x01131d0f, 0x01141d0e,
+	0x01141d0e, 0x02151c0d, 0x02151c0d, 0x03161c0b, 0x03161c0b,
+	0x04171b0a, 0x04171b0a, 0x05171b09, 0x05181a09, 0x06181a08,
+	0x06191a07, 0x07191907, 0x071a1906, 0x081a1806, 0x081a1806,
+	0x091a1805, 0x0a1b1704, 0x0a1b1704, 0x0b1c1603, 0x0b1c1603,
+	0x0c1c1503, 0x0d1c1502, 0x0d1d1402, 0x0e1d1401, 0x0f1d1301,
+	0x0f1d1301, 0x101e1200,
+	/* counter = 16 */
+};
+
+static int scal_rcq_setup(struct scaler_submodule *p_scal, u8 __iomem *base,
+			  struct g2d_rcq_mem_info *p_rcq_info)
+{
+	u8 __iomem *reg_base = base + G2D_VSU;
+	int ret = -1;
+
+	if (!p_scal) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	p_scal->reg_info->size = sizeof(struct g2d_mixer_video_scaler_reg);
+	p_scal->reg_info->vir_addr = (u8 *)g2d_top_reg_memory_alloc(
+	    p_scal->reg_info->size, (void *)&(p_scal->reg_info->phy_addr),
+	    p_rcq_info);
+
+	if (!p_scal->reg_info->vir_addr) {
+		G2D_ERR_MSG("Malloc scaler reg rcq memory fail!\n");
+		goto OUT;
+	}
+
+	p_scal->reg_blks->vir_addr = p_scal->reg_info->vir_addr;
+	p_scal->reg_blks->phy_addr = p_scal->reg_info->phy_addr;
+	p_scal->reg_blks->size = p_scal->reg_info->size;
+	p_scal->reg_blks->reg_addr = reg_base;
+	ret = 0;
+
+OUT:
+	return ret;
+}
+
+static __u32 scal_get_reg_block_num(struct scaler_submodule *p_scal)
+{
+	if (p_scal)
+		return p_scal->reg_blk_num;
+	return 0;
+}
+
+static __s32 scal_get_reg_block(struct scaler_submodule *p_scal,
+			    struct g2d_reg_block **blks)
+{
+	__s32 i = 0, ret = -1;
+	if (p_scal) {
+		for (i = 0; i < p_scal->reg_blk_num; ++i)
+			blks[i] = p_scal->reg_blks + i;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static struct g2d_mixer_video_scaler_reg *scal_get_reg(struct scaler_submodule *p_scal)
+{
+
+#if G2D_MIXER_RCQ_USED == 1
+	return (struct g2d_mixer_video_scaler_reg *)(p_scal->reg_blks
+						     ->vir_addr);
+#else
+	return (struct g2d_mixer_video_scaler_reg *)(p_scal->reg_blks
+						     ->reg_addr);
+#endif
+
+	return NULL;
+}
+
+static void scal_set_block_dirty(struct scaler_submodule *p_scal, __u32 blk_id, __u32 dirty)
+{
+#if G2D_MIXER_RCQ_USED == 1
+	if (p_scal && p_scal->reg_blks->rcq_hd)
+		p_scal->reg_blks->rcq_hd->dirty.bits.dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#else
+
+	if (p_scal)
+		p_scal->reg_blks->dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#endif
+}
+
+/**
+ * function       : g2d_vsu_calc_fir_coef(unsigned int step)
+ * description    : set fir coefficients
+ * parameters     :
+ *                  step		<horizontal scale ratio of vsu>
+ * return         :
+ *                  offset (in word) of coefficient table
+ */
+static __u32 g2d_vsu_calc_fir_coef(__u32 step)
+{
+	__u32 pt_coef;
+	__u32 scale_ratio, int_part, float_part, fir_coef_ofst;
+
+	scale_ratio = step >> (VSU_PHASE_FRAC_BITWIDTH - 3);
+	int_part = scale_ratio >> 3;
+	float_part = scale_ratio & 0x7;
+	fir_coef_ofst = (int_part == 0) ? VSU_ZOOM0_SIZE :
+	    (int_part == 1) ? VSU_ZOOM0_SIZE + float_part :
+	    (int_part ==
+	     2) ? VSU_ZOOM0_SIZE + VSU_ZOOM1_SIZE +
+	    (float_part >> 1) : (int_part ==
+				  3) ? VSU_ZOOM0_SIZE + VSU_ZOOM1_SIZE +
+	    VSU_ZOOM2_SIZE : (int_part ==
+			       4) ? VSU_ZOOM0_SIZE + VSU_ZOOM1_SIZE +
+	    VSU_ZOOM2_SIZE + VSU_ZOOM3_SIZE : VSU_ZOOM0_SIZE +
+	    VSU_ZOOM1_SIZE + VSU_ZOOM2_SIZE + VSU_ZOOM3_SIZE + VSU_ZOOM4_SIZE;
+	pt_coef = fir_coef_ofst * VSU_PHASE_NUM;
+	return pt_coef;
+}
+
+__s32 g2d_vsu_para_set(struct scaler_submodule *p_scal, __u32 fmt, __u32 in_w,
+		       __u32 in_h, __u32 out_w, __u32 out_h, __u8 alpha)
+{
+	__u64 temp;
+	__u32 yhstep, yvstep;
+	__u32 incw, inch;
+	__u32 yhcoef_offset, yvcoef_offset, chcoef_offset;
+	__u32 format;
+	__s32 ret = -1;
+
+	struct g2d_mixer_video_scaler_reg *p_reg = NULL;
+	p_reg = p_scal->get_reg(p_scal);
+	if (!p_reg)
+		goto OUT;
+
+	p_reg->vs_ctrl.bits.coef_access_sel = 1;
+	p_reg->vs_ctrl.bits.en = 1;
+	if (fmt > G2D_FORMAT_IYUV422_Y1U0Y0V0)
+		p_reg->vs_ctrl.bits.filter_type = 1;
+	else
+		p_reg->vs_ctrl.bits.filter_type = 0;
+
+	p_reg->out_size.bits.out_width = out_w - 1;
+	p_reg->out_size.bits.out_height = out_h - 1;
+	p_reg->glb_alpha.bits.glb_alpha = alpha;
+
+	p_reg->y_ch_size.bits.y_width = in_w - 1;
+	p_reg->y_ch_size.bits.y_height = in_h - 1;
+
+	temp = in_w << VSU_PHASE_FRAC_BITWIDTH;
+	if (out_w)
+		do_div(temp, out_w);
+	else
+		temp = 0;
+
+	yhstep = temp;
+	p_reg->y_hor_step.dwval = yhstep << 1;
+	temp = in_h << VSU_PHASE_FRAC_BITWIDTH;
+	if (out_h)
+		do_div(temp, out_h);
+	else
+		temp = 0;
+	yvstep = temp;
+	p_reg->y_ver_step.dwval = yvstep << 1;
+
+	yhcoef_offset = g2d_vsu_calc_fir_coef(yhstep);
+	memcpy(&p_reg->vs_y_ch_hor_filter_coef[0],
+	       &lan2coefftab32_full[yhcoef_offset], VSU_PHASE_NUM * sizeof(unsigned int));
+
+	yvcoef_offset = g2d_vsu_calc_fir_coef(yvstep);
+	switch (fmt) {
+	case G2D_FORMAT_Y8:
+		format = VSU_FORMAT_RGB;
+		incw = (in_w + 1) >> 1;
+		inch = in_h;
+		p_reg->c_ch_size.bits.y_width = 0;
+		p_reg->c_ch_size.bits.y_height = 0;
+		p_reg->c_hor_step.dwval = 0;
+		p_reg->c_ver_step.dwval = 0;
+		memcpy(&p_reg->vs_y_ch_ver_filter_coef[0],
+		       &linearcoefftab32[0],
+		       VSU_PHASE_NUM * sizeof(unsigned int));
+		p_reg->y_hor_phase.dwval = 0;
+		p_reg->y_ver_phase.dwval = 0x0;
+		p_reg->y_ver_phase.bits.integer =
+		    ((in_h / out_h) < 3) ? 0 : (in_h / out_h - 3);
+		p_reg->c_hor_phase.dwval = 0;
+		p_reg->c_ver_phase.dwval = 0;
+		break;
+	case G2D_FORMAT_IYUV422_V0Y1U0Y0:
+	case G2D_FORMAT_IYUV422_Y1V0Y0U0:
+	case G2D_FORMAT_IYUV422_U0Y1V0Y0:
+	case G2D_FORMAT_IYUV422_Y1U0Y0V0:{
+			incw = (in_w + 1) >> 1;
+			inch = in_h;
+			format = VSU_FORMAT_YUV422;
+			p_reg->c_ch_size.bits.y_width = incw - 1;
+			p_reg->c_ch_size.bits.y_height = inch - 1;
+
+			    /* chstep = yhstep>>1 cvstep = yvstep */
+			p_reg->c_hor_step.dwval = yhstep;
+			p_reg->c_ver_step.dwval = yvstep << 1;
+			chcoef_offset = g2d_vsu_calc_fir_coef(yhstep >> 1);
+			memcpy(&p_reg->vs_c_ch_hor_filter_coef[0],
+			       &lan2coefftab32_full[chcoef_offset],
+			       VSU_PHASE_NUM * sizeof(unsigned int));
+			memcpy(&p_reg->vs_y_ch_ver_filter_coef[0],
+			       &linearcoefftab32[0],
+			       VSU_PHASE_NUM * sizeof(unsigned int));
+			break;
+		}
+	case G2D_FORMAT_YUV422UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV422UVC_U1V1U0V0:
+	case G2D_FORMAT_YUV422_PLANAR:{
+			incw = (in_w + 1) >> 1;
+			inch = in_h;
+			format = VSU_FORMAT_YUV422;
+			p_reg->c_ch_size.bits.y_width = incw - 1;
+			p_reg->c_ch_size.bits.y_height = inch - 1;
+
+			    /* chstep = yhstep>>1 cvstep = yvstep>>1 */
+			p_reg->c_hor_step.dwval = yhstep;
+			p_reg->c_ver_step.dwval = yvstep << 1;
+			chcoef_offset = g2d_vsu_calc_fir_coef(yhstep >> 1);
+
+			memcpy(&p_reg->vs_c_ch_hor_filter_coef[0],
+			       &lan2coefftab32_full[chcoef_offset],
+			       VSU_PHASE_NUM * sizeof(unsigned int));
+
+			memcpy(&p_reg->vs_y_ch_ver_filter_coef[0],
+			       &lan2coefftab32_full[yvcoef_offset],
+			       VSU_PHASE_NUM * sizeof(unsigned int));
+			break;
+		}
+	case G2D_FORMAT_YUV420_PLANAR:
+	case G2D_FORMAT_YUV420UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV420UVC_U1V1U0V0:{
+			incw = (in_w + 1) >> 1;
+			inch = (in_h + 1) >> 1;
+			format = VSU_FORMAT_YUV420;
+			p_reg->c_ch_size.bits.y_width = incw - 1;
+			p_reg->c_ch_size.bits.y_height = inch - 1;
+
+			    /* chstep = yhstep>>1 cvstep = yvstep>>1 */
+			p_reg->c_hor_step.dwval = yhstep;
+			p_reg->c_ver_step.dwval = yvstep;
+
+			chcoef_offset = g2d_vsu_calc_fir_coef(yhstep >> 1);
+
+			memcpy(&p_reg->vs_c_ch_hor_filter_coef[0],
+			       &lan2coefftab32_full[chcoef_offset],
+			       VSU_PHASE_NUM * sizeof(unsigned int));
+			memcpy(&p_reg->vs_y_ch_ver_filter_coef[0],
+			       &lan2coefftab32_full[yvcoef_offset],
+			       VSU_PHASE_NUM * sizeof(unsigned int));
+			break;
+		}
+	case G2D_FORMAT_YUV411_PLANAR:
+	case G2D_FORMAT_YUV411UVC_V1U1V0U0:
+	case G2D_FORMAT_YUV411UVC_U1V1U0V0:{
+			incw = (in_w + 3) >> 2;
+			inch = in_h;
+			format = VSU_FORMAT_YUV411;
+			p_reg->c_ch_size.bits.y_width = incw - 1;
+			p_reg->c_ch_size.bits.y_height = inch - 1;
+
+			    /* chstep = yhstep>>2 cvstep = yvstep */
+			p_reg->c_hor_step.dwval = yhstep >> 1;
+			p_reg->c_ver_step.dwval = yvstep << 1;
+
+			chcoef_offset = g2d_vsu_calc_fir_coef(yhstep >> 2);
+			memcpy(&p_reg->vs_c_ch_hor_filter_coef[0],
+			       &lan2coefftab32_full[chcoef_offset],
+			       VSU_PHASE_NUM * sizeof(unsigned int));
+
+			memcpy(&p_reg->vs_y_ch_ver_filter_coef[0],
+			       &lan2coefftab32_full[yvcoef_offset],
+			       VSU_PHASE_NUM * sizeof(unsigned int));
+
+			break;
+		}
+	default:
+		format = VSU_FORMAT_RGB;
+		incw = in_w;
+		inch = in_h;
+		p_reg->c_ch_size.bits.y_width = incw - 1;
+		p_reg->c_ch_size.bits.y_height = inch - 1;
+
+		p_reg->c_hor_step.dwval = yhstep << 1;
+		p_reg->c_ver_step.dwval = yvstep << 1;
+		    /* chstep = yhstep cvstep = yvstep */
+		chcoef_offset = g2d_vsu_calc_fir_coef(yhstep);
+
+		memcpy(&p_reg->vs_c_ch_hor_filter_coef[0],
+		       &lan2coefftab32_full[chcoef_offset],
+		       VSU_PHASE_NUM * sizeof(unsigned int));
+
+		memcpy(&p_reg->vs_y_ch_ver_filter_coef[0],
+		       &linearcoefftab32[0],
+		       VSU_PHASE_NUM * sizeof(unsigned int));
+
+		break;
+	}
+	if (format == VSU_FORMAT_YUV420) {
+		/**
+		 * yhphase = 0;
+		 * yvphase = 0;
+		 * chphase = 0xFFFE0000;
+		 * cvphase = 0xFFFE0000;
+		 */
+		p_reg->y_hor_phase.dwval = 0;
+		p_reg->y_ver_phase.dwval = 0;
+		p_reg->c_hor_phase.dwval = 0xFFFc0000;
+		p_reg->c_ver_phase.dwval = 0xFFFc0000;
+	} else if (fmt != G2D_FORMAT_Y8) {
+		p_reg->y_hor_phase.dwval = 0;
+		p_reg->y_ver_phase.dwval = 0;
+		p_reg->c_hor_phase.dwval = 0;
+		p_reg->c_ver_phase.dwval = 0;
+	}
+
+	ret = 0;
+	p_scal->set_block_dirty(p_scal, 0, 1);
+OUT:
+	return ret;
+}
+
+static __u32 scal_get_rcq_mem_size(struct scaler_submodule *p_scal)
+{
+	return G2D_RCQ_BYTE_ALIGN(sizeof(struct g2d_mixer_video_scaler_reg));
+}
+
+static __s32 scal_destory(struct scaler_submodule *p_scal)
+{
+	__s32 ret = -1;
+
+	if (p_scal) {
+		kfree(p_scal->reg_blks);
+		p_scal->reg_blks = NULL;
+
+		kfree(p_scal->reg_info);
+		p_scal->reg_info = NULL;
+		kfree(p_scal);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+struct scaler_submodule *g2d_scaler_submodule_setup(struct g2d_mixer_frame *p_frame)
+{
+	struct scaler_submodule *p_scal = NULL;
+
+	p_scal = kmalloc(sizeof(struct scaler_submodule), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_scal) {
+		G2D_ERR_MSG("Kmalloc wb submodule fail!\n");
+		return NULL;
+	}
+
+	p_scal->rcq_setup = scal_rcq_setup;
+	p_scal->reg_blk_num = 1;
+	p_scal->get_reg_block_num = scal_get_reg_block_num;
+	p_scal->get_reg_block = scal_get_reg_block;
+	p_scal->get_reg = scal_get_reg;
+	p_scal->set_block_dirty = scal_set_block_dirty;
+	p_scal->get_rcq_mem_size = scal_get_rcq_mem_size;
+	p_scal->destory = scal_destory;
+
+	p_scal->reg_blks =
+	    kmalloc(sizeof(struct g2d_reg_block) * p_scal->reg_blk_num,
+		    GFP_KERNEL | __GFP_ZERO);
+	p_scal->reg_info =
+	    kmalloc(sizeof(struct g2d_reg_mem_info), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_scal->reg_blks || !p_scal->reg_info) {
+		G2D_ERR_MSG("Kmalloc wb reg info fail!\n");
+		goto FREE_WB;
+	}
+
+
+	return p_scal;
+FREE_WB:
+	kfree(p_scal->reg_blks);
+	kfree(p_scal->reg_info);
+	kfree(p_scal);
+
+	return NULL;
+}
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.h
new file mode 100644
index 000000000..13dfae81c
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_scal.h
@@ -0,0 +1,43 @@
+/*
+ * g2d_scal.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_SCAL_H
+#define _G2D_SCAL_H
+#include "g2d_rcq.h"
+#include "g2d_mixer_type.h"
+#include "g2d_mixer.h"
+
+struct g2d_mixer_frame;
+struct scaler_submodule {
+	struct g2d_reg_block *reg_blks;
+	__u32 reg_blk_num;
+	struct g2d_reg_mem_info *reg_info;
+	__s32 (*destory)(struct scaler_submodule *p_scal);
+	__s32 (*rcq_setup)(struct scaler_submodule *p_scal, u8 __iomem *base,
+			  struct g2d_rcq_mem_info *p_rcq_info);
+	__u32 (*get_reg_block_num)(struct scaler_submodule *p_scal);
+	__s32 (*apply)(struct scaler_submodule *p_scal, g2d_image_enh *p_image);
+	__u32 (*get_rcq_mem_size)(struct scaler_submodule *p_scal);
+	__s32 (*get_reg_block)(struct scaler_submodule *p_scal, struct g2d_reg_block **blks);
+	struct g2d_mixer_video_scaler_reg  *(*get_reg)(struct scaler_submodule *p_scal);
+	void (*set_block_dirty)(struct scaler_submodule *p_scal, __u32 blk_id, __u32 dirty);
+};
+
+__s32 g2d_vsu_para_set(struct scaler_submodule *p_scal, __u32 fmt, __u32 in_w,
+		       __u32 in_h, __u32 out_w, __u32 out_h, __u8 alpha);
+struct scaler_submodule *g2d_scaler_submodule_setup(struct g2d_mixer_frame *p_frame);
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_top.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_top.c
new file mode 100644
index 000000000..aeb2cdf5c
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_top.c
@@ -0,0 +1,156 @@
+/*
+ * g2d_top/g2d_top.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "g2d_driver_i.h"
+#include "g2d_top.h"
+#include "g2d_top_type.h"
+
+static volatile struct g2d_top_reg *g2d_top;
+static volatile struct g2d_mixer_glb_reg *mixer_glb;
+
+void g2d_top_set_base(unsigned long base)
+{
+	g2d_top = (struct g2d_top_reg *)(base);
+	mixer_glb = (struct g2d_mixer_glb_reg *)(base + 0x0100);
+}
+
+void g2d_mixer_scan_order_fun(__u32 scan_order)
+{
+	mixer_glb->mixer_ctrl.bits.scan_order = scan_order;
+}
+
+void g2d_mixer_start(__u32 start)
+{
+	mixer_glb->mixer_ctrl.bits.start = start;
+}
+
+void g2d_mixer_irq_en(__u32 en)
+{
+	mixer_glb->mixer_interrupt.bits.finish_irq_en = en;
+}
+
+__s32 g2d_mixer_irq_query(void)
+{
+	if (mixer_glb->mixer_interrupt.bits.mixer_irq & 0x1) {
+		mixer_glb->mixer_interrupt.bits.mixer_irq = 1;
+		return 1;
+	}
+	return 0;
+}
+
+__s32 g2d_bsp_open(void)
+{
+	g2d_top->sclk_gate.bits.mixer_sclk_gate = 1;
+	g2d_top->sclk_gate.bits.rot_sclk_gate = 1;
+	g2d_top->hclk_gate.bits.mixer_hclk_gate = 1;
+	g2d_top->hclk_gate.bits.rot_hclk_gate = 1;
+	g2d_top->ahb_rst.bits.mixer_ahb_rst = 1;
+	g2d_top->ahb_rst.bits.rot_ahb_rst = 1;
+	return 0;
+}
+
+__s32 g2d_bsp_close(void)
+{
+	g2d_top->sclk_gate.bits.mixer_sclk_gate = 0;
+	g2d_top->sclk_gate.bits.rot_sclk_gate = 0;
+	g2d_top->hclk_gate.bits.mixer_hclk_gate = 0;
+	g2d_top->hclk_gate.bits.rot_hclk_gate = 0;
+	g2d_top->ahb_rst.bits.mixer_ahb_rst = 0;
+	g2d_top->ahb_rst.bits.rot_ahb_rst = 0;
+	return 0;
+}
+
+__s32 g2d_bsp_reset(void)
+{
+	g2d_top->ahb_rst.bits.mixer_ahb_rst = 0;
+	g2d_top->ahb_rst.bits.rot_ahb_rst = 0;
+	g2d_top->ahb_rst.bits.mixer_ahb_rst = 1;
+	g2d_top->ahb_rst.bits.rot_ahb_rst = 1;
+	return 0;
+}
+
+__s32 g2d_top_mixer_reset(void)
+{
+	g2d_top->ahb_rst.bits.mixer_ahb_rst = 0;
+	g2d_top->ahb_rst.bits.mixer_ahb_rst = 1;
+	return 0;
+}
+
+__s32 g2d_top_rot_reset(void)
+{
+	g2d_top->ahb_rst.bits.rot_ahb_rst = 0;
+	g2d_top->ahb_rst.bits.rot_ahb_rst = 1;
+	return 0;
+}
+
+
+__s32 g2d_top_mixer_sclk_div(__u32 div)
+{
+	g2d_top->sclk_div.bits.mixer_sclk_div = div;
+	return 0;
+}
+
+__s32 g2d_top_rot_sclk_div(__u32 div)
+{
+	g2d_top->sclk_div.bits.rot_sclk_div = div;
+	return 0;
+}
+
+void g2d_top_rcq_irq_en(__u32 en)
+{
+	g2d_top->rcq_irq_ctl.bits.task_end_irq_en = en;
+	/*g2d_top->rcq_irq_ctl.bits.rcq_cfg_finish_irq_en = en;*/
+}
+
+void g2d_top_rcq_update_en(__u32 en)
+{
+	g2d_top->rcq_ctrl.bits.update = en;
+}
+
+__s32 g2d_top_rcq_task_irq_query(void)
+{
+	if (g2d_top->rcq_status.bits.task_end_irq & 0x1) {
+		g2d_top->rcq_status.bits.task_end_irq = 1;
+		return 1;
+	}
+	return 0;
+}
+
+__s32 g2d_top_rcq_cfg_irq_query(void)
+{
+	if (g2d_top->rcq_status.bits.cfg_finish_irq & 0x1) {
+		g2d_top->rcq_status.bits.cfg_finish_irq = 1;
+		return 1;
+	}
+	return 0;
+}
+
+__u32 g2d_top_get_rcq_frame_cnt(void)
+{
+	return g2d_top->rcq_status.bits.frame_cnt;
+}
+
+
+void g2d_top_set_rcq_head(u64 addr, __u32 len)
+{
+	__u32 haddr = (__u32)(addr >> 32);
+
+	g2d_top->rcq_header_low_addr = addr;
+	g2d_top->rcq_header_high_addr = haddr;
+	g2d_top->rcq_header_len.bits.rcq_header_len = len;
+}
+
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_top.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_top.h
new file mode 100644
index 000000000..491fe208a
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_top.h
@@ -0,0 +1,40 @@
+/*
+ * g2d_top/g2d_top.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_TOP_H
+#define _G2D_TOP_H
+#include <linux/types.h>
+
+void g2d_top_set_base(unsigned long base);
+__u32 g2d_top_get_rcq_frame_cnt(void);
+__s32 g2d_top_rcq_cfg_irq_query(void);
+__s32 g2d_top_rcq_task_irq_query(void);
+__s32 g2d_bsp_reset(void);
+void g2d_top_rcq_update_en(__u32 en);
+void g2d_top_rcq_irq_en(__u32 en);
+__s32 g2d_top_mixer_sclk_div(__u32 div);
+__s32 g2d_top_rot_sclk_div(__u32 div);
+__s32 g2d_top_rot_reset(void);
+__s32 g2d_top_mixer_reset(void);
+void g2d_top_set_rcq_head(u64 addr, __u32 len);
+__s32 g2d_bsp_open(void);
+__s32 g2d_bsp_close(void);
+void g2d_mixer_scan_order_fun(__u32 scan_order);
+__s32 g2d_mixer_irq_query(void);
+void g2d_mixer_irq_en(__u32 en);
+void g2d_mixer_start(__u32 start);
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_top_type.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_top_type.h
new file mode 100644
index 000000000..e2a5d9d9b
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_top_type.h
@@ -0,0 +1,159 @@
+/*
+ * g2d_top_type/g2d_top_type.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_TOP_TYPE_H
+#define _G2D_TOP_TYPE_H
+
+
+union g2d_sclk_gate {
+	unsigned int dwval;
+	struct {
+		unsigned int mixer_sclk_gate:1;
+		unsigned int rot_sclk_gate:1;
+		unsigned int res0:30;
+	} bits;
+};
+
+union g2d_hclk_gate {
+	unsigned int dwval;
+	struct {
+		unsigned int mixer_hclk_gate:1;
+		unsigned int rot_hclk_gate:1;
+		unsigned int res0:30;
+	} bits;
+};
+
+union g2d_ahb_reset {
+	unsigned int dwval;
+	struct {
+		unsigned int mixer_ahb_rst:1;
+		unsigned int rot_ahb_rst:1;
+		unsigned int res0:30;
+	} bits;
+};
+
+union g2d_sclk_div {
+	unsigned int dwval;
+	struct {
+		unsigned int mixer_sclk_div:4;
+		unsigned int rot_sclk_div:4;
+		unsigned int res0:24;
+	} bits;
+};
+
+union g2d_version {
+	unsigned int dwval;
+	struct {
+		unsigned int gsu_no:2;
+		unsigned int vsu_no:2;
+		unsigned int rtmx_no:1;
+		unsigned int res0:3;
+		unsigned int rot_no:1;
+		unsigned int res1:7;
+		unsigned int ip_version:16;
+	} bits;
+};
+
+union g2d_rcq_irq_ctl {
+	unsigned int dwval;
+	struct {
+		unsigned int rcq_sel:1;
+		unsigned int res0:3;
+		unsigned int task_end_irq_en:1;
+		unsigned int res1:1;
+		unsigned int rcq_cfg_finish_irq_en:1;
+		unsigned int res2:25;
+	} bits;
+};
+
+union g2d_rcq_status {
+	unsigned int dwval;
+	struct {
+		unsigned int task_end_irq:1;
+		unsigned int res0:1;
+		unsigned int cfg_finish_irq:1;
+		unsigned int res1:5;
+		unsigned int frame_cnt:8;
+		unsigned int res2:16;
+	} bits;
+};
+
+union g2d_rcq_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int update:1;
+		unsigned int res0:31;
+	} bits;
+};
+
+union g2d_rcq_header_len {
+	unsigned int dwval;
+	struct {
+		unsigned int rcq_header_len:16;
+		unsigned int res0:16;
+	} bits;
+};
+
+
+struct g2d_top_reg {
+	/*0x00*/
+	union g2d_sclk_gate sclk_gate;
+	union g2d_hclk_gate hclk_gate;
+	union g2d_ahb_reset ahb_rst;
+	union g2d_sclk_div sclk_div;
+	/*0x10*/
+	union g2d_version version;
+	unsigned int res0[3];
+	/*0x20*/
+	union g2d_rcq_irq_ctl rcq_irq_ctl;
+	union g2d_rcq_status rcq_status;
+	union g2d_rcq_ctrl rcq_ctrl;
+	unsigned int rcq_header_low_addr;
+	/*0x30*/
+	unsigned int rcq_header_high_addr;
+	union g2d_rcq_header_len rcq_header_len;
+};
+
+/*mixer global register define start*/
+union g2d_mxier_ctrl {
+	unsigned int dwval;
+	struct {
+		unsigned int res0:4;
+		unsigned int scan_order:2;
+		unsigned int res1:2;
+		unsigned int bist_en:1;
+		unsigned int res2:22;
+		unsigned int start:1;
+	} bits;
+};
+
+union g2d_mixer_interrupt {
+	unsigned int dwval;
+	struct {
+		unsigned int mixer_irq:1;
+		unsigned int res0:3;
+		unsigned int finish_irq_en:1;
+		unsigned int res1:27;
+	} bits;
+};
+
+struct g2d_mixer_glb_reg {
+	union g2d_mxier_ctrl mixer_ctrl;
+	union g2d_mixer_interrupt mixer_interrupt;
+};
+/*mixer global register define end*/
+
+#endif /*End of file*/
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.c b/drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.c
new file mode 100644
index 000000000..cf9b6f38a
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.c
@@ -0,0 +1,233 @@
+/*
+ * g2d_wb/g2d_wb.c
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "g2d_wb.h"
+
+static int wb_rcq_setup(struct wb_submodule *p_wb, u8 __iomem *base,
+			struct g2d_rcq_mem_info *p_rcq_info)
+{
+	u8 __iomem *reg_base = base + G2D_WB;
+	int ret = -1;
+
+	if (!p_wb) {
+		G2D_ERR_MSG("Null pointer!\n");
+		goto OUT;
+	}
+
+	p_wb->reg_info->size = sizeof(struct g2d_mixer_write_back_reg);
+	p_wb->reg_info->vir_addr = (u8 *)g2d_top_reg_memory_alloc(
+	    p_wb->reg_info->size, (void *)&(p_wb->reg_info->phy_addr),
+	    p_rcq_info);
+
+	if (!p_wb->reg_info->vir_addr) {
+		G2D_ERR_MSG("Malloc writeback reg rcq memory fail!\n");
+		goto OUT;
+	}
+
+	p_wb->reg_blks->vir_addr = p_wb->reg_info->vir_addr;
+	p_wb->reg_blks->phy_addr = p_wb->reg_info->phy_addr;
+	p_wb->reg_blks->size = p_wb->reg_info->size;
+	p_wb->reg_blks->reg_addr = reg_base;
+	ret = 0;
+
+OUT:
+	return ret;
+}
+
+static __u32 wb_get_reg_block_num(struct wb_submodule *p_wb)
+{
+	if (p_wb)
+		return p_wb->reg_blk_num;
+	return 0;
+}
+
+static __s32 wb_get_reg_block(struct wb_submodule *p_wb,
+			    struct g2d_reg_block **blks)
+{
+	__s32 i = 0, ret = -1;
+
+	if (p_wb) {
+		for (i = 0; i < p_wb->reg_blk_num; ++i)
+			blks[i] = p_wb->reg_blks + i;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static struct g2d_mixer_write_back_reg *wb_get_reg(struct wb_submodule *p_wb)
+{
+#if G2D_MIXER_RCQ_USED == 1
+	return (struct g2d_mixer_write_back_reg *)(p_wb->reg_blks
+						   ->vir_addr);
+#else
+	return (struct g2d_mixer_write_back_reg *)(p_wb->reg_blks
+						   ->reg_addr);
+#endif
+	return NULL;
+}
+
+
+static void wb_set_block_dirty(struct wb_submodule *p_wb, __u32 blk_id, __u32 dirty)
+{
+#if G2D_MIXER_RCQ_USED == 1
+	if (p_wb && p_wb->reg_blks->rcq_hd)
+		p_wb->reg_blks->rcq_hd->dirty.bits.dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#else
+
+	if (p_wb)
+		p_wb->reg_blks->dirty = dirty;
+	else
+		G2D_ERR_MSG("Null pointer!\n");
+#endif
+}
+
+__s32 g2d_wb_set(struct wb_submodule *p_wb, g2d_image_enh *p_image)
+{
+	struct g2d_mixer_write_back_reg *p_reg = NULL;
+	__u64 addr0, addr1, addr2;
+	__u32 ycnt, ucnt, vcnt;
+	__u32 pitch0, pitch1, pitch2;
+	__u32 ch, cw, cy, cx;
+	__s32 ret = -1;
+
+	if (p_wb && p_image) {
+		p_reg = p_wb->get_reg(p_wb);
+		if (!p_reg)
+			goto OUT;
+		p_reg->wb_attr.bits.fmt = p_image->format;
+		p_reg->data_size.bits.height =
+		    (!p_image->clip_rect.h) ? 0 : p_image->clip_rect.h - 1;
+		p_reg->data_size.bits.width =
+		    (!p_image->clip_rect.w) ? 0 : p_image->clip_rect.w - 1;
+
+		if ((p_image->format >= G2D_FORMAT_YUV422UVC_V1U1V0U0) &&
+		    (p_image->format <= G2D_FORMAT_YUV422_PLANAR)) {
+			cw = p_image->width >> 1;
+			ch = p_image->height;
+			cx = p_image->clip_rect.x >> 1;
+			cy = p_image->clip_rect.y;
+		} else if ((p_image->format >= G2D_FORMAT_YUV420UVC_V1U1V0U0) &&
+			   (p_image->format <= G2D_FORMAT_YUV420_PLANAR)) {
+			cw = p_image->width >> 1;
+			ch = p_image->height >> 1;
+			cx = p_image->clip_rect.x >> 1;
+			cy = p_image->clip_rect.y >> 1;
+		} else if ((p_image->format >= G2D_FORMAT_YUV411UVC_V1U1V0U0) &&
+			   (p_image->format <= G2D_FORMAT_YUV411_PLANAR)) {
+			cw = p_image->width >> 2;
+			ch = p_image->height;
+			cx = p_image->clip_rect.x >> 2;
+			cy = p_image->clip_rect.y;
+		} else {
+			cw = 0;
+			ch = 0;
+			cx = 0;
+			cy = 0;
+		}
+
+		g2d_byte_cal(p_image->format, &ycnt, &ucnt, &vcnt);
+		pitch0 = cal_align(ycnt * p_image->width, p_image->align[0]);
+		p_reg->pitch0 = pitch0;
+		pitch1 = cal_align(ucnt * cw, p_image->align[1]);
+		p_reg->pitch1 = pitch1;
+		pitch2 = cal_align(vcnt * cw, p_image->align[2]);
+		p_reg->pitch2 = pitch2;
+
+		addr0 = p_image->laddr[0] + ((__u64)p_image->haddr[0] << 32) +
+			pitch0 * p_image->clip_rect.y +
+			ycnt * p_image->clip_rect.x;
+		p_reg->laddr0 = addr0 & 0xffffffff;
+		p_reg->haddr0 = (addr0 >> 32) & 0xff;
+		addr1 = p_image->laddr[1] + ((__u64)p_image->haddr[1] << 32) +
+			pitch1 * cy + ucnt * cx;
+		p_reg->laddr1 = addr1 & 0xffffffff;
+		p_reg->haddr1 = (addr1 >> 32) & 0xff;
+		addr2 = p_image->laddr[2] + ((__u64)p_image->haddr[2] << 32) +
+			pitch2 * cy + vcnt * cx;
+		p_reg->laddr2 = addr2 & 0xffffffff;
+		p_reg->haddr2 = (addr1 >> 32) & 0xff;
+		p_wb->set_block_dirty(p_wb, 0, 1);
+	}
+
+OUT:
+	return ret;
+}
+
+static __u32 wb_get_rcq_mem_size(struct wb_submodule *p_wb)
+{
+	return G2D_RCQ_BYTE_ALIGN(sizeof(struct g2d_mixer_write_back_reg));
+}
+
+static __s32 wb_destory(struct wb_submodule *p_wb)
+{
+	__s32 ret = -1;
+
+	if (p_wb) {
+		kfree(p_wb->reg_blks);
+		p_wb->reg_blks = NULL;
+
+		kfree(p_wb->reg_info);
+		p_wb->reg_info = NULL;
+		ret = 0;
+		kfree(p_wb);
+	}
+
+	return ret;
+}
+
+struct wb_submodule *g2d_wb_submodule_setup(struct g2d_mixer_frame *p_frame)
+{
+	struct wb_submodule *p_wb = NULL;
+
+	p_wb = kmalloc(sizeof(struct wb_submodule), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_wb) {
+		G2D_ERR_MSG("Kmalloc wb submodule fail!\n");
+		return NULL;
+	}
+
+	p_wb->rcq_setup = wb_rcq_setup;
+	p_wb->reg_blk_num = 1;
+	p_wb->get_reg_block_num = wb_get_reg_block_num;
+	p_wb->get_reg_block = wb_get_reg_block;
+	p_wb->get_reg = wb_get_reg;
+	p_wb->set_block_dirty = wb_set_block_dirty;
+	p_wb->get_rcq_mem_size = wb_get_rcq_mem_size;
+	p_wb->destory = wb_destory;
+
+	p_wb->reg_blks =
+	    kmalloc(sizeof(struct g2d_reg_block) * p_wb->reg_blk_num,
+		    GFP_KERNEL | __GFP_ZERO);
+	p_wb->reg_info =
+	    kmalloc(sizeof(struct g2d_reg_mem_info), GFP_KERNEL | __GFP_ZERO);
+
+	if (!p_wb->reg_blks || !p_wb->reg_info) {
+		G2D_ERR_MSG("Kmalloc wb reg info fail!\n");
+		goto FREE_WB;
+	}
+
+
+	return p_wb;
+FREE_WB:
+	kfree(p_wb->reg_blks);
+	kfree(p_wb->reg_info);
+	kfree(p_wb);
+
+	return NULL;
+}
diff --git a/drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.h b/drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.h
new file mode 100644
index 000000000..06de85bb6
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_rcq/g2d_wb.h
@@ -0,0 +1,42 @@
+/*
+ * g2d_wb/g2d_wb.h
+ *
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _G2D_WB_H
+#define _G2D_WB_H
+#include "g2d_rcq.h"
+#include "g2d_mixer_type.h"
+#include "g2d_mixer.h"
+
+struct g2d_mixer_frame;
+
+struct wb_submodule {
+	struct g2d_reg_block *reg_blks;
+	__u32 reg_blk_num;
+	struct g2d_reg_mem_info *reg_info;
+	__s32 (*destory)(struct wb_submodule *p_wb);
+	__s32 (*apply)(struct wb_submodule *p_wb, g2d_image_enh *p_image);
+	__s32 (*rcq_setup)(struct wb_submodule *p_wb, u8 __iomem *base,
+			struct g2d_rcq_mem_info *p_rcq_info);
+	__u32 (*get_reg_block_num)(struct wb_submodule *p_wb);
+	__u32 (*get_rcq_mem_size)(struct wb_submodule *p_wb);
+	__s32 (*get_reg_block)(struct wb_submodule *p_wb, struct g2d_reg_block **blks);
+	struct g2d_mixer_write_back_reg  *(*get_reg)(struct wb_submodule *p_wb);
+	void (*set_block_dirty)(struct wb_submodule *p_wb, __u32 blk_id, __u32 dirty);
+};
+struct wb_submodule *g2d_wb_submodule_setup(struct g2d_mixer_frame *p_frame);
+__s32 g2d_wb_set(struct wb_submodule *p_wb, g2d_image_enh *p_image);
+
+#endif
diff --git a/drivers/char/sunxi_g2d/g2d_regs.h b/drivers/char/sunxi_g2d/g2d_regs.h
new file mode 100644
index 000000000..f7fbc3bac
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_regs.h
@@ -0,0 +1,208 @@
+/* g2d_regs.h
+ *
+ * Copyright (c)	2011 Allwinnertech Co., Ltd.
+ *					2011 Yupu Tang
+ *
+ * G2D driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __G2D_MIXER_REGS_H
+#define __G2D_MIXER_REGS_H
+
+/*
+ *Graphics 2D General Registers
+ */
+#define G2D_BASE_ADDR			(0x01e80000)/* Base Address */
+#define G2D_CONTROL_REG			(0x00)	    /* Control register */
+#define G2D_STATUS_REG			(0x04)	    /* Status register */
+/* DMA scan order control register */
+#define G2D_SCAN_ORDER_REG		(0x08)
+
+/*
+ *	Graphics 2D Input Address Parameter Setting Registers
+ */
+/* Input DMA high 4 bits start addr register    */
+#define G2D_DMA_HADDR_REG		(0x0c)
+/* Input DMA0 low 32 bits start addr register   */
+#define G2D_DMA0_LADDR_REG		(0x10)
+/* Input DMA1 low 32 bits start addr register   */
+#define G2D_DMA1_LADDR_REG		(0x14)
+/* Input DMA2 low 32 bits start addr register   */
+#define G2D_DMA2_LADDR_REG		(0x18)
+/* Input DMA3 low 32 bits start addr register   */
+#define G2D_DMA3_LADDR_REG		(0x1c)
+
+/*
+ *	Graphics 2D Input Linewidth Buffer Parameter Setting Registers
+ */
+/* Input DMA0 line stride register	*/
+#define G2D_DMA0_STRIDE_REG		(0x20)
+/* Input DMA1 line stride register	*/
+
+#define G2D_DMA1_STRIDE_REG		(0x24)
+/* Input DMA2 line stride register	*/
+
+#define G2D_DMA2_STRIDE_REG		(0x28)
+/* Input DMA3 line stride register	*/
+
+#define G2D_DMA3_STRIDE_REG		(0x2c)
+
+/* Input DMA0 memory block size register	*/
+#define G2D_DMA0_SIZE_REG		(0x30)
+/* Input DMA1 memory block size register	*/
+#define G2D_DMA1_SIZE_REG		(0x34)
+/* Input DMA2 memory block size register	*/
+#define G2D_DMA2_SIZE_REG		(0x38)
+/* Input DMA3 memory block size register	*/
+#define G2D_DMA3_SIZE_REG		(0x3c)
+
+/* Input DMA0 memory block coordinate register	*/
+#define G2D_DMA0_COOR_REG		(0x40)
+/* Input DMA1 memory block coordinate register	*/
+#define G2D_DMA1_COOR_REG		(0x44)
+/* Input DMA2 memory block coordinate register	*/
+#define G2D_DMA2_COOR_REG		(0x48)
+/* Input DMA3 memory block coordinate register	*/
+#define G2D_DMA3_COOR_REG		(0x4c)
+
+/* Input DMA0 control register	*/
+#define G2D_DMA0_CONTROL_REG	(0x50)
+/* Input DMA1 control register	*/
+#define G2D_DMA1_CONTROL_REG	(0x54)
+/* Input DMA2 control register	*/
+#define G2D_DMA2_CONTROL_REG	(0x58)
+/* Input DMA3 control register	*/
+#define G2D_DMA3_CONTROL_REG	(0x5c)
+/* Input DMA0 fillcolor register	*/
+
+#define G2D_DMA0_FILLCOLOR_REG	(0x60)
+/* Input DMA1 fillcolor register	*/
+#define G2D_DMA1_FILLCOLOR_REG	(0x64)
+/* Input DMA2 fillcolor register	*/
+#define G2D_DMA2_FILLCOLOR_REG	(0x68)
+/* Input DMA3 fillcolor register	*/
+#define G2D_DMA3_FILLCOLOR_REG	(0x6c)
+
+/* Color space converter0 control register	*/
+#define G2D_CSC0_CONTROL_REG	(0x74)
+/* Color space converter1 control register	*/
+#define G2D_CSC1_CONTROL_REG	(0x78)
+
+/* Scaler control register	*/
+#define G2D_SCALER_CONTROL_REG	(0x80)
+/* Scaler output size control register	*/
+#define G2D_SCALER_SIZE_REG		(0x84)
+/* Scaler horizontal scaling factor register	*/
+#define G2D_SCALER_HFACTOR_REG	(0x88)
+/* Scaler vertical scaling factor register	*/
+#define G2D_SCALER_VFACTOR_REG	(0x8c)
+/* Scaler horizontal start phase register	*/
+#define G2D_SCALER_HPHASE_REG	(0x90)
+/* Scaler vertical start phase register */
+#define G2D_SCALER_VPHASE_REG	(0x94)
+
+/* Rop control register */
+#define G2D_ROP_CONTROL_REG		(0xb0)
+/* Rop index0 control table setting register	*/
+#define G2D_ROP_INDEX0_REG		(0xb8)
+/* Rop index1 control table setting register	*/
+#define G2D_ROP_INDEX1_REG		(0xbc)
+
+/* Colorkey/alpha control register	*/
+#define G2D_CK_CONTROL_REG		(0xc0)
+/* Colorkey min color control register	*/
+#define G2D_CK_MINCOLOR_REG		(0xc4)
+/* Colorkey max color control register	*/
+#define G2D_CK_MAXCOLOR_REG		(0xc8)
+/* Rop output fillcolor setting register	*/
+#define G2D_ROP_FILLCOLOR_REG	(0xcc)
+/* Color space converter2 control register	*/
+#define G2D_CSC2_CONTROL_REG	(0xd0)
+
+/* Output control register	*/
+#define G2D_OUTPUT_CONTROL_REG	(0xe0)
+/* Output size register */
+#define G2D_OUTPUT_SIZE_REG		(0xe8)
+/* Output high 4 bits address control register	*/
+#define G2D_OUTPUT_HADDR_REG	(0xec)
+/* Output low 32 bits address control register	*/
+#define G2D_OUTPUT0_LADDR_REG	(0xf0)
+/* Output low 32 bits address control register	*/
+#define G2D_OUTPUT1_LADDR_REG	(0xf4)
+/* Output low 32 bits address control register	*/
+#define G2D_OUTPUT2_LADDR_REG	(0xf8)
+
+/* Output channel0 line stride control register */
+#define G2D_OUTPUT0_STRIDE_REG	(0x100)
+/* Output channel1 line stride control register */
+#define G2D_OUTPUT1_STRIDE_REG	(0x104)
+/* Output channel2 line stride control register */
+#define G2D_OUTPUT2_STRIDE_REG	(0x108)
+/* Output alpha control register	*/
+#define G2D_OALPHA_CONTROL_REG	(0x120)
+
+/* Input DMA0 micro block control register	*/
+#define G2D_DMA0_MBCTL_REG		(0x130)
+/* Input DMA1 micro block control register	*/
+#define G2D_DMA1_MBCTL_REG		(0x134)
+/* Input DMA2 micro block control register	*/
+#define G2D_DMA2_MBCTL_REG		(0x138)
+/* Input DMA3 micro block control register	*/
+#define G2D_DMA3_MBCTL_REG		(0x13c)
+
+/* command queue control register	*/
+#define G2D_CMDQ_CTL_REG		(0x140)
+/* command queue status register	*/
+#define G2D_CMDQ_STS_REG		(0x144)
+/* command queue storage start address register */
+#define G2D_CMDQ_ADDR_REG		(0x148)
+
+/* CSC0/1 coefficient/constant start addr register(0x180-0x1ac) */
+#define G2D_CSC01_ADDR_REG		(0x180)
+/* CSC2 coefficient/constant start addr register(0x1c0-0x1ec)	*/
+#define G2D_CSC2_ADDR_REG		(0x1c0)
+/* Scaling horizontal filtering coefficient ram block register(0x200-0x27c) */
+#define G2D_SCALER_HFILTER_REG	(0x200)
+/* Scaling vertical filtering coefficient ram block register(0x280-0x2fc) */
+#define G2D_SCALER_VFILTER_REG	(0x280)
+/* Scaling horizontal filtering coefficient ram block register(0x400-0x7fc) */
+#define G2D_PALETTE_TAB_REG		(0x400)
+
+/* Input DMA setting */
+#define G2D_FILL_ENABLE		(1<<16)
+#define G2D_FILL_DISABLE	(0<<16)
+
+/* Work Mode Select */
+#define G2D_IDMA_ENABLE		(1<<0)
+#define G2D_IDMA_DISABLE	(0<<0)
+
+/* Scaler Control Select */
+#define G2D_SCALER_DISABLE	(0<<0)
+#define G2D_SCALER_ENABLE	(1<<0)
+#define G2D_SCALER_4TAP4	(0<<4)
+
+/* byte input */
+#define get_bvalue(n)	(*((volatile __u8 *)(n)))
+/* byte output */
+#define put_bvalue(n, c)	(*((volatile __u8 *)(n)) = (c))
+/* half word input */
+#define get_hvalue(n)	(*((volatile __u16 *)(n)))
+/* half word output */
+#define put_hvalue(n, c)	(*((volatile __u16 *)(n)) = (c))
+/* word input */
+#define get_wvalue(n)	(*((volatile __u32 *)(n)))
+/* word output */
+#define put_wvalue(n, c)	(*((volatile __u32 *)(n)) = (c))
+
+#endif /* __G2D_MIXER_REGS_H */
+
diff --git a/drivers/char/sunxi_g2d/g2d_regs_v2.h b/drivers/char/sunxi_g2d/g2d_regs_v2.h
new file mode 100644
index 000000000..df9ad982e
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_regs_v2.h
@@ -0,0 +1,234 @@
+/*
+ * Allwinner SoCs g2d driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+
+#ifndef __G2D_MIXER_REGS_H
+#define __G2D_MIXER_REGS_H
+
+/* module base addr */
+/*
+ *#define G2D_TOP        (0x00000 + G2D_BASE)
+ *#define G2D_MIXER      (0x00100 + G2D_BASE)
+ *#define G2D_BLD        (0x00400 + G2D_BASE)
+ *#define G2D_V0         (0x00800 + G2D_BASE)
+ *#define G2D_UI0        (0x01000 + G2D_BASE)
+ *#define G2D_UI1        (0x01800 + G2D_BASE)
+ *#define G2D_UI2        (0x02000 + G2D_BASE)
+ *#define G2D_WB         (0x03000 + G2D_BASE)
+ *#define G2D_VSU        (0x08000 + G2D_BASE)
+ *#define G2D_ROT        (0x28000 + G2D_BASE)
+ *#define G2D_GSU        (0x30000 + G2D_BASE)
+ */
+#define G2D_TOP        (0x00000)
+#define G2D_MIXER      (0x00100)
+#define G2D_BLD        (0x00400)
+#define G2D_V0         (0x00800)
+#define G2D_UI0        (0x01000)
+#define G2D_UI1        (0x01800)
+#define G2D_UI2        (0x02000)
+#define G2D_WB         (0x03000)
+#define G2D_VSU        (0x08000)
+#define G2D_ROT        (0x28000)
+#define G2D_GSU        (0x30000)
+
+/* register offset */
+/* TOP register */
+#define G2D_SCLK_GATE  (0x00 + G2D_TOP)
+#define G2D_HCLK_GATE  (0x04 + G2D_TOP)
+#define G2D_AHB_RESET  (0x08 + G2D_TOP)
+#define G2D_SCLK_DIV   (0x0C + G2D_TOP)
+
+/* MIXER GLB register */
+#define G2D_MIXER_CTL  (0x00 + G2D_MIXER)
+#define G2D_MIXER_INT  (0x04 + G2D_MIXER)
+#define G2D_MIXER_CLK  (0x08 + G2D_MIXER)
+
+/* LAY VIDEO register */
+#define V0_ATTCTL      (0x00 + G2D_V0)
+#define V0_MBSIZE      (0x04 + G2D_V0)
+#define V0_COOR        (0x08 + G2D_V0)
+#define V0_PITCH0      (0x0C + G2D_V0)
+#define V0_PITCH1      (0x10 + G2D_V0)
+#define V0_PITCH2      (0x14 + G2D_V0)
+#define V0_LADD0       (0x18 + G2D_V0)
+#define V0_LADD1       (0x1C + G2D_V0)
+#define V0_LADD2       (0x20 + G2D_V0)
+#define V0_FILLC       (0x24 + G2D_V0)
+#define V0_HADD        (0x28 + G2D_V0)
+#define V0_SIZE        (0x2C + G2D_V0)
+#define V0_HDS_CTL0    (0x30 + G2D_V0)
+#define V0_HDS_CTL1    (0x34 + G2D_V0)
+#define V0_VDS_CTL0    (0x38 + G2D_V0)
+#define V0_VDS_CTL1    (0x3C + G2D_V0)
+
+/* LAY0 UI register */
+#define UI0_ATTR       (0x00 + G2D_UI0)
+#define UI0_MBSIZE     (0x04 + G2D_UI0)
+#define UI0_COOR       (0x08 + G2D_UI0)
+#define UI0_PITCH      (0x0C + G2D_UI0)
+#define UI0_LADD       (0x10 + G2D_UI0)
+#define UI0_FILLC      (0x14 + G2D_UI0)
+#define UI0_HADD       (0x18 + G2D_UI0)
+#define UI0_SIZE       (0x1C + G2D_UI0)
+
+/* LAY1 UI register */
+#define UI1_ATTR       (0x00 + G2D_UI1)
+#define UI1_MBSIZE     (0x04 + G2D_UI1)
+#define UI1_COOR       (0x08 + G2D_UI1)
+#define UI1_PITCH      (0x0C + G2D_UI1)
+#define UI1_LADD       (0x10 + G2D_UI1)
+#define UI1_FILLC      (0x14 + G2D_UI1)
+#define UI1_HADD       (0x18 + G2D_UI1)
+#define UI1_SIZE       (0x1C + G2D_UI1)
+
+/* LAY2 UI register */
+#define UI2_ATTR       (0x00 + G2D_UI2)
+#define UI2_MBSIZE     (0x04 + G2D_UI2)
+#define UI2_COOR       (0x08 + G2D_UI2)
+#define UI2_PITCH      (0x0C + G2D_UI2)
+#define UI2_LADD       (0x10 + G2D_UI2)
+#define UI2_FILLC      (0x14 + G2D_UI2)
+#define UI2_HADD       (0x18 + G2D_UI2)
+#define UI2_SIZE       (0x1C + G2D_UI2)
+
+/* VSU register */
+#define VS_CTRL           (0x000 + G2D_VSU)
+#define VS_OUT_SIZE       (0x040 + G2D_VSU)
+#define VS_GLB_ALPHA      (0x044 + G2D_VSU)
+#define VS_Y_SIZE         (0x080 + G2D_VSU)
+#define VS_Y_HSTEP        (0x088 + G2D_VSU)
+#define VS_Y_VSTEP        (0x08C + G2D_VSU)
+#define VS_Y_HPHASE       (0x090 + G2D_VSU)
+#define VS_Y_VPHASE0      (0x098 + G2D_VSU)
+#define VS_C_SIZE         (0x0C0 + G2D_VSU)
+#define VS_C_HSTEP        (0x0C8 + G2D_VSU)
+#define VS_C_VSTEP        (0x0CC + G2D_VSU)
+#define VS_C_HPHASE       (0x0D0 + G2D_VSU)
+#define VS_C_VPHASE0      (0x0D8 + G2D_VSU)
+#define VS_Y_HCOEF0       (0x200 + G2D_VSU)
+#define VS_Y_VCOEF0       (0x300 + G2D_VSU)
+#define VS_C_HCOEF0       (0x400 + G2D_VSU)
+
+/* BLD register */
+#define BLD_EN_CTL         (0x000 + G2D_BLD)
+#define BLD_FILLC0         (0x010 + G2D_BLD)
+#define BLD_FILLC1         (0x014 + G2D_BLD)
+#define BLD_CH_ISIZE0      (0x020 + G2D_BLD)
+#define BLD_CH_ISIZE1      (0x024 + G2D_BLD)
+#define BLD_CH_OFFSET0     (0x030 + G2D_BLD)
+#define BLD_CH_OFFSET1     (0x034 + G2D_BLD)
+#define BLD_PREMUL_CTL     (0x040 + G2D_BLD)
+#define BLD_BK_COLOR       (0x044 + G2D_BLD)
+#define BLD_SIZE           (0x048 + G2D_BLD)
+#define BLD_CTL            (0x04C + G2D_BLD)
+#define BLD_KEY_CTL        (0x050 + G2D_BLD)
+#define BLD_KEY_CON        (0x054 + G2D_BLD)
+#define BLD_KEY_MAX        (0x058 + G2D_BLD)
+#define BLD_KEY_MIN        (0x05C + G2D_BLD)
+#define BLD_OUT_COLOR      (0x060 + G2D_BLD)
+#define ROP_CTL            (0x080 + G2D_BLD)
+#define ROP_INDEX0         (0x084 + G2D_BLD)
+#define ROP_INDEX1         (0x088 + G2D_BLD)
+#define BLD_CSC_CTL        (0x100 + G2D_BLD)
+#define BLD_CSC0_COEF00    (0x110 + G2D_BLD)
+#define BLD_CSC0_COEF01    (0x114 + G2D_BLD)
+#define BLD_CSC0_COEF02    (0x118 + G2D_BLD)
+#define BLD_CSC0_CONST0    (0x11C + G2D_BLD)
+#define BLD_CSC0_COEF10    (0x120 + G2D_BLD)
+#define BLD_CSC0_COEF11    (0x124 + G2D_BLD)
+#define BLD_CSC0_COEF12    (0x128 + G2D_BLD)
+#define BLD_CSC0_CONST1    (0x12C + G2D_BLD)
+#define BLD_CSC0_COEF20    (0x130 + G2D_BLD)
+#define BLD_CSC0_COEF21    (0x134 + G2D_BLD)
+#define BLD_CSC0_COEF22    (0x138 + G2D_BLD)
+#define BLD_CSC0_CONST2    (0x13C + G2D_BLD)
+#define BLD_CSC1_COEF00    (0x140 + G2D_BLD)
+#define BLD_CSC1_COEF01    (0x144 + G2D_BLD)
+#define BLD_CSC1_COEF02    (0x148 + G2D_BLD)
+#define BLD_CSC1_CONST0    (0x14C + G2D_BLD)
+#define BLD_CSC1_COEF10    (0x150 + G2D_BLD)
+#define BLD_CSC1_COEF11    (0x154 + G2D_BLD)
+#define BLD_CSC1_COEF12    (0x158 + G2D_BLD)
+#define BLD_CSC1_CONST1    (0x15C + G2D_BLD)
+#define BLD_CSC1_COEF20    (0x160 + G2D_BLD)
+#define BLD_CSC1_COEF21    (0x164 + G2D_BLD)
+#define BLD_CSC1_COEF22    (0x168 + G2D_BLD)
+#define BLD_CSC1_CONST2    (0x16C + G2D_BLD)
+#define BLD_CSC2_COEF00    (0x170 + G2D_BLD)
+#define BLD_CSC2_COEF01    (0x174 + G2D_BLD)
+#define BLD_CSC2_COEF02    (0x178 + G2D_BLD)
+#define BLD_CSC2_CONST0    (0x17C + G2D_BLD)
+#define BLD_CSC2_COEF10    (0x180 + G2D_BLD)
+#define BLD_CSC2_COEF11    (0x184 + G2D_BLD)
+#define BLD_CSC2_COEF12    (0x188 + G2D_BLD)
+#define BLD_CSC2_CONST1    (0x18C + G2D_BLD)
+#define BLD_CSC2_COEF20    (0x190 + G2D_BLD)
+#define BLD_CSC2_COEF21    (0x194 + G2D_BLD)
+#define BLD_CSC2_COEF22    (0x198 + G2D_BLD)
+#define BLD_CSC2_CONST2    (0x19C + G2D_BLD)
+
+/* WB register */
+#define WB_ATT             (0x00 + G2D_WB)
+#define WB_SIZE            (0x04 + G2D_WB)
+#define WB_PITCH0          (0x08 + G2D_WB)
+#define WB_PITCH1          (0x0C + G2D_WB)
+#define WB_PITCH2          (0x10 + G2D_WB)
+#define WB_LADD0           (0x14 + G2D_WB)
+#define WB_HADD0           (0x18 + G2D_WB)
+#define WB_LADD1           (0x1C + G2D_WB)
+#define WB_HADD1           (0x20 + G2D_WB)
+#define WB_LADD2           (0x24 + G2D_WB)
+#define WB_HADD2           (0x28 + G2D_WB)
+
+/* Rotate register */
+#define ROT_CTL            (0x00 + G2D_ROT)
+#define ROT_INT            (0x04 + G2D_ROT)
+#define ROT_TIMEOUT        (0x08 + G2D_ROT)
+#define ROT_IFMT           (0x20 + G2D_ROT)
+#define ROT_ISIZE          (0x24 + G2D_ROT)
+#define ROT_IPITCH0        (0x30 + G2D_ROT)
+#define ROT_IPITCH1        (0x34 + G2D_ROT)
+#define ROT_IPITCH2        (0x38 + G2D_ROT)
+#define ROT_ILADD0         (0x40 + G2D_ROT)
+#define ROT_IHADD0         (0x44 + G2D_ROT)
+#define ROT_ILADD1         (0x48 + G2D_ROT)
+#define ROT_IHADD1         (0x4C + G2D_ROT)
+#define ROT_ILADD2         (0x50 + G2D_ROT)
+#define ROT_IHADD2         (0x54 + G2D_ROT)
+#define ROT_OSIZE          (0x84 + G2D_ROT)
+#define ROT_OPITCH0        (0x90 + G2D_ROT)
+#define ROT_OPITCH1        (0x94 + G2D_ROT)
+#define ROT_OPITCH2        (0x98 + G2D_ROT)
+#define ROT_OLADD0         (0xA0 + G2D_ROT)
+#define ROT_OHADD0         (0xA4 + G2D_ROT)
+#define ROT_OLADD1         (0xA8 + G2D_ROT)
+#define ROT_OHADD1         (0xAC + G2D_ROT)
+#define ROT_OLADD2         (0xB0 + G2D_ROT)
+#define ROT_OHADD2         (0xB4 + G2D_ROT)
+
+/* #define write_wvalue(addr, data) m_usbwordwrite32(  addr, data ) */
+/* #define write_wvalue(addr, v) put_wvalue(addr, v) */
+/* #define read_wvalue(addr) get_wvalue(addr) */
+
+/* byte input */
+#define get_bvalue(n)	(*((volatile __u8 *)(n)))
+/* byte output */
+#define put_bvalue(n, c)	(*((volatile __u8 *)(n)) = (c))
+/* half word input */
+#define get_hvalue(n)	(*((volatile __u16 *)(n)))
+/* half word output */
+#define put_hvalue(n, c)	(*((volatile __u16 *)(n)) = (c))
+/* word input */
+#define get_wvalue(n)	(*((volatile __u32 *)(n)))
+/* word output */
+#define put_wvalue(n, c)	(*((volatile __u32 *)(n)) = (c))
+
+#endif /*
+ */
diff --git a/drivers/char/sunxi_g2d/g2d_trace.h b/drivers/char/sunxi_g2d/g2d_trace.h
new file mode 100644
index 000000000..c4f9dc0f0
--- /dev/null
+++ b/drivers/char/sunxi_g2d/g2d_trace.h
@@ -0,0 +1,45 @@
+/*
+ * Allwinner SoCs g2d driver.
+ *
+ * Copyright (C) 2020 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_INCLUDE_PATH ../../../drivers/char/sunxi_g2d
+#define TRACE_SYSTEM g2d_trace
+
+#if !defined(_TRACE_G2D_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_G2D_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(g2d_tracing,
+	TP_PROTO(int pid, const char *name, bool trace_begin),
+	TP_ARGS(pid, name, trace_begin),
+	TP_STRUCT__entry(
+		__field(int, pid)
+		__string(trace_name, name)
+		__field(bool, trace_begin)
+		),
+	TP_fast_assign(
+		__entry->pid = pid;
+		__assign_str(trace_name, name);
+		__entry->trace_begin = trace_begin;
+		),
+
+	TP_printk("%s|%d|%s", __entry->trace_begin ? "B" : "E",
+		__entry->pid, __get_str(trace_name))
+);
+
+#define G2D_TRACE_END(name)   trace_g2d_tracing(current->tgid, name, 0)
+#define G2D_TRACE_BEGIN(name) trace_g2d_tracing(current->tgid, name, 1)
+#define G2D_TRACE_FUNC()      G2D_TRACE_BEGIN(__func__)
+
+#endif
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/drivers/char/sunxi_g2d/syncfence.c b/drivers/char/sunxi_g2d/syncfence.c
new file mode 100644
index 000000000..757b91991
--- /dev/null
+++ b/drivers/char/sunxi_g2d/syncfence.c
@@ -0,0 +1,409 @@
+/*
+ * Allwinner SoCs display driver.
+ *
+ * Copyright (C) 2018 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+/*
+ * This driver is modified from sw_sync, because we cannot
+ * access sw_sync through debugfs after Android-11.
+ */
+
+#include <linux/dma-fence.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/sync_file.h>
+#include <linux/miscdevice.h>
+
+/*
+ * struct syncfence_create_data
+ * @value:	the seqno to initialise the fence with
+ * @name:	the name of the new sync point
+ * @fence:	return the fd of the new sync_file with the created fence
+ */
+struct syncfence_create_data {
+	__u32   value;
+	char    name[32];
+	__s32   fence;
+};
+
+#define SYNCFENCE_IOC_MAGIC	'Z'
+#define SYNCFENCE_IOC_CREATE_FENCE \
+	_IOWR(SYNCFENCE_IOC_MAGIC, 0, struct syncfence_create_data)
+#define SYNCFENCE_IOC_INC _IOW(SYNCFENCE_IOC_MAGIC, 1, __u32)
+
+struct fence_timeline {
+	struct kref ref;
+	char name[32];
+
+	u64 context;
+	int value;
+	struct list_head pt_list;
+	spinlock_t lock;
+
+	struct list_head timeline_list;
+};
+
+struct syncfence {
+	struct dma_fence base;
+	struct list_head link;
+};
+
+static LIST_HEAD(timeline_list_head);
+static DEFINE_SPINLOCK(timeline_list_lock);
+
+static const struct dma_fence_ops timeline_fence_ops;
+
+static inline struct syncfence *dma_fence_to_syncfence(struct dma_fence *fence)
+{
+	if (fence->ops != &timeline_fence_ops)
+		return NULL;
+	return container_of(fence, struct syncfence, base);
+}
+
+static inline struct fence_timeline *dma_fence_parent(struct dma_fence *fence)
+{
+	return container_of(fence->lock, struct fence_timeline, lock);
+}
+
+static struct fence_timeline *fence_timeline_create(const char *name)
+{
+	unsigned long flags;
+	struct fence_timeline *timeline;
+
+	timeline = kzalloc(sizeof(*timeline), GFP_KERNEL);
+	if (!timeline)
+		return NULL;
+
+	kref_init(&timeline->ref);
+	timeline->context = dma_fence_context_alloc(1);
+	strlcpy(timeline->name, name, sizeof(timeline->name));
+	INIT_LIST_HEAD(&timeline->pt_list);
+
+	/* add the new timeline into timeline_list_head */
+	spin_lock_irqsave(&timeline_list_lock, flags);
+	list_add_tail(&timeline->timeline_list, &timeline_list_head);
+	spin_unlock_irqrestore(&timeline_list_lock, flags);
+
+	return timeline;
+}
+
+static void fence_timeline_free(struct kref *ref)
+{
+	unsigned long flags;
+	struct fence_timeline *timeline =
+		container_of(ref, struct fence_timeline, ref);
+
+	/* remove it from timeline_list_head */
+	spin_lock_irqsave(&timeline_list_lock, flags);
+	list_del(&timeline->timeline_list);
+	spin_unlock_irqrestore(&timeline_list_lock, flags);
+
+	kfree(timeline);
+}
+
+static void fence_timeline_get(struct fence_timeline *timeline)
+{
+	kref_get(&timeline->ref);
+}
+
+static void fence_timeline_put(struct fence_timeline *timeline)
+{
+	kref_put(&timeline->ref, fence_timeline_free);
+}
+
+static const char *timeline_fence_get_driver_name(struct dma_fence *fence)
+{
+	return "syncfence";
+}
+
+static const char *timeline_fence_get_timeline_name(struct dma_fence *fence)
+{
+	struct fence_timeline *parent = dma_fence_parent(fence);
+	return parent->name;
+}
+
+static void timeline_fence_release(struct dma_fence *fence)
+{
+	unsigned long flags;
+	struct syncfence *sf = dma_fence_to_syncfence(fence);
+	struct fence_timeline *parent = dma_fence_parent(fence);
+
+	spin_lock_irqsave(fence->lock, flags);
+	if (!list_empty(&sf->link))
+		list_del(&sf->link);
+	spin_unlock_irqrestore(fence->lock, flags);
+
+	fence_timeline_put(parent);
+	dma_fence_free(fence);
+}
+
+static bool timeline_fence_signaled(struct dma_fence *fence)
+{
+	struct fence_timeline *parent = dma_fence_parent(fence);
+	return !__dma_fence_is_later(fence->seqno, parent->value, fence->ops);
+}
+
+static bool timeline_fence_enable_signaling(struct dma_fence *fence)
+{
+	return true;
+}
+
+static void timeline_fence_value_str(struct dma_fence *fence,
+		char *str, int size)
+{
+	snprintf(str, size, "%lld", fence->seqno);
+}
+
+static void timeline_fence_timeline_value_str(struct dma_fence *fence,
+		char *str, int size)
+{
+	struct fence_timeline *parent = dma_fence_parent(fence);
+	snprintf(str, size, "%d", parent->value);
+}
+
+static const struct dma_fence_ops timeline_fence_ops = {
+	.get_driver_name = timeline_fence_get_driver_name,
+	.get_timeline_name = timeline_fence_get_timeline_name,
+	.enable_signaling = timeline_fence_enable_signaling,
+	.signaled = timeline_fence_signaled,
+	.release = timeline_fence_release,
+	.fence_value_str = timeline_fence_value_str,
+	.timeline_value_str = timeline_fence_timeline_value_str,
+};
+
+static void fence_timeline_signal(struct fence_timeline *timeline, unsigned int inc)
+{
+	struct syncfence *pt, *next;
+
+	spin_lock_irq(&timeline->lock);
+
+	timeline->value += inc;
+
+	list_for_each_entry_safe(pt, next, &timeline->pt_list, link) {
+		if (!timeline_fence_signaled(&pt->base))
+			continue;
+
+		list_del_init(&pt->link);
+		dma_fence_signal_locked(&pt->base);
+	}
+
+	spin_unlock_irq(&timeline->lock);
+}
+
+static struct syncfence *syncfence_create(struct fence_timeline *timeline,
+		unsigned int value)
+{
+	struct syncfence *fence;
+
+	fence = kzalloc(sizeof(*fence), GFP_KERNEL);
+	if (!fence)
+		return NULL;
+
+	fence_timeline_get(timeline);
+	dma_fence_init(&fence->base, &timeline_fence_ops, &timeline->lock,
+			timeline->context, value);
+	INIT_LIST_HEAD(&fence->link);
+
+	spin_lock_irq(&timeline->lock);
+	if (!dma_fence_is_signaled_locked(&fence->base)) {
+		list_add_tail(&fence->link, &timeline->pt_list);
+	}
+
+	spin_unlock_irq(&timeline->lock);
+
+	return fence;
+}
+
+static int syncfence_open(struct inode *inode, struct file *file)
+{
+	struct fence_timeline *timeline;
+	char name[64];
+
+	sprintf(name, "syncfence-%d", task_pid_nr(current));
+	timeline = fence_timeline_create(name);
+	if (!timeline)
+		return -ENOMEM;
+
+	file->private_data = timeline;
+	return 0;
+}
+
+static int syncfence_release(struct inode *inode, struct file *file)
+{
+	struct fence_timeline *timeline = file->private_data;
+	struct syncfence *fence, *next;
+
+	spin_lock_irq(&timeline->lock);
+
+	list_for_each_entry_safe(fence, next, &timeline->pt_list, link) {
+		dma_fence_set_error(&fence->base, -ENOENT);
+		dma_fence_signal_locked(&fence->base);
+	}
+
+	spin_unlock_irq(&timeline->lock);
+
+	fence_timeline_put(timeline);
+	return 0;
+}
+
+static long syncfence_ioctl_create_fence(struct fence_timeline *timeline,
+		unsigned long arg)
+{
+	int fd = get_unused_fd_flags(O_CLOEXEC);
+	int err;
+	struct syncfence *fence;
+	struct sync_file *sync_file;
+	struct syncfence_create_data data;
+
+	if (fd < 0)
+		return fd;
+
+	if (copy_from_user(&data, (void __user *)arg, sizeof(data))) {
+		err = -EFAULT;
+		goto err;
+	}
+
+	fence = syncfence_create(timeline, data.value);
+	if (!fence) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+	sync_file = sync_file_create(&fence->base);
+	dma_fence_put(&fence->base);
+	if (!sync_file) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+	data.fence = fd;
+	if (copy_to_user((void __user *)arg, &data, sizeof(data))) {
+		fput(sync_file->file);
+		err = -EFAULT;
+		goto err;
+	}
+
+	fd_install(fd, sync_file->file);
+
+	return 0;
+
+err:
+	put_unused_fd(fd);
+	return err;
+}
+
+static long syncfence_ioctl_inc(struct fence_timeline *timeline, unsigned long arg)
+{
+	u32 value;
+
+	if (copy_from_user(&value, (void __user *)arg, sizeof(value)))
+		return -EFAULT;
+
+	while (value > INT_MAX)  {
+		fence_timeline_signal(timeline, INT_MAX);
+		value -= INT_MAX;
+	}
+
+	fence_timeline_signal(timeline, value);
+
+	return 0;
+}
+
+static long syncfence_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	struct fence_timeline *timeline = file->private_data;
+
+	switch (cmd) {
+	case SYNCFENCE_IOC_CREATE_FENCE:
+		return syncfence_ioctl_create_fence(timeline, arg);
+
+	case SYNCFENCE_IOC_INC:
+		return syncfence_ioctl_inc(timeline, arg);
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+static ssize_t syncfence_debug_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned long flags;
+	ssize_t printed_count = 0;
+	struct fence_timeline *timeline, *next_timeline;
+	struct syncfence *pt, *next;
+
+	spin_lock_irqsave(&timeline_list_lock, flags);
+
+	list_for_each_entry_safe(timeline, next_timeline, &timeline_list_head, timeline_list) {
+		printed_count += snprintf(buf+printed_count, PAGE_SIZE-printed_count,
+				"\n+ timeline: %s [%d]:\n", timeline->name, timeline->value);
+
+		spin_lock_irq(&timeline->lock);
+		list_for_each_entry_safe(pt, next, &timeline->pt_list, link) {
+			bool signaled = timeline_fence_signaled(&pt->base);
+
+			printed_count += snprintf(buf+printed_count, PAGE_SIZE-printed_count,
+					"\t%lld [%d]\n", pt->base.seqno, signaled);
+		}
+		spin_unlock_irq(&timeline->lock);
+	}
+
+	spin_unlock_irqrestore(&timeline_list_lock, flags);
+	return printed_count;
+}
+
+static DEVICE_ATTR(debug, 0444, syncfence_debug_show, NULL);
+
+static struct attribute *syncfence_attrs[] = {
+	&dev_attr_debug.attr,
+	NULL
+};
+
+static const struct attribute_group syncfence_attr_group = {
+	.attrs = syncfence_attrs
+};
+
+static const struct attribute_group *syncfence_attr_groups[] = {
+	&syncfence_attr_group,
+	NULL
+};
+
+static struct file_operations syncfence_ops = {
+	.owner          = THIS_MODULE,
+	.open           = syncfence_open,
+	.release        = syncfence_release,
+	.unlocked_ioctl = syncfence_ioctl,
+	.compat_ioctl   = syncfence_ioctl,
+};
+
+struct miscdevice syncfence_device = {
+	.minor  = MISC_DYNAMIC_MINOR,
+	.name   = "syncfence",
+	.fops   = &syncfence_ops,
+	.groups = syncfence_attr_groups,
+};
+
+int syncfence_init(void)
+{
+	int result = 0;
+	result = misc_register(&syncfence_device);
+	if (result)
+		pr_err("Error %d adding syncfence", result);
+	return 0;
+}
+
+void syncfence_exit(void)
+{
+	misc_deregister(&syncfence_device);
+}
+
diff --git a/drivers/char/sunxi_standby/Kconfig b/drivers/char/sunxi_standby/Kconfig
new file mode 100644
index 000000000..167a11271
--- /dev/null
+++ b/drivers/char/sunxi_standby/Kconfig
@@ -0,0 +1,13 @@
+#
+# sunxi standby debug config.
+#
+
+config SUNXI_STANDBY_DEBUG
+	tristate "sunxi standby debug driver"
+	depends on ARCH_SUNXI && PM && (ARM || ARM64)
+	default y
+	---help---
+	  Say y here if you want to support standby debug module.
+	  The standby debug module is used to debug system suspend.
+	  When in doubt, say "Y".
+
diff --git a/drivers/char/sunxi_standby/Makefile b/drivers/char/sunxi_standby/Makefile
new file mode 100644
index 000000000..c61d010f1
--- /dev/null
+++ b/drivers/char/sunxi_standby/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_SUNXI_STANDBY_DEBUG) += sunxi_standby.o
diff --git a/drivers/char/sunxi_standby/sunxi_standby.c b/drivers/char/sunxi_standby/sunxi_standby.c
new file mode 100644
index 000000000..84c046658
--- /dev/null
+++ b/drivers/char/sunxi_standby/sunxi_standby.c
@@ -0,0 +1,133 @@
+/*
+ *
+ * Copyright (c) 2012 Allwinner.
+ * 2012-05-01 Written by sunny (sunny@allwinnertech.com).
+ * 2012-10-01 Written by superm (superm@allwinnertech.com).
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/module.h>
+#include <linux/device.h>
+#include <soc/allwinner/sunxi_sip.h>
+
+static u32 time_to_wakeup_ms;
+static u32 debug_dram_crc_en;
+static u32 debug_dram_crc_srcaddr = 0x40000000;
+static u32 debug_dram_crc_len = (1024 * 1024);
+
+static ssize_t time_to_wakeup_ms_show(struct class *class, struct class_attribute *attr,
+		char *buf)
+{
+	ssize_t size = 0;
+
+	size = sprintf(buf, "%u\n", time_to_wakeup_ms);
+
+	return size;
+}
+
+static ssize_t time_to_wakeup_ms_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	u32 value = 0;
+	int ret;
+
+	ret = kstrtoint(buf, 10, &value);
+	if (ret) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	time_to_wakeup_ms = value;
+
+	invoke_scp_fn_smc(SET_WAKEUP_SRC,
+			SET_WAKEUP_TIME_MS(time_to_wakeup_ms), 0, 0);
+
+	pr_info("time_to_wakeup_ms change to %d\n", time_to_wakeup_ms);
+
+	return count;
+}
+static CLASS_ATTR_RW(time_to_wakeup_ms);
+
+static ssize_t dram_crc_paras_show(struct class *class, struct class_attribute *attr,
+			 char *buf)
+{
+	ssize_t size = 0;
+
+	size = sprintf(buf, "enable:0x%x srcaddr:0x%x lenght:0x%x\n", debug_dram_crc_en,
+			debug_dram_crc_srcaddr, debug_dram_crc_len);
+
+	return size;
+}
+
+static ssize_t dram_crc_paras_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	u32 dram_crc_en      = 0;
+	u32 dram_crc_srcaddr = 0;
+	u32 dram_crc_len     = 0;
+
+	sscanf(buf, "%x %x %x\n", &dram_crc_en, &dram_crc_srcaddr, &dram_crc_len);
+
+	if ((dram_crc_en != 0) && (dram_crc_en != 1)) {
+		pr_err("invalid debug dram crc paras [%x] [%x] [%x] to set\n",
+			dram_crc_en, dram_crc_srcaddr, dram_crc_len);
+
+		return count;
+	}
+
+	debug_dram_crc_en = dram_crc_en;
+	debug_dram_crc_srcaddr = dram_crc_srcaddr;
+	debug_dram_crc_len = dram_crc_len;
+	invoke_scp_fn_smc(SET_DEBUG_DRAM_CRC_PARAS,
+			debug_dram_crc_en,
+			debug_dram_crc_srcaddr,
+			debug_dram_crc_len);
+	pr_info("dram_crc_en=0x%x, dram_crc_srcaddr=0x%x, dram_crc_len=0x%x\n",
+		debug_dram_crc_en, debug_dram_crc_srcaddr, debug_dram_crc_len);
+
+	return count;
+}
+static CLASS_ATTR_RW(dram_crc_paras);
+
+static struct attribute *sunxi_standby_class_attrs[] = {
+	&class_attr_time_to_wakeup_ms.attr,
+	&class_attr_dram_crc_paras.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(sunxi_standby_class);
+
+struct class sunxi_standby_class = {
+	.name = "sunxi_standby",
+	.class_groups = sunxi_standby_class_groups,
+};
+
+static int __init sunxi_standby_debug_init(void)
+{
+	int ret;
+
+	ret = class_register(&sunxi_standby_class);
+	if (ret < 0)
+		pr_err("%s,%d err, ret:%d\n", __func__, __LINE__, ret);
+
+	return ret;
+}
+
+static void __exit sunxi_standby_debug_exit(void)
+{
+	class_unregister(&sunxi_standby_class);
+}
+
+module_init(sunxi_standby_debug_init);
+module_exit(sunxi_standby_debug_exit);
+
+MODULE_DESCRIPTION("SUNXI STANDBY DEBUG");
+MODULE_LICENSE("GPL");
-- 
2.17.1

