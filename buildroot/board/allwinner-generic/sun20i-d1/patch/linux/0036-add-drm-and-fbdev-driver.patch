From 031da646942b4a020b9e757e413e4509e2348d2a Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 16:56:48 +0800
Subject: [PATCH 36/93] add drm and fbdev driver

---
 drivers/gpu/Makefile                          |    1 +
 drivers/gpu/drm/Kconfig                       |    4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c    |    2 -
 drivers/gpu/drm/bochs/bochs_kms.c             |    1 -
 drivers/gpu/drm/bridge/Kconfig                |    8 +
 drivers/gpu/drm/bridge/Makefile               |    1 +
 drivers/gpu/drm/bridge/adv7511/adv7511_drv.c  |    3 +
 drivers/gpu/drm/bridge/lt9611.c               | 1140 +++++++++++++++
 drivers/gpu/drm/drm_connector.c               |  101 +-
 drivers/gpu/drm/drm_dp_helper.c               |   59 +
 drivers/gpu/drm/drm_edid.c                    |   24 +-
 drivers/gpu/drm/drm_fb_helper.c               |    6 +-
 drivers/gpu/drm/drm_file.c                    |    7 +
 drivers/gpu/drm/drm_framebuffer.c             |    3 +-
 drivers/gpu/drm/drm_ioctl.c                   |    6 +-
 drivers/gpu/drm/drm_mipi_dsi.c                |    1 +
 drivers/gpu/drm/drm_modes.c                   |    1 +
 drivers/gpu/drm/drm_panel.c                   |   22 +
 drivers/gpu/drm/drm_prime.c                   |   23 +
 drivers/gpu/drm/drm_property.c                |   14 +-
 drivers/gpu/drm/hisilicon/kirin/Kconfig       |   32 +-
 drivers/gpu/drm/hisilicon/kirin/Makefile      |   14 +-
 drivers/gpu/drm/hisilicon/kirin/dw_dsi_reg.h  |   46 +-
 .../drm/hisilicon/kirin/kirin/dw_drm_dsi.c    |  656 +++++++++
 .../drm/hisilicon/kirin/kirin960/dw_drm_dsi.c | 1220 ++++++++++++++++
 .../gpu/drm/hisilicon/kirin/kirin_ade_reg.h   |    4 +-
 .../gpu/drm/hisilicon/kirin/kirin_dpe_reg.h   |  393 ++++++
 .../gpu/drm/hisilicon/kirin/kirin_drm_dpe.c   | 1233 +++++++++++++++++
 .../gpu/drm/hisilicon/kirin/kirin_drm_drv.c   |    7 +
 .../gpu/drm/hisilicon/kirin/kirin_drm_drv.h   |    5 +
 .../gpu/drm/hisilicon/kirin/kirin_drm_dsi.c   |  444 ++++++
 .../gpu/drm/hisilicon/kirin/kirin_drm_dsi.h   |  259 ++++
 drivers/gpu/drm/i915/Kconfig                  |    2 +-
 .../gpu/drm/i915/display/intel_connector.c    |    2 +-
 drivers/gpu/drm/i915/display/intel_panel.c    |    2 +-
 drivers/gpu/drm/msm/adreno/a6xx_gmu.c         |  112 +-
 drivers/gpu/drm/msm/adreno/a6xx_gmu.h         |    7 +-
 drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c     |   12 +-
 drivers/gpu/drm/virtio/virtgpu_display.c      |    5 -
 drivers/gpu/drm/virtio/virtgpu_plane.c        |   48 +-
 drivers/gpu/trace/Kconfig                     |    4 +
 drivers/gpu/trace/Makefile                    |    3 +
 drivers/gpu/trace/trace_gpu_mem.c             |   13 +
 43 files changed, 5785 insertions(+), 165 deletions(-)
 create mode 100644 drivers/gpu/drm/bridge/lt9611.c
 create mode 100644 drivers/gpu/drm/hisilicon/kirin/kirin/dw_drm_dsi.c
 create mode 100644 drivers/gpu/drm/hisilicon/kirin/kirin960/dw_drm_dsi.c
 create mode 100644 drivers/gpu/drm/hisilicon/kirin/kirin_dpe_reg.h
 create mode 100644 drivers/gpu/drm/hisilicon/kirin/kirin_drm_dpe.c
 create mode 100644 drivers/gpu/drm/hisilicon/kirin/kirin_drm_dsi.c
 create mode 100644 drivers/gpu/drm/hisilicon/kirin/kirin_drm_dsi.h
 create mode 100644 drivers/gpu/trace/Kconfig
 create mode 100644 drivers/gpu/trace/Makefile
 create mode 100644 drivers/gpu/trace/trace_gpu_mem.c

diff --git a/drivers/gpu/Makefile b/drivers/gpu/Makefile
index f17d01f07..835c88318 100644
--- a/drivers/gpu/Makefile
+++ b/drivers/gpu/Makefile
@@ -5,3 +5,4 @@
 obj-$(CONFIG_TEGRA_HOST1X)	+= host1x/
 obj-y			+= drm/ vga/
 obj-$(CONFIG_IMX_IPUV3_CORE)	+= ipu-v3/
+obj-$(CONFIG_TRACE_GPU_MEM)		+= trace/
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index e67c194c2..6c300f636 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -6,7 +6,7 @@
 # Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
 #
 menuconfig DRM
-	tristate "Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)"
+	bool "Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)"
 	depends on (AGP || AGP=n) && !EMULATED_CMPXCHG && HAS_DMA
 	select DRM_PANEL_ORIENTATION_QUIRKS
 	select HDMI
@@ -55,7 +55,7 @@ config DRM_DEBUG_MM
 	  If in doubt, say "N".
 
 config DRM_DEBUG_SELFTEST
-	tristate "kselftests for DRM"
+	bool "kselftests for DRM"
 	depends on DRM
 	depends on DEBUG_KERNEL
 	select PRIME_NUMBERS
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 5e1dce424..6e8bda88b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -2176,8 +2176,6 @@ static int amdgpu_device_ip_suspend_phase1(struct amdgpu_device *adev)
 {
 	int i, r;
 
-	amdgpu_device_set_pg_state(adev, AMD_PG_STATE_UNGATE);
-	amdgpu_device_set_cg_state(adev, AMD_CG_STATE_UNGATE);
 
 	for (i = adev->num_ip_blocks - 1; i >= 0; i--) {
 		if (!adev->ip_blocks[i].status.valid)
diff --git a/drivers/gpu/drm/bochs/bochs_kms.c b/drivers/gpu/drm/bochs/bochs_kms.c
index fa50ab252..02a9c1ed1 100644
--- a/drivers/gpu/drm/bochs/bochs_kms.c
+++ b/drivers/gpu/drm/bochs/bochs_kms.c
@@ -194,7 +194,6 @@ int bochs_kms_init(struct bochs_device *bochs)
 	bochs->dev->mode_config.preferred_depth = 24;
 	bochs->dev->mode_config.prefer_shadow = 0;
 	bochs->dev->mode_config.prefer_shadow_fbdev = 1;
-	bochs->dev->mode_config.fbdev_use_iomem = true;
 	bochs->dev->mode_config.quirk_addfb_prefer_host_byte_order = true;
 
 	bochs->dev->mode_config.funcs = &bochs_mode_funcs;
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 1cc9f502c..441350fcc 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -45,6 +45,14 @@ config DRM_DUMB_VGA_DAC
 	  Support for non-programmable RGB to VGA DAC bridges, such as ADI
 	  ADV7123, TI THS8134 and THS8135 or passive resistor ladder DACs.
 
+config DRM_LONTIUM_LT9611
+	tristate "Lontium LT9611 DSI/HDMI bridge"
+	depends on OF
+	select DRM_PANEL_BRIDGE
+	select DRM_KMS_HELPER
+	help
+	  Lontium LT9611 DSI/HDMI bridge chip driver.
+
 config DRM_LVDS_ENCODER
 	tristate "Transparent parallel to LVDS encoder support"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 4934fcf5a..8b1d176da 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -2,6 +2,7 @@
 obj-$(CONFIG_DRM_ANALOGIX_ANX78XX) += analogix-anx78xx.o
 obj-$(CONFIG_DRM_CDNS_DSI) += cdns-dsi.o
 obj-$(CONFIG_DRM_DUMB_VGA_DAC) += dumb-vga-dac.o
+obj-$(CONFIG_DRM_LONTIUM_LT9611) += lt9611.o
 obj-$(CONFIG_DRM_LVDS_ENCODER) += lvds-encoder.o
 obj-$(CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW) += megachips-stdpxxxx-ge-b850v3-fw.o
 obj-$(CONFIG_DRM_NXP_PTN3460) += nxp-ptn3460.o
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
index 9e13e466e..f9e07b46d 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -356,6 +356,9 @@ static void __adv7511_power_on(struct adv7511 *adv7511)
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
 			   ADV7511_REG_POWER2_HPD_SRC_MASK,
 			   ADV7511_REG_POWER2_HPD_SRC_NONE);
+
+	/* HACK: If we don't delay here edid probing doesn't work properly */
+	msleep(200);
 }
 
 static void adv7511_power_on(struct adv7511 *adv7511)
diff --git a/drivers/gpu/drm/bridge/lt9611.c b/drivers/gpu/drm/bridge/lt9611.c
new file mode 100644
index 000000000..5ee6dbf97
--- /dev/null
+++ b/drivers/gpu/drm/bridge/lt9611.c
@@ -0,0 +1,1140 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019. Linaro Ltd
+ */
+
+#define DEBUG
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio/consumer.h>
+#include <linux/regmap.h>
+#include <linux/interrupt.h>
+#include <linux/component.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/of_irq.h>
+#include <linux/regulator/consumer.h>
+#include <drm/drm_probe_helper.h>
+#include <linux/hdmi.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_print.h>
+
+#define EDID_SEG_SIZE 256
+
+#define LT9611_4LANES	0
+
+struct lt9611 {
+	struct device *dev;
+	struct drm_bridge bridge;
+	struct drm_connector connector;
+
+	struct regmap *regmap;
+
+	struct device_node *dsi0_node;
+	struct device_node *dsi1_node;
+	struct mipi_dsi_device *dsi0;
+	struct mipi_dsi_device *dsi1;
+
+	bool ac_mode;
+
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *enable_gpio;
+
+	bool power_on;
+
+	struct regulator_bulk_data supplies[2];
+
+	struct i2c_client *client;
+
+	enum drm_connector_status status;
+
+	u8 edid_buf[EDID_SEG_SIZE];
+	u32 vic;
+};
+
+static const struct regmap_config lt9611_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE,
+};
+
+struct lt9611_mode {
+	u16 hdisplay;
+	u16 vdisplay;
+	u8 fps;
+	u8 lanes;
+	u8 intfs;
+};
+
+static struct lt9611_mode lt9611_modes[] = {
+	{ 3840, 2160, 30, 4, 2 }, /* 3840x2160 24bit 30Hz 4Lane 2ports */
+	{ 1920, 1080, 60, 4, 1 }, /* 1080P 24bit 60Hz 4lane 1port */
+	{ 1920, 1080, 30, 3, 1 }, /* 1080P 24bit 30Hz 3lane 1port */
+	{ 1920, 1080, 24, 3, 1 },
+	{ 720, 480, 60, 4, 1 },
+	{ 720, 576, 50, 2, 1 },
+	{ 640, 480, 60, 2, 1 },
+};
+
+static struct lt9611 *bridge_to_lt9611(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct lt9611, bridge);
+}
+
+static struct lt9611 *connector_to_lt9611(struct drm_connector *connector)
+{
+	return container_of(connector, struct lt9611, connector);
+}
+
+static int lt9611_mipi_input_analog(struct lt9611 *lt9611)
+{
+	struct reg_sequence reg_cfg[] = {
+		{ 0xff, 0x81 },
+		{ 0x06, 0x40 }, /*port A rx current*/
+		{ 0x0a, 0xfe }, /*port A ldo voltage set*/
+		{ 0x0b, 0xbf }, /*enable port A lprx*/
+		{ 0x11, 0x40 }, /*port B rx current*/
+		{ 0x15, 0xfe }, /*port B ldo voltage set*/
+		{ 0x16, 0xbf }, /*enable port B lprx*/
+
+		{ 0x1c, 0x03 }, /*PortA clk lane no-LP mode*/
+		{ 0x20, 0x03 }, /*PortB clk lane with-LP mode*/
+	};
+
+	regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+
+	return 0;
+}
+
+static int lt9611_mipi_input_digital(struct lt9611 *lt9611,
+				     const struct drm_display_mode *mode)
+{
+	struct reg_sequence reg_cfg[] = {
+		{ 0xff, 0x82 },
+		{ 0x4f, 0x80 },
+		{ 0x50, 0x10 },
+		{ 0xff, 0x83 },
+
+		{ 0x02, 0x0a },
+		{ 0x06, 0x0a },
+	};
+
+	regmap_write(lt9611->regmap, 0xff, 0x83);
+	regmap_write(lt9611->regmap, 0x00, LT9611_4LANES);
+
+	if (mode->hdisplay == 3840)
+		regmap_write(lt9611->regmap, 0x0a, 0x03);
+	else
+		regmap_write(lt9611->regmap, 0x0a, 0x00);
+
+	regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+
+	return 0;
+}
+
+static void lt9611_mipi_video_setup(struct lt9611 *lt9611,
+				    const struct drm_display_mode *mode)
+{
+	u32 h_total, h_act, hpw, hfp, hss;
+	u32 v_total, v_act, vpw, vfp, vss;
+
+	h_total = mode->htotal;
+	v_total = mode->vtotal;
+
+	h_act = mode->hdisplay;
+	hpw = mode->hsync_end - mode->hsync_start;
+	hfp = mode->hsync_start - mode->hdisplay;
+	hss = (mode->hsync_end - mode->hsync_start) + (mode->htotal - mode->hsync_end);
+
+	v_act = mode->vdisplay;
+	vpw = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vss = (mode->vsync_end - mode->vsync_start) + (mode->vtotal - mode->vsync_end);
+
+	regmap_write(lt9611->regmap, 0xff, 0x83);
+
+	regmap_write(lt9611->regmap, 0x0d, (u8)(v_total / 256));
+	regmap_write(lt9611->regmap, 0x0e, (u8)(v_total % 256));
+
+	regmap_write(lt9611->regmap, 0x0f, (u8)(v_act / 256));
+	regmap_write(lt9611->regmap, 0x10, (u8)(v_act % 256));
+
+	regmap_write(lt9611->regmap, 0x11, (u8)(h_total / 256));
+	regmap_write(lt9611->regmap, 0x12, (u8)(h_total % 256));
+
+	regmap_write(lt9611->regmap, 0x13, (u8)(h_act / 256));
+	regmap_write(lt9611->regmap, 0x14, (u8)(h_act % 256));
+
+	regmap_write(lt9611->regmap, 0x15, (u8)(vpw % 256));
+	regmap_write(lt9611->regmap, 0x16, (u8)(hpw % 256));
+
+	regmap_write(lt9611->regmap, 0x17, (u8)(vfp % 256));
+
+	regmap_write(lt9611->regmap, 0x18, (u8)(vss % 256));
+
+	regmap_write(lt9611->regmap, 0x19, (u8)(hfp % 256));
+
+	regmap_write(lt9611->regmap, 0x1a, (u8)(hss / 256));
+	regmap_write(lt9611->regmap, 0x1b, (u8)(hss % 256));
+}
+
+static int lt9611_pcr_setup(struct lt9611 *lt9611,
+			    const struct drm_display_mode *mode)
+{
+	struct reg_sequence reg_cfg[] = {
+		{ 0xff, 0x83 },
+		{ 0x0b, 0x01 },
+		{ 0x0c, 0x10 },
+		{ 0x48, 0x00 },
+		{ 0x49, 0x81 },
+
+		/* stage 1 */
+		{ 0x21, 0x4a },
+		{ 0x24, 0x71 },
+		{ 0x25, 0x30 },
+		{ 0x2a, 0x01 },
+
+		/* stage 2 */
+		{ 0x4a, 0x40 },
+		{ 0x1d, 0x10 },
+
+		/* MK limit */
+		{ 0x2d, 0x38 },
+		{ 0x31, 0x08 },
+	};
+
+	regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+
+	switch (mode->hdisplay) {
+	case 640:
+		regmap_write(lt9611->regmap, 0x26, 0x14);
+		break;
+	case 1920:
+		regmap_write(lt9611->regmap, 0x26, 0x37);
+		break;
+	case 3840:
+		regmap_write(lt9611->regmap, 0x0b, 0x03);
+		regmap_write(lt9611->regmap, 0x0c, 0xd0);
+		regmap_write(lt9611->regmap, 0x48, 0x03);
+		regmap_write(lt9611->regmap, 0x49, 0xe0);
+		regmap_write(lt9611->regmap, 0x24, 0x72);
+		regmap_write(lt9611->regmap, 0x25, 0x00);
+		regmap_write(lt9611->regmap, 0x2a, 0x01);
+		regmap_write(lt9611->regmap, 0x4a, 0x10);
+		regmap_write(lt9611->regmap, 0x1d, 0x10);
+		regmap_write(lt9611->regmap, 0x26, 0x37);
+		break;
+	}
+
+	/* pcr rst */
+	regmap_write(lt9611->regmap, 0xff, 0x80);
+	regmap_write(lt9611->regmap, 0x11, 0x5a);
+	regmap_write(lt9611->regmap, 0x11, 0xfa);
+
+	return 0;
+}
+
+static int lt9611_pll_setup(struct lt9611 *lt9611,
+			    const struct drm_display_mode *mode)
+{
+	unsigned int pclk = mode->clock;
+	struct reg_sequence reg_cfg[] = {
+		/* txpll init */
+		{ 0xff, 0x81 },
+		{ 0x23, 0x40 },
+		{ 0x24, 0x64 },
+		{ 0x25, 0x80 },
+		{ 0x26, 0x55 },
+		{ 0x2c, 0x37 },
+		{ 0x2f, 0x01 },
+		{ 0x26, 0x55 },
+		{ 0x27, 0x66 },
+		{ 0x28, 0x88 },
+	};
+
+	regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+
+	if (pclk > 150000)
+		regmap_write(lt9611->regmap, 0x2d, 0x88);
+	else if (pclk > 70000)
+		regmap_write(lt9611->regmap, 0x2d, 0x99);
+	else
+		regmap_write(lt9611->regmap, 0x2d, 0xaa);
+
+	regmap_write(lt9611->regmap, 0xff, 0x82);
+	regmap_write(lt9611->regmap, 0xe3, pclk >> 17); /* pclk[19:16] */
+	regmap_write(lt9611->regmap, 0xe4, pclk >> 9);  /* pclk[15:8]  */
+	regmap_write(lt9611->regmap, 0xe5, pclk >> 1);  /* pclk[7:0]   */
+
+	regmap_write(lt9611->regmap, 0xde, 0x20);
+	regmap_write(lt9611->regmap, 0xde, 0xe0);
+
+	regmap_write(lt9611->regmap, 0xff, 0x80);
+	regmap_write(lt9611->regmap, 0x16, 0xf1);
+	regmap_write(lt9611->regmap, 0x16, 0xf3);
+
+	return 0;
+}
+
+static int lt9611_video_check(struct lt9611 *lt9611)
+{
+	u32 v_total, v_act, h_act_a, h_act_b, h_total_sysclk;
+	unsigned int temp;
+	int ret;
+
+	/* top module video check */
+	regmap_write(lt9611->regmap, 0xff, 0x82);
+
+	/* v_act */
+	ret = regmap_read(lt9611->regmap, 0x82, &temp);
+	if (ret)
+		goto end;
+
+	v_act = temp << 8;
+	ret = regmap_read(lt9611->regmap, 0x83, &temp);
+	if (ret)
+		goto end;
+	v_act = v_act + temp;
+
+	/* v_total */
+	ret = regmap_read(lt9611->regmap, 0x6c, &temp);
+	if (ret)
+		goto end;
+	v_total = temp << 8;
+	ret = regmap_read(lt9611->regmap, 0x6d, &temp);
+	if (ret)
+		goto end;
+	v_total = v_total + temp;
+
+	/* h_total_sysclk */
+	ret = regmap_read(lt9611->regmap, 0x86, &temp);
+	if (ret)
+		goto end;
+	h_total_sysclk = temp << 8;
+	ret = regmap_read(lt9611->regmap, 0x87, &temp);
+	if (ret)
+		goto end;
+	h_total_sysclk = h_total_sysclk + temp;
+
+	/* h_act_a */
+	regmap_write(lt9611->regmap, 0xff, 0x83);
+	ret = regmap_read(lt9611->regmap, 0x82, &temp);
+	if (ret)
+		goto end;
+	h_act_a = temp << 8;
+	ret = regmap_read(lt9611->regmap, 0x83, &temp);
+	if (ret)
+		goto end;
+	h_act_a = (h_act_a + temp)/3;
+
+	/* h_act_b */
+	regmap_write(lt9611->regmap, 0xff, 0x83);
+	ret = regmap_read(lt9611->regmap, 0x86, &temp);
+	if (ret)
+		goto end;
+	h_act_b = temp << 8;
+	ret = regmap_read(lt9611->regmap, 0x87, &temp);
+	if (ret)
+		goto end;
+	h_act_b = (h_act_b + temp)/3;
+
+	dev_info(lt9611->dev, "video check: h_act_a=%d, h_act_b=%d, v_act=%d, v_total=%d, h_total_sysclk=%d\n",
+		h_act_a, h_act_b, v_act, v_total, h_total_sysclk);
+
+	return 0;
+
+end:
+	dev_err(lt9611->dev, "read video check error\n");
+	return ret;
+}
+
+static void lt9611_hdmi_tx_digital(struct lt9611 *lt9611)
+{
+	regmap_write(lt9611->regmap, 0xff, 0x84);
+	regmap_write(lt9611->regmap, 0x43, 0x46 - lt9611->vic);
+	regmap_write(lt9611->regmap, 0x44, 0x84);
+	regmap_write(lt9611->regmap, 0x47, lt9611->vic);
+
+	regmap_write(lt9611->regmap, 0xff, 0x82);
+	regmap_write(lt9611->regmap, 0xd6, 0x8c);
+	regmap_write(lt9611->regmap, 0xd7, 0x04);
+}
+
+static void lt9611_hdmi_tx_phy(struct lt9611 *lt9611)
+{
+	struct reg_sequence reg_cfg[] = {
+		{ 0xff, 0x81 },
+		{ 0x30, 0x6a },
+		{ 0x31, 0x44 }, /* HDMI DC mode */
+		{ 0x32, 0x4a },
+		{ 0x33, 0x0b },
+		{ 0x34, 0x00 },
+		{ 0x35, 0x00 },
+		{ 0x36, 0x00 },
+		{ 0x37, 0x44 },
+		{ 0x3f, 0x0f },
+		{ 0x40, 0xa0 },
+		{ 0x41, 0xa0 },
+		{ 0x42, 0xa0 },
+		{ 0x43, 0xa0 },
+		{ 0x44, 0x0a },
+	};
+
+	/* HDMI AC mode */
+	if (lt9611->ac_mode)
+		reg_cfg[2].def = 0x73;
+
+	regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+}
+
+static irqreturn_t lt9611_irq_thread_handler(int irq, void *dev_id)
+{
+	struct lt9611 *lt9611 = dev_id;
+	unsigned int irq_flag0 = 0;
+	unsigned int irq_flag3 = 0;
+
+	regmap_write(lt9611->regmap, 0xff, 0x82);
+	regmap_read(lt9611->regmap, 0x0f, &irq_flag3);
+	regmap_read(lt9611->regmap, 0x0c, &irq_flag0);
+
+	printk(KERN_ERR "%s() irq_flag0: %#x irq_flag3: %#x\n", __func__, irq_flag0, irq_flag3);
+
+	 /* hpd changed low */
+	if (irq_flag3 & 0x80) {
+		dev_info(lt9611->dev, "hdmi cable disconnected\n");
+
+		regmap_write(lt9611->regmap, 0xff, 0x82); /* irq 3 clear flag */
+		regmap_write(lt9611->regmap, 0x07, 0xbf);
+		regmap_write(lt9611->regmap, 0x07, 0x3f);
+	}
+	 /* hpd changed high */
+	if (irq_flag3 & 0x40) {
+		dev_info(lt9611->dev, "hdmi cable connected\n");
+
+		regmap_write(lt9611->regmap, 0xff, 0x82); /* irq 3 clear flag */
+		regmap_write(lt9611->regmap, 0x07, 0x7f);
+		regmap_write(lt9611->regmap, 0x07, 0x3f);
+	}
+
+//	if (irq_flag3 & 0xc0)
+//		drm_kms_helper_hotplug_event(lt9611->bridge.dev);
+
+	/* video input changed */
+	if (irq_flag0 & 0x01) {
+		dev_info(lt9611->dev, "video input changed\n");
+		regmap_write(lt9611->regmap, 0xff, 0x82); /* irq 0 clear flag */
+		regmap_write(lt9611->regmap, 0x9e, 0xff);
+		regmap_write(lt9611->regmap, 0x9e, 0xf7);
+		regmap_write(lt9611->regmap, 0x04, 0xff);
+		regmap_write(lt9611->regmap, 0x04, 0xfe);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void lt9611_enable_hpd_interrupts(struct lt9611 *lt9611)
+{
+	unsigned int val;
+
+	dev_dbg(lt9611->dev, "enabling hpd interrupts\n");
+
+	regmap_write(lt9611->regmap, 0xff, 0x82);
+	regmap_read(lt9611->regmap, 0x03, &val);
+
+	val &= ~0xc0;
+	regmap_write(lt9611->regmap, 0x03, val);
+	regmap_write(lt9611->regmap, 0x07, 0xff); //clear
+	regmap_write(lt9611->regmap, 0x07, 0x3f);
+}
+
+static int lt9611_power_on(struct lt9611 *lt9611)
+{
+	int ret;
+	const struct reg_sequence seq[] = {
+		/* LT9611_System_Init */
+		{ 0xFF, 0x81 },
+		{ 0x01, 0x18 }, /* sel xtal clock */
+
+		/* timer for frequency meter */
+		{ 0xff, 0x82 },
+		{ 0x1b, 0x69 }, /*timer 2*/
+		{ 0x1c, 0x78 },
+		{ 0xcb, 0x69 }, /*timer 1 */
+		{ 0xcc, 0x78 },
+
+		/* irq init */
+		{ 0xff, 0x82 },
+		{ 0x51, 0x01 },
+		{ 0x58, 0x0a }, /* hpd irq */
+		{ 0x59, 0x80 }, /* hpd debounce width */
+		{ 0x9e, 0xf7 }, /* video check irq */
+
+		/* power consumption for work */
+		{ 0xff, 0x80 },
+		{ 0x04, 0xf0 },
+		{ 0x06, 0xf0 },
+		{ 0x0a, 0x80 },
+		{ 0x0b, 0x40 },
+		{ 0x0d, 0xef },
+		{ 0x11, 0xfa },
+	};
+
+	if (lt9611->power_on)
+		return 0;
+	
+	dev_dbg(lt9611->dev, "power on\n");
+
+	ret = regmap_multi_reg_write(lt9611->regmap, seq, ARRAY_SIZE(seq));
+	if (!ret)
+		lt9611->power_on = true;
+
+	return ret;
+}
+
+static int lt9611_power_off(struct lt9611 *lt9611)
+{
+	int ret;
+	const struct reg_sequence off[] = {
+		{ 0xff, 0x81 },
+		{ 0x30, 0x6a },
+	};
+
+	dev_dbg(lt9611->dev, "power off\n");
+
+	ret = regmap_multi_reg_write(lt9611->regmap, off, ARRAY_SIZE(off));
+	if (!ret)
+		lt9611->power_on = false;
+
+	return ret;
+}
+
+static void lt9611_i2s_init(struct lt9611 *lt9611)
+{
+	const struct reg_sequence init[] = {
+		{ 0xff, 0x82 },
+		{ 0xd6, 0x8c },
+		{ 0xd7, 0x04 },
+
+		{ 0xff, 0x84 },
+		{ 0x06, 0x08 },
+		{ 0x07, 0x10 },
+
+		{ 0x34, 0xd4 },
+	};
+
+	regmap_multi_reg_write(lt9611->regmap, init, ARRAY_SIZE(init));
+}
+
+static void lt9611_reset(struct lt9611 *lt9611)
+{
+	gpiod_set_value_cansleep(lt9611->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(lt9611->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(lt9611->reset_gpio, 1);
+	msleep(100);
+}
+
+static void lt9611_assert_5v(struct lt9611 *lt9611)
+{
+	if (!lt9611->enable_gpio)
+		return;
+
+	gpiod_set_value_cansleep(lt9611->enable_gpio, 1);
+	msleep(20);
+}
+
+static int lt9611_regulator_init(struct lt9611 *lt9611)
+{
+	int ret;
+
+	lt9611->supplies[0].supply = "vdd";
+	lt9611->supplies[1].supply = "vcc";
+	ret = devm_regulator_bulk_get(lt9611->dev, 2, lt9611->supplies);
+	if (ret < 0)
+		return ret;
+
+	return regulator_set_load(lt9611->supplies[0].consumer, 300000);
+}
+
+static int lt9611_regulator_enable(struct lt9611 *lt9611)
+{
+	int ret;
+
+	ret = regulator_enable(lt9611->supplies[0].consumer);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(1000, 10000);
+
+	ret = regulator_enable(lt9611->supplies[1].consumer);
+	if (ret < 0) {
+		regulator_disable(lt9611->supplies[0].consumer);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct lt9611_mode *lt9611_find_mode(const struct drm_display_mode *mode)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lt9611_modes); i++) {
+		if (lt9611_modes[i].hdisplay == mode->hdisplay &&
+		    lt9611_modes[i].vdisplay == mode->vdisplay &&
+		    lt9611_modes[i].fps == drm_mode_vrefresh(mode)) {
+			return &lt9611_modes[i];
+		}
+	}
+
+	return NULL;
+}
+
+/* connector funcs */
+static enum drm_connector_status
+lt9611_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct lt9611 *lt9611 = connector_to_lt9611(connector);
+	unsigned int reg_val = 0;
+	int connected = 0;
+
+	regmap_write(lt9611->regmap, 0xff, 0x82);
+	regmap_read(lt9611->regmap, 0x5e, &reg_val);
+	connected  = (reg_val & BIT(2));
+	dev_dbg(lt9611->dev, "connected = %x\n", connected);
+
+	lt9611->status = connected ?  connector_status_connected :
+				connector_status_disconnected;
+
+	return lt9611->status;
+}
+
+static int lt9611_read_edid(struct lt9611 *lt9611)
+{
+	unsigned int temp;
+	int ret = 0;
+	int i, j;
+
+	memset(lt9611->edid_buf, 0, EDID_SEG_SIZE);
+
+	regmap_write(lt9611->regmap, 0xff, 0x85);
+	regmap_write(lt9611->regmap, 0x03, 0xc9);
+	regmap_write(lt9611->regmap, 0x04, 0xa0); /* 0xA0 is EDID device address */
+	regmap_write(lt9611->regmap, 0x05, 0x00); /* 0x00 is EDID offset address */
+	regmap_write(lt9611->regmap, 0x06, 0x20); /* length for read */
+	regmap_write(lt9611->regmap, 0x14, 0x7f);
+
+	for (i = 0 ; i < 8 ; i++) {
+		regmap_write(lt9611->regmap, 0x05, i * 32); /* offset address */
+		regmap_write(lt9611->regmap, 0x07, 0x36);
+		regmap_write(lt9611->regmap, 0x07, 0x31);
+		regmap_write(lt9611->regmap, 0x07, 0x37);
+		usleep_range(5000, 10000);
+
+		regmap_read(lt9611->regmap, 0x40, &temp);
+
+		if (temp & 0x02) {  /*KEY_DDC_ACCS_DONE=1*/
+			for (j = 0; j < 32; j++) {
+				regmap_read(lt9611->regmap, 0x83, &temp);
+				lt9611->edid_buf[i*32+j] = temp;
+			}
+		} else if (temp & 0x50) { /* DDC No Ack or Abitration lost */
+			dev_err(lt9611->dev, "read edid failed: no ack\n");
+			ret = -EIO;
+			goto end;
+		} else {
+			dev_err(lt9611->dev, "read edid failed: access not done\n");
+			ret = -EIO;
+			goto end;
+		}
+	}
+
+	dev_dbg(lt9611->dev, "read edid succeeded, checksum = 0x%x\n",
+		lt9611->edid_buf[255]);
+
+end:
+	regmap_write(lt9611->regmap, 0x07, 0x1f);
+	return ret;
+}
+
+/* TODO: add support for more extenstion blocks */
+static int lt9611_get_edid_block(void *data, u8 *buf, unsigned int block,
+				  size_t len)
+{
+	struct lt9611 *lt9611 = data;
+	int ret;
+
+	dev_dbg(lt9611->dev, "get edid block: block=%d, len=%d\n", block, (int)len);
+
+	if (len > 128)
+		return -EINVAL;
+
+	/* support up to 1 extension block */
+	if (block > 1)
+		return -EINVAL;
+
+	if (block == 0) {
+		/* always read 2 edid blocks once */
+		ret = lt9611_read_edid(lt9611);
+		if (ret) {
+			dev_err(lt9611->dev, "edid read failed\n");
+			return ret;
+		}
+	}
+
+	if (block % 2 == 0)
+		memcpy(buf, lt9611->edid_buf, len);
+	else
+		memcpy(buf, lt9611->edid_buf + 128, len);
+
+	return 0;
+}
+
+static int lt9611_connector_get_modes(struct drm_connector *connector)
+{
+	struct lt9611 *lt9611 = connector_to_lt9611(connector);
+	unsigned int count;
+	struct edid *edid;
+
+	dev_dbg(lt9611->dev, "get modes\n");
+
+	lt9611_power_on(lt9611);
+	edid = drm_do_get_edid(connector, lt9611_get_edid_block, lt9611);
+	drm_connector_update_edid_property(connector, edid);
+	count = drm_add_edid_modes(connector, edid);
+	kfree(edid);
+
+	return count;
+}
+
+static enum drm_mode_status lt9611_connector_mode_valid(
+	struct drm_connector *connector, struct drm_display_mode *mode)
+{
+	struct lt9611_mode *lt9611_mode = lt9611_find_mode(mode);
+
+	return lt9611_mode ? MODE_OK : MODE_BAD;
+}
+
+/* bridge funcs */
+static void lt9611_bridge_enable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	const struct reg_sequence on[] = {
+		{ 0xff, 0x81 },
+		{ 0x30, 0xea },
+	};
+
+	dev_dbg(lt9611->dev, "bridge enable\n");
+
+	if (lt9611_power_on(lt9611)) {
+		dev_err(lt9611->dev, "power on failed\n");
+		return;
+	}
+
+	dev_dbg(lt9611->dev, "video on\n");
+
+	lt9611_mipi_input_analog(lt9611);
+	lt9611_hdmi_tx_digital(lt9611);
+	lt9611_hdmi_tx_phy(lt9611);
+
+	msleep(500);
+
+	lt9611_video_check(lt9611);
+
+	/* Enable HDMI output */
+	regmap_multi_reg_write(lt9611->regmap, on, ARRAY_SIZE(on));
+}
+
+static void lt9611_bridge_disable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	int ret;
+	const struct reg_sequence hdmi_off[] = {
+		{ 0xff, 0x81 },
+		{ 0x30, 0x6a },
+	};
+
+	dev_dbg(lt9611->dev, "bridge disable\n");
+
+	/* Disable HDMI output */
+	ret = regmap_multi_reg_write(lt9611->regmap, hdmi_off, ARRAY_SIZE(hdmi_off));
+	if (ret) {
+		dev_err(lt9611->dev, "video on failed\n");
+		return;
+	}
+
+	if (lt9611_power_off(lt9611)) {
+		dev_err(lt9611->dev, "power on failed\n");
+		return;
+	}
+}
+
+static struct drm_connector_helper_funcs lt9611_bridge_connector_helper_funcs = {
+	.get_modes = lt9611_connector_get_modes,
+	.mode_valid = lt9611_connector_mode_valid,
+};
+
+static const struct drm_connector_funcs lt9611_bridge_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = lt9611_connector_detect,
+	.destroy = drm_connector_cleanup,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static struct mipi_dsi_device *lt9611_attach_dsi(struct lt9611 *lt9611,
+						 struct device_node *dsi_node)
+{
+	const struct mipi_dsi_device_info info = { "lt9611", 0, NULL };
+	struct mipi_dsi_device *dsi;
+	struct mipi_dsi_host *host;
+	int ret;
+
+	host = of_find_mipi_dsi_host_by_node(dsi_node);
+	if (!host) {
+		dev_err(lt9611->dev, "failed to find dsi host\n");
+		return ERR_PTR(-EPROBE_DEFER);
+	}
+
+	dsi = mipi_dsi_device_register_full(host, &info);
+	if (IS_ERR(dsi)) {
+		dev_err(lt9611->dev, "failed to create dsi device\n");
+		return dsi;
+	}
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_VIDEO_HSE;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(lt9611->dev, "failed to attach dsi to host\n");
+		mipi_dsi_device_unregister(dsi);
+		return ERR_PTR(ret);
+	}
+
+	return dsi;
+}
+
+static int lt9611_bridge_attach(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	int ret;
+
+	dev_dbg(lt9611->dev, "bridge attach\n");
+
+	ret = drm_connector_init(bridge->dev, &lt9611->connector,
+				 &lt9611_bridge_connector_funcs,
+				 DRM_MODE_CONNECTOR_HDMIA);
+	if (ret) {
+		DRM_ERROR("Failed to initialize connector with drm\n");
+		return ret;
+	}
+
+	drm_connector_helper_add(&lt9611->connector,
+				 &lt9611_bridge_connector_helper_funcs);
+	drm_connector_attach_encoder(&lt9611->connector, bridge->encoder);
+
+	if (!bridge->encoder) {
+		DRM_ERROR("Parent encoder object not found");
+		return -ENODEV;
+	}
+
+	/* Attach primary DSI */
+	lt9611->dsi0 = lt9611_attach_dsi(lt9611, lt9611->dsi0_node);
+	if (IS_ERR(lt9611->dsi0))
+		return PTR_ERR(lt9611->dsi0);
+
+	/* Attach secondary DSI, if specified */
+	if (lt9611->dsi1_node) {
+		lt9611->dsi1 = lt9611_attach_dsi(lt9611, lt9611->dsi1_node);
+		if (IS_ERR(lt9611->dsi1)) {
+			ret = PTR_ERR(lt9611->dsi1);
+			goto err_unregister_dsi0;
+		}
+	}
+
+	return 0;
+
+err_unregister_dsi0:
+	mipi_dsi_device_unregister(lt9611->dsi0);
+
+	return ret;
+}
+
+static void lt9611_bridge_detach(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	if (lt9611->dsi1) {
+		mipi_dsi_detach(lt9611->dsi1);
+		mipi_dsi_device_unregister(lt9611->dsi1);
+	}
+
+	mipi_dsi_detach(lt9611->dsi0);
+	mipi_dsi_device_unregister(lt9611->dsi0);
+}
+
+static enum drm_mode_status
+lt9611_bridge_mode_valid(struct drm_bridge *bridge,
+			 const struct drm_display_mode *mode)
+{
+	struct lt9611_mode *lt9611_mode = lt9611_find_mode(mode);
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	if (lt9611_mode->intfs > 1 && !lt9611->dsi1)
+		return MODE_PANEL;
+	else
+		return MODE_OK;
+}
+
+static void lt9611_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	dev_dbg(lt9611->dev, "bridge pre_enable\n");
+
+	regmap_write(lt9611->regmap, 0xff, 0x80);
+	regmap_write(lt9611->regmap, 0xee, 0x01);
+}
+
+static void lt9611_bridge_post_disable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	dev_dbg(lt9611->dev, "bridge post_disable\n");
+
+	/* TODO: We still need to figure out how to best put the
+	 * hardware to sleep while still allowing hotplug
+	 * detection to work here. -jstultz
+	 */
+}
+
+static void lt9611_bridge_mode_set(struct drm_bridge *bridge,
+				   const struct drm_display_mode *mode,
+				   const struct drm_display_mode *adj_mode)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	struct hdmi_avi_infoframe avi_frame;
+	int ret;
+
+	dev_dbg(lt9611->dev, "bridge mode_set: hdisplay=%d, vdisplay=%d, vrefresh=%d, clock=%d\n",
+		adj_mode->hdisplay, adj_mode->vdisplay,
+		adj_mode->vrefresh, adj_mode->clock);
+
+	lt9611_mipi_input_digital(lt9611, mode);
+	lt9611_pll_setup(lt9611, mode);
+	lt9611_mipi_video_setup(lt9611, mode);
+	lt9611_pcr_setup(lt9611, mode);
+
+	ret = drm_hdmi_avi_infoframe_from_display_mode(&avi_frame,
+						       &lt9611->connector,
+						       mode);
+	if (!ret)
+		lt9611->vic = avi_frame.video_code;
+}
+
+static const struct drm_bridge_funcs lt9611_bridge_funcs = {
+	.attach = lt9611_bridge_attach,
+	.detach = lt9611_bridge_detach,
+	.mode_valid = lt9611_bridge_mode_valid,
+	.pre_enable   = lt9611_bridge_pre_enable,
+	.enable = lt9611_bridge_enable,
+	.disable = lt9611_bridge_disable,
+	.post_disable = lt9611_bridge_post_disable,
+	.mode_set = lt9611_bridge_mode_set,
+};
+
+static int lt9611_parse_dt(struct device *dev,
+	struct lt9611 *lt9611)
+{
+	lt9611->dsi0_node = of_graph_get_remote_node(dev->of_node, 1, -1);
+	if (!lt9611->dsi0_node) {
+		DRM_DEV_ERROR(dev,
+			"failed to get remote node for primary dsi\n");
+		return -ENODEV;
+	}
+
+	lt9611->dsi1_node = of_graph_get_remote_node(dev->of_node, 2, -1);
+
+	lt9611->ac_mode = of_property_read_bool(dev->of_node, "lt,ac-mode");
+	dev_dbg(lt9611->dev, "ac_mode=%d\n", lt9611->ac_mode);
+
+	return 0;
+}
+
+static int lt9611_gpio_init(struct lt9611 *lt9611)
+{
+	struct device *dev = lt9611->dev;
+
+	lt9611->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(lt9611->reset_gpio)) {
+		dev_err(dev, "failed to acquire reset gpio\n");
+		return PTR_ERR(lt9611->reset_gpio);
+	}
+
+	lt9611->enable_gpio = devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_LOW);
+	if (IS_ERR(lt9611->enable_gpio)) {
+		dev_err(dev, "failed to acquire enable gpio\n");
+		return PTR_ERR(lt9611->enable_gpio);
+	}
+
+	return 0;
+}
+
+static int lt9611_read_device_rev(struct lt9611 *lt9611)
+{
+	unsigned int rev;
+	int ret;
+
+	regmap_write(lt9611->regmap, 0xff, 0x80);
+	regmap_write(lt9611->regmap, 0xee, 0x01);
+
+	ret = regmap_read(lt9611->regmap, 0x02, &rev);
+	if (ret)
+		dev_err(lt9611->dev, "failed to read revision: %d\n", ret);
+
+	dev_info(lt9611->dev, "LT9611 revsion: 0x%x\n", rev);
+
+	return ret;
+}
+
+static int lt9611_probe(struct i2c_client *client,
+	 const struct i2c_device_id *id)
+{
+	struct lt9611 *lt9611;
+	struct device *dev = &client->dev;
+	int ret;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(dev, "device doesn't support I2C\n");
+		return -ENODEV;
+	}
+
+	lt9611 = devm_kzalloc(dev, sizeof(*lt9611), GFP_KERNEL);
+	if (!lt9611)
+		return -ENOMEM;
+
+	lt9611->dev = &client->dev;
+	lt9611->client = client;
+
+	lt9611->regmap = devm_regmap_init_i2c(client, &lt9611_regmap_config);
+	if (IS_ERR(lt9611->regmap)) {
+		DRM_ERROR("regmap i2c init failed\n");
+		return PTR_ERR(lt9611->regmap);
+	}
+
+	ret = lt9611_parse_dt(&client->dev, lt9611);
+	if (ret) {
+		dev_err(dev, "failed to parse device tree\n");
+		return ret;
+	}
+
+	ret = lt9611_gpio_init(lt9611);
+	if (ret < 0)
+		return ret;
+
+	ret = lt9611_regulator_init(lt9611);
+	if (ret < 0)
+		return ret;
+
+	lt9611_assert_5v(lt9611);
+
+	ret = lt9611_regulator_enable(lt9611);
+	if (ret)
+		return ret;
+
+	lt9611_reset(lt9611);
+
+	ret = lt9611_read_device_rev(lt9611);
+	if (ret) {
+		dev_err(dev, "failed to read chip rev\n");
+		goto err_disable_regulators;
+	}
+
+	lt9611_i2s_init(lt9611);
+
+	ret = devm_request_threaded_irq(dev, client->irq, NULL,
+					lt9611_irq_thread_handler,
+					IRQF_ONESHOT, "lt9611", lt9611);
+	if (ret) {
+		dev_err(dev, "failed to request irq\n");
+		goto err_disable_regulators;
+	}
+
+	i2c_set_clientdata(client, lt9611);
+
+	lt9611->bridge.funcs = &lt9611_bridge_funcs;
+	lt9611->bridge.of_node = client->dev.of_node;
+
+	drm_bridge_add(&lt9611->bridge);
+
+	lt9611_enable_hpd_interrupts(lt9611);
+
+	return 0;
+
+err_disable_regulators:
+	regulator_bulk_disable(ARRAY_SIZE(lt9611->supplies), lt9611->supplies);
+
+	of_node_put(lt9611->dsi0_node);
+	of_node_put(lt9611->dsi1_node);
+
+	return ret;
+}
+
+static int lt9611_remove(struct i2c_client *client)
+{
+	struct lt9611 *lt9611 = i2c_get_clientdata(client);
+
+	disable_irq(client->irq);
+
+	drm_bridge_remove(&lt9611->bridge);
+
+	regulator_bulk_disable(ARRAY_SIZE(lt9611->supplies), lt9611->supplies);
+
+	of_node_put(lt9611->dsi0_node);
+	of_node_put(lt9611->dsi1_node);
+
+	return 0;
+}
+
+
+static struct i2c_device_id lt9611_id[] = {
+	{ "lt,lt9611", 0},
+	{}
+};
+
+static const struct of_device_id lt9611_match_table[] = {
+	{.compatible = "lt,lt9611"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, lt9611_match_table);
+
+static struct i2c_driver lt9611_driver = {
+	.driver = {
+		.name = "lt9611",
+		.of_match_table = lt9611_match_table,
+	},
+	.probe = lt9611_probe,
+	.remove = lt9611_remove,
+	.id_table = lt9611_id,
+};
+module_i2c_driver(lt9611_driver);
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c
index 2337b3827..d932256d7 100644
--- a/drivers/gpu/drm/drm_connector.c
+++ b/drivers/gpu/drm/drm_connector.c
@@ -887,6 +887,38 @@ static const struct drm_prop_enum_list hdmi_colorspaces[] = {
 	{ DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER, "DCI-P3_RGB_Theater" },
 };
 
+/*
+ * As per DP 1.4a spec, 2.2.5.7.5 VSC SDP Payload for Pixel Encoding/Colorimetry
+ * Format Table 2-120
+ */
+static const struct drm_prop_enum_list dp_colorspaces[] = {
+	/* For Default case, driver will set the colorspace */
+	{ DRM_MODE_COLORIMETRY_DEFAULT, "Default" },
+	{ DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED, "RGB_Wide_Gamut_Fixed_Point" },
+	/* Colorimetry based on scRGB (IEC 61966-2-2) */
+	{ DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT, "RGB_Wide_Gamut_Floating_Point" },
+	/* Colorimetry based on IEC 61966-2-5 */
+	{ DRM_MODE_COLORIMETRY_OPRGB, "opRGB" },
+	/* Colorimetry based on SMPTE RP 431-2 */
+	{ DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65, "DCI-P3_RGB_D65" },
+	/* Colorimetry based on ITU-R BT.2020 */
+	{ DRM_MODE_COLORIMETRY_BT2020_RGB, "BT2020_RGB" },
+	{ DRM_MODE_COLORIMETRY_BT601_YCC, "BT601_YCC" },
+	{ DRM_MODE_COLORIMETRY_BT709_YCC, "BT709_YCC" },
+	/* Standard Definition Colorimetry based on IEC 61966-2-4 */
+	{ DRM_MODE_COLORIMETRY_XVYCC_601, "XVYCC_601" },
+	/* High Definition Colorimetry based on IEC 61966-2-4 */
+	{ DRM_MODE_COLORIMETRY_XVYCC_709, "XVYCC_709" },
+	/* Colorimetry based on IEC 61966-2-1/Amendment 1 */
+	{ DRM_MODE_COLORIMETRY_SYCC_601, "SYCC_601" },
+	/* Colorimetry based on IEC 61966-2-5 [33] */
+	{ DRM_MODE_COLORIMETRY_OPYCC_601, "opYCC_601" },
+	/* Colorimetry based on ITU-R BT.2020 */
+	{ DRM_MODE_COLORIMETRY_BT2020_CYCC, "BT2020_CYCC" },
+	/* Colorimetry based on ITU-R BT.2020 */
+	{ DRM_MODE_COLORIMETRY_BT2020_YCC, "BT2020_YCC" },
+};
+
 /**
  * DOC: standard connector properties
  *
@@ -1679,7 +1711,6 @@ EXPORT_SYMBOL(drm_mode_create_aspect_ratio_property);
  * DOC: standard connector properties
  *
  * Colorspace:
- *     drm_mode_create_colorspace_property - create colorspace property
  *     This property helps select a suitable colorspace based on the sink
  *     capability. Modern sink devices support wider gamut like BT2020.
  *     This helps switch to BT2020 mode if the BT2020 encoded video stream
@@ -1699,32 +1730,68 @@ EXPORT_SYMBOL(drm_mode_create_aspect_ratio_property);
  *      - This property is just to inform sink what colorspace
  *        source is trying to drive.
  *
+ * Because between HDMI and DP have different colorspaces,
+ * drm_mode_create_hdmi_colorspace_property() is used for HDMI connector and
+ * drm_mode_create_dp_colorspace_property() is used for DP connector.
+ */
+
+/**
+ * drm_mode_create_hdmi_colorspace_property - create hdmi colorspace property
+ * @connector: connector to create the Colorspace property on.
+ *
  * Called by a driver the first time it's needed, must be attached to desired
- * connectors.
+ * HDMI connectors.
+ *
+ * Returns:
+ * Zero on success, negative errono on failure.
  */
-int drm_mode_create_colorspace_property(struct drm_connector *connector)
+int drm_mode_create_hdmi_colorspace_property(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
-	struct drm_property *prop;
 
-	if (connector->connector_type == DRM_MODE_CONNECTOR_HDMIA ||
-	    connector->connector_type == DRM_MODE_CONNECTOR_HDMIB) {
-		prop = drm_property_create_enum(dev, DRM_MODE_PROP_ENUM,
-						"Colorspace",
-						hdmi_colorspaces,
-						ARRAY_SIZE(hdmi_colorspaces));
-		if (!prop)
-			return -ENOMEM;
-	} else {
-		DRM_DEBUG_KMS("Colorspace property not supported\n");
+	if (connector->colorspace_property)
 		return 0;
-	}
 
-	connector->colorspace_property = prop;
+	connector->colorspace_property =
+		drm_property_create_enum(dev, DRM_MODE_PROP_ENUM, "Colorspace",
+					 hdmi_colorspaces,
+					 ARRAY_SIZE(hdmi_colorspaces));
+
+	if (!connector->colorspace_property)
+		return -ENOMEM;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_mode_create_hdmi_colorspace_property);
+
+/**
+ * drm_mode_create_dp_colorspace_property - create dp colorspace property
+ * @connector: connector to create the Colorspace property on.
+ *
+ * Called by a driver the first time it's needed, must be attached to desired
+ * DP connectors.
+ *
+ * Returns:
+ * Zero on success, negative errono on failure.
+ */
+int drm_mode_create_dp_colorspace_property(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+
+	if (connector->colorspace_property)
+		return 0;
+
+	connector->colorspace_property =
+		drm_property_create_enum(dev, DRM_MODE_PROP_ENUM, "Colorspace",
+					 dp_colorspaces,
+					 ARRAY_SIZE(dp_colorspaces));
+
+	if (!connector->colorspace_property)
+		return -ENOMEM;
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_mode_create_colorspace_property);
+EXPORT_SYMBOL(drm_mode_create_dp_colorspace_property);
 
 /**
  * drm_mode_create_content_type_property - create content type property
diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index ffc68d305..8b6dd549f 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -336,6 +336,65 @@ int drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,
 }
 EXPORT_SYMBOL(drm_dp_dpcd_read_link_status);
 
+/**
+ * drm_dp_send_real_edid_checksum() - send back real edid checksum value
+ * @aux: DisplayPort AUX channel
+ * @real_edid_checksum: real edid checksum for the last block
+ *
+ * Returns:
+ * True on success
+ */
+bool drm_dp_send_real_edid_checksum(struct drm_dp_aux *aux,
+				    u8 real_edid_checksum)
+{
+	u8 link_edid_read = 0, auto_test_req = 0, test_resp = 0;
+
+	if (drm_dp_dpcd_read(aux, DP_DEVICE_SERVICE_IRQ_VECTOR,
+			     &auto_test_req, 1) < 1) {
+		DRM_ERROR("DPCD failed read at register 0x%x\n",
+			  DP_DEVICE_SERVICE_IRQ_VECTOR);
+		return false;
+	}
+	auto_test_req &= DP_AUTOMATED_TEST_REQUEST;
+
+	if (drm_dp_dpcd_read(aux, DP_TEST_REQUEST, &link_edid_read, 1) < 1) {
+		DRM_ERROR("DPCD failed read at register 0x%x\n",
+			  DP_TEST_REQUEST);
+		return false;
+	}
+	link_edid_read &= DP_TEST_LINK_EDID_READ;
+
+	if (!auto_test_req || !link_edid_read) {
+		DRM_DEBUG_KMS("Source DUT does not support TEST_EDID_READ\n");
+		return false;
+	}
+
+	if (drm_dp_dpcd_write(aux, DP_DEVICE_SERVICE_IRQ_VECTOR,
+			      &auto_test_req, 1) < 1) {
+		DRM_ERROR("DPCD failed write at register 0x%x\n",
+			  DP_DEVICE_SERVICE_IRQ_VECTOR);
+		return false;
+	}
+
+	/* send back checksum for the last edid extension block data */
+	if (drm_dp_dpcd_write(aux, DP_TEST_EDID_CHECKSUM,
+			      &real_edid_checksum, 1) < 1) {
+		DRM_ERROR("DPCD failed write at register 0x%x\n",
+			  DP_TEST_EDID_CHECKSUM);
+		return false;
+	}
+
+	test_resp |= DP_TEST_EDID_CHECKSUM_WRITE;
+	if (drm_dp_dpcd_write(aux, DP_TEST_RESPONSE, &test_resp, 1) < 1) {
+		DRM_ERROR("DPCD failed write at register 0x%x\n",
+			  DP_TEST_RESPONSE);
+		return false;
+	}
+
+	return true;
+}
+EXPORT_SYMBOL(drm_dp_send_real_edid_checksum);
+
 /**
  * drm_dp_link_probe() - probe a DisplayPort link for capabilities
  * @aux: DisplayPort AUX channel
diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c
index 9b69e55ad..4525e0a50 100644
--- a/drivers/gpu/drm/drm_edid.c
+++ b/drivers/gpu/drm/drm_edid.c
@@ -1351,11 +1351,22 @@ static int validate_displayid(u8 *displayid, int length, int idx);
 static int drm_edid_block_checksum(const u8 *raw_edid)
 {
 	int i;
-	u8 csum = 0;
-	for (i = 0; i < EDID_LENGTH; i++)
+	u8 csum = 0, crc = 0;
+
+	for (i = 0; i < EDID_LENGTH - 1; i++)
 		csum += raw_edid[i];
 
-	return csum;
+	crc = 0x100 - csum;
+
+	return crc;
+}
+
+static bool drm_edid_block_checksum_diff(const u8 *raw_edid, u8 real_checksum)
+{
+	if (raw_edid[EDID_LENGTH - 1] != real_checksum)
+		return true;
+	else
+		return false;
 }
 
 static bool drm_edid_is_zero(const u8 *in_edid, int length)
@@ -1413,7 +1424,7 @@ bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
 	}
 
 	csum = drm_edid_block_checksum(raw_edid);
-	if (csum) {
+	if (drm_edid_block_checksum_diff(raw_edid, csum)) {
 		if (edid_corrupt)
 			*edid_corrupt = true;
 
@@ -1554,6 +1565,11 @@ static void connector_bad_edid(struct drm_connector *connector,
 			       u8 *edid, int num_blocks)
 {
 	int i;
+	u8 num_of_ext = edid[0x7e];
+
+	/* Calculate real checksum for the last edid extension block data */
+	connector->real_edid_checksum =
+		drm_edid_block_checksum(edid + num_of_ext * EDID_LENGTH);
 
 	if (connector->bad_edid_counter++ && !(drm_debug & DRM_UT_KMS))
 		return;
diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c
index 6b8502bcf..8d193a583 100644
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
@@ -390,11 +390,7 @@ static void drm_fb_helper_dirty_blit_real(struct drm_fb_helper *fb_helper,
 	unsigned int y;
 
 	for (y = clip->y1; y < clip->y2; y++) {
-		if (!fb_helper->dev->mode_config.fbdev_use_iomem)
-			memcpy(dst, src, len);
-		else
-			memcpy_toio((void __iomem *)dst, src, len);
-
+		memcpy(dst, src, len);
 		src += fb->pitches[0];
 		dst += fb->pitches[0];
 	}
diff --git a/drivers/gpu/drm/drm_file.c b/drivers/gpu/drm/drm_file.c
index ea34bc991..6940812a9 100644
--- a/drivers/gpu/drm/drm_file.c
+++ b/drivers/gpu/drm/drm_file.c
@@ -49,6 +49,8 @@
 /* from BKL pushdown */
 DEFINE_MUTEX(drm_global_mutex);
 
+#define MAX_DRM_OPEN_COUNT		128
+
 /**
  * DOC: file operations
  *
@@ -380,6 +382,11 @@ int drm_open(struct inode *inode, struct file *filp)
 	if (!dev->open_count++)
 		need_setup = 1;
 
+	if (dev->open_count >= MAX_DRM_OPEN_COUNT) {
+		retcode = -EPERM;
+		goto err_undo;
+	}
+
 	/* share address_space across all char-devs of a single device */
 	filp->f_mapping = dev->anon_inode->i_mapping;
 
diff --git a/drivers/gpu/drm/drm_framebuffer.c b/drivers/gpu/drm/drm_framebuffer.c
index 57564318c..c62250c16 100644
--- a/drivers/gpu/drm/drm_framebuffer.c
+++ b/drivers/gpu/drm/drm_framebuffer.c
@@ -295,7 +295,8 @@ drm_internal_framebuffer_create(struct drm_device *dev,
 	struct drm_framebuffer *fb;
 	int ret;
 
-	if (r->flags & ~(DRM_MODE_FB_INTERLACED | DRM_MODE_FB_MODIFIERS)) {
+	if (r->flags & ~(DRM_MODE_FB_INTERLACED | DRM_MODE_FB_MODIFIERS |
+			DRM_MODE_FB_SECURE)) {
 		DRM_DEBUG_KMS("bad framebuffer flags 0x%08x\n", r->flags);
 		return ERR_PTR(-EINVAL);
 	}
diff --git a/drivers/gpu/drm/drm_ioctl.c b/drivers/gpu/drm/drm_ioctl.c
index fcd728d7c..e293cf7bc 100644
--- a/drivers/gpu/drm/drm_ioctl.c
+++ b/drivers/gpu/drm/drm_ioctl.c
@@ -676,9 +676,9 @@ static const struct drm_ioctl_desc drm_ioctls[] = {
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_RMFB, drm_mode_rmfb_ioctl, 0),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_PAGE_FLIP, drm_mode_page_flip_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DIRTYFB, drm_mode_dirtyfb_ioctl, DRM_MASTER),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_DUMB, drm_mode_create_dumb_ioctl, 0),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_MAP_DUMB, drm_mode_mmap_dumb_ioctl, 0),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROY_DUMB, drm_mode_destroy_dumb_ioctl, 0),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_DUMB, drm_mode_create_dumb_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_MAP_DUMB, drm_mode_mmap_dumb_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROY_DUMB, drm_mode_destroy_dumb_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_GETPROPERTIES, drm_mode_obj_get_properties_ioctl, 0),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_SETPROPERTY, drm_mode_obj_set_property_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CURSOR2, drm_mode_cursor2_ioctl, DRM_MASTER),
diff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c
index b99f96dcc..edaec70eb 100644
--- a/drivers/gpu/drm/drm_mipi_dsi.c
+++ b/drivers/gpu/drm/drm_mipi_dsi.c
@@ -355,6 +355,7 @@ static ssize_t mipi_dsi_device_transfer(struct mipi_dsi_device *dsi,
 
 	if (dsi->mode_flags & MIPI_DSI_MODE_LPM)
 		msg->flags |= MIPI_DSI_MSG_USE_LPM;
+	msg->flags |= MIPI_DSI_MSG_LASTCOMMAND;
 
 	return ops->transfer(dsi->host, msg);
 }
diff --git a/drivers/gpu/drm/drm_modes.c b/drivers/gpu/drm/drm_modes.c
index 3fd35e6b9..e4e33cafd 100644
--- a/drivers/gpu/drm/drm_modes.c
+++ b/drivers/gpu/drm/drm_modes.c
@@ -2052,6 +2052,7 @@ int drm_mode_convert_umode(struct drm_device *dev,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(drm_mode_convert_umode);
 
 /**
  * drm_mode_is_420_only - if a given videomode can be only supported in YCBCR420
diff --git a/drivers/gpu/drm/drm_panel.c b/drivers/gpu/drm/drm_panel.c
index 6b0bf4203..da69dc2a9 100644
--- a/drivers/gpu/drm/drm_panel.c
+++ b/drivers/gpu/drm/drm_panel.c
@@ -51,6 +51,7 @@ static LIST_HEAD(panel_list);
 void drm_panel_init(struct drm_panel *panel)
 {
 	INIT_LIST_HEAD(&panel->list);
+	BLOCKING_INIT_NOTIFIER_HEAD(&panel->nh);
 }
 EXPORT_SYMBOL(drm_panel_init);
 
@@ -266,6 +267,27 @@ struct drm_panel *of_drm_find_panel(const struct device_node *np)
 EXPORT_SYMBOL(of_drm_find_panel);
 #endif
 
+int drm_panel_notifier_register(struct drm_panel *panel,
+	struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&panel->nh, nb);
+}
+EXPORT_SYMBOL_GPL(drm_panel_notifier_register);
+
+int drm_panel_notifier_unregister(struct drm_panel *panel,
+	struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&panel->nh, nb);
+}
+EXPORT_SYMBOL_GPL(drm_panel_notifier_unregister);
+
+int drm_panel_notifier_call_chain(struct drm_panel *panel,
+	unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&panel->nh, val, v);
+}
+EXPORT_SYMBOL_GPL(drm_panel_notifier_call_chain);
+
 MODULE_AUTHOR("Thierry Reding <treding@nvidia.com>");
 MODULE_DESCRIPTION("DRM panel infrastructure");
 MODULE_LICENSE("GPL and additional rights");
diff --git a/drivers/gpu/drm/drm_prime.c b/drivers/gpu/drm/drm_prime.c
index 0a2316e0e..f9f60de27 100644
--- a/drivers/gpu/drm/drm_prime.c
+++ b/drivers/gpu/drm/drm_prime.c
@@ -767,6 +767,28 @@ int drm_gem_dmabuf_mmap(struct dma_buf *dma_buf, struct vm_area_struct *vma)
 }
 EXPORT_SYMBOL(drm_gem_dmabuf_mmap);
 
+/**
+ * drm_gem_dmabuf_get_uuid - dma_buf get_uuid implementation for GEM
+ * @dma_buf: buffer to query
+ * @uuid: uuid outparam
+ *
+ * Queries the buffer's virtio UUID. This can be used as the
+ * &dma_buf_ops.get_uuid callback. Calls into &drm_driver.gem_prime_get_uuid.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_gem_dmabuf_get_uuid(struct dma_buf *dma_buf, uuid_t *uuid)
+{
+	struct drm_gem_object *obj = dma_buf->priv;
+	struct drm_device *dev = obj->dev;
+
+	if (!dev->driver->gem_prime_get_uuid)
+		return -ENODEV;
+
+	return dev->driver->gem_prime_get_uuid(obj, uuid);
+}
+EXPORT_SYMBOL(drm_gem_dmabuf_get_uuid);
+
 static const struct dma_buf_ops drm_gem_prime_dmabuf_ops =  {
 	.cache_sgt_mapping = true,
 	.attach = drm_gem_map_attach,
@@ -777,6 +799,7 @@ static const struct dma_buf_ops drm_gem_prime_dmabuf_ops =  {
 	.mmap = drm_gem_dmabuf_mmap,
 	.vmap = drm_gem_dmabuf_vmap,
 	.vunmap = drm_gem_dmabuf_vunmap,
+	.get_uuid = drm_gem_dmabuf_get_uuid,
 };
 
 /**
diff --git a/drivers/gpu/drm/drm_property.c b/drivers/gpu/drm/drm_property.c
index 6ee04803c..b363578f5 100644
--- a/drivers/gpu/drm/drm_property.c
+++ b/drivers/gpu/drm/drm_property.c
@@ -31,6 +31,9 @@
 
 #include "drm_crtc_internal.h"
 
+#define MAX_BLOB_PROP_SIZE	(PAGE_SIZE * 30)
+#define MAX_BLOB_PROP_COUNT	250
+
 /**
  * DOC: overview
  *
@@ -787,12 +790,21 @@ int drm_mode_createblob_ioctl(struct drm_device *dev,
 			      void *data, struct drm_file *file_priv)
 {
 	struct drm_mode_create_blob *out_resp = data;
-	struct drm_property_blob *blob;
+	struct drm_property_blob *blob, *bt;
 	int ret = 0;
+	u32 count = 0;
 
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EOPNOTSUPP;
 
+	mutex_lock(&dev->mode_config.blob_lock);
+	list_for_each_entry(bt, &file_priv->blobs, head_file)
+		count++;
+	mutex_unlock(&dev->mode_config.blob_lock);
+
+	if (count >= MAX_BLOB_PROP_COUNT)
+		return -EOPNOTSUPP;
+
 	blob = drm_property_create_blob(dev, out_resp->length, NULL);
 	if (IS_ERR(blob))
 		return PTR_ERR(blob);
diff --git a/drivers/gpu/drm/hisilicon/kirin/Kconfig b/drivers/gpu/drm/hisilicon/kirin/Kconfig
index 290553e2f..0f2a29e84 100644
--- a/drivers/gpu/drm/hisilicon/kirin/Kconfig
+++ b/drivers/gpu/drm/hisilicon/kirin/Kconfig
@@ -6,7 +6,37 @@ config DRM_HISI_KIRIN
 	select DRM_GEM_CMA_HELPER
 	select DRM_KMS_CMA_HELPER
 	select DRM_MIPI_DSI
+	select DRM_PANEL
 	help
-	  Choose this option if you have a hisilicon Kirin chipsets(hi6220).
+	  Choose this option if you have a hisilicon Kirin chipsets.
 	  If M is selected the module will be called kirin-drm.
 
+if DRM_HISI_KIRIN
+config DRM_HISI_KIRIN620
+	bool "DRM Support for Hisilicon Kirin620 Platform"
+	default n
+	depends on DRM_HISI_KIRIN
+	select DRM_KMS_HELPER
+	select DRM_GEM_CMA_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DSI
+	select DRM_PANEL
+	help
+	  Choose this option if you have hisilicon Kirin Chipset(kirin620).
+	  It includes kirin620 ade and dsi drivers.
+	  If y is to build kirin620 drm into kirin drm drivers.
+
+config DRM_HISI_KIRIN960
+	bool "DRM Support for Hisilicon Kirin960 Platform"
+	default n
+	depends on DRM_HISI_KIRIN
+	select DRM_KMS_HELPER
+	select DRM_GEM_CMA_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DSI
+	select DRM_PANEL
+	help
+	  Choose this option if you have hisilicon Kirin Chipset(kirin960), such
+	  as hikey board. It includes kirin620 dpe and dsi drivers.
+	  If y is to build kirin960 drm into kirin drm drivers.
+endif
diff --git a/drivers/gpu/drm/hisilicon/kirin/Makefile b/drivers/gpu/drm/hisilicon/kirin/Makefile
index d9323f66a..d00c94853 100644
--- a/drivers/gpu/drm/hisilicon/kirin/Makefile
+++ b/drivers/gpu/drm/hisilicon/kirin/Makefile
@@ -1,6 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0-only
-kirin-drm-y := kirin_drm_drv.o \
-	       kirin_drm_ade.o
+EXTRA_CFLAGS += \
+		-Iinclude/drm
 
-obj-$(CONFIG_DRM_HISI_KIRIN) += kirin-drm.o dw_drm_dsi.o
 
+kirin-drm-y := kirin_drm_drv.o
+kirin-drm-$(CONFIG_DRM_HISI_KIRIN620) += kirin_drm_ade.o
+kirin-drm-$(CONFIG_DRM_HISI_KIRIN960) += kirin_drm_dpe.o
+
+kirin-dsi-y := kirin_drm_dsi.o
+kirin-dsi-$(CONFIG_DRM_HISI_KIRIN620) += kirin/dw_drm_dsi.o
+kirin-dsi-$(CONFIG_DRM_HISI_KIRIN960) += kirin960/dw_drm_dsi.o
+
+obj-$(CONFIG_DRM_HISI_KIRIN) += kirin-drm.o kirin-dsi.o
diff --git a/drivers/gpu/drm/hisilicon/kirin/dw_dsi_reg.h b/drivers/gpu/drm/hisilicon/kirin/dw_dsi_reg.h
index 19e81ff64..6c31ee0b4 100644
--- a/drivers/gpu/drm/hisilicon/kirin/dw_dsi_reg.h
+++ b/drivers/gpu/drm/hisilicon/kirin/dw_dsi_reg.h
@@ -8,7 +8,7 @@
 #define __DW_DSI_REG_H__
 
 #define MASK(x)				(BIT(x) - 1)
-
+#define DEFAULT_MAX_TX_ESC_CLK	(10 * 1000000UL)	//for hikey960
 /*
  * regs
  */
@@ -52,6 +52,50 @@
 #define VID_VACTIVE_LINES       0x60  /* Vertical resolution */
 #define VID_PKT_SIZE            0x3C  /* Video packet size */
 #define VID_MODE_CFG            0x38  /* Video mode configuration */
+/***************************for hikey960***********************************/
+#define GEN_HDR			0x6c
+#define GEN_HDATA(data)		(((data) & 0xffff) << 8)
+#define GEN_HDATA_MASK		(0xffff << 8)
+#define GEN_HTYPE(type)		(((type) & 0xff) << 0)
+#define GEN_HTYPE_MASK		0xff
+#define GEN_PLD_DATA		0x70
+#define CMD_PKT_STATUS		0x74
+#define GEN_CMD_EMPTY		BIT(0)
+#define GEN_CMD_FULL		BIT(1)
+#define GEN_PLD_W_EMPTY		BIT(2)
+#define GEN_PLD_W_FULL		BIT(3)
+#define GEN_PLD_R_EMPTY		BIT(4)
+#define GEN_PLD_R_FULL		BIT(5)
+#define GEN_RD_CMD_BUSY		BIT(6)
+#define CMD_MODE_CFG		0x68
+#define MAX_RD_PKT_SIZE_LP	BIT(24)
+#define DCS_LW_TX_LP		BIT(19)
+#define DCS_SR_0P_TX_LP		BIT(18)
+#define DCS_SW_1P_TX_LP		BIT(17)
+#define DCS_SW_0P_TX_LP		BIT(16)
+#define GEN_LW_TX_LP		BIT(14)
+#define GEN_SR_2P_TX_LP		BIT(13)
+#define GEN_SR_1P_TX_LP		BIT(12)
+#define GEN_SR_0P_TX_LP		BIT(11)
+#define GEN_SW_2P_TX_LP		BIT(10)
+#define GEN_SW_1P_TX_LP		BIT(9)
+#define GEN_SW_0P_TX_LP		BIT(8)
+#define EN_ACK_RQST		BIT(1)
+#define EN_TEAR_FX		BIT(0)
+#define CMD_PKT_STATUS_TIMEOUT_US	20000
+#define CMD_MODE_ALL_LP		(MAX_RD_PKT_SIZE_LP | \
+				 DCS_LW_TX_LP | \
+				 DCS_SR_0P_TX_LP | \
+				 DCS_SW_1P_TX_LP | \
+				 DCS_SW_0P_TX_LP | \
+				 GEN_LW_TX_LP | \
+				 GEN_SR_2P_TX_LP | \
+				 GEN_SR_1P_TX_LP | \
+				 GEN_SR_0P_TX_LP | \
+				 GEN_SW_2P_TX_LP | \
+				 GEN_SW_1P_TX_LP | \
+				 GEN_SW_0P_TX_LP)
+/***************************for hikey960***********************************/
 #define PHY_TMR_CFG             0x9C  /* Data lanes timing configuration */
 #define BTA_TO_CNT              0x8C  /* Response timeout definition */
 #define PHY_TMR_LPCLK_CFG       0x98  /* clock lane timing configuration */
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin/dw_drm_dsi.c b/drivers/gpu/drm/hisilicon/kirin/kirin/dw_drm_dsi.c
new file mode 100644
index 000000000..100f502f1
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin/dw_drm_dsi.c
@@ -0,0 +1,656 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * DesignWare MIPI DSI Host Controller v1.02 driver
+ *
+ * Copyright (c) 2016 Linaro Limited.
+ * Copyright (c) 2014-2016 Hisilicon Limited.
+ *
+ * Author:
+ *	Xinliang Liu <z.liuxinliang@hisilicon.com>
+ *	Xinliang Liu <xinliang.liu@linaro.org>
+ *	Xinwei Kong <kong.kongxinwei@hisilicon.com>
+ *	Da Lv <lvda3@hisilicon.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_device.h>
+#include <drm/drm_encoder_slave.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_of.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+
+#include "../kirin_drm_dsi.h"
+#include "../dw_dsi_reg.h"
+
+#define MAX_TX_ESC_CLK		10
+
+static u32 dsi_calc_phy_rate(u32 req_kHz, struct mipi_phy_params *phy)
+{
+	u32 ref_clk_ps = PHY_REF_CLK_PERIOD_PS;
+	u32 tmp_kHz = req_kHz;
+	u32 i = 0;
+	u32 q_pll = 1;
+	u32 m_pll = 0;
+	u32 n_pll = 0;
+	u32 r_pll = 1;
+	u32 m_n = 0;
+	u32 m_n_int = 0;
+	u32 f_kHz = 0;
+	u64 temp;
+
+	/*
+	 * Find a rate >= req_kHz.
+	 */
+	do {
+		f_kHz = tmp_kHz;
+
+		for (i = 0; i < ARRAY_SIZE(dphy_range_info); i++)
+			if (f_kHz >= dphy_range_info[i].min_range_kHz &&
+			    f_kHz <= dphy_range_info[i].max_range_kHz)
+				break;
+
+		if (i == ARRAY_SIZE(dphy_range_info)) {
+			DRM_ERROR("%dkHz out of range\n", f_kHz);
+			return 0;
+		}
+
+		phy->pll_vco_750M = dphy_range_info[i].pll_vco_750M;
+		phy->hstx_ckg_sel = dphy_range_info[i].hstx_ckg_sel;
+
+		if (phy->hstx_ckg_sel <= 7 &&
+		    phy->hstx_ckg_sel >= 4)
+			q_pll = 0x10 >> (7 - phy->hstx_ckg_sel);
+
+		temp = f_kHz * (u64)q_pll * (u64)ref_clk_ps;
+		m_n_int = temp / (u64)1000000000;
+		m_n = (temp % (u64)1000000000) / (u64)100000000;
+
+		if (m_n_int % 2 == 0) {
+			if (m_n * 6 >= 50) {
+				n_pll = 2;
+				m_pll = (m_n_int + 1) * n_pll;
+			} else if (m_n * 6 >= 30) {
+				n_pll = 3;
+				m_pll = m_n_int * n_pll + 2;
+			} else {
+				n_pll = 1;
+				m_pll = m_n_int * n_pll;
+			}
+		} else {
+			if (m_n * 6 >= 50) {
+				n_pll = 1;
+				m_pll = (m_n_int + 1) * n_pll;
+			} else if (m_n * 6 >= 30) {
+				n_pll = 1;
+				m_pll = (m_n_int + 1) * n_pll;
+			} else if (m_n * 6 >= 10) {
+				n_pll = 3;
+				m_pll = m_n_int * n_pll + 1;
+			} else {
+				n_pll = 2;
+				m_pll = m_n_int * n_pll;
+			}
+		}
+
+		if (n_pll == 1) {
+			phy->pll_fbd_p = 0;
+			phy->pll_pre_div1p = 1;
+		} else {
+			phy->pll_fbd_p = n_pll;
+			phy->pll_pre_div1p = 0;
+		}
+
+		if (phy->pll_fbd_2p <= 7 && phy->pll_fbd_2p >= 4)
+			r_pll = 0x10 >> (7 - phy->pll_fbd_2p);
+
+		if (m_pll == 2) {
+			phy->pll_pre_p = 0;
+			phy->pll_fbd_s = 0;
+			phy->pll_fbd_div1f = 0;
+			phy->pll_fbd_div5f = 1;
+		} else if (m_pll >= 2 * 2 * r_pll && m_pll <= 2 * 4 * r_pll) {
+			phy->pll_pre_p = m_pll / (2 * r_pll);
+			phy->pll_fbd_s = 0;
+			phy->pll_fbd_div1f = 1;
+			phy->pll_fbd_div5f = 0;
+		} else if (m_pll >= 2 * 5 * r_pll && m_pll <= 2 * 150 * r_pll) {
+			if (((m_pll / (2 * r_pll)) % 2) == 0) {
+				phy->pll_pre_p =
+					(m_pll / (2 * r_pll)) / 2 - 1;
+				phy->pll_fbd_s =
+					(m_pll / (2 * r_pll)) % 2 + 2;
+			} else {
+				phy->pll_pre_p =
+					(m_pll / (2 * r_pll)) / 2;
+				phy->pll_fbd_s =
+					(m_pll / (2 * r_pll)) % 2;
+			}
+			phy->pll_fbd_div1f = 0;
+			phy->pll_fbd_div5f = 0;
+		} else {
+			phy->pll_pre_p = 0;
+			phy->pll_fbd_s = 0;
+			phy->pll_fbd_div1f = 0;
+			phy->pll_fbd_div5f = 1;
+		}
+
+		f_kHz = (u64)1000000000 * (u64)m_pll /
+			((u64)ref_clk_ps * (u64)n_pll * (u64)q_pll);
+
+		if (f_kHz >= req_kHz)
+			break;
+
+		tmp_kHz += 10;
+
+	} while (true);
+
+	return f_kHz;
+}
+
+static void dsi_get_phy_params(u32 phy_req_kHz,
+			       struct mipi_phy_params *phy)
+{
+	u32 ref_clk_ps = PHY_REF_CLK_PERIOD_PS;
+	u32 phy_rate_kHz;
+	u32 ui;
+
+	memset(phy, 0, sizeof(*phy));
+
+	phy_rate_kHz = dsi_calc_phy_rate(phy_req_kHz, phy);
+	if (!phy_rate_kHz)
+		return;
+
+	ui = 1000000 / phy_rate_kHz;
+
+	phy->clk_t_lpx = ROUND(50, 8 * ui);
+	phy->clk_t_hs_prepare = ROUND(133, 16 * ui) - 1;
+
+	phy->clk_t_hs_zero = ROUND(262, 8 * ui);
+	phy->clk_t_hs_trial = 2 * (ROUND(60, 8 * ui) - 1);
+	phy->clk_t_wakeup = ROUND(1000000, (ref_clk_ps / 1000) - 1);
+	if (phy->clk_t_wakeup > 0xff)
+		phy->clk_t_wakeup = 0xff;
+	phy->data_t_wakeup = phy->clk_t_wakeup;
+	phy->data_t_lpx = phy->clk_t_lpx;
+	phy->data_t_hs_prepare = ROUND(125 + 10 * ui, 16 * ui) - 1;
+	phy->data_t_hs_zero = ROUND(105 + 6 * ui, 8 * ui);
+	phy->data_t_hs_trial = 2 * (ROUND(60 + 4 * ui, 8 * ui) - 1);
+	phy->data_t_ta_go = 3;
+	phy->data_t_ta_get = 4;
+
+	phy->pll_enbwt = 1;
+	phy->clklp2hs_time = ROUND(407, 8 * ui) + 12;
+	phy->clkhs2lp_time = ROUND(105 + 12 * ui, 8 * ui);
+	phy->lp2hs_time = ROUND(240 + 12 * ui, 8 * ui) + 1;
+	phy->hs2lp_time = phy->clkhs2lp_time;
+	phy->clk_to_data_delay = 1 + phy->clklp2hs_time;
+	phy->data_to_clk_delay = ROUND(60 + 52 * ui, 8 * ui) +
+				phy->clkhs2lp_time;
+
+	phy->lane_byte_clk_kHz = phy_rate_kHz / 8;
+	phy->clk_division =
+		DIV_ROUND_UP(phy->lane_byte_clk_kHz, MAX_TX_ESC_CLK);
+}
+
+static u32 dsi_get_dpi_color_coding(enum mipi_dsi_pixel_format format)
+{
+	u32 val;
+
+	/*
+	 * TODO: only support RGB888 now, to support more
+	 */
+	switch (format) {
+	case MIPI_DSI_FMT_RGB888:
+		val = DSI_24BITS_1;
+		break;
+	default:
+		val = DSI_24BITS_1;
+		break;
+	}
+
+	return val;
+}
+
+/*
+ * dsi phy reg write function
+ */
+static void dsi_phy_tst_set(void __iomem *base, u32 reg, u32 val)
+{
+	u32 reg_write = 0x10000 + reg;
+
+	/*
+	 * latch reg first
+	 */
+	writel(reg_write, base + PHY_TST_CTRL1);
+	writel(0x02, base + PHY_TST_CTRL0);
+	writel(0x00, base + PHY_TST_CTRL0);
+
+	/*
+	 * then latch value
+	 */
+	writel(val, base + PHY_TST_CTRL1);
+	writel(0x02, base + PHY_TST_CTRL0);
+	writel(0x00, base + PHY_TST_CTRL0);
+}
+
+static void dsi_set_phy_timer(void __iomem *base,
+			      struct mipi_phy_params *phy,
+			      u32 lanes)
+{
+	u32 val;
+
+	/*
+	 * Set lane value and phy stop wait time.
+	 */
+	val = (lanes - 1) | (PHY_STOP_WAIT_TIME << 8);
+	writel(val, base + PHY_IF_CFG);
+
+	/*
+	 * Set phy clk division.
+	 */
+	val = readl(base + CLKMGR_CFG) | phy->clk_division;
+	writel(val, base + CLKMGR_CFG);
+
+	/*
+	 * Set lp and hs switching params.
+	 */
+	dw_update_bits(base + PHY_TMR_CFG, 24, MASK(8), phy->hs2lp_time);
+	dw_update_bits(base + PHY_TMR_CFG, 16, MASK(8), phy->lp2hs_time);
+	dw_update_bits(base + PHY_TMR_LPCLK_CFG, 16, MASK(10),
+		       phy->clkhs2lp_time);
+	dw_update_bits(base + PHY_TMR_LPCLK_CFG, 0, MASK(10),
+		       phy->clklp2hs_time);
+	dw_update_bits(base + CLK_DATA_TMR_CFG, 8, MASK(8),
+		       phy->data_to_clk_delay);
+	dw_update_bits(base + CLK_DATA_TMR_CFG, 0, MASK(8),
+		       phy->clk_to_data_delay);
+}
+
+static void dsi_set_mipi_phy(void __iomem *base,
+			     struct mipi_phy_params *phy,
+			     u32 lanes)
+{
+	u32 delay_count;
+	u32 val;
+	u32 i;
+
+	/* phy timer setting */
+	dsi_set_phy_timer(base, phy, lanes);
+
+	/*
+	 * Reset to clean up phy tst params.
+	 */
+	writel(0, base + PHY_RSTZ);
+	writel(0, base + PHY_TST_CTRL0);
+	writel(1, base + PHY_TST_CTRL0);
+	writel(0, base + PHY_TST_CTRL0);
+
+	/*
+	 * Clock lane timing control setting: TLPX, THS-PREPARE,
+	 * THS-ZERO, THS-TRAIL, TWAKEUP.
+	 */
+	dsi_phy_tst_set(base, CLK_TLPX, phy->clk_t_lpx);
+	dsi_phy_tst_set(base, CLK_THS_PREPARE, phy->clk_t_hs_prepare);
+	dsi_phy_tst_set(base, CLK_THS_ZERO, phy->clk_t_hs_zero);
+	dsi_phy_tst_set(base, CLK_THS_TRAIL, phy->clk_t_hs_trial);
+	dsi_phy_tst_set(base, CLK_TWAKEUP, phy->clk_t_wakeup);
+
+	/*
+	 * Data lane timing control setting: TLPX, THS-PREPARE,
+	 * THS-ZERO, THS-TRAIL, TTA-GO, TTA-GET, TWAKEUP.
+	 */
+	for (i = 0; i < lanes; i++) {
+		dsi_phy_tst_set(base, DATA_TLPX(i), phy->data_t_lpx);
+		dsi_phy_tst_set(base, DATA_THS_PREPARE(i),
+				phy->data_t_hs_prepare);
+		dsi_phy_tst_set(base, DATA_THS_ZERO(i), phy->data_t_hs_zero);
+		dsi_phy_tst_set(base, DATA_THS_TRAIL(i), phy->data_t_hs_trial);
+		dsi_phy_tst_set(base, DATA_TTA_GO(i), phy->data_t_ta_go);
+		dsi_phy_tst_set(base, DATA_TTA_GET(i), phy->data_t_ta_get);
+		dsi_phy_tst_set(base, DATA_TWAKEUP(i), phy->data_t_wakeup);
+	}
+
+	/*
+	 * physical configuration: I, pll I, pll II, pll III,
+	 * pll IV, pll V.
+	 */
+	dsi_phy_tst_set(base, PHY_CFG_I, phy->hstx_ckg_sel);
+	val = (phy->pll_fbd_div5f << 5) + (phy->pll_fbd_div1f << 4) +
+				(phy->pll_fbd_2p << 1) + phy->pll_enbwt;
+	dsi_phy_tst_set(base, PHY_CFG_PLL_I, val);
+	dsi_phy_tst_set(base, PHY_CFG_PLL_II, phy->pll_fbd_p);
+	dsi_phy_tst_set(base, PHY_CFG_PLL_III, phy->pll_fbd_s);
+	val = (phy->pll_pre_div1p << 7) + phy->pll_pre_p;
+	dsi_phy_tst_set(base, PHY_CFG_PLL_IV, val);
+	val = (5 << 5) + (phy->pll_vco_750M << 4) + (phy->pll_lpf_rs << 2) +
+		phy->pll_lpf_cs;
+	dsi_phy_tst_set(base, PHY_CFG_PLL_V, val);
+
+	writel(PHY_ENABLECLK, base + PHY_RSTZ);
+	udelay(1);
+	writel(PHY_ENABLECLK | PHY_UNSHUTDOWNZ, base + PHY_RSTZ);
+	udelay(1);
+	writel(PHY_ENABLECLK | PHY_UNRSTZ | PHY_UNSHUTDOWNZ, base + PHY_RSTZ);
+	usleep_range(1000, 1500);
+
+	/*
+	 * wait for phy's clock ready
+	 */
+	delay_count = 100;
+	while (delay_count) {
+		val = readl(base +  PHY_STATUS);
+		if ((BIT(0) | BIT(2)) & val)
+			break;
+
+		udelay(1);
+		delay_count--;
+	}
+
+	if (!delay_count)
+		DRM_INFO("phylock and phystopstateclklane is not ready.\n");
+}
+
+static void dsi_set_mode_timing(void __iomem *base,
+				u32 lane_byte_clk_kHz,
+				struct drm_display_mode *mode,
+				enum mipi_dsi_pixel_format format)
+{
+	u32 hfp, hbp, hsw, vfp, vbp, vsw;
+	u32 hline_time;
+	u32 hsa_time;
+	u32 hbp_time;
+	u32 pixel_clk_kHz;
+	int htot, vtot;
+	u32 val;
+	u64 tmp;
+
+	val = dsi_get_dpi_color_coding(format);
+	writel(val, base + DPI_COLOR_CODING);
+
+	val = (mode->flags & DRM_MODE_FLAG_NHSYNC ? 1 : 0) << 2;
+	val |= (mode->flags & DRM_MODE_FLAG_NVSYNC ? 1 : 0) << 1;
+	writel(val, base +  DPI_CFG_POL);
+
+	/*
+	 * The DSI IP accepts vertical timing using lines as normal,
+	 * but horizontal timing is a mixture of pixel-clocks for the
+	 * active region and byte-lane clocks for the blanking-related
+	 * timings.  hfp is specified as the total hline_time in byte-
+	 * lane clocks minus hsa, hbp and active.
+	 */
+	pixel_clk_kHz = mode->clock;
+	htot = mode->htotal;
+	vtot = mode->vtotal;
+	hfp = mode->hsync_start - mode->hdisplay;
+	hbp = mode->htotal - mode->hsync_end;
+	hsw = mode->hsync_end - mode->hsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+	vsw = mode->vsync_end - mode->vsync_start;
+	if (vsw > 15) {
+		DRM_DEBUG_DRIVER("vsw exceeded 15\n");
+		vsw = 15;
+	}
+
+	hsa_time = (hsw * lane_byte_clk_kHz) / pixel_clk_kHz;
+	hbp_time = (hbp * lane_byte_clk_kHz) / pixel_clk_kHz;
+	tmp = (u64)htot * (u64)lane_byte_clk_kHz;
+	hline_time = DIV_ROUND_UP(tmp, pixel_clk_kHz);
+
+	/* all specified in byte-lane clocks */
+	writel(hsa_time, base + VID_HSA_TIME);
+	writel(hbp_time, base + VID_HBP_TIME);
+	writel(hline_time, base + VID_HLINE_TIME);
+
+	writel(vsw, base + VID_VSA_LINES);
+	writel(vbp, base + VID_VBP_LINES);
+	writel(vfp, base + VID_VFP_LINES);
+	writel(mode->vdisplay, base + VID_VACTIVE_LINES);
+	writel(mode->hdisplay, base + VID_PKT_SIZE);
+
+	DRM_DEBUG_DRIVER("htot=%d, hfp=%d, hbp=%d, hsw=%d\n",
+			 htot, hfp, hbp, hsw);
+	DRM_DEBUG_DRIVER("vtol=%d, vfp=%d, vbp=%d, vsw=%d\n",
+			 vtot, vfp, vbp, vsw);
+	DRM_DEBUG_DRIVER("hsa_time=%d, hbp_time=%d, hline_time=%d\n",
+			 hsa_time, hbp_time, hline_time);
+}
+
+static void dsi_set_video_mode(void __iomem *base, unsigned long flags)
+{
+	u32 val;
+	u32 mode_mask = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+	u32 non_burst_sync_pulse = MIPI_DSI_MODE_VIDEO |
+		MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+	u32 non_burst_sync_event = MIPI_DSI_MODE_VIDEO;
+
+	/*
+	 * choose video mode type
+	 */
+	if ((flags & mode_mask) == non_burst_sync_pulse)
+		val = DSI_NON_BURST_SYNC_PULSES;
+	else if ((flags & mode_mask) == non_burst_sync_event)
+		val = DSI_NON_BURST_SYNC_EVENTS;
+	else
+		val = DSI_BURST_SYNC_PULSES_1;
+	writel(val, base + VID_MODE_CFG);
+
+	writel(PHY_TXREQUESTCLKHS, base + LPCLK_CTRL);
+	writel(DSI_VIDEO_MODE, base + MODE_CFG);
+}
+
+static void dsi_mipi_init(struct dw_dsi *dsi)
+{
+	struct dsi_hw_ctx *ctx = dsi->ctx;
+	struct mipi_phy_params *phy = &dsi->phy;
+	struct drm_display_mode *mode = &dsi->cur_mode;
+	u32 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+	void __iomem *base = ctx->base;
+	u32 dphy_req_kHz;
+
+	/*
+	 * count phy params
+	 */
+	dphy_req_kHz = mode->clock * bpp / dsi->lanes;
+	dsi_get_phy_params(dphy_req_kHz, phy);
+
+	/* reset Core */
+	writel(RESET, base + PWR_UP);
+
+	/* set dsi phy params */
+	dsi_set_mipi_phy(base, phy, dsi->lanes);
+
+	/* set dsi mode timing */
+	dsi_set_mode_timing(base, phy->lane_byte_clk_kHz, mode, dsi->format);
+
+	/* set dsi video mode */
+	dsi_set_video_mode(base, dsi->mode_flags);
+
+	/* dsi wake up */
+	writel(POWERUP, base + PWR_UP);
+
+	DRM_DEBUG_DRIVER("lanes=%d, pixel_clk=%d kHz, bytes_freq=%d kHz\n",
+			 dsi->lanes, mode->clock, phy->lane_byte_clk_kHz);
+}
+
+static void dsi_encoder_enable_sub(struct drm_encoder *encoder)
+{
+	struct dw_dsi *dsi = encoder_to_dsi(encoder);
+	struct dsi_hw_ctx *ctx = dsi->ctx;
+	int ret;
+
+	if (dsi->enable)
+		return;
+
+	ret = clk_prepare_enable(ctx->pclk);
+	if (ret) {
+		DRM_ERROR("fail to enable pclk: %d\n", ret);
+		return;
+	}
+
+	dsi_mipi_init(dsi);
+}
+
+static enum drm_mode_status dsi_encoder_phy_mode_valid(
+					struct drm_encoder *encoder,
+					const struct drm_display_mode *mode)
+{
+	struct dw_dsi *dsi = encoder_to_dsi(encoder);
+	struct mipi_phy_params phy;
+	u32 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+	u32 req_kHz, act_kHz, lane_byte_clk_kHz;
+
+	/* Calculate the lane byte clk using the adjusted mode clk */
+	memset(&phy, 0, sizeof(phy));
+	req_kHz = mode->clock * bpp / dsi->lanes;
+	act_kHz = dsi_calc_phy_rate(req_kHz, &phy);
+	lane_byte_clk_kHz = act_kHz / 8;
+
+	DRM_DEBUG_DRIVER("Checking mode %ix%i-%i@%i clock: %i...",
+			mode->hdisplay, mode->vdisplay, bpp,
+			drm_mode_vrefresh(mode), mode->clock);
+
+	/*
+	 * Make sure the adjusted mode clock and the lane byte clk
+	 * have a common denominator base frequency
+	 */
+	if (mode->clock/dsi->lanes == lane_byte_clk_kHz/3) {
+		DRM_DEBUG_DRIVER("OK!\n");
+		return MODE_OK;
+	}
+
+	DRM_DEBUG_DRIVER("BAD!\n");
+	return MODE_BAD;
+}
+
+static enum drm_mode_status dsi_encoder_mode_valid(struct drm_encoder *encoder,
+					const struct drm_display_mode *mode)
+
+{
+	const struct drm_crtc_helper_funcs *crtc_funcs = NULL;
+	struct drm_crtc *crtc = NULL;
+	struct drm_display_mode adj_mode;
+	enum drm_mode_status ret;
+
+	/*
+	 * The crtc might adjust the mode, so go through the
+	 * possible crtcs (technically just one) and call
+	 * mode_fixup to figure out the adjusted mode before we
+	 * validate it.
+	 */
+	drm_for_each_crtc(crtc, encoder->dev) {
+		/*
+		 * reset adj_mode to the mode value each time,
+		 * so we don't adjust the mode twice
+		 */
+		drm_mode_copy(&adj_mode, mode);
+
+		crtc_funcs = crtc->helper_private;
+		if (crtc_funcs && crtc_funcs->mode_fixup)
+			if (!crtc_funcs->mode_fixup(crtc, mode, &adj_mode))
+				return MODE_BAD;
+
+		ret = dsi_encoder_phy_mode_valid(encoder, &adj_mode);
+		if (ret != MODE_OK)
+			return ret;
+	}
+	return MODE_OK;
+}
+
+static int dsi_host_attach(struct mipi_dsi_host *host,
+			   struct mipi_dsi_device *mdsi)
+{
+	struct dw_dsi *dsi = host_to_dsi(host);
+
+	if (mdsi->lanes < 1 || mdsi->lanes > 4) {
+		DRM_ERROR("dsi device params invalid\n");
+		return -EINVAL;
+	}
+
+	dsi->lanes = mdsi->lanes;
+	dsi->format = mdsi->format;
+	dsi->mode_flags = mdsi->mode_flags;
+
+	return 0;
+}
+
+static int dsi_host_detach(struct mipi_dsi_host *host,
+			   struct mipi_dsi_device *mdsi)
+{
+	/* do nothing */
+	return 0;
+}
+
+static const struct mipi_dsi_host_ops dsi_host_ops = {
+	.attach = dsi_host_attach,
+	.detach = dsi_host_detach,
+};
+
+static int dsi_host_init(struct device *dev, struct dw_dsi *dsi)
+{
+	struct mipi_dsi_host *host = &dsi->host;
+	int ret;
+
+	host->dev = dev;
+	host->ops = &dsi_host_ops;
+	ret = mipi_dsi_host_register(host);
+	if (ret) {
+		DRM_ERROR("failed to register dsi host\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dsi_parse_dt(struct platform_device *pdev, struct dw_dsi *dsi)
+{
+	struct dsi_hw_ctx *ctx = dsi->ctx;
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *res;
+	int ret;
+
+	/*
+	 * Get the endpoint node. In our case, dsi has one output port1
+	 * to which the external HDMI bridge is connected.
+	 */
+	ret = drm_of_find_panel_or_bridge(np, 1, 0, NULL, &dsi->bridge);
+	if (ret)
+		return ret;
+
+	ctx->pclk = devm_clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(ctx->pclk)) {
+		DRM_ERROR("failed to get pclk clock\n");
+		return PTR_ERR(ctx->pclk);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ctx->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ctx->base)) {
+		DRM_ERROR("failed to remap dsi io region\n");
+		return PTR_ERR(ctx->base);
+	}
+
+	return 0;
+}
+
+const struct kirin_dsi_ops kirin_dsi_620 = {
+	.version = KIRIN620_DSI,
+	.parse_dt = dsi_parse_dt,
+	.host_init = dsi_host_init,
+	.encoder_enable = dsi_encoder_enable_sub,
+	.encoder_valid = dsi_encoder_mode_valid
+};
+
+MODULE_AUTHOR("Xinliang Liu <xinliang.liu@linaro.org>");
+MODULE_AUTHOR("Xinliang Liu <z.liuxinliang@hisilicon.com>");
+MODULE_AUTHOR("Xinwei Kong <kong.kongxinwei@hisilicon.com>");
+MODULE_DESCRIPTION("DesignWare MIPI DSI Host Controller v1.02 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin960/dw_drm_dsi.c b/drivers/gpu/drm/hisilicon/kirin/kirin960/dw_drm_dsi.c
new file mode 100644
index 000000000..84f0b76ab
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin960/dw_drm_dsi.c
@@ -0,0 +1,1220 @@
+/*
+ * DesignWare MIPI DSI Host Controller v1.02 driver
+ *
+ * Copyright (c) 2016 Linaro Limited.
+ * Copyright (c) 2014-2016 Hisilicon Limited.
+ *
+ * Author:
+ *	<shizongxuan@huawei.com>
+ *	<zhangxiubin@huawei.com>
+ *  <lvda3@hisilicon.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/component.h>
+#include <linux/of_graph.h>
+#include <linux/iopoll.h>
+#include <video/mipi_display.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of_address.h>
+
+#include <drm/drm_of.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_encoder_slave.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_device.h>
+#include <drm/drm_sysfs.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+
+#include "../kirin_drm_dsi.h"
+#include "../dw_dsi_reg.h"
+#include "../kirin_dpe_reg.h"
+
+#define DTS_COMP_DSI_NAME "hisilicon,hi3660-dsi"
+#define ROUND1(x, y)	((x) / (y) + ((x) % (y)  ? 1 : 0))
+#define DSS_REDUCE(x)	((x) > 0 ? ((x) - 1) : (x))
+
+#define DEFAULT_MIPI_CLK_RATE	(192 * 100000L)
+#define DEFAULT_PCLK_DSI_RATE	(120 * 1000000L)
+
+#define outp32(addr, val) writel(val, addr)
+#define inp32(addr)       readl(addr)
+
+struct dss_rect {
+	s32 x;
+	s32 y;
+	s32 w;
+	s32 h;
+};
+
+enum {
+	DSI_1_LANES = 0,
+	DSI_2_LANES,
+	DSI_3_LANES,
+	DSI_4_LANES,
+};
+
+static void set_reg(char __iomem *addr, uint32_t val, uint8_t bw, uint8_t bs)
+{
+	u32 mask = (1UL << bw) - 1UL;
+	u32 tmp = 0;
+
+	tmp = inp32(addr);
+	tmp &= ~(mask << bs);
+
+	outp32(addr, tmp | ((val & mask) << bs));
+}
+
+static enum drm_mode_status dsi_encoder_phy_mode_valid(
+					struct drm_encoder *encoder,
+					const struct drm_display_mode *mode)
+{
+	/* XXX HACK whitelist for now, to move it out of
+	 * common adv7511 code.  This should be replaced by
+	 * something closer to dsi_encoder_phy_mode_valid()
+	 * found in in:
+	 *   drivers/gpu/drm/hisilicon/kirin/dw_drm_dsi.c
+	 */
+	DRM_DEBUG_DRIVER("Checking mode %ix%i@%i clock: %i...",
+			mode->hdisplay, mode->vdisplay,
+			drm_mode_vrefresh(mode), mode->clock);
+	if ((mode->hdisplay == 1920 && mode->vdisplay == 1080 && mode->clock == 148500) ||
+	    (mode->hdisplay == 1920 && mode->vdisplay == 1080 && mode->clock == 80192)  ||
+	    (mode->hdisplay == 1920 && mode->vdisplay == 1080 && mode->clock == 74250)  ||
+	    (mode->hdisplay == 1920 && mode->vdisplay == 1080 && mode->clock == 61855)  ||
+	    (mode->hdisplay == 1680 && mode->vdisplay == 1050 && mode->clock == 147116) ||
+	    (mode->hdisplay == 1680 && mode->vdisplay == 1050 && mode->clock == 146250) ||
+	    (mode->hdisplay == 1680 && mode->vdisplay == 1050 && mode->clock == 144589) ||
+	    (mode->hdisplay == 1600 && mode->vdisplay == 1200 && mode->clock == 160961) ||
+	    (mode->hdisplay == 1600 && mode->vdisplay == 900  && mode->clock == 118963) ||
+	    (mode->hdisplay == 1440 && mode->vdisplay == 900  && mode->clock == 126991) ||
+	    (mode->hdisplay == 1280 && mode->vdisplay == 1024 && mode->clock == 128946) ||
+	    (mode->hdisplay == 1280 && mode->vdisplay == 1024 && mode->clock == 98619)  ||
+	    (mode->hdisplay == 1280 && mode->vdisplay == 960  && mode->clock == 102081) ||
+	    (mode->hdisplay == 1280 && mode->vdisplay == 800  && mode->clock == 83496)  ||
+	    (mode->hdisplay == 1280 && mode->vdisplay == 720  && mode->clock == 74440)  ||
+	    (mode->hdisplay == 1280 && mode->vdisplay == 720  && mode->clock == 74250)  ||
+	    (mode->hdisplay == 1024 && mode->vdisplay == 768  && mode->clock == 78800)  ||
+	    (mode->hdisplay == 1024 && mode->vdisplay == 768  && mode->clock == 75000)  ||
+	    (mode->hdisplay == 1024 && mode->vdisplay == 768  && mode->clock == 81833)  ||
+	    (mode->hdisplay == 800  && mode->vdisplay == 600  && mode->clock == 48907)  ||
+	    (mode->hdisplay == 800  && mode->vdisplay == 600  && mode->clock == 40000)  ||
+	    (mode->hdisplay == 800  && mode->vdisplay == 480  && mode->clock == 32000)) {
+		DRM_DEBUG("OK\n");
+		return MODE_OK;
+	}
+	DRM_DEBUG("BAD\n");
+	return MODE_BAD;
+}
+
+static enum drm_mode_status dsi_encoder_mode_valid(struct drm_encoder *encoder,
+					const struct drm_display_mode *mode)
+
+{
+	struct drm_crtc *crtc = NULL;
+	struct drm_display_mode adj_mode;
+	enum drm_mode_status ret;
+
+	/*
+	 * The crtc might adjust the mode, so go through the
+	 * possible crtcs (technically just one) and call
+	 * mode_fixup to figure out the adjusted mode before we
+	 * validate it.
+	 */
+	drm_for_each_crtc(crtc, encoder->dev) {
+		/*
+		 * reset adj_mode to the mode value each time,
+		 * so we don't adjust the mode twice
+		 */
+		drm_mode_copy(&adj_mode, mode);
+
+		/* XXX - skip this as we're just using a whitelist
+		crtc_funcs = crtc->helper_private;
+		if (crtc_funcs && crtc_funcs->mode_fixup)
+			if (!crtc_funcs->mode_fixup(crtc, mode, &adj_mode))
+				return MODE_BAD;
+		*/
+		ret = dsi_encoder_phy_mode_valid(encoder, &adj_mode);
+		if (ret != MODE_OK)
+			return ret;
+	}
+	return MODE_OK;
+}
+
+static void get_dsi_phy_ctrl(struct dw_dsi *dsi,
+							struct mipi_phy_params *phy_ctrl)
+{
+	struct mipi_panel_info *mipi = NULL;
+	struct drm_display_mode *mode = NULL;
+	u32 dphy_req_kHz;
+	int bpp;
+	u32 id = 0;
+	u32 ui = 0;
+	u32 m_pll = 0;
+	u32 n_pll = 0;
+	u32 m_n_fract = 0;
+	u32 m_n_int = 0;
+	u64 lane_clock = 0;
+	u64 vco_div = 1;
+
+	u32 accuracy = 0;
+	u32 unit_tx_byte_clk_hs = 0;
+	u32 clk_post = 0;
+	u32 clk_pre = 0;
+	u32 clk_t_hs_exit = 0;
+	u32 clk_pre_delay = 0;
+	u32 clk_t_hs_prepare = 0;
+	u32 clk_t_lpx = 0;
+	u32 clk_t_hs_zero = 0;
+	u32 clk_t_hs_trial = 0;
+	u32 data_post_delay = 0;
+	u32 data_t_hs_prepare = 0;
+	u32 data_t_hs_zero = 0;
+	u32 data_t_hs_trial = 0;
+	u32 data_t_lpx = 0;
+	u32 clk_pre_delay_reality = 0;
+	u32 clk_t_hs_zero_reality = 0;
+	u32 clk_post_delay_reality = 0;
+	u32 data_t_hs_zero_reality = 0;
+	u32 data_post_delay_reality = 0;
+	u32 data_pre_delay_reality = 0;
+
+	WARN_ON(!phy_ctrl);
+	WARN_ON(!dsi);
+
+	id = dsi->cur_client;
+	mode = &dsi->cur_mode;
+	mipi = &dsi->mipi;
+
+	/*
+	 * count phy params
+	 */
+	bpp = mipi_dsi_pixel_format_to_bpp(dsi->client[id].format);
+	if (bpp < 0)
+		return;
+	if (mode->clock > 80000)
+	    dsi->client[id].lanes = 4;
+	else
+	    dsi->client[id].lanes = 3;
+	if (dsi->client[id].phy_clock)
+		dphy_req_kHz = dsi->client[id].phy_clock;
+	else
+		dphy_req_kHz = mode->clock * bpp / dsi->client[id].lanes;
+
+	lane_clock = dphy_req_kHz / 1000;
+	DRM_INFO("Expected : lane_clock = %llu M\n", lane_clock);
+
+	/************************  PLL parameters config  *********************/
+	/*chip spec :
+		If the output data rate is below 320 Mbps,
+		RG_BNAD_SEL should be set to 1.
+		At this mode a post divider of 1/4 will be applied to VCO.
+	*/
+	if ((320 <= lane_clock) && (lane_clock <= 2500)) {
+		phy_ctrl->rg_band_sel = 0;	/*0x1E[2]*/
+		vco_div = 1;
+	} else if ((80 <= lane_clock) && (lane_clock < 320)) {
+		phy_ctrl->rg_band_sel = 1;
+		vco_div = 4;
+	} else {
+		DRM_ERROR("80M <= lane_clock< = 2500M, not support lane_clock = %llu M\n",
+			lane_clock);
+	}
+
+	m_n_int = lane_clock * vco_div * 1000000UL / DEFAULT_MIPI_CLK_RATE;
+	m_n_fract = ((lane_clock * vco_div * 1000000UL * 1000UL / DEFAULT_MIPI_CLK_RATE) % 1000) * 10 / 1000;
+
+	if (m_n_int % 2 == 0) {
+		if (m_n_fract * 6 >= 50) {
+			n_pll = 2;
+			m_pll = (m_n_int + 1) * n_pll;
+		} else if (m_n_fract * 6 >= 30) {
+			n_pll = 3;
+			m_pll = m_n_int * n_pll + 2;
+		} else {
+			n_pll = 1;
+			m_pll = m_n_int * n_pll;
+		}
+	} else {
+		if (m_n_fract * 6 >= 50) {
+			n_pll = 1;
+			m_pll = (m_n_int + 1) * n_pll;
+		} else if (m_n_fract * 6 >= 30) {
+			n_pll = 1;
+			m_pll = (m_n_int + 1) * n_pll;
+		} else if (m_n_fract * 6 >= 10) {
+			n_pll = 3;
+			m_pll = m_n_int * n_pll + 1;
+		} else {
+			n_pll = 2;
+			m_pll = m_n_int * n_pll;
+		}
+	}
+
+	/*if set rg_pll_enswc=1, pll_fbd_s can't be 0*/
+	if (m_pll <= 8) {
+		phy_ctrl->pll_fbd_s = 1;
+		phy_ctrl->rg_pll_enswc = 0;
+
+		if (m_pll % 2 == 0) {
+			phy_ctrl->pll_fbd_p = m_pll / 2;
+		} else {
+			if (n_pll == 1) {
+				n_pll *= 2;
+				phy_ctrl->pll_fbd_p = (m_pll  * 2) / 2;
+			} else {
+				DRM_ERROR("phy m_pll not support!m_pll = %d\n", m_pll);
+				return;
+			}
+		}
+	} else if (m_pll <= 300) {
+		if (m_pll % 2 == 0)
+			phy_ctrl->rg_pll_enswc = 0;
+		else
+			phy_ctrl->rg_pll_enswc = 1;
+
+		phy_ctrl->pll_fbd_s = 1;
+		phy_ctrl->pll_fbd_p = m_pll / 2;
+	} else if (m_pll <= 315) {
+		phy_ctrl->pll_fbd_p = 150;
+		phy_ctrl->pll_fbd_s = m_pll - 2 * phy_ctrl->pll_fbd_p;
+		phy_ctrl->rg_pll_enswc = 1;
+	} else {
+		DRM_ERROR("phy m_pll not support!m_pll = %d\n", m_pll);
+		return;
+	}
+
+	phy_ctrl->pll_pre_p = n_pll;
+
+	lane_clock = m_pll * (DEFAULT_MIPI_CLK_RATE / n_pll) / vco_div;
+	DRM_INFO("Config : lane_clock = %llu\n", lane_clock);
+
+	/*FIXME :*/
+	phy_ctrl->rg_pll_cp = 1;		/*0x16[7:5]*/
+	phy_ctrl->rg_pll_cp_p = 3;		/*0x1E[7:5]*/
+
+	/*test_code_0x14 other parameters config*/
+	phy_ctrl->pll_enbwt = 0;	/*0x14[2]*/
+	phy_ctrl->rg_pll_chp = 0;		/*0x14[1:0]*/
+
+	/*test_code_0x16 other parameters config,  0x16[3:2] reserved*/
+	phy_ctrl->pll_lpf_cs = 0;	/*0x16[4]*/
+	phy_ctrl->rg_pll_refsel = 1;		/*0x16[1:0]*/
+
+	/*test_code_0x1E other parameters config*/
+	phy_ctrl->reload_sel = 1;			/*0x1E[4]*/
+	phy_ctrl->rg_phase_gen_en = 1;	/*0x1E[3]*/
+	phy_ctrl->pll_power_down = 0;		/*0x1E[1]*/
+	phy_ctrl->pll_register_override = 1;	/*0x1E[0]*/
+
+	/*HSTX select VCM VREF*/
+	phy_ctrl->rg_vrefsel_vcm = 0x55;
+	if (mipi->rg_vrefsel_vcm_clk_adjust != 0)
+		phy_ctrl->rg_vrefsel_vcm = (phy_ctrl->rg_vrefsel_vcm & 0x0F) |
+			((mipi->rg_vrefsel_vcm_clk_adjust & 0x0F) << 4);
+
+	if (mipi->rg_vrefsel_vcm_data_adjust != 0)
+		phy_ctrl->rg_vrefsel_vcm = (phy_ctrl->rg_vrefsel_vcm & 0xF0) |
+			(mipi->rg_vrefsel_vcm_data_adjust & 0x0F);
+
+	/*if reload_sel = 1, need to set load_command*/
+	phy_ctrl->load_command = 0x5A;
+
+	/********************  clock/data lane parameters config  ******************/
+	accuracy = 10;
+	ui =  10 * 1000000000UL * accuracy / lane_clock;
+	/*unit of measurement*/
+	unit_tx_byte_clk_hs = 8 * ui;
+
+	/* D-PHY Specification : 60ns + 52*UI <= clk_post*/
+	clk_post = 600 * accuracy + 52 * ui + mipi->clk_post_adjust * ui;
+
+	/* D-PHY Specification : clk_pre >= 8*UI*/
+	clk_pre = 8 * ui + mipi->clk_pre_adjust * ui;
+
+	/* D-PHY Specification : clk_t_hs_exit >= 100ns*/
+	clk_t_hs_exit = 1000 * accuracy + mipi->clk_t_hs_exit_adjust * ui;
+
+	/* clocked by TXBYTECLKHS*/
+	clk_pre_delay = 0 + mipi->clk_pre_delay_adjust * ui;
+
+	/* D-PHY Specification : clk_t_hs_trial >= 60ns*/
+	/* clocked by TXBYTECLKHS*/
+	clk_t_hs_trial = 600 * accuracy + 3 * unit_tx_byte_clk_hs + mipi->clk_t_hs_trial_adjust * ui;
+
+	/* D-PHY Specification : 38ns <= clk_t_hs_prepare <= 95ns*/
+	/* clocked by TXBYTECLKHS*/
+	if (mipi->clk_t_hs_prepare_adjust == 0)
+		mipi->clk_t_hs_prepare_adjust = 43;
+
+	clk_t_hs_prepare = ((380 * accuracy + mipi->clk_t_hs_prepare_adjust * ui) <= (950 * accuracy - 8 * ui)) ?
+		(380 * accuracy + mipi->clk_t_hs_prepare_adjust * ui) : (950 * accuracy - 8 * ui);
+
+	/* clocked by TXBYTECLKHS*/
+	data_post_delay = 0 + mipi->data_post_delay_adjust * ui;
+
+	/* D-PHY Specification : data_t_hs_trial >= max( n*8*UI, 60ns + n*4*UI ), n = 1*/
+	/* clocked by TXBYTECLKHS*/
+	data_t_hs_trial = ((600 * accuracy + 4 * ui) >= (8 * ui) ? (600 * accuracy + 4 * ui) : (8 * ui)) + 8 * ui +
+		3 * unit_tx_byte_clk_hs + mipi->data_t_hs_trial_adjust * ui;
+
+	/* D-PHY Specification : 40ns + 4*UI <= data_t_hs_prepare <= 85ns + 6*UI*/
+	/* clocked by TXBYTECLKHS*/
+	if (mipi->data_t_hs_prepare_adjust == 0)
+		mipi->data_t_hs_prepare_adjust = 35;
+
+	data_t_hs_prepare = ((400  * accuracy + 4 * ui + mipi->data_t_hs_prepare_adjust * ui) <= (850 * accuracy + 6 * ui - 8 * ui)) ?
+		(400  * accuracy + 4 * ui + mipi->data_t_hs_prepare_adjust * ui) : (850 * accuracy + 6 * ui - 8 * ui);
+
+	/* D-PHY chip spec : clk_t_lpx + clk_t_hs_prepare > 200ns*/
+	/* D-PHY Specification : clk_t_lpx >= 50ns*/
+	/* clocked by TXBYTECLKHS*/
+	clk_t_lpx = (((2000 * accuracy - clk_t_hs_prepare) >= 500 * accuracy) ?
+		((2000 * accuracy - clk_t_hs_prepare)) : (500 * accuracy)) +
+		mipi->clk_t_lpx_adjust * ui;
+
+	/* D-PHY Specification : clk_t_hs_zero + clk_t_hs_prepare >= 300 ns*/
+	/* clocked by TXBYTECLKHS*/
+	clk_t_hs_zero = 3000 * accuracy - clk_t_hs_prepare + 3 * unit_tx_byte_clk_hs + mipi->clk_t_hs_zero_adjust * ui;
+
+	/* D-PHY chip spec : data_t_lpx + data_t_hs_prepare > 200ns*/
+	/* D-PHY Specification : data_t_lpx >= 50ns*/
+	/* clocked by TXBYTECLKHS*/
+	data_t_lpx = clk_t_lpx + mipi->data_t_lpx_adjust * ui; /*2000 * accuracy - data_t_hs_prepare;*/
+
+	/* D-PHY Specification : data_t_hs_zero + data_t_hs_prepare >= 145ns + 10*UI*/
+	/* clocked by TXBYTECLKHS*/
+	data_t_hs_zero = 1450 * accuracy + 10 * ui - data_t_hs_prepare +
+		3 * unit_tx_byte_clk_hs + mipi->data_t_hs_zero_adjust * ui;
+
+	phy_ctrl->clk_pre_delay = ROUND1(clk_pre_delay, unit_tx_byte_clk_hs);
+	phy_ctrl->clk_t_hs_prepare = ROUND1(clk_t_hs_prepare, unit_tx_byte_clk_hs);
+	phy_ctrl->clk_t_lpx = ROUND1(clk_t_lpx, unit_tx_byte_clk_hs);
+	phy_ctrl->clk_t_hs_zero = ROUND1(clk_t_hs_zero, unit_tx_byte_clk_hs);
+	phy_ctrl->clk_t_hs_trial = ROUND1(clk_t_hs_trial, unit_tx_byte_clk_hs);
+
+	phy_ctrl->data_post_delay = ROUND1(data_post_delay, unit_tx_byte_clk_hs);
+	phy_ctrl->data_t_hs_prepare = ROUND1(data_t_hs_prepare, unit_tx_byte_clk_hs);
+	phy_ctrl->data_t_lpx = ROUND1(data_t_lpx, unit_tx_byte_clk_hs);
+	phy_ctrl->data_t_hs_zero = ROUND1(data_t_hs_zero, unit_tx_byte_clk_hs);
+	phy_ctrl->data_t_hs_trial = ROUND1(data_t_hs_trial, unit_tx_byte_clk_hs);
+	phy_ctrl->data_t_ta_go = 4;
+	phy_ctrl->data_t_ta_get = 5;
+
+	clk_pre_delay_reality = phy_ctrl->clk_pre_delay + 2;
+	clk_t_hs_zero_reality = phy_ctrl->clk_t_hs_zero + 8;
+	data_t_hs_zero_reality = phy_ctrl->data_t_hs_zero + 4;
+	data_post_delay_reality = phy_ctrl->data_post_delay + 4;
+
+	phy_ctrl->clk_post_delay = phy_ctrl->data_t_hs_trial + ROUND1(clk_post, unit_tx_byte_clk_hs);
+	phy_ctrl->data_pre_delay = clk_pre_delay_reality + phy_ctrl->clk_t_lpx +
+		phy_ctrl->clk_t_hs_prepare + clk_t_hs_zero_reality + ROUND1(clk_pre, unit_tx_byte_clk_hs) ;
+
+	clk_post_delay_reality = phy_ctrl->clk_post_delay + 4;
+	data_pre_delay_reality = phy_ctrl->data_pre_delay + 2;
+
+	phy_ctrl->clk_lane_lp2hs_time = clk_pre_delay_reality + phy_ctrl->clk_t_lpx +
+		phy_ctrl->clk_t_hs_prepare + clk_t_hs_zero_reality + 3;
+	phy_ctrl->clk_lane_hs2lp_time = clk_post_delay_reality + phy_ctrl->clk_t_hs_trial + 3;
+	phy_ctrl->data_lane_lp2hs_time = data_pre_delay_reality + phy_ctrl->data_t_lpx +
+		phy_ctrl->data_t_hs_prepare + data_t_hs_zero_reality + 3;
+	phy_ctrl->data_lane_hs2lp_time = data_post_delay_reality + phy_ctrl->data_t_hs_trial + 3;
+	phy_ctrl->phy_stop_wait_time = clk_post_delay_reality +
+		phy_ctrl->clk_t_hs_trial + ROUND1(clk_t_hs_exit, unit_tx_byte_clk_hs) -
+		(data_post_delay_reality + phy_ctrl->data_t_hs_trial) + 3;
+
+	phy_ctrl->lane_byte_clk = lane_clock / 8;
+	phy_ctrl->clk_division = (((phy_ctrl->lane_byte_clk / 2) % mipi->max_tx_esc_clk) > 0) ?
+		(phy_ctrl->lane_byte_clk / 2 / mipi->max_tx_esc_clk + 1) :
+		(phy_ctrl->lane_byte_clk / 2 / mipi->max_tx_esc_clk);
+
+	DRM_INFO("PHY clock_lane and data_lane config : \n"
+		"rg_vrefsel_vcm=%u\n"
+		"clk_pre_delay=%u\n"
+		"clk_post_delay=%u\n"
+		"clk_t_hs_prepare=%u\n"
+		"clk_t_lpx=%u\n"
+		"clk_t_hs_zero=%u\n"
+		"clk_t_hs_trial=%u\n"
+		"data_pre_delay=%u\n"
+		"data_post_delay=%u\n"
+		"data_t_hs_prepare=%u\n"
+		"data_t_lpx=%u\n"
+		"data_t_hs_zero=%u\n"
+		"data_t_hs_trial=%u\n"
+		"data_t_ta_go=%u\n"
+		"data_t_ta_get=%u\n",
+		phy_ctrl->rg_vrefsel_vcm,
+		phy_ctrl->clk_pre_delay,
+		phy_ctrl->clk_post_delay,
+		phy_ctrl->clk_t_hs_prepare,
+		phy_ctrl->clk_t_lpx,
+		phy_ctrl->clk_t_hs_zero,
+		phy_ctrl->clk_t_hs_trial,
+		phy_ctrl->data_pre_delay,
+		phy_ctrl->data_post_delay,
+		phy_ctrl->data_t_hs_prepare,
+		phy_ctrl->data_t_lpx,
+		phy_ctrl->data_t_hs_zero,
+		phy_ctrl->data_t_hs_trial,
+		phy_ctrl->data_t_ta_go,
+		phy_ctrl->data_t_ta_get);
+	DRM_INFO("clk_lane_lp2hs_time=%u\n"
+		"clk_lane_hs2lp_time=%u\n"
+		"data_lane_lp2hs_time=%u\n"
+		"data_lane_hs2lp_time=%u\n"
+		"phy_stop_wait_time=%u\n",
+		phy_ctrl->clk_lane_lp2hs_time,
+		phy_ctrl->clk_lane_hs2lp_time,
+		phy_ctrl->data_lane_lp2hs_time,
+		phy_ctrl->data_lane_hs2lp_time,
+		phy_ctrl->phy_stop_wait_time);
+}
+
+static void dsi_set_burst_mode(void __iomem *base, unsigned long flags)
+{
+	u32 val;
+	u32 mode_mask = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+	u32 non_burst_sync_pulse = MIPI_DSI_MODE_VIDEO |
+		MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+	u32 non_burst_sync_event = MIPI_DSI_MODE_VIDEO;
+
+	/*
+	 * choose video mode type
+	 */
+	if ((flags & mode_mask) == non_burst_sync_pulse)
+		val = DSI_NON_BURST_SYNC_PULSES;
+	else if ((flags & mode_mask) == non_burst_sync_event)
+		val = DSI_NON_BURST_SYNC_EVENTS;
+	else
+		val = DSI_BURST_SYNC_PULSES_1;
+
+	set_reg(base + MIPIDSI_VID_MODE_CFG_OFFSET, val, 2, 0);
+}
+
+/*
+ * dsi phy reg write function
+ */
+static void dsi_phy_tst_set(void __iomem *base, u32 reg, u32 val)
+{
+	u32 reg_write = 0x10000 + reg;
+
+	/*
+	 * latch reg first
+	 */
+	writel(reg_write, base + MIPIDSI_PHY_TST_CTRL1_OFFSET);
+	writel(0x02, base + MIPIDSI_PHY_TST_CTRL0_OFFSET);
+	writel(0x00, base + MIPIDSI_PHY_TST_CTRL0_OFFSET);
+
+	/*
+	 * then latch value
+	 */
+	writel(val, base + MIPIDSI_PHY_TST_CTRL1_OFFSET);
+	writel(0x02, base + MIPIDSI_PHY_TST_CTRL0_OFFSET);
+	writel(0x00, base + MIPIDSI_PHY_TST_CTRL0_OFFSET);
+}
+
+static void dsi_mipi_init(struct dw_dsi *dsi, char __iomem *mipi_dsi_base)
+{
+	u32 hline_time = 0;
+	u32 hsa_time = 0;
+	u32 hbp_time = 0;
+	u64 pixel_clk = 0;
+	u32 i = 0;
+	u32 id = 0;
+	unsigned long dw_jiffies = 0;
+	u32 tmp = 0;
+	bool is_ready = false;
+	struct mipi_panel_info *mipi = NULL;
+	struct dss_rect rect;
+	u32 cmp_stopstate_val = 0;
+	u32 lanes;
+
+	WARN_ON(!dsi);
+	WARN_ON(!mipi_dsi_base);
+
+	id = dsi->cur_client;
+	mipi = &dsi->mipi;
+
+	if (mipi->max_tx_esc_clk == 0) {
+		DRM_INFO("max_tx_esc_clk is invalid!");
+		mipi->max_tx_esc_clk = DEFAULT_MAX_TX_ESC_CLK;
+	}
+
+	memset(&dsi->phy, 0, sizeof(struct mipi_phy_params));
+	get_dsi_phy_ctrl(dsi, &dsi->phy);
+
+	rect.x = 0;
+	rect.y = 0;
+	rect.w = dsi->cur_mode.hdisplay;
+	rect.h = dsi->cur_mode.vdisplay;
+	lanes = dsi->client[id].lanes - 1;
+	/***************Configure the DPHY start**************/
+
+	set_reg(mipi_dsi_base + MIPIDSI_PHY_IF_CFG_OFFSET, lanes, 2, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_CLKMGR_CFG_OFFSET, dsi->phy.clk_division, 8, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_CLKMGR_CFG_OFFSET, dsi->phy.clk_division, 8, 8);
+
+	outp32(mipi_dsi_base + MIPIDSI_PHY_RSTZ_OFFSET, 0x00000000);
+
+	outp32(mipi_dsi_base + MIPIDSI_PHY_TST_CTRL0_OFFSET, 0x00000000);
+	outp32(mipi_dsi_base + MIPIDSI_PHY_TST_CTRL0_OFFSET, 0x00000001);
+	outp32(mipi_dsi_base + MIPIDSI_PHY_TST_CTRL0_OFFSET, 0x00000000);
+
+	/* physical configuration PLL I*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x14,
+		(dsi->phy.pll_fbd_s << 4) + (dsi->phy.rg_pll_enswc << 3) +
+		(dsi->phy.pll_enbwt << 2) + dsi->phy.rg_pll_chp);
+
+	/* physical configuration PLL II, M*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x15, dsi->phy.pll_fbd_p);
+
+	/* physical configuration PLL III*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x16,
+		(dsi->phy.rg_pll_cp << 5) + (dsi->phy.pll_lpf_cs << 4) +
+		dsi->phy.rg_pll_refsel);
+
+	/* physical configuration PLL IV, N*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x17, dsi->phy.pll_pre_p);
+
+	/* sets the analog characteristic of V reference in D-PHY TX*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x1D, dsi->phy.rg_vrefsel_vcm);
+
+	/* MISC AFE Configuration*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x1E,
+		(dsi->phy.rg_pll_cp_p << 5) + (dsi->phy.reload_sel << 4) +
+		(dsi->phy.rg_phase_gen_en << 3) + (dsi->phy.rg_band_sel << 2) +
+		(dsi->phy.pll_power_down << 1) + dsi->phy.pll_register_override);
+
+	/*reload_command*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x1F, dsi->phy.load_command);
+
+	/* pre_delay of clock lane request setting*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x20, DSS_REDUCE(dsi->phy.clk_pre_delay));
+
+	/* post_delay of clock lane request setting*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x21, DSS_REDUCE(dsi->phy.clk_post_delay));
+
+	/* clock lane timing ctrl - t_lpx*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x22, DSS_REDUCE(dsi->phy.clk_t_lpx));
+
+	/* clock lane timing ctrl - t_hs_prepare*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x23, DSS_REDUCE(dsi->phy.clk_t_hs_prepare));
+
+	/* clock lane timing ctrl - t_hs_zero*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x24, DSS_REDUCE(dsi->phy.clk_t_hs_zero));
+
+	/* clock lane timing ctrl - t_hs_trial*/
+	dsi_phy_tst_set(mipi_dsi_base, 0x25, dsi->phy.clk_t_hs_trial);
+
+	for (i = 0; i <= lanes; i++) {
+		/* data lane pre_delay*/
+		tmp = 0x30 + (i << 4);
+		dsi_phy_tst_set(mipi_dsi_base, tmp, DSS_REDUCE(dsi->phy.data_pre_delay));
+
+		/*data lane post_delay*/
+		tmp = 0x31 + (i << 4);
+		dsi_phy_tst_set(mipi_dsi_base, tmp, DSS_REDUCE(dsi->phy.data_post_delay));
+
+		/* data lane timing ctrl - t_lpx*/
+		dsi_phy_tst_set(mipi_dsi_base, tmp, DSS_REDUCE(dsi->phy.data_t_lpx));
+
+		/* data lane timing ctrl - t_hs_prepare*/
+		tmp = 0x33 + (i << 4);
+		dsi_phy_tst_set(mipi_dsi_base, tmp, DSS_REDUCE(dsi->phy.data_t_hs_prepare));
+
+		/* data lane timing ctrl - t_hs_zero*/
+		tmp = 0x34 + (i << 4);
+		dsi_phy_tst_set(mipi_dsi_base, tmp, DSS_REDUCE(dsi->phy.data_t_hs_zero));
+
+		/* data lane timing ctrl - t_hs_trial*/
+		tmp = 0x35 + (i << 4);
+		dsi_phy_tst_set(mipi_dsi_base, tmp, DSS_REDUCE(dsi->phy.data_t_hs_trial));
+
+		/* data lane timing ctrl - t_ta_go*/
+		tmp = 0x36 + (i << 4);
+		dsi_phy_tst_set(mipi_dsi_base, tmp, DSS_REDUCE(dsi->phy.data_t_ta_go));
+
+		/* data lane timing ctrl - t_ta_get*/
+		tmp = 0x37 + (i << 4);
+		dsi_phy_tst_set(mipi_dsi_base, tmp, DSS_REDUCE(dsi->phy.data_t_ta_get));
+	}
+
+	outp32(mipi_dsi_base + MIPIDSI_PHY_RSTZ_OFFSET, 0x00000007);
+
+	is_ready = false;
+	dw_jiffies = jiffies + HZ / 2;
+	do {
+		tmp = inp32(mipi_dsi_base + MIPIDSI_PHY_STATUS_OFFSET);
+		if ((tmp & 0x00000001) == 0x00000001) {
+			is_ready = true;
+			break;
+		}
+	} while (time_after(dw_jiffies, jiffies));
+
+	if (!is_ready) {
+		DRM_INFO("phylock is not ready!MIPIDSI_PHY_STATUS_OFFSET=0x%x.\n",
+			tmp);
+	}
+
+	if (lanes >= DSI_4_LANES)
+		cmp_stopstate_val = (BIT(4) | BIT(7) | BIT(9) | BIT(11));
+	else if (lanes >= DSI_3_LANES)
+		cmp_stopstate_val = (BIT(4) | BIT(7) | BIT(9));
+	else if (lanes >= DSI_2_LANES)
+		cmp_stopstate_val = (BIT(4) | BIT(7));
+	else
+		cmp_stopstate_val = (BIT(4));
+
+	is_ready = false;
+	dw_jiffies = jiffies + HZ / 2;
+	do {
+		tmp = inp32(mipi_dsi_base + MIPIDSI_PHY_STATUS_OFFSET);
+		if ((tmp & cmp_stopstate_val) == cmp_stopstate_val) {
+			is_ready = true;
+			break;
+		}
+	} while (time_after(dw_jiffies, jiffies));
+
+	if (!is_ready) {
+		DRM_INFO("phystopstateclklane is not ready! MIPIDSI_PHY_STATUS_OFFSET=0x%x.\n",
+			tmp);
+	}
+
+	/*************************Configure the DPHY end*************************/
+
+	/* phy_stop_wait_time*/
+	set_reg(mipi_dsi_base + MIPIDSI_PHY_IF_CFG_OFFSET, dsi->phy.phy_stop_wait_time, 8, 8);
+
+	/*--------------configuring the DPI packet transmission----------------*/
+	/*
+	** 2. Configure the DPI Interface:
+	** This defines how the DPI interface interacts with the controller.
+	*/
+	set_reg(mipi_dsi_base + MIPIDSI_DPI_VCID_OFFSET, mipi->vc, 2, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_DPI_COLOR_CODING_OFFSET, mipi->color_mode, 4, 0);
+
+	set_reg(mipi_dsi_base + MIPIDSI_DPI_CFG_POL_OFFSET, dsi->ldi.data_en_plr, 1, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_DPI_CFG_POL_OFFSET, dsi->ldi.vsync_plr, 1, 1);
+	set_reg(mipi_dsi_base + MIPIDSI_DPI_CFG_POL_OFFSET, dsi->ldi.hsync_plr, 1, 2);
+	set_reg(mipi_dsi_base + MIPIDSI_DPI_CFG_POL_OFFSET, 0x0, 1, 3);
+	set_reg(mipi_dsi_base + MIPIDSI_DPI_CFG_POL_OFFSET, 0x0, 1, 4);
+
+	/*
+	** 3. Select the Video Transmission Mode:
+	** This defines how the processor requires the video line to be
+	** transported through the DSI link.
+	*/
+	/* video mode: low power mode*/
+	set_reg(mipi_dsi_base + MIPIDSI_VID_MODE_CFG_OFFSET, 0x3f, 6, 8);
+	/* set_reg(mipi_dsi_base + MIPIDSI_VID_MODE_CFG_OFFSET, 0x0, 1, 14); */
+
+	/* TODO: fix blank display bug when set backlight*/
+	set_reg(mipi_dsi_base + MIPIDSI_DPI_LP_CMD_TIM_OFFSET, 0x4, 8, 16);
+	/* video mode: send read cmd by lp mode*/
+	set_reg(mipi_dsi_base + MIPIDSI_VID_MODE_CFG_OFFSET, 0x1, 1, 15);
+
+	set_reg(mipi_dsi_base + MIPIDSI_VID_PKT_SIZE_OFFSET, rect.w, 14, 0);
+
+	/* burst mode*/
+	dsi_set_burst_mode(mipi_dsi_base, dsi->client[id].mode_flags);
+	/* for dsi read, BTA enable*/
+	set_reg(mipi_dsi_base + MIPIDSI_PCKHDL_CFG_OFFSET, 0x1, 1, 2);
+
+	/*
+	** 4. Define the DPI Horizontal timing configuration:
+	**
+	** Hsa_time = HSA*(PCLK period/Clk Lane Byte Period);
+	** Hbp_time = HBP*(PCLK period/Clk Lane Byte Period);
+	** Hline_time = (HSA+HBP+HACT+HFP)*(PCLK period/Clk Lane Byte Period);
+	*/
+	pixel_clk = dsi->cur_mode.clock * 1000;
+	/*htot = dsi->cur_mode.htotal;*/
+	/*vtot = dsi->cur_mode.vtotal;*/
+	dsi->ldi.h_front_porch = dsi->cur_mode.hsync_start - dsi->cur_mode.hdisplay;
+	dsi->ldi.h_back_porch = dsi->cur_mode.htotal - dsi->cur_mode.hsync_end;
+	dsi->ldi.h_pulse_width = dsi->cur_mode.hsync_end - dsi->cur_mode.hsync_start;
+	dsi->ldi.v_front_porch = dsi->cur_mode.vsync_start - dsi->cur_mode.vdisplay;
+	dsi->ldi.v_back_porch = dsi->cur_mode.vtotal - dsi->cur_mode.vsync_end;
+	dsi->ldi.v_pulse_width = dsi->cur_mode.vsync_end - dsi->cur_mode.vsync_start;
+	if (dsi->ldi.v_pulse_width > 15) {
+		DRM_DEBUG_DRIVER("vsw exceeded 15\n");
+		dsi->ldi.v_pulse_width = 15;
+	}
+	hsa_time = dsi->ldi.h_pulse_width * dsi->phy.lane_byte_clk / pixel_clk;
+	hbp_time = dsi->ldi.h_back_porch * dsi->phy.lane_byte_clk / pixel_clk;
+	hline_time = ROUND1((dsi->ldi.h_pulse_width + dsi->ldi.h_back_porch +
+		rect.w + dsi->ldi.h_front_porch) * dsi->phy.lane_byte_clk, pixel_clk);
+
+	DRM_INFO("hsa_time=%d, hbp_time=%d, hline_time=%d\n",
+	    hsa_time, hbp_time, hline_time);
+	DRM_INFO("lane_byte_clk=%llu, pixel_clk=%llu\n",
+	    dsi->phy.lane_byte_clk, pixel_clk);
+	set_reg(mipi_dsi_base + MIPIDSI_VID_HSA_TIME_OFFSET, hsa_time, 12, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_VID_HBP_TIME_OFFSET, hbp_time, 12, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_VID_HLINE_TIME_OFFSET, hline_time, 15, 0);
+
+	/* Define the Vertical line configuration*/
+	set_reg(mipi_dsi_base + MIPIDSI_VID_VSA_LINES_OFFSET, dsi->ldi.v_pulse_width, 10, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_VID_VBP_LINES_OFFSET, dsi->ldi.v_back_porch, 10, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_VID_VFP_LINES_OFFSET, dsi->ldi.v_front_porch, 10, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_VID_VACTIVE_LINES_OFFSET, rect.h, 14, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_TO_CNT_CFG_OFFSET, 0x7FF, 16, 0);
+
+	/* Configure core's phy parameters*/
+	set_reg(mipi_dsi_base + MIPIDSI_PHY_TMR_LPCLK_CFG_OFFSET, dsi->phy.clk_lane_lp2hs_time, 10, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_PHY_TMR_LPCLK_CFG_OFFSET, dsi->phy.clk_lane_hs2lp_time, 10, 16);
+
+	set_reg(mipi_dsi_base + MIPIDSI_PHY_TMR_RD_CFG_OFFSET, 0x7FFF, 15, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_PHY_TMR_CFG_OFFSET, dsi->phy.data_lane_lp2hs_time, 10, 0);
+	set_reg(mipi_dsi_base + MIPIDSI_PHY_TMR_CFG_OFFSET, dsi->phy.data_lane_hs2lp_time, 10, 16);
+
+	/* Waking up Core*/
+	set_reg(mipi_dsi_base + MIPIDSI_PWR_UP_OFFSET, 0x1, 1, 0);
+}
+
+static int mipi_dsi_on_sub1(struct dw_dsi *dsi, char __iomem *mipi_dsi_base)
+{
+	WARN_ON(!mipi_dsi_base);
+
+	/* mipi init */
+	dsi_mipi_init(dsi, mipi_dsi_base);
+	DRM_INFO("dsi_mipi_init ok\n");
+	/* switch to cmd mode */
+	set_reg(mipi_dsi_base + MIPIDSI_MODE_CFG_OFFSET, 0x1, 1, 0);
+	/* cmd mode: low power mode */
+	set_reg(mipi_dsi_base + MIPIDSI_CMD_MODE_CFG_OFFSET, 0x7f, 7, 8);
+	set_reg(mipi_dsi_base + MIPIDSI_CMD_MODE_CFG_OFFSET, 0xf, 4, 16);
+	set_reg(mipi_dsi_base + MIPIDSI_CMD_MODE_CFG_OFFSET, 0x1, 1, 24);
+	/* disable generate High Speed clock */
+	/* delete? */
+	set_reg(mipi_dsi_base + MIPIDSI_LPCLK_CTRL_OFFSET, 0x0, 1, 0);
+
+	return 0;
+}
+
+static int mipi_dsi_on_sub2(struct dw_dsi *dsi, char __iomem *mipi_dsi_base)
+{
+	WARN_ON(!mipi_dsi_base);
+
+	/* switch to video mode */
+	set_reg(mipi_dsi_base + MIPIDSI_MODE_CFG_OFFSET, 0x0, 1, 0);
+
+	/* enable EOTP TX */
+	set_reg(mipi_dsi_base + MIPIDSI_PCKHDL_CFG_OFFSET, 0x1, 1, 0);
+
+	/* enable generate High Speed clock, continue clock */
+	set_reg(mipi_dsi_base + MIPIDSI_LPCLK_CTRL_OFFSET, 0x1, 2, 0);
+
+	return 0;
+}
+
+static void dsi_encoder_enable_sub(struct drm_encoder *encoder)
+{
+	struct dw_dsi *dsi = encoder_to_dsi(encoder);
+	struct dsi_hw_ctx *ctx = dsi->ctx;
+	int ret;
+
+	if (dsi->enable)
+		return;
+
+	ret = clk_prepare_enable(ctx->dss_dphy0_ref_clk);
+	if (ret) {
+		DRM_ERROR("fail to enable dss_dphy0_ref_clk: %d\n", ret);
+		return;
+	}
+
+	ret = clk_prepare_enable(ctx->dss_dphy0_cfg_clk);
+	if (ret) {
+		DRM_ERROR("fail to enable dss_dphy0_cfg_clk: %d\n", ret);
+		return;
+	}
+
+	ret = clk_prepare_enable(ctx->dss_pclk_dsi0_clk);
+	if (ret) {
+		DRM_ERROR("fail to enable dss_pclk_dsi0_clk: %d\n", ret);
+		return;
+	}
+
+	mipi_dsi_on_sub1(dsi, ctx->base);
+
+	mipi_dsi_on_sub2(dsi, ctx->base);
+}
+
+static int dsi_host_attach(struct mipi_dsi_host *host,
+			   struct mipi_dsi_device *mdsi)
+{
+	struct dw_dsi *dsi = host_to_dsi(host);
+	u32 id = mdsi->channel >= 1 ? OUT_PANEL : OUT_HDMI;
+
+	if (mdsi->lanes < 1 || mdsi->lanes > 4) {
+		DRM_ERROR("dsi device params invalid\n");
+		return -EINVAL;
+	}
+
+	dsi->client[id].lanes = mdsi->lanes;
+	dsi->client[id].format = mdsi->format;
+	dsi->client[id].mode_flags = mdsi->mode_flags;
+	dsi->client[id].phy_clock = 0;//mdsi->phy_clock;
+
+	DRM_INFO("host attach, client name=[%s], id=%d\n", mdsi->name, id);
+
+	return 0;
+}
+
+static int dsi_host_detach(struct mipi_dsi_host *host,
+			   struct mipi_dsi_device *mdsi)
+{
+	/* do nothing */
+	return 0;
+}
+
+static int dsi_gen_pkt_hdr_write(void __iomem *base, u32 val)
+{
+	u32 status;
+	int ret;
+
+	ret = readx_poll_timeout(readl, base + CMD_PKT_STATUS, status,
+				 !(status & GEN_CMD_FULL), 1000,
+				 CMD_PKT_STATUS_TIMEOUT_US);
+	if (ret < 0) {
+		DRM_ERROR("failed to get available command FIFO\n");
+		return ret;
+	}
+
+	writel(val, base + GEN_HDR);
+
+	ret = readx_poll_timeout(readl, base + CMD_PKT_STATUS, status,
+				 status & (GEN_CMD_EMPTY | GEN_PLD_W_EMPTY),
+				 1000, CMD_PKT_STATUS_TIMEOUT_US);
+	if (ret < 0) {
+		DRM_ERROR("failed to write command FIFO\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dsi_dcs_short_write(void __iomem *base,
+			       const struct mipi_dsi_msg *msg)
+{
+	const u16 *tx_buf = msg->tx_buf;
+	u32 val = GEN_HDATA(*tx_buf) | GEN_HTYPE(msg->type);
+
+	if (msg->tx_len > 2) {
+		DRM_ERROR("too long tx buf length %zu for short write\n",
+			  msg->tx_len);
+		return -EINVAL;
+	}
+
+	return dsi_gen_pkt_hdr_write(base, val);
+}
+
+static int dsi_dcs_long_write(void __iomem *base,
+			      const struct mipi_dsi_msg *msg)
+{
+	const u32 *tx_buf = msg->tx_buf;
+	int len = msg->tx_len, pld_data_bytes = sizeof(*tx_buf), ret;
+	u32 val = GEN_HDATA(msg->tx_len) | GEN_HTYPE(msg->type);
+	u32 remainder = 0;
+	u32 status;
+
+	if (msg->tx_len < 3) {
+		DRM_ERROR("wrong tx buf length %zu for long write\n",
+			  msg->tx_len);
+		return -EINVAL;
+	}
+
+	while (DIV_ROUND_UP(len, pld_data_bytes)) {
+		if (len < pld_data_bytes) {
+			memcpy(&remainder, tx_buf, len);
+			writel(remainder, base + GEN_PLD_DATA);
+			len = 0;
+		} else {
+			writel(*tx_buf, base + GEN_PLD_DATA);
+			tx_buf++;
+			len -= pld_data_bytes;
+		}
+
+		ret = readx_poll_timeout(readl, base + CMD_PKT_STATUS,
+					 status, !(status & GEN_PLD_W_FULL), 1000,
+					 CMD_PKT_STATUS_TIMEOUT_US);
+		if (ret < 0) {
+			DRM_ERROR("failed to get available write payload FIFO\n");
+			return ret;
+		}
+	}
+
+	return dsi_gen_pkt_hdr_write(base, val);
+}
+
+static ssize_t dsi_host_transfer(struct mipi_dsi_host *host,
+				    const struct mipi_dsi_msg *msg)
+{
+	struct dw_dsi *dsi = host_to_dsi(host);
+	struct dsi_hw_ctx *ctx = dsi->ctx;
+	void __iomem *base = ctx->base;
+	int ret;
+
+	switch (msg->type) {
+	case MIPI_DSI_DCS_SHORT_WRITE:
+	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+	case MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:
+		ret = dsi_dcs_short_write(base, msg);
+		break;
+	case MIPI_DSI_DCS_LONG_WRITE:
+		ret = dsi_dcs_long_write(base, msg);
+		break;
+	default:
+		DRM_ERROR("unsupported message type\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct mipi_dsi_host_ops dsi_host_ops = {
+	.attach = dsi_host_attach,
+	.detach = dsi_host_detach,
+	.transfer = dsi_host_transfer,
+};
+
+static int dsi_host_init(struct device *dev, struct dw_dsi *dsi)
+{
+	struct mipi_dsi_host *host = &dsi->host;
+	struct mipi_panel_info *mipi = &dsi->mipi;
+	int ret;
+
+	host->dev = dev;
+	host->ops = &dsi_host_ops;
+
+	mipi->max_tx_esc_clk = 10 * 1000000UL;
+	mipi->vc = 0;
+	mipi->color_mode = DSI_24BITS_1;
+	mipi->clk_post_adjust = 120;
+	mipi->clk_pre_adjust = 0;
+	mipi->clk_t_hs_prepare_adjust = 0;
+	mipi->clk_t_lpx_adjust = 0;
+	mipi->clk_t_hs_trial_adjust = 0;
+	mipi->clk_t_hs_exit_adjust = 0;
+	mipi->clk_t_hs_zero_adjust = 0;
+
+	dsi->ldi.data_en_plr = 0;
+	dsi->ldi.vsync_plr = 0;
+	dsi->ldi.hsync_plr = 0;
+
+	ret = mipi_dsi_host_register(host);
+	if (ret) {
+		DRM_ERROR("failed to register dsi host\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dsi_parse_bridge_endpoint(struct dw_dsi *dsi,
+				     struct device_node *endpoint)
+{
+	struct device_node *bridge_node;
+	struct drm_bridge *bridge;
+
+	bridge_node = of_graph_get_remote_port_parent(endpoint);
+	if (!bridge_node) {
+		DRM_ERROR("no valid bridge node\n");
+		return -ENODEV;
+	}
+	of_node_put(bridge_node);
+
+	bridge = of_drm_find_bridge(bridge_node);
+	if (!bridge) {
+		DRM_INFO("wait for external HDMI bridge driver.\n");
+		return -EPROBE_DEFER;
+	}
+	dsi->bridge = bridge;
+
+	return 0;
+}
+
+static int dsi_parse_panel_endpoint(struct dw_dsi *dsi,
+				    struct device_node *endpoint)
+{
+	struct device_node *panel_node;
+	struct drm_panel *panel;
+
+	panel_node = of_graph_get_remote_port_parent(endpoint);
+	if (!panel_node) {
+		DRM_ERROR("no valid panel node\n");
+		return -ENODEV;
+	}
+	of_node_put(panel_node);
+
+	panel = of_drm_find_panel(panel_node);
+	if (IS_ERR(panel)) {
+		DRM_DEBUG_DRIVER("skip this panel endpoint.\n");
+		return 0;
+	}
+	dsi->panel = panel;
+
+	return 0;
+}
+
+static int dsi_parse_endpoint(struct dw_dsi *dsi,
+			      struct device_node *np,
+			      enum dsi_output_client client)
+{
+	struct device_node *ep_node;
+	struct of_endpoint ep;
+	int ret = 0;
+
+	if (client == OUT_MAX)
+		return -EINVAL;
+
+	for_each_endpoint_of_node(np, ep_node) {
+		ret = of_graph_parse_endpoint(ep_node, &ep);
+		if (ret) {
+			of_node_put(ep_node);
+			return ret;
+		}
+
+		/* skip dsi input port, port == 0 is input port */
+		if (ep.port == 0)
+			continue;
+
+		/* parse bridge endpoint */
+		if (client == OUT_HDMI) {
+			if (ep.id == 0) {
+				ret = dsi_parse_bridge_endpoint(dsi, ep_node);
+				if (dsi->bridge)
+					break;
+			}
+		} else { /* parse panel endpoint */
+			if (ep.id > 0) {
+				ret = dsi_parse_panel_endpoint(dsi, ep_node);
+				if (dsi->panel)
+					break;
+			}
+		}
+
+		if (ret) {
+			of_node_put(ep_node);
+			return ret;
+		}
+	}
+
+	if (!dsi->bridge && !dsi->panel) {
+		DRM_ERROR("at least one bridge or panel node is required\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int dsi_parse_dt(struct platform_device *pdev, struct dw_dsi *dsi)
+{
+	struct dsi_hw_ctx *ctx = dsi->ctx;
+	int ret = 0;
+	struct device_node *np = pdev->dev.of_node;
+
+	/* parse HDMI bridge endpoint */
+	ret = dsi_parse_endpoint(dsi, np, OUT_HDMI);
+	if (ret)
+		return ret;
+
+
+
+	/* parse panel endpoint */
+	ret = dsi_parse_endpoint(dsi, np, OUT_PANEL);
+	if (ret)
+		return ret;
+	
+
+	np = of_find_compatible_node(NULL, NULL, DTS_COMP_DSI_NAME);
+	if (!np) {
+			DRM_ERROR("NOT FOUND device node %s!\n",
+				    DTS_COMP_DSI_NAME);
+			return -ENXIO;
+	}
+
+	ctx->base = of_iomap(np, 0);
+	if (!(ctx->base)) {
+			DRM_ERROR ("failed to get base resource.\n");
+			return -ENXIO;
+	}
+
+	ctx->peri_crg_base = of_iomap(np, 1);
+	if (!(ctx->peri_crg_base)) {
+			DRM_ERROR ("failed to get peri_crg_base resource.\n");
+			return -ENXIO;
+	}
+
+	dsi->gpio_mux = devm_gpiod_get(&pdev->dev, "mux", GPIOD_OUT_HIGH);
+	if (IS_ERR(dsi->gpio_mux))
+		return PTR_ERR(dsi->gpio_mux);
+	/* set dsi default output to panel */
+	dsi->cur_client = OUT_PANEL;
+
+	/*dis-reset*/
+	/*ip_reset_dis_dsi0, ip_reset_dis_dsi1*/
+	outp32(ctx->peri_crg_base + PERRSTDIS3, 0x30000000);
+
+	ctx->dss_dphy0_ref_clk = devm_clk_get(&pdev->dev, "clk_txdphy0_ref");
+	if (IS_ERR(ctx->dss_dphy0_ref_clk)) {
+		DRM_ERROR("failed to get dss_dphy0_ref_clk clock\n");
+		return PTR_ERR(ctx->dss_dphy0_ref_clk);
+	}
+
+	ret = clk_set_rate(ctx->dss_dphy0_ref_clk, DEFAULT_MIPI_CLK_RATE);
+	if (ret < 0) {
+		DRM_ERROR("dss_dphy0_ref_clk clk_set_rate(%lu) failed, error=%d!\n",
+			DEFAULT_MIPI_CLK_RATE, ret);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("dss_dphy0_ref_clk:[%lu]->[%lu].\n",
+		DEFAULT_MIPI_CLK_RATE, clk_get_rate(ctx->dss_dphy0_ref_clk));
+
+	ctx->dss_dphy0_cfg_clk = devm_clk_get(&pdev->dev, "clk_txdphy0_cfg");
+	if (IS_ERR(ctx->dss_dphy0_cfg_clk)) {
+		DRM_ERROR("failed to get dss_dphy0_cfg_clk clock\n");
+		return PTR_ERR(ctx->dss_dphy0_cfg_clk);
+	}
+
+	ret = clk_set_rate(ctx->dss_dphy0_cfg_clk, DEFAULT_MIPI_CLK_RATE);
+	if (ret < 0) {
+		DRM_ERROR("dss_dphy0_cfg_clk clk_set_rate(%lu) failed, error=%d!\n",
+			DEFAULT_MIPI_CLK_RATE, ret);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("dss_dphy0_cfg_clk:[%lu]->[%lu].\n",
+		DEFAULT_MIPI_CLK_RATE, clk_get_rate(ctx->dss_dphy0_cfg_clk));
+
+	ctx->dss_pclk_dsi0_clk = devm_clk_get(&pdev->dev, "pclk_dsi0");
+	if (IS_ERR(ctx->dss_pclk_dsi0_clk)) {
+		DRM_ERROR("failed to get dss_pclk_dsi0_clk clock\n");
+		return PTR_ERR(ctx->dss_pclk_dsi0_clk);
+	}
+
+	return 0;
+}
+
+const struct kirin_dsi_ops kirin_dsi_960 = {
+	.version = KIRIN960_DSI,
+	.parse_dt = dsi_parse_dt,
+	.host_init = dsi_host_init,
+	.encoder_enable = dsi_encoder_enable_sub,
+	.encoder_valid = dsi_encoder_mode_valid
+};
+
+MODULE_DESCRIPTION("DesignWare MIPI DSI Host Controller v1.02 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_ade_reg.h b/drivers/gpu/drm/hisilicon/kirin/kirin_ade_reg.h
index e2ac09894..6d7f2e8a0 100644
--- a/drivers/gpu/drm/hisilicon/kirin/kirin_ade_reg.h
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_ade_reg.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2016 Linaro Limited.
- * Copyright (c) 2014-2016 Hisilicon Limited.
+ * Copyright (c) 2016,2019 Linaro Limited.
+ * Copyright (c) 2014-2016,2019 Hisilicon Limited.
  */
 
 #ifndef __KIRIN_ADE_REG_H__
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_dpe_reg.h b/drivers/gpu/drm/hisilicon/kirin/kirin_dpe_reg.h
new file mode 100644
index 000000000..f0ea3ee3f
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_dpe_reg.h
@@ -0,0 +1,393 @@
+/* SPDX-License-Identifier: GPL-2.0+
+ *
+ * Copyright (c) 2016 Linaro Limited.
+ * Copyright (c) 2014-2016 Hisilicon Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __KIRIN_DPE_REG_H__
+#define __KIRIN_DPE_REG_H__
+
+#define BIT_MMU_IRPT_NS                  BIT(28)
+#define BIT_ITF0_INTS                    BIT(16)
+#define BIT_DPP_INTS                     BIT(15)
+#define BIT_VACTIVE0_END                 BIT(8)
+#define BIT_VACTIVE0_START               BIT(7)
+#define BIT_VSYNC                        BIT(4)
+#define BIT_LDI_UNFLOW                   BIT(2)
+
+#define DFS_TIME                         (80)
+#define DFS_TIME_MIN                     (50)
+#define DFS_TIME_MIN_4K                  (10)
+#define DBUF0_DEPTH                      (1408)
+#define DBUF_WIDTH_BIT                   (144)
+#define PERRSTDIS3                       (0x088)
+
+#define DPE_GLB0_OFFSET                  (0x12000)
+#define DPE_DBG_OFFSET                   (0x11000)
+#define DPE_CMDLIST_OFFSET               (0x02000)
+#define DPE_SMMU_OFFSET                  (0x08000)
+#define DPE_MIF_OFFSET                   (0x0A000)
+#define DPE_MCTRL_SYS_OFFSET             (0x10000)
+#define DPE_MCTRL_CTL0_OFFSET            (0x10800)
+#define DPE_RCH_VG0_DMA_OFFSET           (0x20000)
+#define DPE_RCH_VG0_SCL_OFFSET           (0x20200)
+#define DPE_RCH_VG0_ARSR_OFFSET          (0x20300)
+#define DPE_RCH_VG1_DMA_OFFSET           (0x28000)
+#define DPE_RCH_VG1_SCL_OFFSET           (0x28200)
+#define DPE_RCH_VG2_DMA_OFFSET           (0x30000)
+#define DPE_RCH_VG2_SCL_OFFSET           (0x30200)
+#define DPE_RCH_G0_DMA_OFFSET            (0x38000)
+#define DPE_RCH_G0_SCL_OFFSET            (0x38200)
+#define DPE_RCH_G1_DMA_OFFSET            (0x40000)
+#define DPE_RCH_G1_SCL_OFFSET            (0x40200)
+#define DPE_RCH_D2_DMA_OFFSET            (0x50000)
+#define DPE_RCH_D3_DMA_OFFSET            (0x51000)
+#define DPE_RCH_D0_DMA_OFFSET            (0x52000)
+#define DPE_RCH_D0_DFC_OFFSET            (0x52100)
+#define DPE_RCH_D1_DMA_OFFSET            (0x53000)
+#define DPE_WCH0_DMA_OFFSET              (0x5A000)
+#define DPE_WCH1_DMA_OFFSET              (0x5C000)
+#define DPE_WCH2_DMA_OFFSET              (0x5E000)
+#define DPE_WCH2_DFC_OFFSET              (0x5E100)
+#define DPE_OVL0_OFFSET                  (0x60000)
+#define DPE_DBUF0_OFFSET                 (0x6D000)
+#define DPE_DPP_OFFSET                   (0x70000)
+#define DPE_DPP_DITHER_OFFSET            (0x70200)
+#define DPE_LDI0_OFFSET                  (0x7D000)
+#define DPE_IFBC_OFFSET                  (0x7D800)
+#define DPE_DSC_OFFSET                   (0x7DC00)
+
+#define GLB_CPU_PDP_INTS                 (DPE_GLB0_OFFSET + 0x224)
+#define GLB_CPU_PDP_INT_MSK              (DPE_GLB0_OFFSET + 0x228)
+#define GLB_CPU_SDP_INTS                 (DPE_GLB0_OFFSET + 0x22C)
+#define GLB_CPU_SDP_INT_MSK              (DPE_GLB0_OFFSET + 0x230)
+
+#define DBG_MCTL_INTS                    (0x023C)
+#define DBG_MCTL_INT_MSK                 (0x0240)
+#define DBG_WCH0_INTS                    (0x0244)
+#define DBG_WCH0_INT_MSK                 (0x0248)
+#define DBG_WCH1_INTS                    (0x024C)
+#define DBG_WCH1_INT_MSK                 (0x0250)
+#define DBG_RCH0_INTS                    (0x0254)
+#define DBG_RCH0_INT_MSK                 (0x0258)
+#define DBG_RCH1_INTS                    (0x025C)
+#define DBG_RCH1_INT_MSK                 (0x0260)
+#define DBG_RCH2_INTS                    (0x0264)
+#define DBG_RCH2_INT_MSK                 (0x0268)
+#define DBG_RCH3_INTS                    (0x026C)
+#define DBG_RCH3_INT_MSK                 (0x0270)
+#define DBG_RCH4_INTS                    (0x0274)
+#define DBG_RCH4_INT_MSK                 (0x0278)
+#define DBG_RCH5_INTS                    (0x027C)
+#define DBG_RCH5_INT_MSK                 (0x0280)
+#define DBG_RCH6_INTS                    (0x0284)
+#define DBG_RCH6_INT_MSK                 (0x0288)
+#define DBG_RCH7_INTS                    (0x028C)
+#define DBG_RCH7_INT_MSK                 (0x0290)
+#define DBG_DPE_GLB_INTS                 (0x0294)
+#define DBG_DPE_GLB_INT_MSK              (0x0298)
+
+#define AIF0_CH0_OFFSET                  (0x7000)
+#define AIF0_CH0_ADD_OFFSET              (0x7004)
+
+#define MIF_ENABLE                       (0x0000)
+#define MIF_MEM_CTRL                     (0x0004)
+#define MIF_CTRL0                        (0x0000)
+#define MIF_CTRL1                        (0x0004)
+#define MIF_CTRL2                        (0x0008)
+#define MIF_CTRL3                        (0x000C)
+#define MIF_CTRL4                        (0x0010)
+#define MIF_CTRL5                        (0x0014)
+#define MIF_CTRL_OFFSET                  (0x0020)
+#define MIF_CH0_OFFSET                   (DPE_MIF_OFFSET + MIF_CTRL_OFFSET * 1)
+
+#define SMMU_SCR                         (0x0000)
+#define SMMU_MEMCTRL                     (0x0004)
+#define SMMU_LP_CTRL                     (0x0008)
+#define SMMU_INTMASK_NS                  (0x0010)
+#define SMMU_INTRAW_NS                   (0x0014)
+#define SMMU_INTSTAT_NS                  (0x0018)
+#define SMMU_INTCLR_NS                   (0x001C)
+#define SMMU_SMRx_NS                     (0x0020)
+
+#define DMA_OFT_X0                       (0x0000)
+#define DMA_OFT_Y0                       (0x0004)
+#define DMA_OFT_X1                       (0x0008)
+#define DMA_OFT_Y1                       (0x000C)
+#define DMA_MASK0                        (0x0010)
+#define DMA_MASK1                        (0x0014)
+#define DMA_STRETCH_SIZE_VRT             (0x0018)
+#define DMA_CTRL                         (0x001C)
+#define DMA_TILE_SCRAM                   (0x0020)
+#define DMA_PULSE                        (0x0028)
+#define DMA_CORE_GT                      (0x002C)
+#define DMA_DATA_ADDR0                   (0x0060)
+#define DMA_STRIDE0                      (0x0064)
+#define DMA_STRETCH_STRIDE0              (0x0068)
+#define DMA_DATA_NUM0                    (0x006C)
+#define DMA_CH_CTL                       (0x00D4)
+#define DMA_CH_REG_DEFAULT               (0x0A00)
+#define DMA_ALIGN_BYTES                  (128 / BITS_PER_BYTE)
+#define DMA_ADDR_ALIGN                   (128 / BITS_PER_BYTE)
+#define DMA_STRIDE_ALIGN                 (128 / BITS_PER_BYTE)
+
+#define DFC_DISP_SIZE                    (0x0000)
+#define DFC_PIX_IN_NUM                   (0x0004)
+#define DFC_GLB_ALPHA                    (0x0008)
+#define DFC_DISP_FMT                     (0x000C)
+#define DFC_CLIP_CTL_HRZ                 (0x0010)
+#define DFC_CLIP_CTL_VRZ                 (0x0014)
+#define DFC_CTL_CLIP_EN                  (0x0018)
+#define DFC_ICG_MODULE                   (0x001C)
+#define DFC_DITHER_ENABLE                (0x0020)
+#define DFC_PADDING_CTL                  (0x0024)
+
+#define MCTL_CTL_EN                      (0x0000)
+#define MCTL_CTL_MUTEX                   (0x0004)
+#define MCTL_CTL_MUTEX_STATUS            (0x0008)
+#define MCTL_CTL_MUTEX_ITF               (0x000C)
+#define MCTL_CTL_MUTEX_DBUF              (0x0010)
+#define MCTL_CTL_MUTEX_SCF               (0x0014)
+#define MCTL_CTL_MUTEX_OV                (0x0018)
+#define MCTL_CTL_MUTEX_WCH0              (0x0020)
+#define MCTL_CTL_MUTEX_RCH0              (0x0030)
+#define MCTL_CTL_TOP                     (0x0050)
+#define MCTL_CTL_DBG                     (0x00E0)
+#define MCTL_RCH0_FLUSH_EN               (0x0100)
+#define MCTL_OV0_FLUSH_EN                (0x0128)
+#define MCTL_RCH0_OV_OEN                 (0x0160)
+#define MCTL_RCH_OV0_SEL                 (0x0180)
+
+#define OVL_SIZE                         (0x0000)
+#define OVL_BG_COLOR                     (0x0004)
+#define OVL_DST_STARTPOS                 (0x0008)
+#define OVL_DST_ENDPOS                   (0x000C)
+#define OVL_GCFG                         (0x0010)
+#define OVL_LAYER0_POS                   (0x0014)
+#define OVL_LAYER0_SIZE                  (0x0018)
+#define OVL_LAYER0_ALPHA                 (0x0030)
+#define OVL_LAYER0_CFG                   (0x0034)
+#define OVL6_REG_DEFAULT                 (0x01A8)
+
+#define DBUF_FRM_SIZE                    (0x0000)
+#define DBUF_FRM_HSIZE                   (0x0004)
+#define DBUF_SRAM_VALID_NUM              (0x0008)
+#define DBUF_WBE_EN                      (0x000C)
+#define DBUF_THD_FILL_LEV0               (0x0010)
+#define DBUF_DFS_FILL_LEV1               (0x0014)
+#define DBUF_THD_RQOS                    (0x0018)
+#define DBUF_THD_WQOS                    (0x001C)
+#define DBUF_THD_CG                      (0x0020)
+#define DBUF_THD_OTHER                   (0x0024)
+#define DBUF_ONLINE_FILL_LEVEL           (0x003C)
+#define DBUF_WB_FILL_LEVEL               (0x0040)
+#define DBUF_DFS_STATUS                  (0x0044)
+#define DBUF_THD_FLUX_REQ_BEF            (0x0048)
+#define DBUF_DFS_LP_CTRL                 (0x004C)
+#define DBUF_RD_SHADOW_SEL               (0x0050)
+#define DBUF_MEM_CTRL                    (0x0054)
+#define DBUF_THD_FLUX_REQ_AFT            (0x0064)
+#define DBUF_THD_DFS_OK                  (0x0068)
+#define DBUF_FLUX_REQ_CTRL               (0x006C)
+#define DBUF_REG_DEFAULT                 (0x00A4)
+
+#define DPP_IMG_SIZE_BEF_SR              (0x000C)
+#define DPP_IMG_SIZE_AFT_SR              (0x0010)
+#define DPP_INTS                         (0x0040)
+#define DPP_INT_MSK                      (0x0044)
+
+#define SCF_COEF_MEM_CTRL                (0x0018)
+#define IFBC_MEM_CTRL                    (0x001C)
+#define DITHER_MEM_CTRL                  (0x002C)
+#define DSC_MEM_CTRL                     (0x0084)
+#define ARSR2P_LB_MEM_CTRL               (0x0084)
+#define SCF_LB_MEM_CTRL                  (0x0090)
+#define ROT_MEM_CTRL                     (0x0538)
+#define VPP_MEM_CTRL                     (0x0704)
+#define CMD_MEM_CTRL                     (0x073C)
+#define DMA_BUF_MEM_CTRL                 (0x0854)
+#define AFBCD_MEM_CTRL                   (0x093C)
+#define AFBCE_MEM_CTRL                   (0x0924)
+
+#define LDI_DPI0_HRZ_CTRL0               (0x0000)
+#define LDI_DPI0_HRZ_CTRL1               (0x0004)
+#define LDI_DPI0_HRZ_CTRL2               (0x0008)
+#define LDI_VRT_CTRL0                    (0x000C)
+#define LDI_VRT_CTRL1                    (0x0010)
+#define LDI_VRT_CTRL2                    (0x0014)
+#define LDI_PLR_CTRL                     (0x0018)
+#define LDI_CTRL                         (0x0024)
+#define LDI_WORK_MODE                    (0x0028)
+#define LDI_DSI_CMD_MOD_CTRL             (0x0030)
+#define LDI_VINACT_MSK_LEN               (0x0050)
+#define LDI_CMD_EVENT_SEL                (0x0060)
+#define LDI_MEM_CTRL                     (0x0100)
+#define LDI_PXL0_DIV2_GT_EN              (0x0210)
+#define LDI_PXL0_DIV4_GT_EN              (0x0214)
+#define LDI_PXL0_GT_EN                   (0x0218)
+#define LDI_PXL0_DSI_GT_EN               (0x021C)
+#define LDI_PXL0_DIVXCFG                 (0x0220)
+#define LDI_VESA_CLK_SEL                 (0x0228)
+#define LDI_CPU_ITF_INTS                 (0x0248)
+#define LDI_CPU_ITF_INT_MSK              (0x024C)
+
+#define MIPIDSI_VERSION_OFFSET           (0x0000)
+#define MIPIDSI_PWR_UP_OFFSET            (0x0004)
+#define MIPIDSI_CLKMGR_CFG_OFFSET        (0x0008)
+#define MIPIDSI_DPI_VCID_OFFSET          (0x000c)
+#define MIPIDSI_DPI_COLOR_CODING_OFFSET  (0x0010)
+#define MIPIDSI_DPI_CFG_POL_OFFSET       (0x0014)
+#define MIPIDSI_DPI_LP_CMD_TIM_OFFSET    (0x0018)
+#define MIPIDSI_PCKHDL_CFG_OFFSET        (0x002c)
+#define MIPIDSI_GEN_VCID_OFFSET          (0x0030)
+#define MIPIDSI_MODE_CFG_OFFSET          (0x0034)
+#define MIPIDSI_VID_MODE_CFG_OFFSET      (0x0038)
+#define MIPIDSI_VID_PKT_SIZE_OFFSET      (0x003c)
+#define MIPIDSI_VID_NUM_CHUNKS_OFFSET    (0x0040)
+#define MIPIDSI_VID_NULL_SIZE_OFFSET     (0x0044)
+#define MIPIDSI_VID_HSA_TIME_OFFSET      (0x0048)
+#define MIPIDSI_VID_HBP_TIME_OFFSET      (0x004c)
+#define MIPIDSI_VID_HLINE_TIME_OFFSET    (0x0050)
+#define MIPIDSI_VID_VSA_LINES_OFFSET     (0x0054)
+#define MIPIDSI_VID_VBP_LINES_OFFSET     (0x0058)
+#define MIPIDSI_VID_VFP_LINES_OFFSET     (0x005c)
+#define MIPIDSI_VID_VACTIVE_LINES_OFFSET (0x0060)
+#define MIPIDSI_EDPI_CMD_SIZE_OFFSET     (0x0064)
+#define MIPIDSI_CMD_MODE_CFG_OFFSET      (0x0068)
+#define MIPIDSI_GEN_HDR_OFFSET           (0x006c)
+#define MIPIDSI_GEN_PLD_DATA_OFFSET      (0x0070)
+#define MIPIDSI_CMD_PKT_STATUS_OFFSET    (0x0074)
+#define MIPIDSI_TO_CNT_CFG_OFFSET        (0x0078)
+#define MIPIDSI_BTA_TO_CNT_OFFSET        (0x008C)
+#define MIPIDSI_SDF_3D_OFFSET            (0x0090)
+#define MIPIDSI_LPCLK_CTRL_OFFSET        (0x0094)
+#define MIPIDSI_PHY_TMR_LPCLK_CFG_OFFSET (0x0098)
+#define MIPIDSI_PHY_TMR_CFG_OFFSET       (0x009c)
+#define MIPIDSI_PHY_RSTZ_OFFSET          (0x00a0)
+#define MIPIDSI_PHY_IF_CFG_OFFSET        (0x00a4)
+#define MIPIDSI_PHY_ULPS_CTRL_OFFSET     (0x00a8)
+#define MIPIDSI_PHY_TX_TRIGGERS_OFFSET   (0x00ac)
+#define MIPIDSI_PHY_STATUS_OFFSET        (0x00b0)
+#define MIPIDSI_PHY_TST_CTRL0_OFFSET     (0x00b4)
+#define MIPIDSI_PHY_TST_CTRL1_OFFSET     (0x00b8)
+#define MIPIDSI_PHY_TMR_RD_CFG_OFFSET    (0x00f4)
+
+enum XRES_DIV {
+	XRES_DIV_1 = 1,
+	XRES_DIV_2,
+};
+
+enum YRES_DIV {
+	YRES_DIV_1 = 1,
+	YRES_DIV_2,
+};
+
+enum PXL0_DIVCFG {
+	PXL0_DIVCFG_0 = 0,
+	PXL0_DIVCFG_1,
+};
+
+enum PXL0_DIV2_GT_EN {
+	PXL0_DIV2_GT_EN_CLOSE = 0,
+	PXL0_DIV2_GT_EN_OPEN,
+};
+
+enum PXL0_DIV4_GT_EN {
+	PXL0_DIV4_GT_EN_CLOSE = 0,
+	PXL0_DIV4_GT_EN_OPEN,
+};
+
+enum PXL0_DSI_GT_EN {
+	PXL0_DSI_GT_EN_0 = 0,
+	PXL0_DSI_GT_EN_1,
+};
+
+enum lcd_format {
+	LCD_RGB888 = 0,
+	LCD_RGB101010,
+	LCD_RGB565,
+};
+
+enum lcd_rgb_order {
+	LCD_RGB = 0,
+	LCD_BGR,
+};
+
+enum dpe_dfc_format {
+	DFC_PIXEL_FORMAT_RGB_565 = 0,
+	DFC_PIXEL_FORMAT_XRGB_4444,
+	DFC_PIXEL_FORMAT_ARGB_4444,
+	DFC_PIXEL_FORMAT_XRGB_5551,
+	DFC_PIXEL_FORMAT_ARGB_5551,
+	DFC_PIXEL_FORMAT_XRGB_8888,
+	DFC_PIXEL_FORMAT_ARGB_8888,
+	DFC_PIXEL_FORMAT_BGR_565,
+	DFC_PIXEL_FORMAT_XBGR_4444,
+	DFC_PIXEL_FORMAT_ABGR_4444,
+	DFC_PIXEL_FORMAT_XBGR_5551,
+	DFC_PIXEL_FORMAT_ABGR_5551,
+	DFC_PIXEL_FORMAT_XBGR_8888,
+	DFC_PIXEL_FORMAT_ABGR_8888,
+	DFC_PIXEL_FORMAT_YUV444,
+	DFC_PIXEL_FORMAT_YVU444,
+	DFC_PIXEL_FORMAT_YUYV422,
+	DFC_PIXEL_FORMAT_YVYU422,
+	DFC_PIXEL_FORMAT_VYUY422,
+	DFC_PIXEL_FORMAT_UYVY422,
+};
+
+enum dpe_dma_format {
+	DMA_PIXEL_FORMAT_RGB_565 = 0,
+	DMA_PIXEL_FORMAT_ARGB_4444,
+	DMA_PIXEL_FORMAT_XRGB_4444,
+	DMA_PIXEL_FORMAT_ARGB_5551,
+	DMA_PIXEL_FORMAT_XRGB_5551,
+	DMA_PIXEL_FORMAT_ARGB_8888,
+	DMA_PIXEL_FORMAT_XRGB_8888,
+	DMA_PIXEL_FORMAT_RESERVED0,
+	DMA_PIXEL_FORMAT_YUYV_422_Pkg,
+	DMA_PIXEL_FORMAT_YUV_420_SP_HP,
+	DMA_PIXEL_FORMAT_YUV_420_P_HP,
+	DMA_PIXEL_FORMAT_YUV_422_SP_HP,
+	DMA_PIXEL_FORMAT_YUV_422_P_HP,
+	DMA_PIXEL_FORMAT_AYUV_4444,
+};
+
+enum dpe_fb_format {
+	DPE_RGB_565 = 0,
+	DPE_RGBX_4444,
+	DPE_RGBA_4444,
+	DPE_RGBX_5551,
+	DPE_RGBA_5551,
+	DPE_RGBX_8888,
+	DPE_RGBA_8888,
+	DPE_BGR_565,
+	DPE_BGRX_4444,
+	DPE_BGRA_4444,
+	DPE_BGRX_5551,
+	DPE_BGRA_5551,
+	DPE_BGRX_8888,
+	DPE_BGRA_8888,
+	DPE_YUV_422_I,
+	/* YUV Semi-planar */
+	DPE_YCbCr_422_SP,
+	DPE_YCrCb_422_SP,
+	DPE_YCbCr_420_SP,
+	DPE_YCrCb_420_SP,
+	/* YUV Planar */
+	DPE_YCbCr_422_P,
+	DPE_YCrCb_422_P,
+	DPE_YCbCr_420_P,
+	DPE_YCrCb_420_P,
+	/* YUV Package */
+	DPE_YUYV_422_Pkg,
+	DPE_UYVY_422_Pkg,
+	DPE_YVYU_422_Pkg,
+	DPE_VYUY_422_Pkg,
+};
+
+#endif
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dpe.c b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dpe.c
new file mode 100644
index 000000000..a15f8d452
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dpe.c
@@ -0,0 +1,1233 @@
+/*
+ * Hisilicon Hi6220 SoC ADE(Advanced Display Engine)'s crtc&plane driver
+ *
+ * Copyright (c) 2016 Linaro Limited.
+ * Copyright (c) 2014-2016 Hisilicon Limited.
+ *
+ * Author:
+ *	Xinliang Liu <z.liuxinliang@hisilicon.com>
+ *	Xinliang Liu <xinliang.liu@linaro.org>
+ *	Xinwei Kong <kong.kongxinwei@hisilicon.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <video/display_timing.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+#include <drm/drm_drv.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_vblank.h>
+#include <drm/drm_fourcc.h>
+
+#include "kirin_drm_drv.h"
+#include "kirin_dpe_reg.h"
+
+#define DPE_WIDTH(width)   ((width) - 1)
+#define DPE_HEIGHT(height) ((height) - 1)
+
+#define GET_FLUX_REQ_IN(max_depth)  ((max_depth) * 50 / 100)
+#define GET_FLUX_REQ_OUT(max_depth)	((max_depth) * 90 / 100)
+
+#define DEFAULT_DPE_CORE_CLK_07V_RATE (400000000UL)
+#define DPE_MAX_PXL0_CLK_144M         (144000000UL)
+
+#define DPE_UNSUPPORT (800)
+#define RES_4K_PHONE  (3840 * 2160)
+
+enum dpe_ovl {
+	DPE_OVL0 = 0,
+	DPE_OVL_NUM
+};
+
+enum dpe_channel {
+	DPE_CH0 = 0, /* channel 1 for primary plane */
+	DPE_CH_NUM
+};
+
+struct dpe_hw_ctx {
+	void __iomem *base;
+	void __iomem *noc_base;
+
+	struct clk *dpe_axi_clk;
+	struct clk *dpe_pclk_clk;
+	struct clk *dpe_pri_clk;
+	struct clk *dpe_pxl0_clk;
+	struct clk *dpe_mmbuf_clk;
+
+	bool power_on;
+	int irq;
+
+	struct drm_crtc *crtc;
+
+	u32 hdisplay;
+	u32 vdisplay;
+};
+
+static const struct kirin_format dpe_formats[] = {
+	{ DRM_FORMAT_RGB565, DPE_RGB_565 },
+	{ DRM_FORMAT_BGR565, DPE_BGR_565 },
+	{ DRM_FORMAT_XRGB8888, DPE_RGBX_8888 },
+	{ DRM_FORMAT_XBGR8888, DPE_BGRX_8888 },
+	{ DRM_FORMAT_RGBA8888, DPE_RGBA_8888 },
+	{ DRM_FORMAT_BGRA8888, DPE_BGRA_8888 },
+	{ DRM_FORMAT_ARGB8888, DPE_BGRA_8888 },
+	{ DRM_FORMAT_ABGR8888, DPE_RGBA_8888 },
+};
+
+static const u32 dpe_channel_formats[] = {
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_BGR565,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+};
+
+static u32 dpe_pixel_dma_format_map[] = {
+	DMA_PIXEL_FORMAT_RGB_565,
+	DMA_PIXEL_FORMAT_XRGB_4444,
+	DMA_PIXEL_FORMAT_ARGB_4444,
+	DMA_PIXEL_FORMAT_XRGB_5551,
+	DMA_PIXEL_FORMAT_ARGB_5551,
+	DMA_PIXEL_FORMAT_XRGB_8888,
+	DMA_PIXEL_FORMAT_ARGB_8888,
+	DMA_PIXEL_FORMAT_RGB_565,
+	DMA_PIXEL_FORMAT_XRGB_4444,
+	DMA_PIXEL_FORMAT_ARGB_4444,
+	DMA_PIXEL_FORMAT_XRGB_5551,
+	DMA_PIXEL_FORMAT_ARGB_5551,
+	DMA_PIXEL_FORMAT_XRGB_8888,
+	DMA_PIXEL_FORMAT_ARGB_8888,
+	DMA_PIXEL_FORMAT_YUYV_422_Pkg,
+	DMA_PIXEL_FORMAT_YUV_422_SP_HP,
+	DMA_PIXEL_FORMAT_YUV_422_SP_HP,
+	DMA_PIXEL_FORMAT_YUV_420_SP_HP,
+	DMA_PIXEL_FORMAT_YUV_420_SP_HP,
+	DMA_PIXEL_FORMAT_YUV_422_P_HP,
+	DMA_PIXEL_FORMAT_YUV_422_P_HP,
+	DMA_PIXEL_FORMAT_YUV_420_P_HP,
+	DMA_PIXEL_FORMAT_YUV_420_P_HP,
+	DMA_PIXEL_FORMAT_YUYV_422_Pkg,
+	DMA_PIXEL_FORMAT_YUYV_422_Pkg,
+	DMA_PIXEL_FORMAT_YUYV_422_Pkg,
+	DMA_PIXEL_FORMAT_YUYV_422_Pkg,
+};
+
+static u32 dpe_pixel_dfc_format_map[] = {
+	DFC_PIXEL_FORMAT_RGB_565,
+	DFC_PIXEL_FORMAT_XBGR_4444,
+	DFC_PIXEL_FORMAT_ABGR_4444,
+	DFC_PIXEL_FORMAT_XBGR_5551,
+	DFC_PIXEL_FORMAT_ABGR_5551,
+	DFC_PIXEL_FORMAT_XBGR_8888,
+	DFC_PIXEL_FORMAT_ABGR_8888,
+	DFC_PIXEL_FORMAT_BGR_565,
+	DFC_PIXEL_FORMAT_XRGB_4444,
+	DFC_PIXEL_FORMAT_ARGB_4444,
+	DFC_PIXEL_FORMAT_XRGB_5551,
+	DFC_PIXEL_FORMAT_ARGB_5551,
+	DFC_PIXEL_FORMAT_XRGB_8888,
+	DFC_PIXEL_FORMAT_ARGB_8888,
+	DFC_PIXEL_FORMAT_YUYV422,
+	DFC_PIXEL_FORMAT_YUYV422,
+	DFC_PIXEL_FORMAT_YVYU422,
+	DFC_PIXEL_FORMAT_YUYV422,
+	DFC_PIXEL_FORMAT_YVYU422,
+	DFC_PIXEL_FORMAT_YUYV422,
+	DFC_PIXEL_FORMAT_YVYU422,
+	DFC_PIXEL_FORMAT_YUYV422,
+	DFC_PIXEL_FORMAT_YVYU422,
+	DFC_PIXEL_FORMAT_YUYV422,
+	DFC_PIXEL_FORMAT_UYVY422,
+	DFC_PIXEL_FORMAT_YVYU422,
+	DFC_PIXEL_FORMAT_VYUY422,
+};
+
+static u32 mid_array[DPE_CH_NUM] = {0xb};
+static u32 aif_offset[DPE_CH_NUM] = {AIF0_CH0_OFFSET};
+static u32 mif_offset[DPE_CH_NUM] = {MIF_CH0_OFFSET};
+static u32 rdma_offset[DPE_CH_NUM] = {DPE_RCH_D0_DMA_OFFSET};
+static u32 rdfc_offset[DPE_CH_NUM] = {DPE_RCH_D0_DFC_OFFSET};
+static u32 dpe_smmu_chn_sid_num[DPE_CH_NUM] = {4};
+static u32 dpe_smmu_smrx_idx[DPE_CH_NUM] = {0};
+static u32 mctl_offset[DPE_OVL_NUM] = {DPE_MCTRL_CTL0_OFFSET};
+static u32 ovl_offset[DPE_OVL_NUM] = {DPE_OVL0_OFFSET};
+
+static u32 dpe_get_format(u32 pixel_format)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dpe_formats); i++)
+		if (dpe_formats[i].pixel_format == pixel_format)
+			return dpe_formats[i].hw_format;
+
+	DRM_ERROR("Not found pixel format!!fourcc_format= %d\n",
+		  pixel_format);
+	return DPE_UNSUPPORT;
+}
+
+static void dpe_set_reg(char __iomem *addr, u32 val, u8 bw, u8 bs)
+{
+	u32 mask = (1UL << bw) - 1UL;
+	u32 tmp = 0;
+
+	tmp = readl(addr);
+	tmp &= ~(mask << bs);
+
+	writel(tmp | ((val & mask) << bs), addr);
+}
+
+/* dpe mctl utils */
+static void dpe_mctl_lock(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *mctl_base = ctx->base + mctl_offset[DPE_OVL0];
+
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX, 0x1, 1, 0);
+}
+
+static void dpe_mctl_unlock(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *mctl_base = ctx->base + mctl_offset[DPE_OVL0];
+
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX, 0x0, 1, 0);
+}
+
+static void dpe_mctl_init(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *mctl_base = ctx->base + mctl_offset[DPE_OVL0];
+
+	dpe_set_reg(mctl_base + MCTL_CTL_EN, 0x1, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX_ITF, 0x1, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_DBG, 0xB13A00, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_TOP, 0x2, 32, 0);
+}
+
+static void dpe_qos_init(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *noc_base = ctx->noc_base;
+
+	writel(0x2, noc_base + 0x000c);
+	writel(0x2, noc_base + 0x008c);
+	writel(0x2, noc_base + 0x010c);
+	writel(0x2, noc_base + 0x018c);
+}
+
+/* dpe ldi utils */
+static void dpe_enable_ldi(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *ldi_base = ctx->base + DPE_LDI0_OFFSET;
+
+	dpe_set_reg(ldi_base + LDI_CTRL, 0x1, 1, 0);
+}
+
+
+/* interrupts utils */
+static void dpe_interrupt_mask(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *base = ctx->base;
+	u32 mask = ~0;
+
+	writel(mask, base + GLB_CPU_PDP_INT_MSK);
+	writel(mask, base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK);
+	writel(mask, base + DPE_DPP_OFFSET + DPP_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_DPE_GLB_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_MCTL_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_WCH0_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_WCH1_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_RCH0_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_RCH1_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_RCH2_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_RCH3_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_RCH4_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_RCH5_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_RCH6_INT_MSK);
+	writel(mask, base + DPE_DBG_OFFSET + DBG_RCH7_INT_MSK);
+}
+
+static void dpe_interrupt_unmask(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *base = ctx->base;
+	u32 unmask;
+
+	unmask = ~0;
+	unmask &= ~(BIT_DPP_INTS | BIT_ITF0_INTS | BIT_MMU_IRPT_NS);
+	writel(unmask, base + GLB_CPU_PDP_INT_MSK);
+
+	unmask = ~0;
+	unmask &= ~(BIT_VSYNC | BIT_LDI_UNFLOW);
+	writel(unmask, base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK);
+}
+
+static void dpe_interrupt_clear(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *base = ctx->base;
+	u32 clear = ~0;
+
+	writel(clear, base + GLB_CPU_PDP_INTS);
+	writel(clear, base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INTS);
+	writel(clear, base + DPE_DPP_OFFSET + DPP_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_MCTL_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_WCH0_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_WCH1_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_RCH0_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_RCH1_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_RCH2_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_RCH3_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_RCH4_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_RCH5_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_RCH6_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_RCH7_INTS);
+	writel(clear, base + DPE_DBG_OFFSET + DBG_DPE_GLB_INTS);
+}
+
+static void dpe_irq_enable(struct dpe_hw_ctx *ctx)
+{
+	enable_irq(ctx->irq);
+}
+
+static void dpe_clk_enable(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *base = ctx->base;
+
+	writel(0x00000088, base + DPE_IFBC_OFFSET + IFBC_MEM_CTRL);
+	writel(0x00000888, base + DPE_DSC_OFFSET + DSC_MEM_CTRL);
+	writel(0x00000008, base + DPE_LDI0_OFFSET + LDI_MEM_CTRL);
+	writel(0x00000008, base + DPE_DBUF0_OFFSET + DBUF_MEM_CTRL);
+	writel(0x00000008, base + DPE_DPP_DITHER_OFFSET + DITHER_MEM_CTRL);
+	writel(0x00000008, base + DPE_CMDLIST_OFFSET + CMD_MEM_CTRL);
+	writel(0x00000088, base + DPE_RCH_VG0_SCL_OFFSET + SCF_COEF_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_VG0_SCL_OFFSET + SCF_LB_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_VG0_ARSR_OFFSET + ARSR2P_LB_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_VG0_DMA_OFFSET + VPP_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_VG0_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00008888, base + DPE_RCH_VG0_DMA_OFFSET + AFBCD_MEM_CTRL);
+	writel(0x00000088, base + DPE_RCH_VG1_SCL_OFFSET + SCF_COEF_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_VG1_SCL_OFFSET + SCF_LB_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_VG1_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00008888, base + DPE_RCH_VG1_DMA_OFFSET + AFBCD_MEM_CTRL);
+	writel(0x00000088, base + DPE_RCH_VG2_SCL_OFFSET + SCF_COEF_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_VG2_SCL_OFFSET + SCF_LB_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_VG2_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00000088, base + DPE_RCH_G0_SCL_OFFSET + SCF_COEF_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_G0_SCL_OFFSET + SCF_LB_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_G0_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00008888, base + DPE_RCH_G0_DMA_OFFSET + AFBCD_MEM_CTRL);
+	writel(0x00000088, base + DPE_RCH_G1_SCL_OFFSET + SCF_COEF_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_G1_SCL_OFFSET + SCF_LB_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_G1_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00008888, base + DPE_RCH_G1_DMA_OFFSET + AFBCD_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_D0_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00008888, base + DPE_RCH_D0_DMA_OFFSET + AFBCD_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_D1_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_D2_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00000008, base + DPE_RCH_D3_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00000008, base + DPE_WCH0_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00000888, base + DPE_WCH0_DMA_OFFSET + AFBCE_MEM_CTRL);
+	writel(0x00000008, base + DPE_WCH0_DMA_OFFSET + ROT_MEM_CTRL);
+	writel(0x00000008, base + DPE_WCH1_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00000888, base + DPE_WCH1_DMA_OFFSET + AFBCE_MEM_CTRL);
+	writel(0x00000008, base + DPE_WCH1_DMA_OFFSET + ROT_MEM_CTRL);
+	writel(0x00000008, base + DPE_WCH2_DMA_OFFSET + DMA_BUF_MEM_CTRL);
+	writel(0x00000008, base + DPE_WCH2_DMA_OFFSET + ROT_MEM_CTRL);
+}
+
+static int dpe_power_up(struct dpe_hw_ctx *ctx)
+{
+	int ret;
+
+	if (ctx->power_on == true)
+		return 0;
+
+	/*peri clk enable */
+	ret = clk_prepare_enable(ctx->dpe_pxl0_clk);
+	if (ret) {
+		DRM_ERROR("failed to enable dpe_pxl0_clk (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ctx->dpe_pri_clk);
+	if (ret) {
+		DRM_ERROR("failed to enable dpe_pri_clk (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ctx->dpe_pclk_clk);
+	if (ret) {
+		DRM_ERROR("failed to enable dpe_pclk_clk (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ctx->dpe_axi_clk);
+	if (ret) {
+		DRM_ERROR("failed to enable dpe_axi_clk (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ctx->dpe_mmbuf_clk);
+	if (ret) {
+		DRM_ERROR("failed to enable dpe_mmbuf_clk (%d)\n", ret);
+		return ret;
+	}
+
+	dpe_clk_enable(ctx);
+	dpe_interrupt_mask(ctx);
+	dpe_interrupt_clear(ctx);
+	dpe_irq_enable(ctx);
+	dpe_interrupt_unmask(ctx);
+
+	ctx->power_on = true;
+	return 0;
+}
+
+static void dpe_dpp_init(struct dpe_hw_ctx *ctx, struct drm_display_mode *mode,
+					struct drm_display_mode *adj_mode)
+{
+	void __iomem *dpp_base = ctx->base + DPE_DPP_OFFSET;
+
+	writel((DPE_HEIGHT(mode->vdisplay) << 16) | DPE_WIDTH(mode->hdisplay),
+			dpp_base + DPP_IMG_SIZE_BEF_SR);
+	writel((DPE_HEIGHT(mode->vdisplay) << 16) | DPE_WIDTH(mode->hdisplay),
+			dpp_base + DPP_IMG_SIZE_AFT_SR);
+}
+
+static void dpe_ovl_init(struct dpe_hw_ctx *ctx, u32 xres, u32 yres)
+{
+	void __iomem *mctl_sys_base = ctx->base + DPE_MCTRL_SYS_OFFSET;
+	void __iomem *mctl_base = ctx->base + mctl_offset[DPE_OVL0];
+	void __iomem *ovl0_base = ctx->base + ovl_offset[DPE_OVL0];
+
+	dpe_set_reg(ovl0_base + OVL6_REG_DEFAULT, 0x1, 32, 0);
+	dpe_set_reg(ovl0_base + OVL6_REG_DEFAULT, 0x0, 32, 0);
+	dpe_set_reg(ovl0_base + OVL_SIZE,
+				(xres - 1) | ((yres - 1) << 16), 32, 0);
+	dpe_set_reg(ovl0_base + OVL_BG_COLOR, 0xFF000000, 32, 0);
+	dpe_set_reg(ovl0_base + OVL_DST_STARTPOS, 0x0, 32, 0);
+	dpe_set_reg(ovl0_base + OVL_DST_ENDPOS,
+				(xres - 1) | ((yres - 1) << 16), 32, 0);
+	dpe_set_reg(ovl0_base + OVL_GCFG, 0x10001, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX_ITF, 0x1, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX_DBUF, 0x1, 2, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX_OV, 1 << DPE_OVL0, 4, 0);
+	dpe_set_reg(mctl_sys_base + MCTL_RCH_OV0_SEL, 0x8, 4, 0);
+	dpe_set_reg(mctl_sys_base + MCTL_OV0_FLUSH_EN, 0xd, 4, 0);
+}
+
+static void dpe_vesa_init(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *base = ctx->base;
+
+	dpe_set_reg(base + DPE_LDI0_OFFSET + LDI_VESA_CLK_SEL, 0, 1, 0);
+}
+
+static int dpe_mipi_ifbc_get_rect(struct drm_rect *rect)
+{
+	u32 xres_div = XRES_DIV_1;
+	u32 yres_div = YRES_DIV_1;
+
+	if ((rect->x2 % xres_div) > 0)
+		DRM_ERROR("xres(%d) is not division_h(%d) pixel aligned!\n",
+					rect->x2, xres_div);
+
+	if ((rect->y2 % yres_div) > 0)
+		DRM_ERROR("yres(%d) is not division_v(%d) pixel aligned!\n",
+					rect->y2, yres_div);
+
+	rect->x2 /= xres_div;
+	rect->y2 /= yres_div;
+
+	return 0;
+}
+
+static void dpe_init_ldi_pxl_div(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *ldi_base = ctx->base + DPE_LDI0_OFFSET;
+
+	dpe_set_reg(ldi_base + LDI_PXL0_DIV2_GT_EN, PXL0_DIV2_GT_EN_CLOSE,
+				1, 0);
+	dpe_set_reg(ldi_base + LDI_PXL0_DIV4_GT_EN, PXL0_DIV4_GT_EN_CLOSE,
+				1, 0);
+	dpe_set_reg(ldi_base + LDI_PXL0_GT_EN, 0x1, 1, 0);
+	dpe_set_reg(ldi_base + LDI_PXL0_DSI_GT_EN, PXL0_DSI_GT_EN_1, 2, 0);
+	dpe_set_reg(ldi_base + LDI_PXL0_DIVXCFG, PXL0_DIVCFG_0, 3, 0);
+}
+
+static void dpe_dbuf_init(struct dpe_hw_ctx *ctx,
+			struct drm_display_mode *mode,
+			struct drm_display_mode *adj_mode)
+{
+	void __iomem *dbuf_base = ctx->base + DPE_DBUF0_OFFSET;
+
+	int sram_valid_num = 0;
+	int sram_max_mem_depth = 0;
+	int sram_min_support_depth = 0;
+
+	u32 thd_rqos_in = 0;
+	u32 thd_rqos_out = 0;
+	u32 thd_wqos_in = 0;
+	u32 thd_wqos_out = 0;
+	u32 thd_cg_in = 0;
+	u32 thd_cg_out = 0;
+	u32 thd_wr_wait = 0;
+	u32 thd_cg_hold = 0;
+	u32 thd_flux_req_befdfs_in = 0;
+	u32 thd_flux_req_befdfs_out = 0;
+	u32 thd_flux_req_aftdfs_in = 0;
+	u32 thd_flux_req_aftdfs_out = 0;
+	u32 thd_dfs_ok = 0;
+	u32 dfs_ok_mask = 0;
+	u32 thd_flux_req_sw_en = 1;
+	u32 hfp, hbp, hsw, vfp, vbp, vsw;
+
+	int dfs_time_min = 0;
+	int depth = 0;
+
+	hfp = mode->hsync_start - mode->hdisplay;
+	hbp = mode->htotal - mode->hsync_end;
+	hsw = mode->hsync_end - mode->hsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+	vsw = mode->vsync_end - mode->vsync_start;
+
+	dbuf_base = ctx->base + DPE_DBUF0_OFFSET;
+
+	if (mode->hdisplay * mode->vdisplay >= RES_4K_PHONE)
+		dfs_time_min = DFS_TIME_MIN_4K;
+	else
+		dfs_time_min = DFS_TIME_MIN;
+
+	depth = DBUF0_DEPTH;
+
+	thd_cg_out = (DFS_TIME * adj_mode->clock * 1000UL * mode->hdisplay) /
+		(((hsw + hbp + hfp) + mode->hdisplay) * 6 * 1000000UL);
+
+	sram_valid_num = thd_cg_out / depth;
+	thd_cg_in = (sram_valid_num + 1) * depth - 1;
+	sram_max_mem_depth = (sram_valid_num + 1) * depth;
+
+	thd_rqos_in = thd_cg_out * 85 / 100;
+	thd_rqos_out = thd_cg_out;
+	thd_flux_req_befdfs_in = GET_FLUX_REQ_IN(sram_max_mem_depth);
+	thd_flux_req_befdfs_out = GET_FLUX_REQ_OUT(sram_max_mem_depth);
+
+	sram_min_support_depth = dfs_time_min * mode->hdisplay /
+			(1000000 / 60 / (mode->vdisplay + vbp + vfp + vsw)
+			* (DBUF_WIDTH_BIT / 3 / BITS_PER_BYTE));
+
+	thd_flux_req_aftdfs_in = (sram_max_mem_depth - sram_min_support_depth);
+	thd_flux_req_aftdfs_in = thd_flux_req_aftdfs_in / 3;
+	thd_flux_req_aftdfs_out = 2 * thd_flux_req_aftdfs_in;
+	thd_dfs_ok = thd_flux_req_befdfs_in;
+
+	writel(mode->hdisplay * mode->vdisplay, dbuf_base + DBUF_FRM_SIZE);
+	writel(DPE_WIDTH(mode->hdisplay), dbuf_base + DBUF_FRM_HSIZE);
+	writel(sram_valid_num, dbuf_base + DBUF_SRAM_VALID_NUM);
+
+	writel((thd_rqos_out << 16) | thd_rqos_in, dbuf_base + DBUF_THD_RQOS);
+	writel((thd_wqos_out << 16) | thd_wqos_in, dbuf_base + DBUF_THD_WQOS);
+	writel((thd_cg_out << 16) | thd_cg_in, dbuf_base + DBUF_THD_CG);
+	writel((thd_cg_hold << 16) | thd_wr_wait, dbuf_base + DBUF_THD_OTHER);
+	writel((thd_flux_req_befdfs_out << 16) | thd_flux_req_befdfs_in,
+			dbuf_base + DBUF_THD_FLUX_REQ_BEF);
+	writel((thd_flux_req_aftdfs_out << 16) | thd_flux_req_aftdfs_in,
+			dbuf_base + DBUF_THD_FLUX_REQ_AFT);
+	writel(thd_dfs_ok, dbuf_base + DBUF_THD_DFS_OK);
+	writel((dfs_ok_mask << 1) | thd_flux_req_sw_en,
+			dbuf_base + DBUF_FLUX_REQ_CTRL);
+
+	writel(0x1, dbuf_base + DBUF_DFS_LP_CTRL);
+}
+
+static void dpe_ldi_init(struct dpe_hw_ctx *ctx, struct drm_display_mode *mode,
+					struct drm_display_mode *adj_mode)
+{
+	void __iomem *ldi_base = ctx->base + DPE_LDI0_OFFSET;
+	struct drm_rect rect = {0, 0, 0, 0};
+	u32 hfp, hbp, hsw, vfp, vbp, vsw;
+	u32 vsync_plr = 0;
+	u32 hsync_plr = 0;
+	u32 pixelclk_plr = 0;
+	u32 data_en_plr = 0;
+
+	hfp = mode->hsync_start - mode->hdisplay;
+	hbp = mode->htotal - mode->hsync_end;
+	hsw = mode->hsync_end - mode->hsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+	vsw = mode->vsync_end - mode->vsync_start;
+
+	rect.x1 = 0;
+	rect.y1 = 0;
+	rect.x2 = mode->hdisplay;
+	rect.y2 = mode->vdisplay;
+	dpe_mipi_ifbc_get_rect(&rect);
+	dpe_init_ldi_pxl_div(ctx);
+
+	writel(hfp | ((hbp + DPE_WIDTH(hsw)) << 16),
+		   ldi_base + LDI_DPI0_HRZ_CTRL0);
+	writel(0, ldi_base + LDI_DPI0_HRZ_CTRL1);
+	writel(DPE_WIDTH(rect.x2), ldi_base + LDI_DPI0_HRZ_CTRL2);
+	writel(vfp | (vbp << 16), ldi_base + LDI_VRT_CTRL0);
+	writel(DPE_HEIGHT(vsw), ldi_base + LDI_VRT_CTRL1);
+	writel(DPE_HEIGHT(rect.y2), ldi_base + LDI_VRT_CTRL2);
+	writel(vsync_plr | (hsync_plr << 1) | (pixelclk_plr << 2)
+				| (data_en_plr << 3), ldi_base + LDI_PLR_CTRL);
+
+	dpe_set_reg(ldi_base + LDI_CTRL, LCD_RGB888, 2, 3);
+	dpe_set_reg(ldi_base + LDI_CTRL, LCD_RGB, 1, 13);
+
+	writel(vfp, ldi_base + LDI_VINACT_MSK_LEN);
+	writel(0x1, ldi_base + LDI_CMD_EVENT_SEL);
+
+	dpe_set_reg(ldi_base + LDI_DSI_CMD_MOD_CTRL, 0x1, 1, 1);
+	dpe_set_reg(ldi_base + LDI_WORK_MODE, 0x1, 1, 0);
+	dpe_set_reg(ldi_base + LDI_CTRL, 0x0, 1, 0);
+}
+
+static void dpe_init(struct dpe_hw_ctx *ctx,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adj_mode)
+{
+	dpe_dbuf_init(ctx, mode, adj_mode);
+	dpe_dpp_init(ctx, mode, adj_mode);
+	dpe_vesa_init(ctx);
+	dpe_ldi_init(ctx, mode, adj_mode);
+	dpe_qos_init(ctx);
+	dpe_mctl_init(ctx);
+
+	dpe_mctl_lock(ctx);
+	dpe_ovl_init(ctx, mode->hdisplay, mode->vdisplay);
+	dpe_mctl_unlock(ctx);
+
+//	dpe_enable_ldi(ctx);
+
+	ctx->hdisplay = mode->hdisplay;
+	ctx->vdisplay = mode->vdisplay;
+	mdelay(60);
+}
+
+static void dpe_ldi_set_mode(struct dpe_hw_ctx *ctx,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adj_mode)
+{
+	int ret;
+	u32 clk_Hz;
+
+	switch (mode->clock) {
+	case 148500:
+		clk_Hz = 144000 * 1000UL;
+		break;
+	case 83496:
+		clk_Hz = 80000 * 1000UL;
+		break;
+	case 74440:
+		clk_Hz = 72000 * 1000UL;
+		break;
+	case 74250:
+		clk_Hz = 72000 * 1000UL;
+		break;
+	default:
+		clk_Hz = mode->clock * 1000UL;
+	}
+
+	ret = clk_set_rate(ctx->dpe_pxl0_clk, clk_Hz);
+	if (ret)
+		DRM_ERROR("failed to set pixel clk %dHz (%d)\n",
+				clk_Hz, ret);
+
+	adj_mode->clock = clk_get_rate(ctx->dpe_pxl0_clk) / 1000;
+}
+
+static int dpe_enable_vblank(struct drm_crtc *crtc)
+{
+	struct kirin_crtc *kcrtc = to_kirin_crtc(crtc);
+	struct dpe_hw_ctx *ctx = kcrtc->hw_ctx;
+
+	dpe_power_up(ctx);
+
+	return 0;
+}
+
+static void dpe_disable_vblank(struct drm_crtc *crtc)
+{
+	struct kirin_crtc *kcrtc = to_kirin_crtc(crtc);
+	struct dpe_hw_ctx *ctx = kcrtc->hw_ctx;
+
+	if (!ctx->power_on) {
+		DRM_ERROR("power is down! vblank disable fail\n");
+		return;
+	}
+}
+
+static void dpe_crtc_atomic_enable(struct drm_crtc *crtc,
+				   struct drm_crtc_state *old_state)
+{
+	struct kirin_crtc *kcrtc = to_kirin_crtc(crtc);
+	struct dpe_hw_ctx *ctx = kcrtc->hw_ctx;
+	int ret;
+
+	if (kcrtc->enable == true)
+		return;
+
+	ret = dpe_power_up(ctx);
+	if (ret)
+		return;
+
+	kcrtc->enable = true;
+	drm_crtc_vblank_on(crtc);
+}
+
+static void dpe_crtc_atomic_disable(struct drm_crtc *crtc,
+				    struct drm_crtc_state *old_state)
+{
+	struct kirin_crtc *kcrtc = to_kirin_crtc(crtc);
+
+	if (kcrtc->enable == false)
+		return;
+
+	drm_crtc_vblank_off(crtc);
+	kcrtc->enable = false;
+}
+
+static void dpe_crtc_mode_set_nofb(struct drm_crtc *crtc)
+{
+	struct kirin_crtc *kcrtc = to_kirin_crtc(crtc);
+	struct dpe_hw_ctx *ctx = kcrtc->hw_ctx;
+	struct drm_display_mode *mode = &crtc->state->mode;
+	struct drm_display_mode *adj_mode = &crtc->state->adjusted_mode;
+
+	dpe_power_up(ctx);
+	dpe_ldi_set_mode(ctx, mode, adj_mode);
+	dpe_init(ctx, mode, adj_mode);
+}
+
+static void dpe_crtc_atomic_begin(struct drm_crtc *crtc,
+				  struct drm_crtc_state *old_state)
+{
+	struct kirin_crtc *kcrtc = to_kirin_crtc(crtc);
+	struct dpe_hw_ctx *ctx = kcrtc->hw_ctx;
+
+	dpe_power_up(ctx);
+}
+
+static void dpe_crtc_atomic_flush(struct drm_crtc *crtc,
+				  struct drm_crtc_state *old_state)
+
+{
+	struct drm_pending_vblank_event *event = crtc->state->event;
+
+	if (event) {
+		crtc->state->event = NULL;
+
+		spin_lock_irq(&crtc->dev->event_lock);
+		if (drm_crtc_vblank_get(crtc) == 0)
+			drm_crtc_arm_vblank_event(crtc, event);
+		else
+			drm_crtc_send_vblank_event(crtc, event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+	}
+}
+
+const struct drm_crtc_helper_funcs dpe_crtc_helper_funcs = {
+	.atomic_enable	= dpe_crtc_atomic_enable,
+	.atomic_disable	= dpe_crtc_atomic_disable,
+	.mode_set_nofb	= dpe_crtc_mode_set_nofb,
+	.atomic_begin	= dpe_crtc_atomic_begin,
+	.atomic_flush	= dpe_crtc_atomic_flush,
+};
+
+const struct drm_crtc_funcs dpe_crtc_funcs = {
+	.destroy = drm_crtc_cleanup,
+	.set_config	= drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state	= drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = dpe_enable_vblank,
+	.disable_vblank	= dpe_disable_vblank,
+};
+
+static void dpe_unflow_handler(struct dpe_hw_ctx *ctx)
+{
+	void __iomem *base = ctx->base;
+	u32 tmp = 0;
+
+	tmp = readl(base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK);
+	tmp &= ~BIT_LDI_UNFLOW;
+
+	writel(tmp, base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK);
+}
+
+static void dpe_mctl_ov_config(struct dpe_hw_ctx *ctx, u32 ch)
+{
+	void __iomem *mctl_base = ctx->base + mctl_offset[DPE_OVL0];
+
+	dpe_set_reg(mctl_base + MCTL_CTL_EN, 0x1, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_TOP, 0x2, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_DBG, 0xB13A00, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX_RCH0 + ch * 4, 0x1, 32, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX_ITF, 0x1, 2, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX_DBUF, 0x1, 2, 0);
+	dpe_set_reg(mctl_base + MCTL_CTL_MUTEX_OV, 1 << DPE_OVL0, 4, 0);
+}
+
+static void dpe_mctl_sys_config(struct dpe_hw_ctx *ctx, u32 ch)
+{
+	void __iomem *mctl_sys_base = ctx->base + DPE_MCTRL_SYS_OFFSET;
+
+	dpe_set_reg(mctl_sys_base + MCTL_RCH0_OV_OEN + ch * 4,
+				(1 << 1) | 0x100, 32, 0);
+	dpe_set_reg(mctl_sys_base + MCTL_RCH_OV0_SEL, 0x8, 4, 0);
+	dpe_set_reg(mctl_sys_base + MCTL_RCH_OV0_SEL,
+				ch, 4, (DPE_OVL0 + 1) * 4);
+	dpe_set_reg(mctl_sys_base + MCTL_OV0_FLUSH_EN, 0xd, 4, 0);
+	dpe_set_reg(mctl_sys_base + MCTL_RCH0_FLUSH_EN + ch * 4, 0x1, 32, 0);
+}
+
+static void dpe_ovl_config(struct dpe_hw_ctx *ctx, const struct drm_rect *rect,
+						   u32 xres, u32 yres)
+{
+	void __iomem *ovl0_base = ctx->base + ovl_offset[DPE_OVL0];
+
+	dpe_set_reg(ovl0_base + OVL6_REG_DEFAULT, 0x1, 32, 0);
+	dpe_set_reg(ovl0_base + OVL6_REG_DEFAULT, 0x0, 32, 0);
+	dpe_set_reg(ovl0_base + OVL_SIZE,
+				(xres - 1) | ((yres - 1) << 16), 32, 0);
+	dpe_set_reg(ovl0_base + OVL_BG_COLOR, 0xFF000000, 32, 0);
+	dpe_set_reg(ovl0_base + OVL_DST_STARTPOS, 0x0, 32, 0);
+	dpe_set_reg(ovl0_base + OVL_DST_ENDPOS,
+				(xres - 1) | ((yres - 1) << 16), 32, 0);
+	dpe_set_reg(ovl0_base + OVL_GCFG, 0x10001, 32, 0);
+	dpe_set_reg(ovl0_base + OVL_LAYER0_POS,
+				(rect->x1) | ((rect->y1) << 16), 32, 0);
+	dpe_set_reg(ovl0_base + OVL_LAYER0_SIZE,
+				(rect->x2) | ((rect->y2) << 16), 32, 0);
+	dpe_set_reg(ovl0_base + OVL_LAYER0_ALPHA, 0x00ff40ff, 32, 0);
+	dpe_set_reg(ovl0_base + OVL_LAYER0_CFG, 0x1, 1, 0);
+}
+
+static void dpe_rdma_config(struct dpe_hw_ctx *ctx,
+				const struct drm_rect *rect,
+				u32 display_addr, u32 hal_format,
+				u32 bpp, int ch)
+{
+	void __iomem *rdma_base = ctx->base + rdma_offset[ch];
+
+	u32 aligned_pixel = 0;
+	u32 rdma_oft_x0, rdma_oft_y0, rdma_oft_x1, rdma_oft_y1;
+	u32 rdma_stride, rdma_format;
+	u32 stretch_size_vrt = 0;
+	u32 h_display = 0;
+
+	aligned_pixel = DMA_ALIGN_BYTES / bpp;
+	rdma_oft_x0 = rect->x1 / aligned_pixel;
+	rdma_oft_y0 = rect->y1;
+	rdma_oft_x1 = rect->x2 / aligned_pixel;
+	rdma_oft_y1 = rect->y2;
+
+	rdma_format = dpe_pixel_dma_format_map[hal_format];
+	stretch_size_vrt = rdma_oft_y1 - rdma_oft_y0;
+
+	h_display = (rect->x2 - rect->x1) + 1;
+	rdma_stride = (h_display * bpp) / DMA_ALIGN_BYTES;
+
+
+	dpe_set_reg(rdma_base + DMA_CH_REG_DEFAULT, 0x1, 32, 0);
+	dpe_set_reg(rdma_base + DMA_CH_REG_DEFAULT, 0x0, 32, 0);
+
+	dpe_set_reg(rdma_base + DMA_OFT_X0, rdma_oft_x0, 12, 0);
+	dpe_set_reg(rdma_base + DMA_OFT_Y0, rdma_oft_y0, 16, 0);
+	dpe_set_reg(rdma_base + DMA_OFT_X1, rdma_oft_x1, 12, 0);
+	dpe_set_reg(rdma_base + DMA_OFT_Y1, rdma_oft_y1, 16, 0);
+	dpe_set_reg(rdma_base + DMA_CTRL, rdma_format, 5, 3);
+	dpe_set_reg(rdma_base + DMA_CTRL, 0x0, 1, 8);
+	dpe_set_reg(rdma_base + DMA_STRETCH_SIZE_VRT, stretch_size_vrt, 32, 0);
+	dpe_set_reg(rdma_base + DMA_DATA_ADDR0, display_addr, 32, 0);
+	dpe_set_reg(rdma_base + DMA_STRIDE0, rdma_stride, 13, 0);
+	dpe_set_reg(rdma_base + DMA_CH_CTL, 0x1, 1, 0);
+}
+
+static void dpe_rdfc_config(struct dpe_hw_ctx *ctx,
+				const struct drm_rect *rect,
+				u32 hal_format, u32 bpp, int ch)
+{
+	void __iomem *rdfc_base = ctx->base + rdfc_offset[ch];
+
+	u32 dfc_pix_in_num = 0;
+	u32 size_hrz = 0;
+	u32 size_vrt = 0;
+	u32 dfc_fmt = 0;
+
+	dfc_pix_in_num = (bpp <= 2) ? 0x1 : 0x0;
+	size_hrz = rect->x2 - rect->x1;
+	size_vrt = rect->y2 - rect->y1;
+
+	dfc_fmt = dpe_pixel_dfc_format_map[hal_format];
+
+	dpe_set_reg(rdfc_base + DFC_DISP_SIZE,
+				(size_vrt | (size_hrz << 16)), 29, 0);
+	dpe_set_reg(rdfc_base + DFC_PIX_IN_NUM, dfc_pix_in_num, 1, 0);
+	dpe_set_reg(rdfc_base + DFC_DISP_FMT, dfc_fmt, 5, 1);
+	dpe_set_reg(rdfc_base + DFC_CTL_CLIP_EN, 0x1, 1, 0);
+	dpe_set_reg(rdfc_base + DFC_ICG_MODULE, 0x1, 1, 0);
+}
+
+static void dpe_aif_config(struct dpe_hw_ctx *ctx, u32 ch)
+{
+	void __iomem *aif_ch_base = ctx->base + aif_offset[ch];
+
+	dpe_set_reg(aif_ch_base, 0x0, 1, 0);
+	dpe_set_reg(aif_ch_base, mid_array[ch], 4, 4);
+}
+
+static void dpe_mif_config(struct dpe_hw_ctx *ctx, u32 ch)
+{
+	void __iomem *mif_ch_base = ctx->base + mif_offset[ch];
+
+	dpe_set_reg(mif_ch_base + MIF_CTRL1, 0x1, 1, 5);
+}
+
+static void dpe_smmu_config_off(struct dpe_hw_ctx *ctx, u32 ch)
+{
+	void __iomem *smmu_base = ctx->base + DPE_SMMU_OFFSET;
+	int i, index;
+
+	for (i = 0; i < dpe_smmu_chn_sid_num[ch]; i++) {
+		index = dpe_smmu_smrx_idx[ch] + i;
+		dpe_set_reg(smmu_base + SMMU_SMRx_NS + index * 0x4, 1, 32, 0);
+	}
+}
+
+static void dpe_update_channel(struct kirin_plane *kplane,
+			       struct drm_framebuffer *fb, int crtc_x,
+			       int crtc_y, unsigned int crtc_w,
+			       unsigned int crtc_h, u32 src_x,
+			       u32 src_y, u32 src_w, u32 src_h)
+{
+	struct dpe_hw_ctx *ctx = kplane->hw_ctx;
+	struct drm_gem_cma_object *obj = drm_fb_cma_get_gem_obj(fb, 0);
+	struct drm_rect rect;
+	u32 bpp;
+	u32 stride;
+	u32 display_addr;
+	u32 hal_fmt;
+	u32 ch = DPE_CH0;
+
+	bpp = fb->format->cpp[0];
+	stride = fb->pitches[0];
+
+	display_addr = (u32)obj->paddr + src_y * stride;
+
+	rect.x1 = 0;
+	rect.x2 = src_w - 1;
+	rect.y1 = 0;
+	rect.y2 = src_h - 1;
+	hal_fmt = dpe_get_format(fb->format->format);
+
+	dpe_mctl_lock(ctx);
+	dpe_aif_config(ctx, ch);
+	dpe_mif_config(ctx, ch);
+	dpe_smmu_config_off(ctx, ch);
+
+	dpe_rdma_config(ctx, &rect, display_addr, hal_fmt, bpp, ch);
+	dpe_rdfc_config(ctx, &rect, hal_fmt, bpp, ch);
+	dpe_ovl_config(ctx, &rect, ctx->hdisplay, ctx->vdisplay);
+
+	dpe_mctl_ov_config(ctx, ch);
+	dpe_mctl_sys_config(ctx, ch);
+	dpe_mctl_unlock(ctx);
+	dpe_unflow_handler(ctx);
+
+	dpe_enable_ldi(ctx);
+}
+
+static void dpe_plane_atomic_update(struct drm_plane *plane,
+				    struct drm_plane_state *old_state)
+{
+	struct drm_plane_state *state = plane->state;
+	struct kirin_plane *kplane = to_kirin_plane(plane);
+
+	if (!state->fb) {
+		state->visible = false;
+		return;
+	}
+
+	dpe_update_channel(kplane, state->fb, state->crtc_x, state->crtc_y,
+			   state->crtc_w, state->crtc_h,
+			   state->src_x >> 16, state->src_y >> 16,
+			   state->src_w >> 16, state->src_h >> 16);
+}
+
+static int dpe_plane_atomic_check(struct drm_plane *plane,
+				  struct drm_plane_state *state)
+{
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_crtc *crtc = state->crtc;
+	struct drm_crtc_state *crtc_state;
+	u32 src_x = state->src_x >> 16;
+	u32 src_y = state->src_y >> 16;
+	u32 src_w = state->src_w >> 16;
+	u32 src_h = state->src_h >> 16;
+	int crtc_x = state->crtc_x;
+	int crtc_y = state->crtc_y;
+	u32 crtc_w = state->crtc_w;
+	u32 crtc_h = state->crtc_h;
+	u32 fmt;
+
+	if (!crtc || !fb)
+		return 0;
+
+	fmt = dpe_get_format(fb->format->format);
+	if (fmt == DPE_UNSUPPORT)
+		return -EINVAL;
+
+	crtc_state = drm_atomic_get_crtc_state(state->state, crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	if (src_w != crtc_w || src_h != crtc_h) {
+		DRM_ERROR("Scale not support!!!\n");
+		return -EINVAL;
+	}
+
+	if (src_x + src_w > fb->width ||
+	    src_y + src_h > fb->height)
+		return -EINVAL;
+
+	if (crtc_x < 0 || crtc_y < 0)
+		return -EINVAL;
+
+	if (crtc_x + crtc_w > crtc_state->adjusted_mode.hdisplay ||
+	    crtc_y + crtc_h > crtc_state->adjusted_mode.vdisplay)
+		return -EINVAL;
+
+	return 0;
+}
+
+const struct drm_plane_helper_funcs dpe_plane_helper_funcs = {
+	.atomic_check = dpe_plane_atomic_check,
+	.atomic_update = dpe_plane_atomic_update,
+};
+
+const struct drm_plane_funcs dpe_plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.destroy = drm_plane_cleanup,
+	.reset = drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static irqreturn_t dpe_irq_handler(int irq, void *data)
+{
+	struct dpe_hw_ctx *ctx = data;
+	struct drm_crtc *crtc = ctx->crtc;
+	void __iomem *base = ctx->base;
+
+	u32 isr_s1 = 0;
+	u32 isr_s2 = 0;
+	u32 isr_s2_dpp = 0;
+	u32 isr_s2_smmu = 0;
+	u32 mask = 0;
+
+	isr_s1 = readl(base + GLB_CPU_PDP_INTS);
+	isr_s2 = readl(base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INTS);
+	isr_s2_dpp = readl(base + DPE_DPP_OFFSET + DPP_INTS);
+	isr_s2_smmu = readl(base + DPE_SMMU_OFFSET + SMMU_INTSTAT_NS);
+
+	writel(isr_s2_smmu, base + DPE_SMMU_OFFSET + SMMU_INTCLR_NS);
+	writel(isr_s2_dpp, base + DPE_DPP_OFFSET + DPP_INTS);
+	writel(isr_s2, base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INTS);
+	writel(isr_s1, base + GLB_CPU_PDP_INTS);
+
+	isr_s1 &= ~(readl(base + GLB_CPU_PDP_INT_MSK));
+	isr_s2 &= ~(readl(base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK));
+	isr_s2_dpp &= ~(readl(base + DPE_DPP_OFFSET + DPP_INT_MSK));
+
+	if (isr_s2 & BIT_VSYNC)
+		drm_crtc_handle_vblank(crtc);
+
+	if (isr_s2 & BIT_LDI_UNFLOW) {
+		mask = readl(base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK);
+		mask |= BIT_LDI_UNFLOW;
+		writel(mask, base + DPE_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK);
+
+		DRM_ERROR("ldi underflow!\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void *dpe_hw_ctx_alloc(struct platform_device *pdev,
+							  struct drm_crtc *crtc)
+{
+	struct dpe_hw_ctx *ctx = NULL;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	int ret = 0;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		DRM_ERROR("failed to alloc ade_hw_ctx\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	ctx->base = of_iomap(np, 0);
+	if (!(ctx->base)) {
+		DRM_ERROR("failed to get ade base resource.\n");
+		return ERR_PTR(-ENXIO);
+	}
+
+	ctx->noc_base = of_iomap(np, 4);
+	if (!(ctx->noc_base)) {
+		DRM_ERROR("failed to get noc_base  resource.\n");
+		return ERR_PTR(-ENXIO);
+	}
+
+	ctx->irq = irq_of_parse_and_map(np, 0);
+	if (ctx->irq <= 0) {
+		DRM_ERROR("failed to get irq_pdp resource.\n");
+		return ERR_PTR(-ENXIO);
+	}
+
+	DRM_INFO("dpe irq = %d.", ctx->irq);
+
+	ctx->dpe_mmbuf_clk = devm_clk_get(dev, "clk_dss_axi_mm");
+	if (!ctx->dpe_mmbuf_clk) {
+		DRM_ERROR("failed to parse dpe_mmbuf_clk\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	ctx->dpe_axi_clk = devm_clk_get(dev, "aclk_dss");
+	if (!ctx->dpe_axi_clk) {
+		DRM_ERROR("failed to parse dpe_axi_clk\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	ctx->dpe_pclk_clk = devm_clk_get(dev, "pclk_dss");
+	if (!ctx->dpe_pclk_clk) {
+		DRM_ERROR("failed to parse dpe_pclk_clk\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	ctx->dpe_pri_clk = devm_clk_get(dev, "clk_edc0");
+	if (!ctx->dpe_pri_clk) {
+		DRM_ERROR("failed to parse dpe_pri_clk\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	ret = clk_set_rate(ctx->dpe_pri_clk, DEFAULT_DPE_CORE_CLK_07V_RATE);
+	if (ret < 0) {
+		DRM_ERROR("dpe_pri_clk clk_set_rate(%lu) failed, error=%d!\n",
+			DEFAULT_DPE_CORE_CLK_07V_RATE, ret);
+		return ERR_PTR(-EINVAL);
+	}
+
+	ctx->dpe_pxl0_clk = devm_clk_get(dev, "clk_ldi0");
+	if (!ctx->dpe_pxl0_clk) {
+		DRM_ERROR("failed to parse dpe_pxl0_clk\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	ret = clk_set_rate(ctx->dpe_pxl0_clk, DPE_MAX_PXL0_CLK_144M);
+	if (ret < 0) {
+		DRM_ERROR("dpe_pxl0_clk clk_set_rate(%lu) failed, error=%d!\n",
+			DPE_MAX_PXL0_CLK_144M, ret);
+		return ERR_PTR(-EINVAL);
+	}
+
+	ctx->crtc = crtc;
+	ret = devm_request_irq(dev, ctx->irq, dpe_irq_handler,
+			       IRQF_SHARED, dev->driver->name, ctx);
+	if (ret)
+		return ERR_PTR(-EIO);
+
+	disable_irq(ctx->irq);
+
+	return ctx;
+}
+
+static void dpe_hw_ctx_cleanup(void *hw_ctx)
+{
+}
+
+extern void dsi_set_output_client(struct drm_device *dev);
+static void kirin_fbdev_output_poll_changed(struct drm_device *dev)
+{
+	dsi_set_output_client(dev);
+}
+
+static const struct drm_mode_config_funcs dpe_mode_config_funcs = {
+	.fb_create = drm_gem_fb_create,
+	.output_poll_changed = kirin_fbdev_output_poll_changed,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(kirin_drm_fops);
+static struct drm_driver dpe_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET |
+				  DRIVER_ATOMIC | DRIVER_RENDER,
+
+	.date			= "20170309",
+	.fops				= &kirin_drm_fops,
+	.gem_free_object_unlocked	= drm_gem_cma_free_object,
+	.gem_vm_ops		= &drm_gem_cma_vm_ops,
+	.dumb_create		= drm_gem_cma_dumb_create_internal,
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
+	.gem_prime_export	= drm_gem_prime_export,
+	.gem_prime_import	= drm_gem_prime_import,
+	.gem_prime_get_sg_table = drm_gem_cma_prime_get_sg_table,
+	.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
+	.gem_prime_vmap		= drm_gem_cma_prime_vmap,
+	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap,
+	.gem_prime_mmap		= drm_gem_cma_prime_mmap,
+
+	.name			= "kirin",
+	.desc			= "Hisilicon Kirin SoCs' DRM Driver",
+	.major			= 1,
+	.minor			= 0,
+};
+
+const struct kirin_drm_data dpe_driver_data = {
+	.register_connects = true,
+	.num_planes = DPE_CH_NUM,
+	.prim_plane = DPE_CH0,
+
+	.channel_formats = dpe_channel_formats,
+	.channel_formats_cnt = ARRAY_SIZE(dpe_channel_formats),
+	.config_max_width = 4096,
+	.config_max_height = 4096,
+
+	.driver = &dpe_driver,
+
+	.crtc_helper_funcs = &dpe_crtc_helper_funcs,
+	.crtc_funcs = &dpe_crtc_funcs,
+	.plane_helper_funcs = &dpe_plane_helper_funcs,
+	.plane_funcs = &dpe_plane_funcs,
+	.mode_config_funcs = &dpe_mode_config_funcs,
+
+	.alloc_hw_ctx = dpe_hw_ctx_alloc,
+	.cleanup_hw_ctx = dpe_hw_ctx_cleanup,
+};
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.c b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.c
index d3145ae87..ace4d30e6 100644
--- a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.c
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.c
@@ -336,9 +336,16 @@ static int kirin_drm_platform_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id kirin_drm_dt_ids[] = {
+#ifdef CONFIG_DRM_HISI_KIRIN620
 	{ .compatible = "hisilicon,hi6220-ade",
 	  .data = &ade_driver_data,
 	},
+#endif
+#ifdef CONFIG_DRM_HISI_KIRIN960
+	{ .compatible = "hisilicon,hi3660-dpe",
+	  .data = &dpe_driver_data,
+	},
+#endif
 	{ /* end node */ },
 };
 MODULE_DEVICE_TABLE(of, kirin_drm_dt_ids);
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.h b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.h
index 4d5c05a24..ad4aaf3d6 100644
--- a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.h
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.h
@@ -53,6 +53,11 @@ struct kirin_drm_data {
 	void (*cleanup_hw_ctx)(void *hw_ctx);
 };
 
+#ifdef CONFIG_DRM_HISI_KIRIN620
 extern struct kirin_drm_data ade_driver_data;
+#endif
+#ifdef CONFIG_DRM_HISI_KIRIN960
+extern const struct kirin_drm_data dpe_driver_data;
+#endif
 
 #endif /* __KIRIN_DRM_DRV_H__ */
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dsi.c b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dsi.c
new file mode 100644
index 000000000..2aa57662d
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dsi.c
@@ -0,0 +1,444 @@
+/*
+ * DesignWare MIPI DSI Host Controller v1.02 driver
+ *
+ * Copyright (c) 2016 Linaro Limited.
+ * Copyright (c) 2014-2016 Hisilicon Limited.
+ *
+ * Author:
+ *	<shizongxuan@huawei.com>
+ *	<zhangxiubin@huawei.com>
+ *	<lvda3@hisilicon.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_device.h>
+#include <drm/drm_encoder_slave.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_of.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_sysfs.h>
+
+#include "kirin_drm_dsi.h"
+#include "dw_dsi_reg.h"
+
+static struct kirin_dsi_ops *hisi_dsi_ops;
+
+void dsi_set_output_client(struct drm_device *dev)
+{
+	enum dsi_output_client client;
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_connector_list_iter conn_iter;
+	struct dw_dsi *dsi;
+
+	mutex_lock(&dev->mode_config.mutex);
+
+	/* find dsi encoder */
+	drm_for_each_encoder(encoder, dev)
+		if (encoder->encoder_type == DRM_MODE_ENCODER_DSI)
+			break;
+	dsi = encoder_to_dsi(encoder);
+
+	/* find HDMI connector */
+	drm_connector_list_iter_begin(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter)
+		if (connector->connector_type == DRM_MODE_CONNECTOR_HDMIA)
+			break;
+	drm_connector_list_iter_end(&conn_iter);
+
+	/*
+	 * set the proper dsi output client
+	 */
+	client = connector->status == connector_status_connected ?
+		OUT_HDMI : OUT_PANEL;
+	if (client != dsi->cur_client) {
+		/* associate bridge and dsi encoder */
+		if (client == OUT_HDMI)
+			encoder->bridge = dsi->bridge;
+		else
+			encoder->bridge = NULL;
+		/*
+		 * set the switch ic to select the HDMI or MIPI_DSI
+		*/
+		if (KIRIN960_DSI == hisi_dsi_ops->version) {
+			gpiod_set_value_cansleep(dsi->gpio_mux, client);
+		}else if (KIRIN620_DSI == hisi_dsi_ops->version) {
+			/*the gpio0_1*/
+		}
+		dsi->cur_client = client;
+		/* let the userspace know panel connector status has changed */
+		drm_sysfs_hotplug_event(dev);
+		DRM_INFO("client change to %s\n", client == OUT_HDMI ?
+				 "HDMI" : "panel");
+	}
+
+	mutex_unlock(&dev->mode_config.mutex);
+}
+EXPORT_SYMBOL_GPL(dsi_set_output_client);
+/************************for the panel attach to dsi*****************************/
+static int dsi_connector_get_modes(struct drm_connector *connector)
+{
+	struct dw_dsi *dsi = connector_to_dsi(connector);
+
+	return drm_panel_get_modes(dsi->panel);
+}
+
+static enum drm_mode_status
+dsi_connector_mode_valid(struct drm_connector *connector,
+			 struct drm_display_mode *mode)
+{
+	enum drm_mode_status mode_status = MODE_OK;
+
+	return mode_status;
+}
+
+static struct drm_encoder *
+dsi_connector_best_encoder(struct drm_connector *connector)
+{
+	struct dw_dsi *dsi = connector_to_dsi(connector);
+
+	return &dsi->encoder;
+}
+
+static struct drm_connector_helper_funcs dsi_connector_helper_funcs = {
+	.get_modes = dsi_connector_get_modes,
+	.mode_valid = dsi_connector_mode_valid,
+	.best_encoder = dsi_connector_best_encoder,
+};
+
+static enum drm_connector_status
+dsi_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct dw_dsi *dsi = connector_to_dsi(connector);
+	enum drm_connector_status status;
+
+	status = dsi->cur_client == OUT_PANEL ?	connector_status_connected :
+		connector_status_disconnected;
+
+	return status;
+}
+
+static void dsi_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
+static struct drm_connector_funcs dsi_atomic_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = dsi_connector_detect,
+	.destroy = dsi_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static int dsi_connector_init(struct drm_device *dev, struct dw_dsi *dsi)
+{
+	struct drm_encoder *encoder = &dsi->encoder;
+	struct drm_connector *connector = &dsi->connector;
+	int ret;
+
+	connector->polled = DRM_CONNECTOR_POLL_HPD;
+	drm_connector_helper_add(connector,
+				 &dsi_connector_helper_funcs);
+
+	ret = drm_connector_init(dev, &dsi->connector,
+				 &dsi_atomic_connector_funcs,
+				 DRM_MODE_CONNECTOR_DSI);
+	if (ret)
+		return ret;
+
+	ret = drm_connector_attach_encoder(connector, encoder);
+	if (ret)
+		return ret;
+
+	ret = drm_panel_attach(dsi->panel, connector);
+	if (ret)
+		return ret;
+
+	DRM_INFO("connector init\n");
+	return 0;
+}
+/****************************************************************************/
+
+/***************************for the encoder_helper_funcs****************************************/
+static const struct drm_encoder_funcs dw_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+
+static int dsi_encoder_atomic_check(struct drm_encoder *encoder,
+				    struct drm_crtc_state *crtc_state,
+				    struct drm_connector_state *conn_state)
+{
+	/* do nothing */
+	return 0;
+}
+
+static enum drm_mode_status dsi_encoder_mode_valid(struct drm_encoder *encoder,
+					const struct drm_display_mode *mode)
+
+{
+	 return hisi_dsi_ops->encoder_valid(encoder,mode);
+}
+
+static void dsi_encoder_mode_set(struct drm_encoder *encoder,
+				 struct drm_display_mode *mode,
+				 struct drm_display_mode *adj_mode)
+{
+	struct dw_dsi *dsi = encoder_to_dsi(encoder);
+
+	drm_mode_copy(&dsi->cur_mode, adj_mode);
+}
+
+static void dsi_encoder_enable(struct drm_encoder *encoder)
+{
+	struct dw_dsi *dsi = encoder_to_dsi(encoder);
+
+
+
+	if (dsi->enable)
+		return;
+
+	hisi_dsi_ops->encoder_enable(encoder);
+
+	if (KIRIN960_DSI == hisi_dsi_ops->version) {
+		/* turn on panel */
+		if (dsi->panel && drm_panel_prepare(dsi->panel))
+			DRM_ERROR("failed to prepare panel\n");
+
+		/*dw_dsi_set_mode(dsi, DSI_VIDEO_MODE);*/
+
+		/* turn on panel's back light */
+		if (dsi->panel && drm_panel_enable(dsi->panel))
+			DRM_ERROR("failed to enable panel\n");
+
+	}
+
+	dsi->enable = true;
+}
+
+static void dw_dsi_set_mode(struct dw_dsi *dsi, enum dsi_work_mode mode)
+{
+	struct dsi_hw_ctx *ctx = dsi->ctx;
+	void __iomem *base = ctx->base;
+
+	writel(RESET, base + PWR_UP);
+	writel(mode, base + MODE_CFG);
+	writel(POWERUP, base + PWR_UP);
+}
+
+static void dsi_encoder_disable(struct drm_encoder *encoder)
+{
+	struct dw_dsi *dsi = encoder_to_dsi(encoder);
+	struct dsi_hw_ctx *ctx = dsi->ctx;
+
+	if (!dsi->enable)
+		return;
+
+	dw_dsi_set_mode(dsi, DSI_COMMAND_MODE);
+	
+	if (KIRIN960_DSI == hisi_dsi_ops->version) {
+		/* turn off panel's backlight */
+		if (dsi->panel && drm_panel_disable(dsi->panel))
+			DRM_ERROR("failed to disable panel\n");
+
+		/* turn off panel */
+		if (dsi->panel && drm_panel_unprepare(dsi->panel))
+			DRM_ERROR("failed to unprepare panel\n");
+
+		clk_disable_unprepare(ctx->dss_dphy0_ref_clk);
+		clk_disable_unprepare(ctx->dss_dphy0_cfg_clk);
+		clk_disable_unprepare(ctx->dss_pclk_dsi0_clk);
+	}
+
+	dsi->enable = false;
+}
+
+static const struct drm_encoder_helper_funcs dw_encoder_helper_funcs = {
+	.atomic_check	= dsi_encoder_atomic_check,
+	.mode_valid	= dsi_encoder_mode_valid,
+	.mode_set	= dsi_encoder_mode_set,
+	.enable		= dsi_encoder_enable,
+	.disable	= dsi_encoder_disable
+};
+
+/****************************************************************************/
+static int dsi_bridge_init(struct drm_device *dev, struct dw_dsi *dsi)
+{
+	struct drm_encoder *encoder = &dsi->encoder;
+	struct drm_bridge *bridge = dsi->bridge;
+	int ret;
+
+	/* associate the bridge to dsi encoder */
+	ret = drm_bridge_attach(encoder, bridge, NULL);
+	if (ret) {
+		DRM_ERROR("failed to attach external bridge\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dw_drm_encoder_init(struct device *dev,
+			       struct drm_device *drm_dev,
+			       struct drm_encoder *encoder)
+{
+	int ret;
+	u32 crtc_mask = drm_of_find_possible_crtcs(drm_dev, dev->of_node);
+
+	if (!crtc_mask) {
+		DRM_ERROR("failed to find crtc mask\n");
+		return -EINVAL;
+	}
+
+	encoder->possible_crtcs = crtc_mask;
+	ret = drm_encoder_init(drm_dev, encoder, &dw_encoder_funcs,
+			       DRM_MODE_ENCODER_DSI, NULL);
+	if (ret) {
+		DRM_ERROR("failed to init dsi encoder\n");
+		return ret;
+	}
+
+	drm_encoder_helper_add(encoder, &dw_encoder_helper_funcs);
+
+	return 0;
+}
+
+static int dsi_bind(struct device *dev, struct device *master, void *data)
+{
+	struct dsi_data *ddata = dev_get_drvdata(dev);
+	struct dw_dsi *dsi = &ddata->dsi;
+	struct drm_device *drm_dev = data;
+	int ret;
+
+	DRM_INFO("+. \n");
+	ret = dw_drm_encoder_init(dev, drm_dev, &dsi->encoder);
+	if (ret)
+		return ret;
+
+	if (dsi->bridge) {
+		ret = dsi_bridge_init(drm_dev, dsi);
+		if (ret)
+			return ret;
+	}
+
+	if (KIRIN960_DSI == hisi_dsi_ops->version) {
+		if (dsi->panel) {
+			ret = dsi_connector_init(drm_dev, dsi);
+			if (ret)
+				return ret;
+		}
+	}else if (KIRIN620_DSI == hisi_dsi_ops->version) {
+		/*the panel for the kirin620 drm have not support*/
+	}
+
+	DRM_INFO("-. \n");
+	return 0;
+}
+
+static void dsi_unbind(struct device *dev, struct device *master, void *data)
+{
+	/* do nothing */
+}
+
+static const struct component_ops dsi_ops = {
+	.bind	= dsi_bind,
+	.unbind	= dsi_unbind,
+};
+
+
+
+static int dsi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct dsi_data *data;
+	struct dw_dsi *dsi;
+	struct dsi_hw_ctx *ctx;
+	int ret;
+
+	hisi_dsi_ops =  (struct kirin_dsi_ops *) of_device_get_match_data(dev);
+
+	DRM_INFO("+. \n");
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		DRM_ERROR("failed to allocate dsi data.\n");
+		return -ENOMEM;
+	}
+	dsi = &data->dsi;
+	ctx = &data->ctx;
+	dsi->ctx = ctx;
+
+	if (NULL == hisi_dsi_ops) {
+		DRM_ERROR("hisi_dsi_ops is not bind\n");
+	}
+	ret = hisi_dsi_ops->host_init(dev, dsi);
+	if (ret)
+		return ret;
+	
+	ret = hisi_dsi_ops->parse_dt(pdev, dsi);
+	if (ret)
+		goto err_host_unregister;
+
+	platform_set_drvdata(pdev, data);
+
+	ret = component_add(dev, &dsi_ops);
+	if (ret)
+		goto err_host_unregister;
+
+	DRM_INFO("-. \n");
+	return 0;
+
+err_host_unregister:
+	mipi_dsi_host_unregister(&dsi->host);
+	return ret;
+}
+static int dsi_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dsi_ops);
+
+	return 0;
+}
+
+static const struct of_device_id dsi_of_match[] = {
+#ifdef CONFIG_DRM_HISI_KIRIN960
+	{
+		.compatible = "hisilicon,hi3660-dsi",
+		.data = &kirin_dsi_960,
+	},
+#endif
+#ifdef CONFIG_DRM_HISI_KIRIN620
+	{
+		.compatible = "hisilicon,hi6220-dsi",
+		.data = &kirin_dsi_620,
+	},
+#endif
+	{ /* end node */}
+};
+MODULE_DEVICE_TABLE(of, dsi_of_match);
+
+static struct platform_driver dsi_driver = {
+	.probe = dsi_probe,
+	.remove = dsi_remove,
+	.driver = {
+		.name = "dw-dsi",
+		.of_match_table = dsi_of_match,
+	},
+};
+
+module_platform_driver(dsi_driver);
+
+MODULE_DESCRIPTION("DesignWare MIPI DSI Host Controller v1.02 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dsi.h b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dsi.h
new file mode 100644
index 000000000..4043784bd
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_dsi.h
@@ -0,0 +1,259 @@
+#ifndef __KIRIN_DRM_DSI_H__
+#define __KIRIN_DRM_DSI_H__
+
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_graph.h>
+#include <linux/iopoll.h>
+#include <video/mipi_display.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+
+#include <drm/drm_of.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_encoder_slave.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_panel.h>
+
+#define ROUND(x, y)		((x) / (y) + \
+				((x) % (y) * 10 / (y) >= 5 ? 1 : 0))
+#define PHY_REF_CLK_RATE	19200000
+#define PHY_REF_CLK_PERIOD_PS	(1000000000 / (PHY_REF_CLK_RATE / 1000))
+
+#define encoder_to_dsi(encoder) \
+	container_of(encoder, struct dw_dsi, encoder)
+#define host_to_dsi(host) \
+	container_of(host, struct dw_dsi, host)
+#define connector_to_dsi(connector) \
+	container_of(connector, struct dw_dsi, connector)
+	
+enum dsi_output_client {
+	OUT_HDMI = 0,
+	OUT_PANEL,
+	OUT_MAX
+};
+
+struct dsi_phy_range {
+	u32 min_range_kHz;
+	u32 max_range_kHz;
+	u32 pll_vco_750M;
+	u32 hstx_ckg_sel;
+};
+
+static const struct dsi_phy_range dphy_range_info[] = {
+	{   46875,    62500,   1,    7 },
+	{   62500,    93750,   0,    7 },
+	{   93750,   125000,   1,    6 },
+	{  125000,   187500,   0,    6 },
+	{  187500,   250000,   1,    5 },
+	{  250000,   375000,   0,    5 },
+	{  375000,   500000,   1,    4 },
+	{  500000,   750000,   0,    4 },
+	{  750000,  1000000,   1,    0 },
+	{ 1000000,  1500000,   0,    0 }
+};
+
+struct dsi_hw_ctx {
+	void __iomem *base;
+	char __iomem *peri_crg_base;
+
+	struct clk *pclk;
+	struct clk *dss_dphy0_ref_clk;
+	struct clk *dss_dphy1_ref_clk;
+	struct clk *dss_dphy0_cfg_clk;
+	struct clk *dss_dphy1_cfg_clk;
+	struct clk *dss_pclk_dsi0_clk;
+	struct clk *dss_pclk_dsi1_clk;
+};
+
+struct mipi_panel_info {
+	u8 dsi_version;
+	u8 vc;
+	u8 lane_nums;
+	u8 lane_nums_select_support;
+	u8 color_mode;
+	u32 dsi_bit_clk; /* clock lane(p/n) */
+	u32 burst_mode;
+	u32 max_tx_esc_clk;
+	u8 non_continue_en;
+
+	u32 dsi_bit_clk_val1;
+	u32 dsi_bit_clk_val2;
+	u32 dsi_bit_clk_val3;
+	u32 dsi_bit_clk_val4;
+	u32 dsi_bit_clk_val5;
+	u32 dsi_bit_clk_upt;
+	/*uint32_t dsi_pclk_rate;*/
+
+	u32 hs_wr_to_time;
+
+	/* dphy config parameter adjust*/
+	u32 clk_post_adjust;
+	u32 clk_pre_adjust;
+	u32 clk_pre_delay_adjust;
+	u32 clk_t_hs_exit_adjust;
+	u32 clk_t_hs_trial_adjust;
+	u32 clk_t_hs_prepare_adjust;
+	int clk_t_lpx_adjust;
+	u32 clk_t_hs_zero_adjust;
+	u32 data_post_delay_adjust;
+	int data_t_lpx_adjust;
+	u32 data_t_hs_prepare_adjust;
+	u32 data_t_hs_zero_adjust;
+	u32 data_t_hs_trial_adjust;
+	u32 rg_vrefsel_vcm_adjust;
+
+	/*only for Chicago<3660> use*/
+	u32 rg_vrefsel_vcm_clk_adjust;
+	u32 rg_vrefsel_vcm_data_adjust;
+};
+
+struct mipi_phy_params {
+	u32 clk_t_lpx;
+	u32 clk_t_hs_prepare;
+	u32 clk_t_hs_zero;
+	u32 clk_t_hs_trial;
+	u32 clk_t_wakeup;
+	u32 data_t_lpx;
+	u32 data_t_hs_prepare;
+	u32 data_t_hs_zero;
+	u32 data_t_hs_trial;
+	u32 data_t_ta_go;
+	u32 data_t_ta_get;
+	u32 data_t_wakeup;
+	u32 hstx_ckg_sel;
+	u32 pll_fbd_div5f;
+	u32 pll_fbd_div1f;
+	u32 pll_fbd_2p;
+	u32 pll_enbwt;
+	u32 pll_fbd_p;
+	u32 pll_fbd_s;
+	u32 pll_pre_div1p;
+	u32 pll_pre_p;
+	u32 pll_vco_750M;
+	u32 pll_lpf_rs;
+	u32 pll_lpf_cs;
+	u32 clk_division;
+	/********for hikey620************/
+	u32 clklp2hs_time;
+	u32 clkhs2lp_time;
+	u32 lp2hs_time;
+	u32 hs2lp_time;
+	u32 clk_to_data_delay;
+	u32 data_to_clk_delay;
+	u32 lane_byte_clk_kHz;
+	/*****************/
+
+	/****for hikey960*****/
+	u64 lane_byte_clk;
+
+	u32 clk_lane_lp2hs_time;
+	u32 clk_lane_hs2lp_time;
+	u32 data_lane_lp2hs_time;
+	u32 data_lane_hs2lp_time;
+	u32 clk2data_delay;
+	u32 data2clk_delay;
+
+	u32 clk_pre_delay;
+	u32 clk_post_delay;
+	u32 data_pre_delay;
+	u32 data_post_delay;
+	u32 phy_stop_wait_time;
+	u32 rg_vrefsel_vcm;
+
+	u32 rg_pll_enswc;
+	u32 rg_pll_chp;
+
+	u32 pll_register_override;		/*0x1E[0]*/
+	u32 pll_power_down;			/*0x1E[1]*/
+	u32 rg_band_sel;				/*0x1E[2]*/
+	u32 rg_phase_gen_en;		/*0x1E[3]*/
+	u32 reload_sel;				/*0x1E[4]*/
+	u32 rg_pll_cp_p;				/*0x1E[7:5]*/
+	u32 rg_pll_refsel;				/*0x16[1:0]*/
+	u32 rg_pll_cp;				/*0x16[7:5]*/
+	u32 load_command;
+	/*********/
+};
+
+struct ldi_panel_info {
+	u32 h_back_porch;
+	u32 h_front_porch;
+	u32 h_pulse_width;
+
+	/*
+	** note: vbp > 8 if used overlay compose,
+	** also lcd vbp > 8 in lcd power on sequence
+	*/
+	u32 v_back_porch;
+	u32 v_front_porch;
+	u32 v_pulse_width;
+
+	u8 hsync_plr;
+	u8 vsync_plr;
+	u8 pixelclk_plr;
+	u8 data_en_plr;
+
+	/* for cabc */
+	u8 dpi0_overlap_size;
+	u8 dpi1_overlap_size;
+};
+
+struct dw_dsi_client {
+	u32 lanes;
+	u32 phy_clock; /* in kHz */
+	enum mipi_dsi_pixel_format format;
+	unsigned long mode_flags;
+};
+
+struct dw_dsi {
+	struct drm_encoder encoder;
+	struct drm_bridge *bridge;
+	struct drm_panel *panel;
+	struct mipi_dsi_host host;
+	struct drm_connector connector; /* connector for panel */
+	struct drm_display_mode cur_mode;
+	struct dsi_hw_ctx *ctx;
+	struct mipi_phy_params phy;
+	struct mipi_panel_info mipi;
+	struct ldi_panel_info ldi;
+	u32 lanes;
+	enum mipi_dsi_pixel_format format;
+	unsigned long mode_flags;
+	struct gpio_desc *gpio_mux;
+	struct dw_dsi_client client[OUT_MAX];
+	enum dsi_output_client cur_client;
+	bool enable;
+};
+
+struct dsi_data {
+	struct dw_dsi dsi;
+	struct dsi_hw_ctx ctx;
+};
+
+enum kirin_dsi_version {
+	KIRIN620_DSI = 0,
+	KIRIN960_DSI
+};
+
+/* display controller init/cleanup ops */
+struct kirin_dsi_ops {
+	enum kirin_dsi_version version;
+	int (*parse_dt)(struct platform_device *pdev, struct dw_dsi *dsi);
+	int (*host_init)(struct device *dev, struct dw_dsi *dsi);
+	void (*encoder_enable)(struct drm_encoder *encoder);
+	enum drm_mode_status(*encoder_valid)(struct drm_encoder *encoder,
+					const struct drm_display_mode *mode);
+};
+
+#ifdef CONFIG_DRM_HISI_KIRIN960
+extern const struct kirin_dsi_ops kirin_dsi_960;
+#endif
+#ifdef CONFIG_DRM_HISI_KIRIN620
+extern const struct kirin_dsi_ops kirin_dsi_620;
+#endif
+
+#endif /* __KIRIN_DRM_DSI_H__ */
diff --git a/drivers/gpu/drm/i915/Kconfig b/drivers/gpu/drm/i915/Kconfig
index 331779894..5fee7c8e6 100644
--- a/drivers/gpu/drm/i915/Kconfig
+++ b/drivers/gpu/drm/i915/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 config DRM_I915
-	tristate "Intel 8xx/9xx/G3x/G4x/HD Graphics"
+	bool "Intel 8xx/9xx/G3x/G4x/HD Graphics"
 	depends on DRM
 	depends on X86 && PCI
 	select INTEL_GTT
diff --git a/drivers/gpu/drm/i915/display/intel_connector.c b/drivers/gpu/drm/i915/display/intel_connector.c
index 308ec6320..ba2ef165a 100644
--- a/drivers/gpu/drm/i915/display/intel_connector.c
+++ b/drivers/gpu/drm/i915/display/intel_connector.c
@@ -277,7 +277,7 @@ intel_attach_aspect_ratio_property(struct drm_connector *connector)
 void
 intel_attach_colorspace_property(struct drm_connector *connector)
 {
-	if (!drm_mode_create_colorspace_property(connector))
+	if (!drm_mode_create_hdmi_colorspace_property(connector))
 		drm_object_attach_property(&connector->base,
 					   connector->colorspace_property, 0);
 }
diff --git a/drivers/gpu/drm/i915/display/intel_panel.c b/drivers/gpu/drm/i915/display/intel_panel.c
index bc14e9c02..ca373b824 100644
--- a/drivers/gpu/drm/i915/display/intel_panel.c
+++ b/drivers/gpu/drm/i915/display/intel_panel.c
@@ -1868,7 +1868,7 @@ static int pwm_setup_backlight(struct intel_connector *connector,
 
 	panel->backlight.min = 0; /* 0% */
 	panel->backlight.max = 100; /* 100% */
-	panel->backlight.level = DIV_ROUND_UP(
+	panel->backlight.level = DIV64_U64_ROUND_UP(
 				 pwm_get_duty_cycle(panel->backlight.pwm) * 100,
 				 CRC_PMIC_PWM_PERIOD_NS);
 	panel->backlight.enabled = panel->backlight.level != 0;
diff --git a/drivers/gpu/drm/msm/adreno/a6xx_gmu.c b/drivers/gpu/drm/msm/adreno/a6xx_gmu.c
index 9ea748667..7ec898148 100644
--- a/drivers/gpu/drm/msm/adreno/a6xx_gmu.c
+++ b/drivers/gpu/drm/msm/adreno/a6xx_gmu.c
@@ -2,6 +2,7 @@
 /* Copyright (c) 2017-2018 The Linux Foundation. All rights reserved. */
 
 #include <linux/clk.h>
+#include <linux/dma-mapping.h>
 #include <linux/interconnect.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_opp.h>
@@ -887,21 +888,10 @@ int a6xx_gmu_stop(struct a6xx_gpu *a6xx_gpu)
 
 static void a6xx_gmu_memory_free(struct a6xx_gmu *gmu, struct a6xx_gmu_bo *bo)
 {
-	int count, i;
-	u64 iova;
-
 	if (IS_ERR_OR_NULL(bo))
 		return;
 
-	count = bo->size >> PAGE_SHIFT;
-	iova = bo->iova;
-
-	for (i = 0; i < count; i++, iova += PAGE_SIZE) {
-		iommu_unmap(gmu->domain, iova, PAGE_SIZE);
-		__free_pages(bo->pages[i], 0);
-	}
-
-	kfree(bo->pages);
+	dma_free_attrs(gmu->dev, bo->size, bo->virt, bo->iova, bo->attrs);
 	kfree(bo);
 }
 
@@ -909,94 +899,23 @@ static struct a6xx_gmu_bo *a6xx_gmu_memory_alloc(struct a6xx_gmu *gmu,
 		size_t size)
 {
 	struct a6xx_gmu_bo *bo;
-	int ret, count, i;
 
 	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
 	if (!bo)
 		return ERR_PTR(-ENOMEM);
 
 	bo->size = PAGE_ALIGN(size);
+	bo->attrs = DMA_ATTR_WRITE_COMBINE;
 
-	count = bo->size >> PAGE_SHIFT;
+	bo->virt = dma_alloc_attrs(gmu->dev, bo->size, &bo->iova, GFP_KERNEL,
+		bo->attrs);
 
-	bo->pages = kcalloc(count, sizeof(struct page *), GFP_KERNEL);
-	if (!bo->pages) {
+	if (!bo->virt) {
 		kfree(bo);
 		return ERR_PTR(-ENOMEM);
 	}
 
-	for (i = 0; i < count; i++) {
-		bo->pages[i] = alloc_page(GFP_KERNEL);
-		if (!bo->pages[i])
-			goto err;
-	}
-
-	bo->iova = gmu->uncached_iova_base;
-
-	for (i = 0; i < count; i++) {
-		ret = iommu_map(gmu->domain,
-			bo->iova + (PAGE_SIZE * i),
-			page_to_phys(bo->pages[i]), PAGE_SIZE,
-			IOMMU_READ | IOMMU_WRITE);
-
-		if (ret) {
-			DRM_DEV_ERROR(gmu->dev, "Unable to map GMU buffer object\n");
-
-			for (i = i - 1 ; i >= 0; i--)
-				iommu_unmap(gmu->domain,
-					bo->iova + (PAGE_SIZE * i),
-					PAGE_SIZE);
-
-			goto err;
-		}
-	}
-
-	bo->virt = vmap(bo->pages, count, VM_IOREMAP,
-		pgprot_writecombine(PAGE_KERNEL));
-	if (!bo->virt)
-		goto err;
-
-	/* Align future IOVA addresses on 1MB boundaries */
-	gmu->uncached_iova_base += ALIGN(size, SZ_1M);
-
 	return bo;
-
-err:
-	for (i = 0; i < count; i++) {
-		if (bo->pages[i])
-			__free_pages(bo->pages[i], 0);
-	}
-
-	kfree(bo->pages);
-	kfree(bo);
-
-	return ERR_PTR(-ENOMEM);
-}
-
-static int a6xx_gmu_memory_probe(struct a6xx_gmu *gmu)
-{
-	int ret;
-
-	/*
-	 * The GMU address space is hardcoded to treat the range
-	 * 0x60000000 - 0x80000000 as un-cached memory. All buffers shared
-	 * between the GMU and the CPU will live in this space
-	 */
-	gmu->uncached_iova_base = 0x60000000;
-
-
-	gmu->domain = iommu_domain_alloc(&platform_bus_type);
-	if (!gmu->domain)
-		return -ENODEV;
-
-	ret = iommu_attach_device(gmu->domain, gmu->dev);
-
-	if (ret) {
-		iommu_domain_free(gmu->domain);
-		gmu->domain = NULL;
-	}
-
-	return ret;
 }
 
 /* Return the 'arc-level' for the given frequency */
@@ -1254,10 +1173,6 @@ void a6xx_gmu_remove(struct a6xx_gpu *a6xx_gpu)
 
 	a6xx_gmu_memory_free(gmu, gmu->hfi);
 
-	iommu_detach_device(gmu->domain, gmu->dev);
-
-	iommu_domain_free(gmu->domain);
-
 	free_irq(gmu->gmu_irq, gmu);
 	free_irq(gmu->hfi_irq, gmu);
 
@@ -1278,7 +1193,10 @@ int a6xx_gmu_init(struct a6xx_gpu *a6xx_gpu, struct device_node *node)
 
 	gmu->dev = &pdev->dev;
 
-	of_dma_configure(gmu->dev, node, true);
+	/* Pass force_dma false to require the DT to set the dma region */
+	ret = of_dma_configure(gmu->dev, node, false);
+	if (ret)
+		return ret;
 
 	/* Fow now, don't do anything fancy until we get our feet under us */
 	gmu->idle_level = GMU_IDLE_STATE_ACTIVE;
@@ -1290,11 +1208,6 @@ int a6xx_gmu_init(struct a6xx_gpu *a6xx_gpu, struct device_node *node)
 	if (ret)
 		goto err_put_device;
 
-	/* Set up the IOMMU context bank */
-	ret = a6xx_gmu_memory_probe(gmu);
-	if (ret)
-		goto err_put_device;
-
 	/* Allocate memory for for the HFI queues */
 	gmu->hfi = a6xx_gmu_memory_alloc(gmu, SZ_16K);
 	if (IS_ERR(gmu->hfi))
@@ -1340,11 +1253,6 @@ int a6xx_gmu_init(struct a6xx_gpu *a6xx_gpu, struct device_node *node)
 err_memory:
 	a6xx_gmu_memory_free(gmu, gmu->hfi);
 
-	if (gmu->domain) {
-		iommu_detach_device(gmu->domain, gmu->dev);
-
-		iommu_domain_free(gmu->domain);
-	}
 	ret = -ENODEV;
 
 err_put_device:
diff --git a/drivers/gpu/drm/msm/adreno/a6xx_gmu.h b/drivers/gpu/drm/msm/adreno/a6xx_gmu.h
index 39a26dd63..f5c733a8d 100644
--- a/drivers/gpu/drm/msm/adreno/a6xx_gmu.h
+++ b/drivers/gpu/drm/msm/adreno/a6xx_gmu.h
@@ -12,8 +12,8 @@
 struct a6xx_gmu_bo {
 	void *virt;
 	size_t size;
-	u64 iova;
-	struct page **pages;
+	dma_addr_t iova;
+	unsigned long attrs;
 };
 
 /*
@@ -49,9 +49,6 @@ struct a6xx_gmu {
 	int hfi_irq;
 	int gmu_irq;
 
-	struct iommu_domain *domain;
-	u64 uncached_iova_base;
-
 	struct device *gxpd;
 
 	int idle_level;
diff --git a/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c b/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c
index 58d5acbcf..d19ae0b51 100644
--- a/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c
+++ b/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c
@@ -858,7 +858,7 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 					  pdpu->pipe_sblk->maxupscale << 16,
 					  true, true);
 	if (ret) {
-		DPU_ERROR_PLANE(pdpu, "Check plane state failed (%d)\n", ret);
+		DPU_DEBUG_PLANE(pdpu, "Check plane state failed (%d)\n", ret);
 		return ret;
 	}
 	if (!state->visible)
@@ -884,13 +884,13 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 		(!(pdpu->features & DPU_SSPP_SCALER) ||
 		 !(pdpu->features & (BIT(DPU_SSPP_CSC)
 		 | BIT(DPU_SSPP_CSC_10BIT))))) {
-		DPU_ERROR_PLANE(pdpu,
+		DPU_DEBUG_PLANE(pdpu,
 				"plane doesn't have scaler/csc for yuv\n");
 		return -EINVAL;
 
 	/* check src bounds */
 	} else if (!dpu_plane_validate_src(&src, &fb_rect, min_src_size)) {
-		DPU_ERROR_PLANE(pdpu, "invalid source " DRM_RECT_FMT "\n",
+		DPU_DEBUG_PLANE(pdpu, "invalid source " DRM_RECT_FMT "\n",
 				DRM_RECT_ARG(&src));
 		return -E2BIG;
 
@@ -899,19 +899,19 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 		   (src.x1 & 0x1 || src.y1 & 0x1 ||
 		    drm_rect_width(&src) & 0x1 ||
 		    drm_rect_height(&src) & 0x1)) {
-		DPU_ERROR_PLANE(pdpu, "invalid yuv source " DRM_RECT_FMT "\n",
+		DPU_DEBUG_PLANE(pdpu, "invalid yuv source " DRM_RECT_FMT "\n",
 				DRM_RECT_ARG(&src));
 		return -EINVAL;
 
 	/* min dst support */
 	} else if (drm_rect_width(&dst) < 0x1 || drm_rect_height(&dst) < 0x1) {
-		DPU_ERROR_PLANE(pdpu, "invalid dest rect " DRM_RECT_FMT "\n",
+		DPU_DEBUG_PLANE(pdpu, "invalid dest rect " DRM_RECT_FMT "\n",
 				DRM_RECT_ARG(&dst));
 		return -EINVAL;
 
 	/* check decimated source width */
 	} else if (drm_rect_width(&src) > max_linewidth) {
-		DPU_ERROR_PLANE(pdpu, "invalid src " DRM_RECT_FMT " line:%u\n",
+		DPU_DEBUG_PLANE(pdpu, "invalid src " DRM_RECT_FMT " line:%u\n",
 				DRM_RECT_ARG(&src), max_linewidth);
 		return -E2BIG;
 	}
diff --git a/drivers/gpu/drm/virtio/virtgpu_display.c b/drivers/gpu/drm/virtio/virtgpu_display.c
index e622485ae..7f5694095 100644
--- a/drivers/gpu/drm/virtio/virtgpu_display.c
+++ b/drivers/gpu/drm/virtio/virtgpu_display.c
@@ -298,10 +298,6 @@ virtio_gpu_user_framebuffer_create(struct drm_device *dev,
 	struct virtio_gpu_framebuffer *virtio_gpu_fb;
 	int ret;
 
-	if (mode_cmd->pixel_format != DRM_FORMAT_HOST_XRGB8888 &&
-	    mode_cmd->pixel_format != DRM_FORMAT_HOST_ARGB8888)
-		return ERR_PTR(-ENOENT);
-
 	/* lookup object associated with res handle */
 	obj = drm_gem_object_lookup(file_priv, mode_cmd->handles[0]);
 	if (!obj)
@@ -350,7 +346,6 @@ void virtio_gpu_modeset_init(struct virtio_gpu_device *vgdev)
 	int i;
 
 	drm_mode_config_init(vgdev->ddev);
-	vgdev->ddev->mode_config.quirk_addfb_prefer_host_byte_order = true;
 	vgdev->ddev->mode_config.funcs = &virtio_gpu_mode_funcs;
 	vgdev->ddev->mode_config.helper_private = &virtio_mode_config_helpers;
 
diff --git a/drivers/gpu/drm/virtio/virtgpu_plane.c b/drivers/gpu/drm/virtio/virtgpu_plane.c
index a492ac3f4..56a27573c 100644
--- a/drivers/gpu/drm/virtio/virtgpu_plane.c
+++ b/drivers/gpu/drm/virtio/virtgpu_plane.c
@@ -30,7 +30,14 @@
 #include "virtgpu_drv.h"
 
 static const uint32_t virtio_gpu_formats[] = {
-	DRM_FORMAT_HOST_XRGB8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_BGRX8888,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_ABGR8888,
 };
 
 static const uint32_t virtio_gpu_cursor_formats[] = {
@@ -42,6 +49,32 @@ uint32_t virtio_gpu_translate_format(uint32_t drm_fourcc)
 	uint32_t format;
 
 	switch (drm_fourcc) {
+#ifdef __BIG_ENDIAN
+	case DRM_FORMAT_XRGB8888:
+		format = VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM;
+		break;
+	case DRM_FORMAT_ARGB8888:
+		format = VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM;
+		break;
+	case DRM_FORMAT_BGRX8888:
+		format = VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM;
+		break;
+	case DRM_FORMAT_BGRA8888:
+		format = VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM;
+		break;
+	case DRM_FORMAT_RGBX8888:
+		format = VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM;
+		break;
+	case DRM_FORMAT_RGBA8888:
+		format = VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM;
+		break;
+	case DRM_FORMAT_XBGR8888:
+		format = VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM;
+		break;
+	case DRM_FORMAT_ABGR8888:
+		format = VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM;
+		break;
+#else
 	case DRM_FORMAT_XRGB8888:
 		format = VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM;
 		break;
@@ -54,6 +87,19 @@ uint32_t virtio_gpu_translate_format(uint32_t drm_fourcc)
 	case DRM_FORMAT_BGRA8888:
 		format = VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM;
 		break;
+	case DRM_FORMAT_RGBX8888:
+		format = VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM;
+		break;
+	case DRM_FORMAT_RGBA8888:
+		format = VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM;
+		break;
+	case DRM_FORMAT_XBGR8888:
+		format = VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM;
+		break;
+	case DRM_FORMAT_ABGR8888:
+		format = VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM;
+		break;
+#endif
 	default:
 		/*
 		 * This should not happen, we handle everything listed
diff --git a/drivers/gpu/trace/Kconfig b/drivers/gpu/trace/Kconfig
new file mode 100644
index 000000000..c24e9edd0
--- /dev/null
+++ b/drivers/gpu/trace/Kconfig
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config TRACE_GPU_MEM
+	bool
diff --git a/drivers/gpu/trace/Makefile b/drivers/gpu/trace/Makefile
new file mode 100644
index 000000000..b70fbdc58
--- /dev/null
+++ b/drivers/gpu/trace/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_TRACE_GPU_MEM) += trace_gpu_mem.o
diff --git a/drivers/gpu/trace/trace_gpu_mem.c b/drivers/gpu/trace/trace_gpu_mem.c
new file mode 100644
index 000000000..01e855897
--- /dev/null
+++ b/drivers/gpu/trace/trace_gpu_mem.c
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * GPU memory trace points
+ *
+ * Copyright (C) 2020 Google, Inc.
+ */
+
+#include <linux/module.h>
+
+#define CREATE_TRACE_POINTS
+#include <trace/events/gpu_mem.h>
+
+EXPORT_TRACEPOINT_SYMBOL(gpu_mem_total);
-- 
2.17.1

