From cf7499f81a76f17acf0ce9406af62ce91262ebdc Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 16:56:20 +0800
Subject: [PATCH 35/93] add sunxi gpio driver

---
 drivers/gpio/Kconfig         |  13 +
 drivers/gpio/Makefile        |   2 +
 drivers/gpio/gpio-bs83b16c.c | 629 +++++++++++++++++++++++++++++
 drivers/gpio/gpio-bs83b16c.h |  55 +++
 drivers/gpio/gpio-eic-sprd.c |   9 +-
 drivers/gpio/gpio-pcf857x.c  |  66 +++
 drivers/gpio/gpio-sunxi.c    | 755 +++++++++++++++++++++++++++++++++++
 7 files changed, 1527 insertions(+), 2 deletions(-)
 create mode 100644 drivers/gpio/gpio-bs83b16c.c
 create mode 100644 drivers/gpio/gpio-bs83b16c.h
 create mode 100644 drivers/gpio/gpio-sunxi.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index f9263426a..9fad04da1 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -141,6 +141,11 @@ config GPIO_RASPBERRYPI_EXP
 	  Turn on GPIO support for the expander on Raspberry Pi 3 boards, using
 	  the firmware mailbox to communicate with VideoCore on BCM283x chips.
 
+config GPIO_SUNXI
+	tristate "SUNXI GPIO Support"
+	help
+	  Say yes if need SUNXI GPIO Support
+
 config GPIO_BCM_KONA
 	bool "Broadcom Kona GPIO"
 	depends on OF_GPIO && (ARCH_BCM_MOBILE || COMPILE_TEST)
@@ -843,6 +848,14 @@ config GPIO_ADNP
 	  enough to represent all pins, but the driver will assume a
 	  register layout for 64 pins (8 registers).
 
+config GPIO_BS83B16C
+	tristate "bs83b16c I2C GPIO expanders"
+	depends on OF_GPIO && PINCONF && PINCTRL_SUNXI
+	default n
+	help
+	 Say yes herer to enable the bs83b16c to be used as an interrupt
+	 controller.
+
 config GPIO_GW_PLD
 	tristate "Gateworks PLD GPIO Expander"
 	depends on OF_GPIO
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index d2fd19c15..f21505bf2 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -37,6 +37,7 @@ obj-$(CONFIG_GPIO_BCM_KONA)		+= gpio-bcm-kona.o
 obj-$(CONFIG_GPIO_BD70528)		+= gpio-bd70528.o
 obj-$(CONFIG_GPIO_BD9571MWV)		+= gpio-bd9571mwv.o
 obj-$(CONFIG_GPIO_BRCMSTB)		+= gpio-brcmstb.o
+obj-$(CONFIG_GPIO_BS83B16C)		+= gpio-bs83b16c.o
 obj-$(CONFIG_GPIO_BT8XX)		+= gpio-bt8xx.o
 obj-$(CONFIG_GPIO_CADENCE)		+= gpio-cadence.o
 obj-$(CONFIG_GPIO_CLPS711X)		+= gpio-clps711x.o
@@ -128,6 +129,7 @@ obj-$(CONFIG_GPIO_SPRD)			+= gpio-sprd.o
 obj-$(CONFIG_GPIO_STA2X11)		+= gpio-sta2x11.o
 obj-$(CONFIG_GPIO_STMPE)		+= gpio-stmpe.o
 obj-$(CONFIG_GPIO_STP_XWAY)		+= gpio-stp-xway.o
+obj-$(CONFIG_GPIO_SUNXI)		+= gpio-sunxi.o
 obj-$(CONFIG_GPIO_SYSCON)		+= gpio-syscon.o
 obj-$(CONFIG_GPIO_TB10X)		+= gpio-tb10x.o
 obj-$(CONFIG_GPIO_TC3589X)		+= gpio-tc3589x.o
diff --git a/drivers/gpio/gpio-bs83b16c.c b/drivers/gpio/gpio-bs83b16c.c
new file mode 100644
index 000000000..c9e062242
--- /dev/null
+++ b/drivers/gpio/gpio-bs83b16c.c
@@ -0,0 +1,629 @@
+/*
+ * drivers/gpio/gpio-bs83b16c.c - Allwinner bs83b16c expender IO driver
+ *
+ * Copyright (C) 2021 Allwinner Technology Limited. All rights reserved.
+ *       http://www.allwinnertech.com
+ * Author : OuJiayu <OuJiayu@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+
+#include <linux/sunxi-gpio.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl-sunxi.h>
+
+#include "gpio-bs83b16c.h"
+
+#define BS_DEBUG 1
+#define NOOP 1
+
+#define MAX_BANK  3
+#define BANK_SIZE 8
+
+/* Match device name */
+static const struct i2c_device_id bs83b16c_id[] = {
+	{ "bs83b16c", 8 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, bs83b16c_id);
+
+static const struct of_device_id bs83b16c_of_table[] = {
+	{ .compatible = "bs83b16c" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, bs83b16c_of_table);
+
+struct bs83b16c {
+	struct gpio_chip        chip;
+	struct i2c_client       *client;
+	struct mutex		lock;		/* protect 'out' */
+	struct mutex		en_lock;
+	struct mutex		dis_lock;
+	spinlock_t		slock;		/* protect irq demux */
+
+	struct work_struct	work;		/* irq demux work */
+	struct work_struct	en_work;
+	struct work_struct	dis_work;
+
+	unsigned                out;			/* software latch */
+	unsigned		status[MAX_BANK];       /* current status */
+	unsigned		int_status[MAX_BANK];	/* interrupt status */
+	unsigned int		state_reg[MAX_BANK];	/* gpio state*/
+	unsigned int		data_reg[MAX_BANK];	/* gpio data */
+	unsigned int		int_reg[MAX_BANK];	/* gpio int */
+	unsigned int		pull_reg[MAX_BANK];	/* gpio pull */
+
+	struct irq_domain       *irq_domain;		/* for irq demux  */
+	int                     irq;			/* int-gpio real irq number */
+	int			en_irq;			/* for pull up gpio */
+	int			dis_irq;		/* for pull down gpio */
+
+	int (*write)(struct i2c_client *client, unsigned int reg, unsigned int val);
+	int (*read)(struct i2c_client *client, unsigned int reg);
+};
+
+static int i2c_write(struct i2c_client *client, unsigned int reg,
+				unsigned int val)
+{
+	return i2c_smbus_write_byte_data(client, reg, val);
+}
+
+static int i2c_read(struct i2c_client *client, unsigned int reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+
+static int bs83b16c_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct bs83b16c *gpio = container_of(chip, struct bs83b16c, chip);
+	unsigned bit, gpio_out;
+	int status;
+	u8 bank;
+
+	bit = offset % BANK_SIZE; /* get gpio offset */
+	bank = offset / BANK_SIZE; /* get gpio bank */
+
+	mutex_lock(&gpio->lock);
+	/* set gpio input*/
+	gpio_out = gpio->read(gpio->client, gpio->state_reg[bank]);
+	gpio_out |= (1 << bit);
+
+	status = gpio->write(gpio->client, gpio->state_reg[bank], gpio_out);
+	mutex_unlock(&gpio->lock);
+
+	return status;
+}
+
+static int bs83b16c_output(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct bs83b16c *gpio = container_of(chip, struct bs83b16c, chip);
+	unsigned bit, data, gpio_out;
+	int status;
+	u8 bank;
+
+	bit = offset % BANK_SIZE; /* get gpio offset */
+	bank = offset / BANK_SIZE; /* get gpio bank */
+
+	mutex_lock(&gpio->lock);
+
+	/* set gpio output*/
+	gpio_out = gpio->read(gpio->client, gpio->state_reg[bank]);
+	gpio_out &= ~(1 << bit);
+	status = gpio->write(gpio->client, gpio->state_reg[bank], gpio_out);
+	if (status < 0) {
+		dev_err(&gpio->client->dev,
+				"set gpio %x output mode failed\n", offset);
+		return status;
+	}
+
+	/* set gpio data */
+	data = gpio->read(gpio->client, gpio->data_reg[bank]);
+	if (value) {
+		data |= (1 << bit);
+	} else {
+		data &= ~(1 << bit);
+	}
+	status = gpio->write(gpio->client, gpio->data_reg[bank], data);
+	if (status < 0) {
+		dev_err(&gpio->client->dev,
+				"set gpio %x output data failed\n", offset);
+		return status;
+	}
+
+	mutex_unlock(&gpio->lock);
+
+	return status;
+}
+
+static int bs83b16c_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct bs83b16c *gpio = container_of(chip, struct bs83b16c, chip);
+	unsigned bit;
+	int value;
+	u8 bank;
+
+	bit = offset % BANK_SIZE; /* get gpio offset */
+	bank = offset / BANK_SIZE; /* get gpio bank */
+
+	mutex_lock(&gpio->lock);
+	value = gpio->read(gpio->client, gpio->data_reg[bank]);
+	mutex_unlock(&gpio->lock);
+
+	return (value < 0) ? 0 : (value & (1 << bit));
+}
+
+static void bs83b16c_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	bs83b16c_output(chip, offset, value);
+}
+
+static int bs83b16c_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct bs83b16c *gpio = container_of(chip, struct bs83b16c, chip);
+
+	return irq_create_mapping(gpio->irq_domain, offset);
+}
+
+static void bs83b16c_irq_demux_work(struct work_struct *work)
+{
+	struct bs83b16c *gpio = container_of(work, struct bs83b16c, work);
+	unsigned long change, status, flags, enabled;
+	int i = 0;
+	unsigned int pin = 0;
+
+	for (i = 0; i < MAX_BANK; i++) {
+		status = gpio->read(gpio->client, gpio->data_reg[i]);
+
+		spin_lock_irqsave(&gpio->slock, flags);
+
+		enabled = gpio->int_status[i];
+		change = (gpio->status[i] ^ status) & enabled;
+
+		if (change == 0) {
+			spin_unlock_irqrestore(&gpio->slock, flags);
+			continue;
+		}
+		for_each_set_bit(pin, &change, gpio->chip.ngpio / MAX_BANK) {
+			generic_handle_irq(irq_find_mapping(gpio->irq_domain,
+					(i * BANK_SIZE + pin)));
+		}
+		gpio->status[i] = status;
+
+		spin_unlock_irqrestore(&gpio->slock, flags);
+	}
+}
+
+static irqreturn_t bs83b16c_irq_demux(int irq, void *data)
+{
+	struct bs83b16c *gpio = data;
+
+	/*
+	 * can't not read/write data here,
+	 * since i2c data access might go to sleep
+	 */
+	schedule_work(&gpio->work);
+
+	return IRQ_HANDLED;
+}
+
+static void bs83b16c_irq_enable_work(struct work_struct *work)
+{
+	struct bs83b16c *gpio = container_of(work, struct bs83b16c, en_work);
+	int bank, bit, ret, offset, i;
+	unsigned int pull;
+
+	mutex_lock(&gpio->en_lock);
+
+	offset = gpio->en_irq;
+	bank = offset / BANK_SIZE;
+	bit = offset % BANK_SIZE;
+
+	pull = gpio->read(gpio->client, gpio->pull_reg[bank]);
+	pull |= (1 << bit);
+
+	ret = gpio->write(gpio->client, gpio->pull_reg[bank], pull);
+	if (ret < 0)
+		dev_err(&gpio->client->dev,
+			"pull up gpio offset:%d failed\n", gpio->irq);
+
+
+	for (i = 0; i < MAX_BANK; i++) {
+		gpio->write(gpio->client, gpio->pull_reg[i],
+				gpio->int_status[i]);
+	}
+
+	mutex_unlock(&gpio->en_lock);
+}
+
+static void bs83b16c_irq_enable(struct irq_data *data)
+{
+	struct bs83b16c *gpio = data->domain->host_data;
+	int bank = data->hwirq / BANK_SIZE;
+	int bit = data->hwirq % BANK_SIZE;
+
+	gpio->int_status[bank] |= (1 << bit);
+	gpio->en_irq = data->hwirq;
+	schedule_work(&gpio->en_work);
+}
+
+static void bs83b16c_irq_disable_work(struct work_struct *work)
+{
+	struct bs83b16c *gpio = container_of(work, struct bs83b16c, dis_work);
+	int bank, bit, ret, offset;
+	unsigned int pull;
+
+	mutex_lock(&gpio->dis_lock);
+
+	offset = gpio->dis_irq;
+	bank = offset / BANK_SIZE;
+	bit = offset % BANK_SIZE;
+
+	pull = gpio->read(gpio->client, gpio->pull_reg[bank]);
+	pull &= ~(1 << bit);
+
+	ret = gpio->write(gpio->client, gpio->pull_reg[bank], pull);
+	if (ret < 0)
+		dev_err(&gpio->client->dev,
+			"pull down gpio offset:%d failed\n", gpio->irq);
+
+	mutex_unlock(&gpio->dis_lock);
+}
+
+static void bs83b16c_irq_disable(struct irq_data *data)
+{
+	struct bs83b16c *gpio = data->domain->host_data;
+	int bank = data->hwirq / BANK_SIZE;
+	int bit = data->hwirq % BANK_SIZE;
+
+	gpio->int_status[bank] &= ~(1 << bit);
+	gpio->dis_irq = data->hwirq;
+	schedule_work(&gpio->dis_work);
+}
+
+#ifdef NOOP
+static void noop(struct irq_data *data) { };
+#endif
+
+static struct irq_chip bs83b16c_irq_chip = {
+	.name = "bs83b16c",
+	.irq_enable = bs83b16c_irq_enable,
+	.irq_disable = bs83b16c_irq_disable,
+#ifdef NOOP
+	.irq_ack = noop,
+	.irq_mask = noop,
+	.irq_unmask = noop,
+#else
+	.irq_mask = bs83b16c_irq_mask,
+	.irq_unmask = bs83b16c_irq_unmask,
+	.irq_set_type = bs83b16c_irq_set_type,
+#endif
+};
+
+static int bs83b16c_irq_domain_map(struct irq_domain *domain, unsigned int virq,
+			irq_hw_number_t hw)
+{
+	irq_set_chip_and_handler(virq,
+				&bs83b16c_irq_chip,
+				handle_edge_irq);
+	return 0;
+}
+
+static struct irq_domain_ops bs83b16c_irq_domain_ops = {
+	.map = bs83b16c_irq_domain_map,
+};
+
+static void bs83b16c_irq_domain_cleanup(struct bs83b16c *gpio)
+{
+	if (gpio->irq_domain)
+		irq_domain_remove(gpio->irq_domain);
+
+	if (gpio->irq)
+		free_irq(gpio->irq, gpio);
+}
+
+static int bs83b16c_irq_domain_init(struct bs83b16c *gpio,
+				struct bs83b16c_platform_data *pdata,
+				struct i2c_client *client)
+{
+	int status;
+
+	gpio->irq_domain = irq_domain_add_linear(client->dev.of_node,
+					gpio->chip.ngpio,
+					&bs83b16c_irq_domain_ops,
+					gpio);
+	if (!gpio->irq_domain)
+		goto fail;
+
+	/* enable gpio to irq */
+	INIT_WORK(&gpio->work, bs83b16c_irq_demux_work);
+	INIT_WORK(&gpio->en_work, bs83b16c_irq_enable_work);
+	INIT_WORK(&gpio->dis_work, bs83b16c_irq_disable_work);
+
+	/* enable real irq */
+	status = request_irq(client->irq, bs83b16c_irq_demux,
+			IRQF_TRIGGER_FALLING | IRQF_SHARED,
+			dev_name(&client->dev), gpio);
+			//IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
+	if (status)
+		goto fail;
+
+	gpio->chip.to_irq = bs83b16c_to_irq;
+	gpio->irq = client->irq;
+
+	return 0;
+fail:
+	bs83b16c_irq_domain_cleanup(gpio);
+	return -EINVAL;
+}
+
+static void get_gpio_default_state(struct bs83b16c *gpio,
+			struct i2c_client *client)
+{
+	int i;
+
+	for (i = 0; i < MAX_BANK; i++) {
+		 gpio->status[i] = gpio->read(client, gpio->data_reg[i]);
+	}
+
+	/* set int reg for 0xFF */
+	for (i = 0; i < MAX_BANK; i++) {
+		gpio->write(client, gpio->int_reg[i], 0xFF);
+	}
+}
+
+static struct bs83b16c_platform_data *of_gpio_bs83b16c(struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	struct device *dev = &client->dev;
+	struct bs83b16c_platform_data *info;
+	int gpio = 0, ret = 0;
+
+	info = devm_kzalloc(&client->dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return NULL;
+	/* get expend io base */
+	if (of_property_read_u32(node, "gpio_base", &info->gpio_base)) {
+		dev_dbg(&client->dev, "can't not get gpio_base from dts\n");
+		info->gpio_base = 1500;
+	}
+
+	/* save irq to client */
+	gpio = of_get_named_gpio(node, "int-gpio", 0);
+	if (gpio < 0) {
+		dev_err(dev, "get int-gpio failed\n");
+		ret = gpio;
+		goto free_info;
+	}
+	client->irq = gpio_to_irq(gpio);
+
+	/* set int gpio function */
+	ret = pinctrl_pm_select_default_state(dev);
+	if (ret != 0) {
+		dev_err(dev, "set int gpio pin function failed\n");
+		goto free_info;
+	}
+	return info;
+
+free_info:
+	return ERR_PTR(ret);
+}
+
+#ifdef BS_DEBUG
+static irqreturn_t gpio_test_handler(int irq, void *data)
+{
+	printk("[%s] line=%d\n", __func__, __LINE__);
+	return IRQ_HANDLED;
+}
+
+static ssize_t gpio_test_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int gpio = 2030;
+	int ret, irq;
+	unsigned int flags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING;
+
+	ret = gpio_request(gpio, "gpio_test");
+	printk("gpio_request return %d\n", ret);
+
+	ret = gpio_direction_input(gpio);
+	printk("gpio_direction_input return %d\n", ret);
+
+	irq = gpio_to_irq(gpio);
+	printk("gpio to irq:%d\n", irq);
+
+	ret = request_irq(irq, gpio_test_handler, flags, dev_name(dev), dev);
+	printk("request irq return:%d\n", ret);
+
+	disable_irq(irq);
+	printk("disable irq\n");
+
+	enable_irq(irq);
+	printk("enable irq\n");
+
+	return 0;
+}
+
+static DEVICE_ATTR(bsgpio_test, 0444, gpio_test_show, NULL);
+#endif
+
+static int bs83b16c_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct bs83b16c_platform_data *pdata;
+	struct bs83b16c *gpio;
+	struct device *dev = &client->dev;
+	int ret, i;
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_dbg(&client->dev, "no platform data\n");
+		pdata = of_gpio_bs83b16c(client);
+		if (IS_ERR(pdata)) {
+			dev_err(dev, "get dts for bs83b16c platform data failed\n");
+		}
+	}
+
+	/* Allocate, initialize, and register this gpio_chip. */
+	gpio = devm_kzalloc(&client->dev, sizeof(*gpio), GFP_KERNEL);
+	if (!gpio) {
+		dev_err(&client->dev, "bs83b16c struct allocate failed\n");
+		return -ENOMEM;
+	}
+
+	/* check i2c dev */
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "SMBUS Byte Data not Supported\n");
+		ret = -EIO;
+		goto free_gpio;
+	}
+
+	mutex_init(&gpio->lock);
+	mutex_init(&gpio->en_lock);
+	spin_lock_init(&gpio->slock);
+
+	gpio->chip.base			= pdata ? pdata->gpio_base : -1;
+	gpio->chip.parent		= &client->dev;
+	gpio->chip.can_sleep            = 1;
+	gpio->chip.owner                = THIS_MODULE;
+	gpio->chip.get                  = bs83b16c_get;
+	gpio->chip.set                  = bs83b16c_set;
+	gpio->chip.direction_input      = bs83b16c_input;
+	gpio->chip.direction_output     = bs83b16c_output;
+	gpio->chip.ngpio                = (id->driver_data * MAX_BANK);
+
+	/* set reg for gpio bank */
+	for (i = 0; i < MAX_BANK; i++) {
+		gpio->state_reg[i] = (unsigned)(PA_STATE + i);
+		gpio->data_reg[i]  = (unsigned)(PA_DATA + i);
+		gpio->int_reg[i]   = (unsigned)(PA_INT + i);
+		gpio->pull_reg[i]  = (unsigned)(PA_PULL + i);
+	}
+
+	gpio->write			= i2c_write;
+	gpio->read			= i2c_read;
+
+	gpio->chip.label		= client->name;
+	gpio->client			= client;
+
+	i2c_set_clientdata(client, gpio);
+
+	gpio->out = pdata ? ~pdata->n_latch : ~0;
+	//gpio->status = gpio->out;
+
+	ret = gpiochip_add(&gpio->chip);
+	if (ret < 0) {
+		dev_err(&client->dev, "gpiochip_add failed\n");
+		goto free_gpio;
+	}
+
+	if (pdata && pdata->setup) {
+		ret = pdata->setup(client, gpio->chip.base,
+				gpio->chip.ngpio, pdata->context);
+		if (ret < 0) {
+			dev_warn(&client->dev, "setup --> %d\n", ret);
+		}
+	}
+
+	/* enable gpio_to_irq() if platform has settings */
+	if (pdata && client->irq) {
+		ret = bs83b16c_irq_domain_init(gpio, pdata, client);
+		if (ret < 0) {
+			dev_err(&client->dev, "irq domain init failed\n");
+			goto fail;
+		}
+	}
+
+	/* set gpio->status */
+	get_gpio_default_state(gpio, client);
+#if BS_DEBUG
+	device_create_file(dev, &dev_attr_bsgpio_test);
+#endif
+	dev_info(&client->dev, "probe success\n");
+
+	return 0;
+
+fail:
+	dev_dbg(&client->dev, "probe error %d for '%s'\n",
+			ret, client->name);
+
+	if (pdata && client->irq)
+		bs83b16c_irq_domain_cleanup(gpio);
+
+free_gpio:
+	kfree(gpio);
+	return ret;
+}
+
+static int bs83b16c_remove(struct i2c_client *client)
+{
+	struct bs83b16c *gpio = i2c_get_clientdata(client);
+	struct bs83b16c_platform_data *pdata = client->dev.platform_data;
+	int ret = 0;
+
+	if (pdata && pdata->teardown) {
+		ret = pdata->teardown(client, gpio->chip.base,
+				gpio->chip.ngpio, pdata->context);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s --> %d\n",
+					"teardown", ret);
+			return ret;
+		}
+	}
+
+	if (pdata && client->irq)
+		bs83b16c_irq_domain_cleanup(gpio);
+
+	gpiochip_remove(&gpio->chip);
+
+	return ret;
+}
+
+static struct i2c_driver bs83b16c_driver = {
+	.driver = {
+		.name = "bs83b16c",
+		.owner = THIS_MODULE,
+		.of_match_table =  of_match_ptr(bs83b16c_of_table),
+	},
+	.probe = bs83b16c_probe,
+	.remove = bs83b16c_remove,
+	.id_table = bs83b16c_id,
+};
+
+static int __init bs83b16c_init(void)
+{
+	return i2c_add_driver(&bs83b16c_driver);
+}
+
+/* register after i2c postcore initcall and before
+ * subsys initcalls that may rely on these GPIOs
+ */
+subsys_initcall_sync(bs83b16c_init);
+
+static void __exit bs83b16c_exit(void)
+{
+	i2c_del_driver(&bs83b16c_driver);
+}
+module_exit(bs83b16c_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
+MODULE_DESCRIPTION("GPIO expander driver for bs83b16c");
+MODULE_AUTHOR("OuJiayu@allwinnertech.com");
diff --git a/drivers/gpio/gpio-bs83b16c.h b/drivers/gpio/gpio-bs83b16c.h
new file mode 100644
index 000000000..b5209cf60
--- /dev/null
+++ b/drivers/gpio/gpio-bs83b16c.h
@@ -0,0 +1,55 @@
+#ifndef __LINUX_BS83B16C_H
+#define __LINUX_BS83B16C_H
+
+#define REG_INTEG	0X0d
+#define REG_INTC0	0x0e
+#define REG_INTC1	0x0f
+#define REG_MFI		0x12
+
+#define REG_PA		0x14
+#define REG_PAC		0x15
+#define REG_PAPU	0x16
+#define REG_PAWU	0x17
+#define REG_PXRM	0x18
+#define REG_PB		0x20
+#define REG_PBC		0x21
+#define REG_PBPU	0x22
+#define REG_PC		0x38
+#define REG_PCC		0x39
+#define REG_PCPU	0x3a
+
+/* read for data, write for output level */
+#define PA_DATA		0x00
+#define PB_DATA		0x01
+#define PC_DATA		0x02
+
+/* control input and output */
+#define PA_STATE	0x03
+#define PB_STATE	0x04
+#define PC_STATE	0x05
+
+/* control pull up */
+#define PA_PULL		0x06
+#define PB_PULL		0x07
+#define PC_PULL		0x08
+
+/* control irq enable */
+#define PA_INT		0x09
+#define PB_INT		0x0a
+#define PC_INT		0x0b
+
+#define BIT_EMI		BIT(0)
+
+struct bs83b16c_platform_data {
+	unsigned	gpio_base;
+	unsigned        n_latch;
+	int             (*setup)(struct i2c_client *client,
+					int gpio, unsigned ngpio,
+					void *context);
+	int             (*teardown)(struct i2c_client *client,
+					int gpio, unsigned ngpio,
+					void *context);
+	void            *context;
+};
+
+#endif /* __LINUX_BS83B16C_H */
diff --git a/drivers/gpio/gpio-eic-sprd.c b/drivers/gpio/gpio-eic-sprd.c
index bb287f35c..8c9757774 100644
--- a/drivers/gpio/gpio-eic-sprd.c
+++ b/drivers/gpio/gpio-eic-sprd.c
@@ -569,6 +569,7 @@ static int sprd_eic_probe(struct platform_device *pdev)
 	const struct sprd_eic_variant_data *pdata;
 	struct gpio_irq_chip *irq;
 	struct sprd_eic *sprd_eic;
+	struct resource *res;
 	int ret, i;
 
 	pdata = of_device_get_match_data(&pdev->dev);
@@ -595,9 +596,13 @@ static int sprd_eic_probe(struct platform_device *pdev)
 		 * have one bank EIC, thus base[1] and base[2] can be
 		 * optional.
 		 */
-		sprd_eic->base[i] = devm_platform_ioremap_resource(pdev, i);
-		if (IS_ERR(sprd_eic->base[i]))
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res)
 			continue;
+
+		sprd_eic->base[i] = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(sprd_eic->base[i]))
+			return PTR_ERR(sprd_eic->base[i]);
 	}
 
 	sprd_eic->chip.label = sprd_eic_label_name[sprd_eic->type];
diff --git a/drivers/gpio/gpio-pcf857x.c b/drivers/gpio/gpio-pcf857x.c
index 14fb8f6a1..46d41c967 100644
--- a/drivers/gpio/gpio-pcf857x.c
+++ b/drivers/gpio/gpio-pcf857x.c
@@ -17,6 +17,7 @@
 #include <linux/of_device.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#include <linux/of_gpio.h>
 
 
 static const struct i2c_device_id pcf857x_id[] = {
@@ -228,6 +229,63 @@ static void pcf857x_irq_bus_sync_unlock(struct irq_data *data)
 	mutex_unlock(&gpio->lock);
 }
 
+#ifdef IO_EXPAND_DEBUG
+static irqreturn_t gpio_test_handler(int irq, void *data)
+{
+	pr_info("[%s] line=%d\n", __func__, __LINE__);
+	return IRQ_HANDLED;
+}
+
+static ssize_t gpio_test_show(struct device  *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int gpio = 2021;
+	int gpio2 = 2023;
+	int ret, irq;
+	int flags = IRQF_TRIGGER_FALLING | IRQF_SHARED;
+
+	pr_info("------gpio:%d state test------\n", gpio);
+	ret = gpio_request(gpio, "gpio_test");
+	pr_info("gpio_request return %d\n", ret);
+
+	ret = gpio_direction_output(gpio, 0);
+	pr_info("gpio_direction_output return %d\n", ret);
+
+	ret = gpio_get_value_cansleep(gpio);
+	pr_info("gpio_get_value return %d\n", ret);
+
+	ret = gpio_direction_input(gpio);
+	pr_info("gpio_direction_input return %d\n", ret);
+
+
+	pr_info("------gpio:%d state test------\n", gpio2);
+	ret = gpio_request(gpio2, "gpio2_test");
+	pr_info("gpio2_request return %d\n", ret);
+
+	ret = gpio_direction_output(gpio2, 1);
+	pr_info("gpio2_direction_output return %d\n", ret);
+
+	ret = gpio_get_value_cansleep(gpio2);
+	pr_info("gpio2_get_value return %d\n", ret);
+
+	pr_info("------gpio:%d irq tese-------\n", gpio);
+	irq = gpio_to_irq(gpio);
+	pr_info("gpio to irq:%d\n", irq);
+
+	ret = request_irq(irq, gpio_test_handler, flags, dev_name(dev), dev);
+	pr_info("request irq return%d\n", ret);
+
+	disable_irq(irq);
+	pr_info("disable irq\n");
+	enable_irq(irq);
+	pr_info("enable irq\n");
+
+	return 0;
+}
+
+static DEVICE_ATTR(gpio_test, 0444, gpio_test_show, NULL);
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 static int pcf857x_probe(struct i2c_client *client,
@@ -263,6 +321,10 @@ static int pcf857x_probe(struct i2c_client *client,
 	gpio->chip.direction_output	= pcf857x_output;
 	gpio->chip.ngpio		= id->driver_data;
 
+	/* get the gpio_base from dts */
+	if (gpio->chip.base < 0)
+		of_property_read_u32(np, "gpio_base", &gpio->chip.base);
+
 	/* NOTE:  the OnSemi jlc1562b is also largely compatible with
 	 * these parts, notably for output.  It has a low-resolution
 	 * DAC instead of pin change IRQs; and its inputs can be the
@@ -380,6 +442,10 @@ static int pcf857x_probe(struct i2c_client *client,
 			dev_warn(&client->dev, "setup --> %d\n", status);
 	}
 
+#ifdef IO_EXPAND_DEBUG
+	device_create_file(&client->dev, &dev_attr_gpio_test);
+#endif
+
 	dev_info(&client->dev, "probed\n");
 
 	return 0;
diff --git a/drivers/gpio/gpio-sunxi.c b/drivers/gpio/gpio-sunxi.c
new file mode 100644
index 000000000..63ae40af8
--- /dev/null
+++ b/drivers/gpio/gpio-sunxi.c
@@ -0,0 +1,755 @@
+/* drivers/gpio/gpio-sunxi.c
+ *
+ *  Copyright (C) 2011 Reuuimlla Technology Co.Ltd
+ *  Charles <yanjianbo@allwinnertech.com>
+ *
+ *  www.reuuimllatech.com
+ *
+ *  User access to the gpios via sysfs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/rwsem.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/ctype.h>
+#include <linux/err.h>
+#include <linux/ctype.h>
+#include <linux/sysfs.h>
+#include <linux/device.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/pinctrl/pinctrl-sunxi.h>
+#include <linux/io.h>
+#include <linux/of_gpio.h>
+#include <linux/device.h>
+#include "../base/base.h"
+
+#define PINS_PER_BANK       32
+
+DECLARE_RWSEM(gpio_sw_list_lock);
+LIST_HEAD(gpio_sw_list);
+static struct class *gpio_sw_class;
+/* static int network_led_data_suspend; */
+
+struct sw_gpio_pd {
+	char name[16];
+	char link[16];
+	unsigned int light;
+};
+
+struct gpio_sw_classdev {
+	const char *name;
+	unsigned int pull, drv, cfg;
+	struct mutex class_mutex;
+	struct gpio_config *item;
+	int (*gpio_sw_cfg_set) (struct gpio_sw_classdev *gpio_sw_cdev,
+				int mul_cfg);
+	int (*gpio_sw_pull_set) (struct gpio_sw_classdev *gpio_sw_cdev,
+				 int mul_cfg);
+	int (*gpio_sw_data_set) (struct gpio_sw_classdev *gpio_sw_cdev,
+				 int mul_cfg);
+	int (*gpio_sw_drv_set) (struct gpio_sw_classdev *gpio_sw_cdev,
+				int mul_cfg);
+	int (*gpio_sw_cfg_get) (struct gpio_sw_classdev *gpio_sw_cdev);
+	int (*gpio_sw_pull_get) (struct gpio_sw_classdev *gpio_sw_cdev);
+	int (*gpio_sw_data_get) (struct gpio_sw_classdev *gpio_sw_cdev);
+	int (*gpio_sw_drv_get) (struct gpio_sw_classdev *gpio_sw_cdev);
+	struct device *dev;
+	struct list_head node;
+};
+
+struct sw_gpio {
+	struct sw_gpio_pd *pdata;
+	struct mutex lock;
+	struct gpio_sw_classdev class;
+};
+
+extern int pin_config_set(const char *dev_name, const char *name,
+		unsigned long config);
+static struct platform_device *gpio_sw_dev[256];
+static struct sw_gpio_pd *sw_pdata[256];
+struct device_node *node;
+static unsigned int easy_light_used;
+
+/*
+ * mul_cfg: 0 - inpit
+ *          1 - output
+*/
+static int gpio_sw_cfg_set(struct gpio_sw_classdev *gpio_sw_cdev, int mul_cfg)
+{
+	char pin_name[32];
+	unsigned long config;
+
+	if (mul_cfg == 0)
+		gpio_direction_input(gpio_sw_cdev->item->gpio);
+	else if (mul_cfg == 1)
+		gpio_direction_output(gpio_sw_cdev->item->gpio, 0);
+	else if (mul_cfg > 1 && mul_cfg <= 7) {
+		sunxi_gpio_to_name(gpio_sw_cdev->item->gpio, pin_name);
+		config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, mul_cfg);
+		if (gpio_sw_cdev->item->gpio < SUNXI_PL_BASE)
+			pin_config_set(SUNXI_PINCTRL, pin_name, config);
+		else
+			pin_config_set(SUNXI_R_PINCTRL, pin_name, config);
+	}
+	gpio_sw_cdev->cfg = mul_cfg;
+	return 0;
+}
+
+static int gpio_sw_cfg_get(struct gpio_sw_classdev *gpio_sw_cdev)
+{
+	return 0;
+}
+
+static int gpio_sw_pull_set(struct gpio_sw_classdev *gpio_sw_cdev, int pull)
+{
+	char pin_name[32];
+	unsigned long config;
+
+	if (pull >= 0 && pull <= 3) {
+		sunxi_gpio_to_name(gpio_sw_cdev->item->gpio, pin_name);
+		config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_PUD, pull);
+		if (gpio_sw_cdev->item->gpio < SUNXI_PL_BASE)
+			pin_config_set(SUNXI_PINCTRL, pin_name, config);
+		else
+			pin_config_set(SUNXI_R_PINCTRL, pin_name, config);
+	}
+
+	gpio_sw_cdev->pull = pull;
+	return 0;
+}
+
+static int gpio_sw_pull_get(struct gpio_sw_classdev *gpio_sw_cdev)
+{
+
+	return 0;
+}
+
+static int gpio_sw_drv_set(struct gpio_sw_classdev *gpio_sw_cdev, int drv)
+{
+	char pin_name[32];
+	unsigned long config;
+
+	if (drv >= 0 && drv <= 3) {
+		sunxi_gpio_to_name(gpio_sw_cdev->item->gpio, pin_name);
+		config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DRV, drv);
+		if (gpio_sw_cdev->item->gpio < SUNXI_PL_BASE)
+			pin_config_set(SUNXI_PINCTRL, pin_name, config);
+		else
+			pin_config_set(SUNXI_R_PINCTRL, pin_name, config);
+	}
+
+	gpio_sw_cdev->drv = drv;
+	return 0;
+}
+
+static int gpio_sw_drv_get(struct gpio_sw_classdev *gpio_sw_cdev)
+{
+
+	return 0;
+}
+
+static int gpio_sw_data_set(struct gpio_sw_classdev *gpio_sw_cdev, int data)
+{
+	__gpio_set_value(gpio_sw_cdev->item->gpio, data);
+	return 0;
+}
+
+static int gpio_sw_data_get(struct gpio_sw_classdev *gpio_sw_cdev)
+{
+	return __gpio_get_value(gpio_sw_cdev->item->gpio);
+}
+
+static ssize_t cfg_sel_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	int length;
+
+	mutex_lock(&gpio_sw_cdev->class_mutex);
+	gpio_sw_cdev->item->mul_sel =
+	    gpio_sw_cdev->gpio_sw_drv_get(gpio_sw_cdev);
+	length = sprintf(buf, "%u\n", gpio_sw_cdev->cfg);
+	mutex_unlock(&gpio_sw_cdev->class_mutex);
+
+	return length;
+}
+
+static ssize_t pull_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	int length;
+
+	mutex_lock(&gpio_sw_cdev->class_mutex);
+	gpio_sw_cdev->item->pull = gpio_sw_cdev->gpio_sw_drv_get(gpio_sw_cdev);
+	length = sprintf(buf, "%u\n", gpio_sw_cdev->pull);
+	mutex_unlock(&gpio_sw_cdev->class_mutex);
+
+	return length;
+}
+
+static ssize_t drv_level_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	int length;
+
+	mutex_lock(&gpio_sw_cdev->class_mutex);
+	gpio_sw_cdev->item->drv_level =
+	    gpio_sw_cdev->gpio_sw_drv_get(gpio_sw_cdev);
+	length = sprintf(buf, "%u\n", gpio_sw_cdev->drv);
+	mutex_unlock(&gpio_sw_cdev->class_mutex);
+
+	return length;
+}
+
+static ssize_t data_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	int length;
+
+	mutex_lock(&gpio_sw_cdev->class_mutex);
+	gpio_sw_cdev->item->data = gpio_sw_cdev->gpio_sw_data_get(gpio_sw_cdev);
+	length = sprintf(buf, "%u\n", gpio_sw_cdev->item->data);
+	mutex_unlock(&gpio_sw_cdev->class_mutex);
+
+	return length;
+}
+
+static ssize_t cfg_sel_store(struct device *dev,
+			     struct device_attribute *attr, const char *buf,
+			     size_t size)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	unsigned long cfg;
+
+	if (kstrtoul(buf, 10, &cfg))
+		return -EINVAL;
+	if (cfg > 7) {
+		return size;
+	}
+	gpio_sw_cdev->gpio_sw_cfg_set(gpio_sw_cdev, cfg);
+	return size;
+}
+
+static ssize_t pull_store(struct device *dev,
+			  struct device_attribute *attr, const char *buf,
+			  size_t size)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	unsigned long pull;
+
+	if (kstrtoul(buf, 10, &pull))
+		return -EINVAL;
+
+	if (pull > 3) {
+		return size;
+	}
+
+	gpio_sw_cdev->gpio_sw_pull_set(gpio_sw_cdev, pull);
+	return size;
+}
+
+static ssize_t drv_level_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t size)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+
+	unsigned long drv_level;
+	if (kstrtoul(buf, 10, &drv_level))
+		return -EINVAL;
+
+	if (drv_level > 3) {
+		return size;
+	}
+
+	gpio_sw_cdev->gpio_sw_drv_set(gpio_sw_cdev, drv_level);
+	return size;
+}
+
+static ssize_t data_store(struct device *dev,
+			  struct device_attribute *attr, const char *buf,
+			  size_t size)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	unsigned long data;
+
+	if (kstrtoul(buf, 10, &data))
+		return -EINVAL;
+
+	gpio_sw_cdev->gpio_sw_data_set(gpio_sw_cdev, data);
+	return size;
+}
+
+static ssize_t light_store(struct device *dev,
+			  struct device_attribute *attr, const char *buf,
+			  size_t size)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	struct sw_gpio_pd *pdata = dev->parent->platform_data;
+	unsigned long data;
+
+	if (kstrtoul(buf, 10, &data))
+		return -EINVAL;
+	if (data)
+		gpio_sw_cdev->gpio_sw_data_set(gpio_sw_cdev, pdata->light ? 1 : 0);
+	else
+		gpio_sw_cdev->gpio_sw_data_set(gpio_sw_cdev, pdata->light ? 0 : 1);
+
+	return size;
+}
+/*
+static int gpio_sw_suspend(struct device *dev, pm_message_t state)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	struct sw_gpio_pd *pdata = dev->parent->platform_data;
+
+	if (strcmp(pdata->link, "network_led") == 0) {
+		network_led_data_suspend = gpio_sw_cdev->gpio_sw_data_get(\
+								gpio_sw_cdev);
+		gpio_sw_cdev->gpio_sw_data_set(gpio_sw_cdev, \
+						pdata->light ? 0 : 1);
+	}
+	return 0;
+}
+
+static int gpio_sw_resume(struct device *dev)
+{
+	struct gpio_sw_classdev *gpio_sw_cdev = dev_get_drvdata(dev);
+	struct sw_gpio_pd *pdata = dev->parent->platform_data;
+
+	if (strcmp(pdata->link, "network_led") == 0) {
+		gpio_sw_cdev->gpio_sw_data_set(gpio_sw_cdev, network_led_data_suspend);
+	}
+	return 0;
+}
+*/
+static struct device_attribute gpio_sw_class_attrs[] = {
+	__ATTR(cfg, 0664, cfg_sel_show, cfg_sel_store),
+	__ATTR(pull, 0664, pull_show, pull_store),
+	__ATTR(drv, 0664, drv_level_show, drv_level_store),
+	__ATTR(data, 0664, data_show, data_store),
+};
+
+static struct device_attribute easy_light_attr =
+	__ATTR(light, 0664, data_show, light_store);
+
+void gpio_sw_classdev_unregister(struct gpio_sw_classdev *gpio_sw_cdev)
+{
+	mutex_destroy(&gpio_sw_cdev->class_mutex);
+	device_unregister(gpio_sw_cdev->dev);
+	down_write(&gpio_sw_list_lock);
+	list_del(&gpio_sw_cdev->node);
+	up_write(&gpio_sw_list_lock);
+}
+
+static int gpio_sw_remove(struct platform_device *dev)
+{
+	struct sw_gpio *sw_gpio_entry = platform_get_drvdata(dev);
+	struct sw_gpio_pd *pdata = dev->dev.platform_data;
+
+	if (strlen(pdata->link) != 0)
+		sysfs_remove_link(&gpio_sw_class->p->subsys.kobj, pdata->link);
+
+	gpio_sw_classdev_unregister(&sw_gpio_entry->class);
+	kfree(sw_gpio_entry->class.item);
+	kfree(sw_gpio_entry);
+	return 0;
+}
+
+int
+gpio_sw_classdev_register(struct device *parent,
+			  struct gpio_sw_classdev *gpio_sw_cdev)
+{
+	struct sw_gpio_pd *pdata = parent->platform_data;
+	int i, ret;
+
+	gpio_sw_cdev->dev = device_create(gpio_sw_class, parent, 0,
+					  gpio_sw_cdev, "%s",
+					  gpio_sw_cdev->name);
+
+	for (i = 0; i < ARRAY_SIZE(gpio_sw_class_attrs); i++) {
+		ret = device_create_file(gpio_sw_cdev->dev, &gpio_sw_class_attrs[i]);
+		if (ret) {
+			pr_err("%s:%u class_create_file() failed. err=%d\n", __func__, __LINE__, ret);
+			while (i--) {
+				device_remove_file(gpio_sw_cdev->dev, &gpio_sw_class_attrs[i]);
+			}
+			class_destroy(gpio_sw_class);
+			gpio_sw_class = NULL;
+			return ret;
+		}
+	}
+
+	if (IS_ERR(gpio_sw_cdev->dev))
+		return PTR_ERR(gpio_sw_cdev->dev);
+	if (easy_light_used && strlen(pdata->link)) {
+		if (sysfs_create_file(&gpio_sw_cdev->dev->kobj, &easy_light_attr.attr))
+			pr_err("gpio_sw: sysfs_create_file fail\n");
+	}
+	down_write(&gpio_sw_list_lock);
+	list_add_tail(&gpio_sw_cdev->node, &gpio_sw_list);
+	up_write(&gpio_sw_list_lock);
+	mutex_init(&gpio_sw_cdev->class_mutex);
+
+	return 0;
+}
+
+static int map_gpio_to_name(char *name, u32 gpio)
+{
+	char base;
+	int num;
+	num = gpio - SUNXI_PA_BASE;
+	if (num < 0)
+		goto map_fail;
+
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'A';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PB_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'B';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PC_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'C';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PD_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'D';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PE_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'E';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PF_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'F';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PG_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'G';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PH_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'H';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PJ_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'J';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PL_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'L';
+		goto map_done;
+	}
+	num = gpio - SUNXI_PM_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'M';
+		goto map_done;
+	}
+	num = gpio - AXP_PIN_BASE;
+	if ((num >= 0) && (num < PINS_PER_BANK)) {
+		base = 'X';
+		goto map_done;
+	}
+	goto map_fail;
+map_done:
+	sprintf(name, "P%c%d", base, num);
+	return 0;
+map_fail:
+	return -1;
+}
+
+static void gpio_sw_release(struct device *dev)
+{
+	pr_info("gpio_sw_release good !\n");
+}
+
+static int gpio_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int gpio_resume(struct platform_device *dev)
+{
+	return 0;
+}
+
+static int gpio_sw_probe(struct platform_device *dev)
+{
+	struct sw_gpio *sw_gpio_entry;
+	struct sw_gpio_pd *pdata = dev->dev.platform_data;
+	enum of_gpio_flags config;
+	int ret;
+	char io_area[16];
+	int gpio;
+
+	sw_gpio_entry = kzalloc(sizeof(struct sw_gpio), GFP_KERNEL);
+	if (!sw_gpio_entry)
+		return -ENOMEM;
+
+	sw_gpio_entry->class.item =
+	    kzalloc(sizeof(struct gpio_config), GFP_KERNEL);
+	if (!sw_gpio_entry->class.item) {
+		kfree(sw_gpio_entry);
+		return -ENOMEM;
+	}
+	gpio = of_get_named_gpio_flags(node, pdata->name, 0, &config);
+	if (!gpio_is_valid(gpio)) {
+		pr_err("get config err!\n");
+		kfree(sw_gpio_entry->class.item);
+		kfree(sw_gpio_entry);
+		return -ENOMEM;
+	}
+
+	(sw_gpio_entry->class.item)->gpio = gpio;
+	platform_set_drvdata(dev, sw_gpio_entry);
+	mutex_init(&sw_gpio_entry->lock);
+	mutex_lock(&sw_gpio_entry->lock);
+	sw_gpio_entry->pdata = pdata;
+
+	ret = map_gpio_to_name(io_area, gpio);
+	pr_info("gpio: %d, name: %s, ret = %d\n", gpio, io_area, ret);
+	if (ret == 0)
+		sw_gpio_entry->class.name = io_area;
+	else
+		sw_gpio_entry->class.name = pdata->name;
+
+	sw_gpio_entry->class.gpio_sw_cfg_set = gpio_sw_cfg_set;
+	sw_gpio_entry->class.gpio_sw_cfg_get = gpio_sw_cfg_get;
+	sw_gpio_entry->class.gpio_sw_pull_set = gpio_sw_pull_set;
+	sw_gpio_entry->class.gpio_sw_pull_get = gpio_sw_pull_get;
+	sw_gpio_entry->class.gpio_sw_drv_set = gpio_sw_drv_set;
+	sw_gpio_entry->class.gpio_sw_drv_get = gpio_sw_drv_get;
+	sw_gpio_entry->class.gpio_sw_data_set = gpio_sw_data_set;
+	sw_gpio_entry->class.gpio_sw_data_get = gpio_sw_data_get;
+
+
+	/* init the gpio */
+	gpio_direction_output(gpio, (config == OF_GPIO_ACTIVE_LOW) ? 0 : 1);
+
+	mutex_unlock(&sw_gpio_entry->lock);
+
+	ret = gpio_sw_classdev_register(&dev->dev, &sw_gpio_entry->class);
+	if (ret < 0) {
+		dev_err(&dev->dev, "gpio_sw_classdev_register failed\n");
+		kfree(sw_gpio_entry->class.item);
+		kfree(sw_gpio_entry);
+		return -1;
+	}
+
+	/* create symbol link */
+	if (strlen(pdata->link) != 0) {
+		ret = sysfs_create_link(&gpio_sw_class->p->subsys.kobj,
+					&sw_gpio_entry->class.dev->kobj,
+					pdata->link);
+	}
+	return 0;
+}
+
+static struct platform_driver gpio_sw_driver = {
+	.probe = gpio_sw_probe,
+	.remove = gpio_sw_remove,
+	.suspend = gpio_suspend,
+	.resume = gpio_resume,
+	.driver = {
+		   .name = "gpio_sw",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static void __exit gpio_sw_exit(void)
+{
+	int i, cnt;
+	enum of_gpio_flags config;
+	int gpio;
+	char gpio_name[32];
+	int ret;
+
+	platform_driver_unregister(&gpio_sw_driver);
+
+	ret = of_property_read_u32(node, "gpio_num", &cnt);
+	if (ret || !cnt) {
+		pr_info("these is zero number for gpio\n");
+		goto EXIT_END;
+	}
+	for (i = 0; i < cnt; i++) {
+		sprintf(gpio_name, "gpio_pin_%d", i + 1);
+		gpio =
+		    of_get_named_gpio_flags(node, gpio_name, 0, &config);
+		if (!gpio_is_valid(gpio)) {
+			pr_err("this gpio is invalid: %d\n", gpio);
+			continue;
+		}
+
+		platform_device_unregister(gpio_sw_dev[i]);
+		kfree(gpio_sw_dev[i]);
+		kfree(sw_pdata[i]);
+		gpio_free(gpio);
+	}
+
+	class_destroy(gpio_sw_class);
+EXIT_END:
+	pr_info("gpio_exit finish !\n");
+}
+
+static int sunxi_init_gpio_probe(struct platform_device *pdev)
+{
+	int i, cnt;
+	enum of_gpio_flags config;
+	int gpio;
+	char gpio_name[32];
+	int ret;
+	const char *normal_led_pin_str = NULL;
+	const char *standby_led_pin_str = NULL;
+	const char *network_led_pin_str = NULL;
+
+	node = pdev->dev.of_node;
+	if (!node)
+		goto INIT_END;
+
+	/* create debug dir: /sys/class/gpio_sw */
+	gpio_sw_class = class_create(THIS_MODULE, "gpio_sw");
+	if (IS_ERR(gpio_sw_class))
+		return PTR_ERR(gpio_sw_class);
+
+	if (of_property_read_u32(node, "easy_light_used", &easy_light_used)) {
+		easy_light_used = 0;
+		pr_err("failed to get easy_light_used assign\n");
+	}
+	if (of_property_read_string(node, "normal_led", &normal_led_pin_str))
+		pr_err("failed to get normal led pin assign\n");
+
+	if (of_property_read_string(node, "standby_led", &standby_led_pin_str))
+		pr_err("failed to get standby led pin assign\n");
+
+	if (of_property_read_string(node, "network_led", &network_led_pin_str))
+		pr_err("failed to get standby led pin assign\n");
+
+	ret = of_property_read_u32(node, "gpio_num", &cnt);
+	if (ret || !cnt) {
+		pr_err("there is zero number for gpio\n");
+		goto INIT_END;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		sprintf(gpio_name, "gpio_pin_%d", i + 1);
+		gpio = of_get_named_gpio_flags(node, gpio_name, 0, &config);
+		if (gpio_request(gpio, NULL)) {
+			pr_err("gpio_pin_%d(%d) gpio_request fail\n", i + 1,
+			       gpio);
+			continue;
+		}
+		pr_info("gpio_pin_%d(%d) gpio_is_valid\n", i + 1, gpio);
+
+		sw_pdata[i] = kzalloc(sizeof(struct sw_gpio_pd), GFP_KERNEL);
+		if (!sw_pdata[i]) {
+			pr_err("kzalloc fail for sw_pdata[%d]\n", i);
+			return -1;
+		}
+
+		gpio_sw_dev[i] =
+		    kzalloc(sizeof(struct platform_device), GFP_KERNEL);
+		if (!gpio_sw_dev[i]) {
+			pr_err("kzalloc fail for gpio_sw_dev[%d]\n", i);
+			return -1;
+		}
+
+		sprintf(sw_pdata[i]->name, "gpio_pin_%d", i + 1);
+		if (normal_led_pin_str
+		       && !strcmp(sw_pdata[i]->name, normal_led_pin_str)) {
+			sprintf(sw_pdata[i]->link, "%s", "normal_led");
+			if (easy_light_used)
+				of_property_read_u32(node, "normal_led_light",  &sw_pdata[i]->light);
+		} else if (standby_led_pin_str
+			   && !strcmp(sw_pdata[i]->name, standby_led_pin_str)) {
+			sprintf(sw_pdata[i]->link, "%s", "standby_led");
+			if (easy_light_used)
+				of_property_read_u32(node, "standby_led_light",  &sw_pdata[i]->light);
+		} else if (network_led_pin_str
+			   && !strcmp(sw_pdata[i]->name, network_led_pin_str)) {
+			sprintf(sw_pdata[i]->link, "%s", "network_led");
+			if (easy_light_used)
+				of_property_read_u32(node, "network_led_light",  &sw_pdata[i]->light);
+		}
+
+		gpio_sw_dev[i]->name = "gpio_sw";
+		gpio_sw_dev[i]->id = i;
+		gpio_sw_dev[i]->dev.platform_data = sw_pdata[i];
+		gpio_sw_dev[i]->dev.release = gpio_sw_release;
+
+		if (platform_device_register(gpio_sw_dev[i])) {
+			pr_err("%s platform_device_register fail\n",
+			       sw_pdata[i]->name);
+			goto INIT_ERR_FREE;
+		}
+	}
+	if (platform_driver_register(&gpio_sw_driver)) {
+		pr_err("gpio user platform_driver_register  fail\n");
+		for (i = 0; i < cnt; i++)
+			platform_device_unregister(gpio_sw_dev[i]);
+		goto INIT_ERR_FREE;
+	}
+
+INIT_END:
+	pr_info("gpio_init finished\n");
+	return 0;
+INIT_ERR_FREE:
+	pr_err("gpio_init err\n");
+	kfree(sw_pdata[i]);
+	kfree(gpio_sw_dev[i]);
+	return -1;
+}
+
+static const struct of_device_id sunxi_gpio_of_match[] = {
+	{.compatible = "allwinner,sunxi-init-gpio", .data = NULL},
+	{ /* sentinel */ }
+};
+
+static struct platform_driver sunxi_gpio_driver = {
+	.driver = {
+		   .name = "sunxi-init-gpio",
+		   .of_match_table = of_match_ptr(sunxi_gpio_of_match),
+		   },
+	.probe = sunxi_init_gpio_probe,
+};
+
+static int __init sunxi_gpio_init(void)
+{
+	if (platform_driver_register(&sunxi_gpio_driver)) {
+		pr_err("gpio user platform_driver_register  fail\n");
+		return -1;
+	}
+	return 0;
+}
+
+module_init(sunxi_gpio_init);
+module_exit(gpio_sw_exit);
+
+MODULE_AUTHOR("yanjianbo");
+MODULE_DESCRIPTION("SW GPIO USER driver");
+MODULE_LICENSE("GPL");
-- 
2.17.1

