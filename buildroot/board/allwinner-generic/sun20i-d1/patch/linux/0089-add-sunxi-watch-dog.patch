From 8f2ef2085f83eb0cd2cc741d2de7afe4587dedb6 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 17:25:52 +0800
Subject: [PATCH 89/93] add sunxi watch dog

---
 drivers/watchdog/Kconfig     |  2 +-
 drivers/watchdog/sunxi_wdt.c | 69 +++++++++++++++++++++++++++---------
 2 files changed, 53 insertions(+), 18 deletions(-)

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index e2745f686..6e26f9db6 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -607,7 +607,7 @@ config RN5T618_WATCHDOG
 
 config SUNXI_WATCHDOG
 	tristate "Allwinner SoCs watchdog support"
-	depends on ARCH_SUNXI || COMPILE_TEST
+	depends on ARCH_SUNXI
 	select WATCHDOG_CORE
 	help
 	  Say Y here to include support for the watchdog timer
diff --git a/drivers/watchdog/sunxi_wdt.c b/drivers/watchdog/sunxi_wdt.c
index 5f05a45ac..7fa2c8570 100644
--- a/drivers/watchdog/sunxi_wdt.c
+++ b/drivers/watchdog/sunxi_wdt.c
@@ -30,9 +30,11 @@
 #define WDT_CTRL_RELOAD         ((1 << 0) | (0x0a57 << 1))
 
 #define WDT_MODE_EN             (1 << 0)
+#define KEY_FIELD_MAGIC		(0x16AA0000)
+
 
 #define DRV_NAME		"sunxi-wdt"
-#define DRV_VERSION		"1.0"
+#define DRV_VERSION		"1.0.1"
 
 static bool nowayout = WATCHDOG_NOWAYOUT;
 static unsigned int timeout;
@@ -42,12 +44,12 @@ static unsigned int timeout;
  * of Allwinner's watchdog hardware.
  */
 struct sunxi_wdt_reg {
-	u8 wdt_ctrl;
-	u8 wdt_cfg;
-	u8 wdt_mode;
-	u8 wdt_timeout_shift;
-	u8 wdt_reset_mask;
-	u8 wdt_reset_val;
+	u8 wdt_ctrl;  /* Offset to WDOG_CTRL_REG */
+	u8 wdt_cfg;   /* Offset to WDOG_CFG_REG */
+	u8 wdt_mode;  /* Offset to WDOG_MODE_REG */
+	u8 wdt_timeout_shift;  /* Bit offset of WDOG_INTV_VALUE in WDOG_MODE_REG */
+	u8 wdt_reset_mask;  /* Bit mask of WDOG_CONFIG in WDOG_CFG_REG */
+	u8 wdt_reset_val;   /* Value to reset whole system of WDOG_CONFIG in WDOG_CFG_REG */
 };
 
 struct sunxi_wdt_dev {
@@ -90,13 +92,13 @@ static int sunxi_wdt_restart(struct watchdog_device *wdt_dev,
 	/* Set system reset function */
 	val = readl(wdt_base + regs->wdt_cfg);
 	val &= ~(regs->wdt_reset_mask);
-	val |= regs->wdt_reset_val;
+	val |= regs->wdt_reset_val | KEY_FIELD_MAGIC;
 	writel(val, wdt_base + regs->wdt_cfg);
 
 	/* Set lowest timeout and enable watchdog */
 	val = readl(wdt_base + regs->wdt_mode);
 	val &= ~(WDT_TIMEOUT_MASK << regs->wdt_timeout_shift);
-	val |= WDT_MODE_EN;
+	val |= WDT_MODE_EN | KEY_FIELD_MAGIC;
 	writel(val, wdt_base + regs->wdt_mode);
 
 	/*
@@ -107,9 +109,6 @@ static int sunxi_wdt_restart(struct watchdog_device *wdt_dev,
 
 	while (1) {
 		mdelay(5);
-		val = readl(wdt_base + regs->wdt_mode);
-		val |= WDT_MODE_EN;
-		writel(val, wdt_base + regs->wdt_mode);
 	}
 	return 0;
 }
@@ -140,7 +139,8 @@ static int sunxi_wdt_set_timeout(struct watchdog_device *wdt_dev,
 
 	reg = readl(wdt_base + regs->wdt_mode);
 	reg &= ~(WDT_TIMEOUT_MASK << regs->wdt_timeout_shift);
-	reg |= wdt_timeout_map[timeout] << regs->wdt_timeout_shift;
+	reg |= (wdt_timeout_map[timeout] << regs->wdt_timeout_shift) |
+		KEY_FIELD_MAGIC;
 	writel(reg, wdt_base + regs->wdt_mode);
 
 	sunxi_wdt_ping(wdt_dev);
@@ -154,7 +154,7 @@ static int sunxi_wdt_stop(struct watchdog_device *wdt_dev)
 	void __iomem *wdt_base = sunxi_wdt->wdt_base;
 	const struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;
 
-	writel(0, wdt_base + regs->wdt_mode);
+	writel((0 | KEY_FIELD_MAGIC), wdt_base + regs->wdt_mode);
 
 	return 0;
 }
@@ -175,17 +175,38 @@ static int sunxi_wdt_start(struct watchdog_device *wdt_dev)
 	/* Set system reset function */
 	reg = readl(wdt_base + regs->wdt_cfg);
 	reg &= ~(regs->wdt_reset_mask);
-	reg |= regs->wdt_reset_val;
+	reg |= regs->wdt_reset_val | KEY_FIELD_MAGIC;
 	writel(reg, wdt_base + regs->wdt_cfg);
 
 	/* Enable watchdog */
 	reg = readl(wdt_base + regs->wdt_mode);
-	reg |= WDT_MODE_EN;
+	reg |= WDT_MODE_EN | KEY_FIELD_MAGIC;
 	writel(reg, wdt_base + regs->wdt_mode);
 
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int sunxi_wdt_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct sunxi_wdt_dev *sunxi_wdt = platform_get_drvdata(pdev);
+	if (watchdog_active(&sunxi_wdt->wdt_dev))
+		sunxi_wdt_stop(&sunxi_wdt->wdt_dev);
+
+	return 0;
+}
+
+static int sunxi_wdt_resume(struct platform_device *pdev)
+{
+	struct sunxi_wdt_dev *sunxi_wdt = platform_get_drvdata(pdev);
+	if (watchdog_active(&sunxi_wdt->wdt_dev)) {
+		sunxi_wdt_start(&sunxi_wdt->wdt_dev);
+	}
+
+	return 0;
+}
+#endif
+
 static const struct watchdog_info sunxi_wdt_info = {
 	.identity	= DRV_NAME,
 	.options	= WDIOF_SETTIMEOUT |
@@ -223,6 +244,7 @@ static const struct sunxi_wdt_reg sun6i_wdt_reg = {
 static const struct of_device_id sunxi_wdt_dt_ids[] = {
 	{ .compatible = "allwinner,sun4i-a10-wdt", .data = &sun4i_wdt_reg },
 	{ .compatible = "allwinner,sun6i-a31-wdt", .data = &sun6i_wdt_reg },
+	{ .compatible = "allwinner,sun20i-wdt", .data = &sun6i_wdt_reg },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, sunxi_wdt_dt_ids);
@@ -235,8 +257,9 @@ static int sunxi_wdt_probe(struct platform_device *pdev)
 
 	sunxi_wdt = devm_kzalloc(dev, sizeof(*sunxi_wdt), GFP_KERNEL);
 	if (!sunxi_wdt)
-		return -EINVAL;
+		return -ENOMEM;
 
+	platform_set_drvdata(pdev, sunxi_wdt);
 	sunxi_wdt->wdt_regs = of_device_get_match_data(dev);
 	if (!sunxi_wdt->wdt_regs)
 		return -ENODEV;
@@ -271,12 +294,24 @@ static int sunxi_wdt_probe(struct platform_device *pdev)
 	return 0;
 }
 
+static void sunxi_wdt_shutdown(struct platform_device *pdev)
+{
+	struct sunxi_wdt_dev *sunxi_wdt = platform_get_drvdata(pdev);
+
+	sunxi_wdt_stop(&sunxi_wdt->wdt_dev);
+}
+
 static struct platform_driver sunxi_wdt_driver = {
 	.probe		= sunxi_wdt_probe,
+	.shutdown       = sunxi_wdt_shutdown,
 	.driver		= {
 		.name		= DRV_NAME,
 		.of_match_table	= sunxi_wdt_dt_ids,
 	},
+#ifdef CONFIG_PM
+	.suspend        = sunxi_wdt_suspend,
+	.resume         = sunxi_wdt_resume,
+#endif
 };
 
 module_platform_driver(sunxi_wdt_driver);
-- 
2.17.1

