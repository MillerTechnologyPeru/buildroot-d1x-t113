From 53fc202bcca2264efa34a734fa5b39aba036d053 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 17:26:45 +0800
Subject: [PATCH 91/93] add sunxi linux headers

---
 include/linux/android_kabi.h             |  113 ++
 include/linux/android_vendor.h           |   32 +
 include/linux/arch_topology.h            |    8 +
 include/linux/aw-spinand-nftl.h          |   55 +
 include/linux/bio-crypt-ctx.h            |  257 ++++
 include/linux/bio.h                      |   11 +
 include/linux/bits.h                     |    2 +-
 include/linux/blk-crypto.h               |   60 +
 include/linux/blk_types.h                |   38 +
 include/linux/blkdev.h                   |   60 +-
 include/linux/cfi.h                      |   44 +
 include/linux/cgroup-defs.h              |    4 +
 include/linux/clk-provider.h             |   15 +
 include/linux/clk/sunxi-ng.h             |    2 +-
 include/linux/clk/sunxi.h                |   25 +
 include/linux/clocksource.h              |    2 +
 include/linux/compiler-clang.h           |   16 +
 include/linux/compiler_types.h           |   14 +-
 include/linux/const.h                    |    5 +-
 include/linux/cpufreq.h                  |    5 +-
 include/linux/cpufreq_times.h            |   42 +
 include/linux/cpuhotplug.h               |    1 +
 include/linux/cpuidle.h                  |    9 +-
 include/linux/cpuset.h                   |    5 -
 include/linux/dcache.h                   |   10 +
 include/linux/debugfs.h                  |    5 +-
 include/linux/device-mapper.h            |   30 +-
 include/linux/device.h                   |  141 +-
 include/linux/dma-buf.h                  |   98 ++
 include/linux/dma-iommu.h                |   16 +
 include/linux/dma-mapping.h              |    6 +
 include/linux/dma/sprd-dma.h             |    4 +
 include/linux/dynamic_debug.h            |    2 +-
 include/linux/ebc.h                      |  216 +++
 include/linux/elevator.h                 |    9 +
 include/linux/elfnote.h                  |    2 +-
 include/linux/ethtool.h                  |    6 +
 include/linux/export.h                   |    2 +-
 include/linux/extcon.h                   |   10 +
 include/linux/f2fs_fs.h                  |    8 +-
 include/linux/fb.h                       |    2 +-
 include/linux/filter.h                   |   64 +-
 include/linux/fs.h                       |   94 +-
 include/linux/fscrypt.h                  |  454 +++---
 include/linux/fsnotify.h                 |    7 +
 include/linux/fsverity.h                 |   26 +-
 include/linux/fwnode.h                   |   50 +
 include/linux/g2d_driver.h               |  530 +++++++
 include/linux/genhd.h                    |   15 +
 include/linux/gfp.h                      |    9 +-
 include/linux/hdmi.h                     |    2 +-
 include/linux/hid.h                      |   42 +-
 include/linux/highmem.h                  |    5 +
 include/linux/hrtimer.h                  |    3 +
 include/linux/huge_mm.h                  |    1 +
 include/linux/ieee80211.h                |   80 +-
 include/linux/init.h                     |   28 +-
 include/linux/io-pgtable.h               |   50 +-
 include/linux/iomap.h                    |    4 +
 include/linux/iommu.h                    |   13 +-
 include/linux/ion.h                      |  419 ++++++
 include/linux/ioport.h                   |    6 +
 include/linux/iova.h                     |    1 +
 include/linux/ipv6.h                     |    7 +
 include/linux/irq.h                      |    6 +
 include/linux/irqdomain.h                |    7 +
 include/linux/jiffies.h                  |    4 +-
 include/linux/kallsyms.h                 |    2 +-
 include/linux/kconfig.h                  |    2 +
 include/linux/kcov.h                     |   23 +
 include/linux/kernel.h                   |    2 +
 include/linux/kernfs.h                   |    9 +
 include/linux/keyslot-manager.h          |  103 ++
 include/linux/kobject.h                  |   16 +
 include/linux/ktime.h                    |    9 +-
 include/linux/limits.h                   |   13 +-
 include/linux/lsm_hooks.h                |   15 +
 include/linux/math64.h                   |   20 +-
 include/linux/memcontrol.h               |    2 +-
 include/linux/mfd/acx00-mfd.h            |  133 ++
 include/linux/mfd/axp2101.h              | 1689 ++++++++++++++++++++++
 include/linux/mfd/sc27xx-pmic.h          |    7 +
 include/linux/mfd/syscon.h               |   14 +
 include/linux/mm.h                       |   38 +-
 include/linux/mm_types.h                 |   36 +-
 include/linux/mmc/core.h                 |   17 +
 include/linux/mmc/host.h                 |   11 +
 include/linux/mmc/pm.h                   |    1 +
 include/linux/mmu_notifier.h             |    9 +
 include/linux/mmzone.h                   |   23 +-
 include/linux/mod_devicetable.h          |    2 +-
 include/linux/module.h                   |   44 +-
 include/linux/mount.h                    |    6 +
 include/linux/mtd/aw-rawnand.h           | 1315 +++++++++++++++++
 include/linux/mtd/aw-spinand-nftl.h      |   55 +
 include/linux/mtd/aw-spinand.h           |  363 +++++
 include/linux/mtd/mtd.h                  |   23 +
 include/linux/mtd/spi-nor.h              |   10 +
 include/linux/net.h                      |    9 +-
 include/linux/netdev_features.h          |    9 +-
 include/linux/netdevice.h                |   59 +-
 include/linux/netfilter/xt_quota2.h      |   26 +
 include/linux/of_address.h               |    9 +-
 include/linux/of_fdt.h                   |   21 +
 include/linux/oom.h                      |    1 +
 include/linux/parser.h                   |    5 +-
 include/linux/pci.h                      |   16 +
 include/linux/pci_ids.h                  |    2 +
 include/linux/perf_event.h               |   36 +-
 include/linux/phy.h                      |   10 +
 include/linux/pinctrl/pinctrl-sunxi.h    |   32 +
 include/linux/pm_qos.h                   |   86 +-
 include/linux/pmic.h                     |  185 +++
 include/linux/power/charger-manager.h    |    2 +-
 include/linux/power_supply.h             |   54 +
 include/linux/printk.h                   |   14 +-
 include/linux/pwm.h                      |   64 +-
 include/linux/qcom_scm.h                 |    2 +
 include/linux/quota.h                    |    9 +
 include/linux/random.h                   |   24 +-
 include/linux/rpmsg.h                    |   27 +
 include/linux/rwsem.h                    |    2 +
 include/linux/sched.h                    |   35 +
 include/linux/sched/coredump.h           |    1 +
 include/linux/sched/signal.h             |    5 +
 include/linux/sched/topology.h           |    5 +
 include/linux/sched/user.h               |    4 +
 include/linux/sched/xacct.h              |    9 +
 include/linux/scs.h                      |   62 +
 include/linux/security.h                 |   39 +-
 include/linux/serdev.h                   |   14 +-
 include/linux/skbuff.h                   |   11 +
 include/linux/soc/mediatek/mtk_sip_svc.h |   25 +
 include/linux/soc/qcom/irq.h             |   34 +
 include/linux/stat.h                     |    3 +-
 include/linux/string.h                   |    2 +
 include/linux/sunxi-boot.h               |  251 ++++
 include/linux/sunxi-dump.h               |   21 +
 include/linux/sunxi-gpio.h               |  188 +++
 include/linux/sunxi-panicpart.h          |   46 +
 include/linux/sunxi-sid.h                |  107 ++
 include/linux/sunxi-smc.h                |   32 +
 include/linux/sunxi_mbus.h               |  148 ++
 include/linux/sunxi_nand_errno.h         |  145 ++
 include/linux/sunxi_nsi.h                |  103 ++
 include/linux/sunxi_timer_test.h         |   31 +
 include/linux/suspend.h                  |    1 +
 include/linux/sys_soc.h                  |    1 +
 include/linux/task_io_accounting.h       |    2 +
 include/linux/task_io_accounting_ops.h   |    1 +
 include/linux/time.h                     |    3 +
 include/linux/time32.h                   |   14 +-
 include/linux/time64.h                   |   10 +-
 include/linux/timer.h                    |    4 +
 include/linux/unicode.h                  |    3 +
 include/linux/usb.h                      |   30 +
 include/linux/usb/composite.h            |    1 +
 include/linux/usb/f_accessory.h          |   23 +
 include/linux/usb/gadget.h               |    6 +
 include/linux/usb/hcd.h                  |   18 +-
 include/linux/usb/typec.h                |   39 +-
 include/linux/usb/usbnet.h               |   10 +
 include/linux/user_namespace.h           |    4 +
 include/linux/vm_event_item.h            |    2 +-
 include/linux/wakeup_reason.h            |   37 +
 include/linux/workqueue.h                |    6 +
 include/linux/xattr.h                    |    9 +-
 167 files changed, 9051 insertions(+), 529 deletions(-)
 create mode 100644 include/linux/android_kabi.h
 create mode 100644 include/linux/android_vendor.h
 create mode 100644 include/linux/aw-spinand-nftl.h
 create mode 100644 include/linux/bio-crypt-ctx.h
 create mode 100644 include/linux/blk-crypto.h
 create mode 100644 include/linux/cfi.h
 create mode 100644 include/linux/clk/sunxi.h
 create mode 100644 include/linux/cpufreq_times.h
 create mode 100644 include/linux/ebc.h
 create mode 100644 include/linux/g2d_driver.h
 create mode 100644 include/linux/ion.h
 create mode 100644 include/linux/keyslot-manager.h
 create mode 100644 include/linux/mfd/acx00-mfd.h
 create mode 100644 include/linux/mfd/axp2101.h
 create mode 100644 include/linux/mfd/sc27xx-pmic.h
 create mode 100644 include/linux/mtd/aw-rawnand.h
 create mode 100644 include/linux/mtd/aw-spinand-nftl.h
 create mode 100644 include/linux/mtd/aw-spinand.h
 create mode 100644 include/linux/netfilter/xt_quota2.h
 create mode 100644 include/linux/pinctrl/pinctrl-sunxi.h
 create mode 100644 include/linux/pmic.h
 create mode 100644 include/linux/scs.h
 create mode 100644 include/linux/soc/mediatek/mtk_sip_svc.h
 create mode 100644 include/linux/soc/qcom/irq.h
 create mode 100644 include/linux/sunxi-boot.h
 create mode 100644 include/linux/sunxi-dump.h
 create mode 100644 include/linux/sunxi-gpio.h
 create mode 100644 include/linux/sunxi-panicpart.h
 create mode 100644 include/linux/sunxi-sid.h
 create mode 100644 include/linux/sunxi-smc.h
 create mode 100644 include/linux/sunxi_mbus.h
 create mode 100644 include/linux/sunxi_nand_errno.h
 create mode 100644 include/linux/sunxi_nsi.h
 create mode 100644 include/linux/sunxi_timer_test.h
 create mode 100644 include/linux/usb/f_accessory.h
 create mode 100644 include/linux/wakeup_reason.h

diff --git a/include/linux/android_kabi.h b/include/linux/android_kabi.h
new file mode 100644
index 000000000..efa52953f
--- /dev/null
+++ b/include/linux/android_kabi.h
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * android_kabi.h - Android kernel abi abstraction header
+ *
+ * Copyright (C) 2020 Google, Inc.
+ *
+ * Heavily influenced by rh_kabi.h which came from the RHEL/CENTOS kernel and
+ * was:
+ *	Copyright (c) 2014 Don Zickus
+ *	Copyright (c) 2015-2018 Jiri Benc
+ *	Copyright (c) 2015 Sabrina Dubroca, Hannes Frederic Sowa
+ *	Copyright (c) 2016-2018 Prarit Bhargava
+ *	Copyright (c) 2017 Paolo Abeni, Larry Woodman
+ *
+ * These macros are to be used to try to help alleviate future kernel abi
+ * changes that will occur as LTS and other kernel patches are merged into the
+ * tree during a period in which the kernel abi is wishing to not be disturbed.
+ *
+ * There are two times these macros should be used:
+ *  - Before the kernel abi is "frozen"
+ *    Padding can be added to various kernel structures that have in the past
+ *    been known to change over time.  That will give "room" in the structure
+ *    that can then be used when fields are added so that the structure size
+ *    will not change.
+ *
+ *  - After the kernel abi is "frozen"
+ *    If a structure's field is changed to a type that is identical in size to
+ *    the previous type, it can be changed with a union macro
+ *    If a field is added to a structure, the padding fields can be used to add
+ *    the new field in a "safe" way.
+ */
+#ifndef _ANDROID_KABI_H
+#define _ANDROID_KABI_H
+
+#include <linux/compiler.h>
+
+/*
+ * Worker macros, don't use these, use the ones without a leading '_'
+ */
+
+#define __ANDROID_KABI_CHECK_SIZE_ALIGN(_orig, _new)				\
+	union {									\
+		_Static_assert(sizeof(struct{_new;}) <= sizeof(struct{_orig;}),	\
+			       __FILE__ ":" __stringify(__LINE__) ": "		\
+			       __stringify(_new)				\
+			       " is larger than "				\
+			       __stringify(_orig) );				\
+		_Static_assert(__alignof__(struct{_new;}) <= __alignof__(struct{_orig;}),	\
+			       __FILE__ ":" __stringify(__LINE__) ": "		\
+			       __stringify(_orig)				\
+			       " is not aligned the same as "			\
+			       __stringify(_new) );				\
+	}
+
+#ifdef __GENKSYMS__
+
+#define _ANDROID_KABI_REPLACE(_orig, _new)		_orig
+
+#else
+
+#define _ANDROID_KABI_REPLACE(_orig, _new)			\
+	union {							\
+		_new;						\
+		struct {					\
+			_orig;					\
+		} __UNIQUE_ID(android_kabi_hide);		\
+		__ANDROID_KABI_CHECK_SIZE_ALIGN(_orig, _new);	\
+	}
+
+#endif /* __GENKSYMS__ */
+
+#define _ANDROID_KABI_RESERVE(n)		u64 android_kabi_reserved##n
+
+
+/*
+ * Macros to use _before_ the ABI is frozen
+ */
+
+/*
+ * ANDROID_KABI_RESERVE
+ *   Reserve some "padding" in a structure for potential future use.
+ *   This normally placed at the end of a structure.
+ *   number: the "number" of the padding variable in the structure.  Start with
+ *   1 and go up.
+ */
+#define ANDROID_KABI_RESERVE(number)	_ANDROID_KABI_RESERVE(number)
+
+
+/*
+ * Macros to use _after_ the ABI is frozen
+ */
+
+/*
+ * ANDROID_KABI_USE(number, _new)
+ *   Use a previous padding entry that was defined with ANDROID_KABI_RESERVE
+ *   number: the previous "number" of the padding variable
+ *   _new: the variable to use now instead of the padding variable
+ */
+#define ANDROID_KABI_USE(number, _new)		\
+	_ANDROID_KABI_REPLACE(_ANDROID_KABI_RESERVE(number), _new)
+
+/*
+ * ANDROID_KABI_USE2(number, _new1, _new2)
+ *   Use a previous padding entry that was defined with ANDROID_KABI_RESERVE for
+ *   two new variables that fit into 64 bits.  This is good for when you do not
+ *   want to "burn" a 64bit padding variable for a smaller variable size if not
+ *   needed.
+ */
+#define ANDROID_KABI_USE2(number, _new1, _new2)			\
+	_ANDROID_KABI_REPLACE(_ANDROID_KABI_RESERVE(number), struct{ _new1; _new2; })
+
+
+#endif /* _ANDROID_KABI_H */
diff --git a/include/linux/android_vendor.h b/include/linux/android_vendor.h
new file mode 100644
index 000000000..c0d3abb54
--- /dev/null
+++ b/include/linux/android_vendor.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * android_vendor.h - Android vendor data
+ *
+ * Copyright 2020 Google LLC
+ *
+ * These macros are to be used to reserve space in kernel data structures
+ * for use by vendor modules.
+ *
+ * These macros should be used before the kernel abi is "frozen".
+ * Fields can be added to various kernel structures that need space
+ * for functionality implemented in vendor modules. The use of
+ * these fields is vendor specific.
+ */
+#ifndef _ANDROID_VENDOR_H
+#define _ANDROID_VENDOR_H
+
+/*
+ * ANDROID_VENDOR_DATA
+ *   Reserve some "padding" in a structure for potential future use.
+ *   This normally placed at the end of a structure.
+ *   number: the "number" of the padding variable in the structure.  Start with
+ *   1 and go up.
+ *
+ * ANDROID_VENDOR_DATA_ARRAY
+ *   Same as ANDROID_VENDOR_DATA but allocates an array of u64 with
+ *   the specified size
+ */
+#define ANDROID_VENDOR_DATA(n)		u64 android_vendor_data##n
+#define ANDROID_VENDOR_DATA_ARRAY(n, s)	u64 android_vendor_data##n[s]
+
+#endif /* _ANDROID_VENDOR_H */
diff --git a/include/linux/arch_topology.h b/include/linux/arch_topology.h
index 42f2b5126..5402bc0e2 100644
--- a/include/linux/arch_topology.h
+++ b/include/linux/arch_topology.h
@@ -33,6 +33,14 @@ unsigned long topology_get_freq_scale(int cpu)
 	return per_cpu(freq_scale, cpu);
 }
 
+DECLARE_PER_CPU(unsigned long, max_freq_scale);
+
+static inline
+unsigned long topology_get_max_freq_scale(struct sched_domain *sd, int cpu)
+{
+	return per_cpu(max_freq_scale, cpu);
+}
+
 struct cpu_topology {
 	int thread_id;
 	int core_id;
diff --git a/include/linux/aw-spinand-nftl.h b/include/linux/aw-spinand-nftl.h
new file mode 100644
index 000000000..f30f2cb70
--- /dev/null
+++ b/include/linux/aw-spinand-nftl.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __AW_SPINAND_NFTL_H__
+#define __AW_SPINAND_NFTL_H__
+
+#include <linux/sunxi-boot.h>
+
+#define AW_NFTL_OOB_LEN (16)
+
+enum AW_NFTL_ECC_STATUS {
+	AW_NFTL_ECC_ERR = -2,
+	AW_NFTL_ECC_LIMIT = 10
+};
+
+
+unsigned int spinand_nftl_get_super_page_size(int type);
+unsigned int spinand_nftl_get_super_block_size(int type);
+unsigned int spinand_nftl_get_single_page_size(int type);
+unsigned int spinand_nftl_get_single_block_size(int type);
+unsigned int spinand_nftl_get_chip_size(int type);
+unsigned int spinand_nftl_get_die_size(int type);
+unsigned int spinand_nftl_get_die_cnt(void);
+unsigned int spinand_nftl_get_chip_cnt(void);
+unsigned int spinand_nftl_get_max_erase_times(void);
+unsigned int spinand_nftl_get_multi_plane_flag(void);
+unsigned int spinand_nftl_get_operation_opt(void);
+void spinand_nftl_get_chip_id(unsigned char *id);
+
+int spinand_nftl_read_super_page(unsigned short dienum, unsigned short blocknum,
+		unsigned short pagenum, unsigned short sectorbitmap,
+		void *rmbuf, void *rspare);
+
+int spinand_nftl_write_super_page(unsigned short dienum, unsigned short blocknum,
+		unsigned short pagenum, unsigned short sectorbitmap,
+		void *wmbuf, void *wspare);
+int spinand_nftl_erase_super_block(unsigned short dienum, unsigned short blocknum);
+int spinand_nftl_super_badblock_check(unsigned short dienum, unsigned short blocknum);
+int spinand_nftl_super_badblock_mark(unsigned short dienum, unsigned short blocknum);
+
+int spinand_nftl_read_single_page(unsigned short dienum, unsigned short blocknum,
+		unsigned short pagenum, unsigned short sectorbitmap,
+		void *rmbuf, void *rspare);
+
+int spinand_nftl_write_single_page(unsigned short dienum, unsigned short blocknum,
+		unsigned short pagenum, unsigned short sectorbitmap,
+		void *wmbuf, void *wspare);
+int spinand_nftl_erase_single_block(unsigned short dienum, unsigned short blocknum);
+
+int spinand_nftl_single_block_copy(unsigned int from_chip,
+		unsigned int from_block, unsigned int to_chip,
+		unsigned int to_block);
+int spinand_nftl_single_badblock_check(unsigned short chipnum, unsigned short blocknum);
+int spinand_nftl_single_badblock_mark(unsigned short chipnum, unsigned short blocknum);
+
+#endif /*AW_SPINAND_NFTL_H*/
diff --git a/include/linux/bio-crypt-ctx.h b/include/linux/bio-crypt-ctx.h
new file mode 100644
index 000000000..9df113f74
--- /dev/null
+++ b/include/linux/bio-crypt-ctx.h
@@ -0,0 +1,257 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 Google LLC
+ */
+#ifndef __LINUX_BIO_CRYPT_CTX_H
+#define __LINUX_BIO_CRYPT_CTX_H
+
+enum blk_crypto_mode_num {
+	BLK_ENCRYPTION_MODE_INVALID,
+	BLK_ENCRYPTION_MODE_AES_256_XTS,
+	BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV,
+	BLK_ENCRYPTION_MODE_ADIANTUM,
+	BLK_ENCRYPTION_MODE_MAX,
+};
+
+#ifdef CONFIG_BLOCK
+#include <linux/blk_types.h>
+
+#ifdef CONFIG_BLK_INLINE_ENCRYPTION
+
+#define BLK_CRYPTO_MAX_KEY_SIZE		64
+#define BLK_CRYPTO_MAX_WRAPPED_KEY_SIZE		128
+
+/**
+ * struct blk_crypto_key - an inline encryption key
+ * @crypto_mode: encryption algorithm this key is for
+ * @data_unit_size: the data unit size for all encryption/decryptions with this
+ *	key.  This is the size in bytes of each individual plaintext and
+ *	ciphertext.  This is always a power of 2.  It might be e.g. the
+ *	filesystem block size or the disk sector size.
+ * @data_unit_size_bits: log2 of data_unit_size
+ * @size: size of this key in bytes (determined by @crypto_mode)
+ * @hash: hash of this key, for keyslot manager use only
+ * @is_hw_wrapped: @raw points to a wrapped key to be used by an inline
+ *	encryption hardware that accepts wrapped keys.
+ * @raw: the raw bytes of this key.  Only the first @size bytes are used.
+ *
+ * A blk_crypto_key is immutable once created, and many bios can reference it at
+ * the same time.  It must not be freed until all bios using it have completed.
+ */
+struct blk_crypto_key {
+	enum blk_crypto_mode_num crypto_mode;
+	unsigned int data_unit_size;
+	unsigned int data_unit_size_bits;
+	unsigned int size;
+
+	/*
+	 * Hack to avoid breaking KMI: pack both hash and dun_bytes into the
+	 * hash field...
+	 */
+#define BLK_CRYPTO_KEY_HASH_MASK		0xffffff
+#define BLK_CRYPTO_KEY_DUN_BYTES_SHIFT		24
+	unsigned int hash;
+
+	bool is_hw_wrapped;
+	u8 raw[BLK_CRYPTO_MAX_WRAPPED_KEY_SIZE];
+};
+
+#define BLK_CRYPTO_MAX_IV_SIZE		32
+#define BLK_CRYPTO_DUN_ARRAY_SIZE	(BLK_CRYPTO_MAX_IV_SIZE/sizeof(u64))
+
+static inline void
+blk_crypto_key_set_hash_and_dun_bytes(struct blk_crypto_key *key,
+				      u32 hash, unsigned int dun_bytes)
+{
+	key->hash = (dun_bytes << BLK_CRYPTO_KEY_DUN_BYTES_SHIFT) |
+		    (hash & BLK_CRYPTO_KEY_HASH_MASK);
+}
+
+static inline u32
+blk_crypto_key_hash(const struct blk_crypto_key *key)
+{
+	return key->hash & BLK_CRYPTO_KEY_HASH_MASK;
+}
+
+static inline unsigned int
+blk_crypto_key_dun_bytes(const struct blk_crypto_key *key)
+{
+	return key->hash >> BLK_CRYPTO_KEY_DUN_BYTES_SHIFT;
+}
+
+/**
+ * struct bio_crypt_ctx - an inline encryption context
+ * @bc_key: the key, algorithm, and data unit size to use
+ * @bc_keyslot: the keyslot that has been assigned for this key in @bc_ksm,
+ *		or -1 if no keyslot has been assigned yet.
+ * @bc_dun: the data unit number (starting IV) to use
+ * @bc_ksm: the keyslot manager into which the key has been programmed with
+ *	    @bc_keyslot, or NULL if this key hasn't yet been programmed.
+ *
+ * A bio_crypt_ctx specifies that the contents of the bio will be encrypted (for
+ * write requests) or decrypted (for read requests) inline by the storage device
+ * or controller, or by the crypto API fallback.
+ */
+struct bio_crypt_ctx {
+	const struct blk_crypto_key	*bc_key;
+	int				bc_keyslot;
+
+	/* Data unit number */
+	u64				bc_dun[BLK_CRYPTO_DUN_ARRAY_SIZE];
+
+	/*
+	 * The keyslot manager where the key has been programmed
+	 * with keyslot.
+	 */
+	struct keyslot_manager		*bc_ksm;
+};
+
+int bio_crypt_ctx_init(void);
+
+struct bio_crypt_ctx *bio_crypt_alloc_ctx(gfp_t gfp_mask);
+
+void bio_crypt_free_ctx(struct bio *bio);
+
+static inline bool bio_has_crypt_ctx(struct bio *bio)
+{
+	return bio->bi_crypt_context;
+}
+
+void bio_crypt_clone(struct bio *dst, struct bio *src, gfp_t gfp_mask);
+
+static inline void bio_crypt_set_ctx(struct bio *bio,
+				     const struct blk_crypto_key *key,
+				     u64 dun[BLK_CRYPTO_DUN_ARRAY_SIZE],
+				     gfp_t gfp_mask)
+{
+	struct bio_crypt_ctx *bc = bio_crypt_alloc_ctx(gfp_mask);
+
+	bc->bc_key = key;
+	memcpy(bc->bc_dun, dun, sizeof(bc->bc_dun));
+	bc->bc_ksm = NULL;
+	bc->bc_keyslot = -1;
+
+	bio->bi_crypt_context = bc;
+}
+
+void bio_crypt_ctx_release_keyslot(struct bio_crypt_ctx *bc);
+
+int bio_crypt_ctx_acquire_keyslot(struct bio_crypt_ctx *bc,
+				  struct keyslot_manager *ksm);
+
+struct request;
+bool bio_crypt_should_process(struct request *rq);
+
+static inline bool bio_crypt_dun_is_contiguous(const struct bio_crypt_ctx *bc,
+					       unsigned int bytes,
+					u64 next_dun[BLK_CRYPTO_DUN_ARRAY_SIZE])
+{
+	int i = 0;
+	unsigned int inc = bytes >> bc->bc_key->data_unit_size_bits;
+
+	while (i < BLK_CRYPTO_DUN_ARRAY_SIZE) {
+		if (bc->bc_dun[i] + inc != next_dun[i])
+			return false;
+		inc = ((bc->bc_dun[i] + inc)  < inc);
+		i++;
+	}
+
+	return true;
+}
+
+
+static inline void bio_crypt_dun_increment(u64 dun[BLK_CRYPTO_DUN_ARRAY_SIZE],
+					   unsigned int inc)
+{
+	int i = 0;
+
+	while (inc && i < BLK_CRYPTO_DUN_ARRAY_SIZE) {
+		dun[i] += inc;
+		inc = (dun[i] < inc);
+		i++;
+	}
+}
+
+static inline void bio_crypt_advance(struct bio *bio, unsigned int bytes)
+{
+	struct bio_crypt_ctx *bc = bio->bi_crypt_context;
+
+	if (!bc)
+		return;
+
+	bio_crypt_dun_increment(bc->bc_dun,
+				bytes >> bc->bc_key->data_unit_size_bits);
+}
+
+bool bio_crypt_ctx_compatible(struct bio *b_1, struct bio *b_2);
+
+bool bio_crypt_ctx_mergeable(struct bio *b_1, unsigned int b1_bytes,
+			     struct bio *b_2);
+
+#else /* CONFIG_BLK_INLINE_ENCRYPTION */
+static inline int bio_crypt_ctx_init(void)
+{
+	return 0;
+}
+
+static inline bool bio_has_crypt_ctx(struct bio *bio)
+{
+	return false;
+}
+
+static inline void bio_crypt_clone(struct bio *dst, struct bio *src,
+				   gfp_t gfp_mask) { }
+
+static inline void bio_crypt_free_ctx(struct bio *bio) { }
+
+static inline void bio_crypt_advance(struct bio *bio, unsigned int bytes) { }
+
+static inline bool bio_crypt_ctx_compatible(struct bio *b_1, struct bio *b_2)
+{
+	return true;
+}
+
+static inline bool bio_crypt_ctx_mergeable(struct bio *b_1,
+					   unsigned int b1_bytes,
+					   struct bio *b_2)
+{
+	return true;
+}
+
+#endif /* CONFIG_BLK_INLINE_ENCRYPTION */
+
+#if IS_ENABLED(CONFIG_DM_DEFAULT_KEY)
+static inline void bio_set_skip_dm_default_key(struct bio *bio)
+{
+	bio->bi_skip_dm_default_key = true;
+}
+
+static inline bool bio_should_skip_dm_default_key(const struct bio *bio)
+{
+	return bio->bi_skip_dm_default_key;
+}
+
+static inline void bio_clone_skip_dm_default_key(struct bio *dst,
+						 const struct bio *src)
+{
+	dst->bi_skip_dm_default_key = src->bi_skip_dm_default_key;
+}
+#else /* CONFIG_DM_DEFAULT_KEY */
+static inline void bio_set_skip_dm_default_key(struct bio *bio)
+{
+}
+
+static inline bool bio_should_skip_dm_default_key(const struct bio *bio)
+{
+	return false;
+}
+
+static inline void bio_clone_skip_dm_default_key(struct bio *dst,
+						 const struct bio *src)
+{
+}
+#endif /* !CONFIG_DM_DEFAULT_KEY */
+
+#endif /* CONFIG_BLOCK */
+
+#endif /* __LINUX_BIO_CRYPT_CTX_H */
diff --git a/include/linux/bio.h b/include/linux/bio.h
index 853d92cee..c21aa1c94 100644
--- a/include/linux/bio.h
+++ b/include/linux/bio.h
@@ -8,6 +8,8 @@
 #include <linux/highmem.h>
 #include <linux/mempool.h>
 #include <linux/ioprio.h>
+#include <linux/bio-crypt-ctx.h>
+#include <linux/android_kabi.h>
 
 #ifdef CONFIG_BLOCK
 /* struct bio, bio_vec and BIO_* flags are defined in blk_types.h */
@@ -319,6 +321,10 @@ struct bio_integrity_payload {
 	struct work_struct	bip_work;	/* I/O completion */
 
 	struct bio_vec		*bip_vec;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+
 	struct bio_vec		bip_inline_vecs[0];/* embedded bvec array */
 };
 
@@ -719,6 +725,11 @@ struct bio_set {
 	struct bio_list		rescue_list;
 	struct work_struct	rescue_work;
 	struct workqueue_struct	*rescue_workqueue;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct biovec_slab {
diff --git a/include/linux/bits.h b/include/linux/bits.h
index 669d69441..a740bbcf3 100644
--- a/include/linux/bits.h
+++ b/include/linux/bits.h
@@ -3,9 +3,9 @@
 #define __LINUX_BITS_H
 
 #include <linux/const.h>
+#include <vdso/bits.h>
 #include <asm/bitsperlong.h>
 
-#define BIT(nr)			(UL(1) << (nr))
 #define BIT_ULL(nr)		(ULL(1) << (nr))
 #define BIT_MASK(nr)		(UL(1) << ((nr) % BITS_PER_LONG))
 #define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
diff --git a/include/linux/blk-crypto.h b/include/linux/blk-crypto.h
new file mode 100644
index 000000000..30a0b3290
--- /dev/null
+++ b/include/linux/blk-crypto.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 Google LLC
+ */
+
+#ifndef __LINUX_BLK_CRYPTO_H
+#define __LINUX_BLK_CRYPTO_H
+
+#include <linux/bio.h>
+
+#ifdef CONFIG_BLK_INLINE_ENCRYPTION
+
+int blk_crypto_submit_bio(struct bio **bio_ptr);
+
+bool blk_crypto_endio(struct bio *bio);
+
+int blk_crypto_init_key(struct blk_crypto_key *blk_key,
+			const u8 *raw_key, unsigned int raw_key_size,
+			bool is_hw_wrapped,
+			enum blk_crypto_mode_num crypto_mode,
+			unsigned int dun_bytes,
+			unsigned int data_unit_size);
+
+int blk_crypto_start_using_mode(enum blk_crypto_mode_num crypto_mode,
+				unsigned int dun_bytes,
+				unsigned int data_unit_size,
+				bool is_hw_wrapped_key,
+				struct request_queue *q);
+
+int blk_crypto_evict_key(struct request_queue *q,
+			 const struct blk_crypto_key *key);
+
+#else /* CONFIG_BLK_INLINE_ENCRYPTION */
+
+static inline int blk_crypto_submit_bio(struct bio **bio_ptr)
+{
+	return 0;
+}
+
+static inline bool blk_crypto_endio(struct bio *bio)
+{
+	return true;
+}
+
+#endif /* CONFIG_BLK_INLINE_ENCRYPTION */
+
+#ifdef CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK
+
+int blk_crypto_fallback_init(void);
+
+#else /* CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK */
+
+static inline int blk_crypto_fallback_init(void)
+{
+	return 0;
+}
+
+#endif /* CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK */
+
+#endif /* __LINUX_BLK_CRYPTO_H */
diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h
index d688b96d1..fc4221736 100644
--- a/include/linux/blk_types.h
+++ b/include/linux/blk_types.h
@@ -9,6 +9,7 @@
 #include <linux/types.h>
 #include <linux/bvec.h>
 #include <linux/ktime.h>
+#include <linux/android_kabi.h>
 
 struct bio_set;
 struct bio;
@@ -18,6 +19,7 @@ struct block_device;
 struct io_context;
 struct cgroup_subsys_state;
 typedef void (bio_end_io_t) (struct bio *);
+struct bio_crypt_ctx;
 
 /*
  * Block error status values.  See block/blk-core:blk_errors for the details.
@@ -173,6 +175,14 @@ struct bio {
 	u64			bi_iocost_cost;
 #endif
 #endif
+
+#ifdef CONFIG_BLK_INLINE_ENCRYPTION
+	struct bio_crypt_ctx	*bi_crypt_context;
+#if IS_ENABLED(CONFIG_DM_DEFAULT_KEY)
+	bool			bi_skip_dm_default_key;
+#endif
+#endif
+
 	union {
 #if defined(CONFIG_BLK_DEV_INTEGRITY)
 		struct bio_integrity_payload *bi_integrity; /* data integrity */
@@ -193,6 +203,9 @@ struct bio {
 
 	struct bio_set		*bi_pool;
 
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+
 	/*
 	 * We can inline a number of vecs at the end of the bio, to avoid
 	 * double allocations for a small number of bio_vecs. This member
@@ -290,6 +303,12 @@ enum req_opf {
 	REQ_OP_ZONE_RESET_ALL	= 8,
 	/* write the zero filled sector many times */
 	REQ_OP_WRITE_ZEROES	= 9,
+	/* Open a zone */
+	REQ_OP_ZONE_OPEN	= 10,
+	/* Close a zone */
+	REQ_OP_ZONE_CLOSE	= 11,
+	/* Transition a zone to full */
+	REQ_OP_ZONE_FINISH	= 12,
 
 	/* SCSI passthrough using struct scsi_request */
 	REQ_OP_SCSI_IN		= 32,
@@ -417,6 +436,25 @@ static inline bool op_is_discard(unsigned int op)
 	return (op & REQ_OP_MASK) == REQ_OP_DISCARD;
 }
 
+/*
+ * Check if a bio or request operation is a zone management operation, with
+ * the exception of REQ_OP_ZONE_RESET_ALL which is treated as a special case
+ * due to its different handling in the block layer and device response in
+ * case of command failure.
+ */
+static inline bool op_is_zone_mgmt(enum req_opf op)
+{
+	switch (op & REQ_OP_MASK) {
+	case REQ_OP_ZONE_RESET:
+	case REQ_OP_ZONE_OPEN:
+	case REQ_OP_ZONE_CLOSE:
+	case REQ_OP_ZONE_FINISH:
+		return true;
+	default:
+		return false;
+	}
+}
+
 static inline int op_stat_group(unsigned int op)
 {
 	if (op_is_discard(op))
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index d5338b9ee..e5ee34f29 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -43,6 +43,7 @@ struct pr_ops;
 struct rq_qos;
 struct blk_queue_stats;
 struct blk_stat_callback;
+struct keyslot_manager;
 
 #define BLKDEV_MIN_RQ	4
 #define BLKDEV_MAX_RQ	128	/* Default maximum */
@@ -349,34 +350,28 @@ struct queue_limits {
 	enum blk_zoned_model	zoned;
 };
 
+typedef int (*report_zones_cb)(struct blk_zone *zone, unsigned int idx,
+			       void *data);
+
 #ifdef CONFIG_BLK_DEV_ZONED
 
-/*
- * Maximum number of zones to report with a single report zones command.
- */
-#define BLK_ZONED_REPORT_MAX_ZONES	8192U
-
-extern unsigned int blkdev_nr_zones(struct block_device *bdev);
-extern int blkdev_report_zones(struct block_device *bdev,
-			       sector_t sector, struct blk_zone *zones,
-			       unsigned int *nr_zones);
-extern int blkdev_reset_zones(struct block_device *bdev, sector_t sectors,
-			      sector_t nr_sectors, gfp_t gfp_mask);
+#define BLK_ALL_ZONES  ((unsigned int)-1)
+int blkdev_report_zones(struct block_device *bdev, sector_t sector,
+			unsigned int nr_zones, report_zones_cb cb, void *data);
+unsigned int blkdev_nr_zones(struct gendisk *disk);
+extern int blkdev_zone_mgmt(struct block_device *bdev, enum req_opf op,
+			    sector_t sectors, sector_t nr_sectors,
+			    gfp_t gfp_mask);
 extern int blk_revalidate_disk_zones(struct gendisk *disk);
 
 extern int blkdev_report_zones_ioctl(struct block_device *bdev, fmode_t mode,
 				     unsigned int cmd, unsigned long arg);
-extern int blkdev_reset_zones_ioctl(struct block_device *bdev, fmode_t mode,
-				    unsigned int cmd, unsigned long arg);
+extern int blkdev_zone_mgmt_ioctl(struct block_device *bdev, fmode_t mode,
+				  unsigned int cmd, unsigned long arg);
 
 #else /* CONFIG_BLK_DEV_ZONED */
 
-static inline unsigned int blkdev_nr_zones(struct block_device *bdev)
-{
-	return 0;
-}
-
-static inline int blk_revalidate_disk_zones(struct gendisk *disk)
+static inline unsigned int blkdev_nr_zones(struct gendisk *disk)
 {
 	return 0;
 }
@@ -388,9 +383,9 @@ static inline int blkdev_report_zones_ioctl(struct block_device *bdev,
 	return -ENOTTY;
 }
 
-static inline int blkdev_reset_zones_ioctl(struct block_device *bdev,
-					   fmode_t mode, unsigned int cmd,
-					   unsigned long arg)
+static inline int blkdev_zone_mgmt_ioctl(struct block_device *bdev,
+					 fmode_t mode, unsigned int cmd,
+					 unsigned long arg)
 {
 	return -ENOTTY;
 }
@@ -481,6 +476,11 @@ struct request_queue {
 	unsigned int		dma_pad_mask;
 	unsigned int		dma_alignment;
 
+#ifdef CONFIG_BLK_INLINE_ENCRYPTION
+	/* Inline crypto capabilities */
+	struct keyslot_manager *ksm;
+#endif
+
 	unsigned int		rq_timeout;
 	int			poll_nsec;
 
@@ -505,9 +505,9 @@ struct request_queue {
 	/*
 	 * Zoned block device information for request dispatch control.
 	 * nr_zones is the total number of zones of the device. This is always
-	 * 0 for regular block devices. seq_zones_bitmap is a bitmap of nr_zones
-	 * bits which indicates if a zone is conventional (bit clear) or
-	 * sequential (bit set). seq_zones_wlock is a bitmap of nr_zones
+	 * 0 for regular block devices. conv_zones_bitmap is a bitmap of nr_zones
+	 * bits which indicates if a zone is conventional (bit set) or
+	 * sequential (bit clear). seq_zones_wlock is a bitmap of nr_zones
 	 * bits which indicates if a zone is write locked, that is, if a write
 	 * request targeting the zone was dispatched. All three fields are
 	 * initialized by the low level device driver (e.g. scsi/sd.c).
@@ -520,7 +520,7 @@ struct request_queue {
 	 * blk_mq_unfreeze_queue().
 	 */
 	unsigned int		nr_zones;
-	unsigned long		*seq_zones_bitmap;
+	unsigned long		*conv_zones_bitmap;
 	unsigned long		*seq_zones_wlock;
 #endif /* CONFIG_BLK_DEV_ZONED */
 
@@ -726,9 +726,11 @@ static inline unsigned int blk_queue_zone_no(struct request_queue *q,
 static inline bool blk_queue_zone_is_seq(struct request_queue *q,
 					 sector_t sector)
 {
-	if (!blk_queue_is_zoned(q) || !q->seq_zones_bitmap)
+	if (!blk_queue_is_zoned(q))
 		return false;
-	return test_bit(blk_queue_zone_no(q, sector), q->seq_zones_bitmap);
+	if (!q->conv_zones_bitmap)
+		return true;
+	return !test_bit(blk_queue_zone_no(q, sector), q->conv_zones_bitmap);
 }
 #else /* CONFIG_BLK_DEV_ZONED */
 static inline unsigned int blk_queue_nr_zones(struct request_queue *q)
@@ -1710,7 +1712,7 @@ struct block_device_operations {
 	/* this callback is with swap_lock and sometimes page table lock held */
 	void (*swap_slot_free_notify) (struct block_device *, unsigned long);
 	int (*report_zones)(struct gendisk *, sector_t sector,
-			    struct blk_zone *zones, unsigned int *nr_zones);
+			unsigned int nr_zones, report_zones_cb cb, void *data);
 	struct module *owner;
 	const struct pr_ops *pr_ops;
 };
diff --git a/include/linux/cfi.h b/include/linux/cfi.h
new file mode 100644
index 000000000..6ef37b35f
--- /dev/null
+++ b/include/linux/cfi.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Clang Control Flow Integrity (CFI) support.
+ *
+ * Copyright (C) 2019 Google LLC
+ */
+#ifndef _LINUX_CFI_H
+#define _LINUX_CFI_H
+
+#include <linux/stringify.h>
+
+#ifdef CONFIG_CFI_CLANG
+#ifdef CONFIG_MODULES
+
+typedef void (*cfi_check_fn)(uint64_t id, void *ptr, void *diag);
+
+/* Compiler-generated function in each module, and the kernel */
+#define CFI_CHECK_FN		__cfi_check
+#define CFI_CHECK_FN_NAME	__stringify(CFI_CHECK_FN)
+
+extern void CFI_CHECK_FN(uint64_t id, void *ptr, void *diag);
+
+#ifdef CONFIG_CFI_CLANG_SHADOW
+extern void cfi_module_add(struct module *mod, unsigned long min_addr,
+	unsigned long max_addr);
+
+extern void cfi_module_remove(struct module *mod, unsigned long min_addr,
+	unsigned long max_addr);
+#else
+static inline void cfi_module_add(struct module *mod, unsigned long min_addr,
+	unsigned long max_addr)
+{
+}
+
+static inline void cfi_module_remove(struct module *mod, unsigned long min_addr,
+	unsigned long max_addr)
+{
+}
+#endif /* CONFIG_CFI_CLANG_SHADOW */
+
+#endif /* CONFIG_MODULES */
+#endif /* CONFIG_CFI_CLANG */
+
+#endif /* _LINUX_CFI_H */
diff --git a/include/linux/cgroup-defs.h b/include/linux/cgroup-defs.h
index 1ccfa3779..e77b6b0da 100644
--- a/include/linux/cgroup-defs.h
+++ b/include/linux/cgroup-defs.h
@@ -797,9 +797,13 @@ struct sock_cgroup_data {
 	union {
 #ifdef __LITTLE_ENDIAN
 		struct {
+#ifdef __GENKSYMS__
+			u8	is_data;
+#else
 			u8	is_data : 1;
 			u8	no_refcnt : 1;
 			u8	unused : 6;
+#endif
 			u8	padding;
 			u16	prioidx;
 			u32	classid;
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 2fdfe8061..a789b23ff 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -32,6 +32,7 @@
 #define CLK_OPS_PARENT_ENABLE	BIT(12)
 /* duty cycle call may be forwarded to the parent clock */
 #define CLK_DUTY_CYCLE_PARENT	BIT(13)
+#define CLK_DONT_HOLD_STATE	BIT(14) /* Don't hold state */
 
 struct clk;
 struct clk_hw;
@@ -199,6 +200,13 @@ struct clk_duty {
  *		directory is provided as an argument.  Called with
  *		prepare_lock held.  Returns 0 on success, -EERROR otherwise.
  *
+ * @pre_rate_change: Optional callback for a clock to fulfill its rate
+ *		change requirements before any rate change has occurred in
+ *		its clock tree. Returns 0 on success, -EERROR otherwise.
+ *
+ * @post_rate_change: Optional callback for a clock to clean up any
+ *		requirements that were needed while the clock and its tree
+ *		was changing states. Returns 0 on success, -EERROR otherwise.
  *
  * The clk_enable/clk_disable and clk_prepare/clk_unprepare pairs allow
  * implementations to split any work between atomic (enable) and sleepable
@@ -245,6 +253,12 @@ struct clk_ops {
 					  struct clk_duty *duty);
 	void		(*init)(struct clk_hw *hw);
 	void		(*debug_init)(struct clk_hw *hw, struct dentry *dentry);
+	int		(*pre_rate_change)(struct clk_hw *hw,
+					   unsigned long rate,
+					   unsigned long new_rate);
+	int		(*post_rate_change)(struct clk_hw *hw,
+					    unsigned long old_rate,
+					    unsigned long rate);
 };
 
 /**
@@ -802,6 +816,7 @@ void devm_clk_unregister(struct device *dev, struct clk *clk);
 
 void clk_hw_unregister(struct clk_hw *hw);
 void devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw);
+void clk_sync_state(struct device *dev);
 
 /* helper functions */
 const char *__clk_get_name(const struct clk *clk);
diff --git a/include/linux/clk/sunxi-ng.h b/include/linux/clk/sunxi-ng.h
index 3cd14acde..4a65cbecb 100644
--- a/include/linux/clk/sunxi-ng.h
+++ b/include/linux/clk/sunxi-ng.h
@@ -8,7 +8,7 @@
 
 #include <linux/errno.h>
 
-#ifdef CONFIG_SUNXI_CCU
+#if IS_ENABLED(CONFIG_SUNXI_CCU)
 int sunxi_ccu_set_mmc_timing_mode(struct clk *clk, bool new_mode);
 int sunxi_ccu_get_mmc_timing_mode(struct clk *clk);
 #else
diff --git a/include/linux/clk/sunxi.h b/include/linux/clk/sunxi.h
new file mode 100644
index 000000000..837de7d1f
--- /dev/null
+++ b/include/linux/clk/sunxi.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2012 Maxime Ripard
+ *
+ * Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * 2013-4-17 15:43 add periph reset assert/deassert, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_CLK_SUNXI_H_
+#define __LINUX_CLK_SUNXI_H_
+
+int sunxi_periph_reset_deassert(struct clk *c);
+int sunxi_periph_reset_assert(struct clk *c);
+
+#endif
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index b21db536f..a781edc98 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -27,6 +27,8 @@ struct module;
 #include <asm/clocksource.h>
 #endif
 
+#include <vdso/clocksource.h>
+
 /**
  * struct clocksource - hardware abstraction for a free running counter
  *	Provides mostly state-free accessors to the underlying hardware.
diff --git a/include/linux/compiler-clang.h b/include/linux/compiler-clang.h
index 333a6695a..b7eea165e 100644
--- a/include/linux/compiler-clang.h
+++ b/include/linux/compiler-clang.h
@@ -42,3 +42,19 @@
  * compilers, like ICC.
  */
 #define barrier() __asm__ __volatile__("" : : : "memory")
+
+#if __has_feature(shadow_call_stack)
+# define __noscs	__attribute__((__no_sanitize__("shadow-call-stack")))
+#else
+# define __noscs
+#endif
+
+#ifdef CONFIG_LTO_CLANG
+#ifdef CONFIG_FTRACE_MCOUNT_RECORD
+#define __norecordmcount \
+	__attribute__((__section__(".text..ftrace")))
+#endif
+
+
+#define __nocfi		__attribute__((__no_sanitize__("cfi")))
+#endif
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index 72393a8c1..40d7f8992 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -104,7 +104,7 @@ struct ftrace_likely_data {
 	unsigned long			constant;
 };
 
-#ifdef CONFIG_ENABLE_MUST_CHECK
+#if defined(CONFIG_ENABLE_MUST_CHECK) && !defined(__GENKSYMS__)
 #define __must_check		__attribute__((__warn_unused_result__))
 #else
 #define __must_check
@@ -202,6 +202,18 @@ struct ftrace_likely_data {
 # define randomized_struct_fields_end
 #endif
 
+#ifndef __noscs
+# define __noscs
+#endif
+
+#ifndef __norecordmcount
+# define __norecordmcount
+#endif
+
+#ifndef __nocfi
+# define __nocfi
+#endif
+
 #ifndef asm_volatile_goto
 #define asm_volatile_goto(x...) asm goto(x)
 #endif
diff --git a/include/linux/const.h b/include/linux/const.h
index 7b55a55f5..81b8aae5a 100644
--- a/include/linux/const.h
+++ b/include/linux/const.h
@@ -1,9 +1,6 @@
 #ifndef _LINUX_CONST_H
 #define _LINUX_CONST_H
 
-#include <uapi/linux/const.h>
-
-#define UL(x)		(_UL(x))
-#define ULL(x)		(_ULL(x))
+#include <vdso/const.h>
 
 #endif /* _LINUX_CONST_H */
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 018dce868..486c1dd88 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -201,9 +201,6 @@ static inline bool policy_is_shared(struct cpufreq_policy *policy)
 	return cpumask_weight(policy->cpus) > 1;
 }
 
-/* /sys/devices/system/cpu/cpufreq: entry point for global variables */
-extern struct kobject *cpufreq_global_kobject;
-
 #ifdef CONFIG_CPU_FREQ
 unsigned int cpufreq_get(unsigned int cpu);
 unsigned int cpufreq_quick_get(unsigned int cpu);
@@ -990,6 +987,8 @@ extern unsigned int arch_freq_get_on_cpu(int cpu);
 
 extern void arch_set_freq_scale(struct cpumask *cpus, unsigned long cur_freq,
 				unsigned long max_freq);
+extern void arch_set_max_freq_scale(struct cpumask *cpus,
+				    unsigned long policy_max_freq);
 
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
diff --git a/include/linux/cpufreq_times.h b/include/linux/cpufreq_times.h
new file mode 100644
index 000000000..38272a5f3
--- /dev/null
+++ b/include/linux/cpufreq_times.h
@@ -0,0 +1,42 @@
+/* drivers/cpufreq/cpufreq_times.c
+ *
+ * Copyright (C) 2018 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_CPUFREQ_TIMES_H
+#define _LINUX_CPUFREQ_TIMES_H
+
+#include <linux/cpufreq.h>
+#include <linux/pid.h>
+
+#ifdef CONFIG_CPU_FREQ_TIMES
+void cpufreq_task_times_init(struct task_struct *p);
+void cpufreq_task_times_alloc(struct task_struct *p);
+void cpufreq_task_times_exit(struct task_struct *p);
+int proc_time_in_state_show(struct seq_file *m, struct pid_namespace *ns,
+			    struct pid *pid, struct task_struct *p);
+void cpufreq_acct_update_power(struct task_struct *p, u64 cputime);
+void cpufreq_times_create_policy(struct cpufreq_policy *policy);
+void cpufreq_times_record_transition(struct cpufreq_policy *policy,
+                                     unsigned int new_freq);
+#else
+static inline void cpufreq_task_times_init(struct task_struct *p) {}
+static inline void cpufreq_task_times_alloc(struct task_struct *p) {}
+static inline void cpufreq_task_times_exit(struct task_struct *p) {}
+static inline void cpufreq_acct_update_power(struct task_struct *p,
+					     u64 cputime) {}
+static inline void cpufreq_times_create_policy(struct cpufreq_policy *policy) {}
+static inline void cpufreq_times_record_transition(
+	struct cpufreq_policy *policy, unsigned int new_freq) {}
+#endif /* CONFIG_CPU_FREQ_TIMES */
+#endif /* _LINUX_CPUFREQ_TIMES_H */
diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h
index 2d55cee63..168b23173 100644
--- a/include/linux/cpuhotplug.h
+++ b/include/linux/cpuhotplug.h
@@ -174,6 +174,7 @@ enum cpuhp_state {
 	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE,
 	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE,
 	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE,
+	CPUHP_AP_PERF_RISCV_ONLINE,
 	CPUHP_AP_WATCHDOG_ONLINE,
 	CPUHP_AP_WORKQUEUE_ONLINE,
 	CPUHP_AP_RCUTREE_ONLINE,
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
index 4b6b5bea8..cc3a188ce 100644
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -61,10 +61,13 @@ struct cpuidle_state {
 	 * CPUs execute ->enter_s2idle with the local tick or entire timekeeping
 	 * suspended, so it must not re-enable interrupts at any point (even
 	 * temporarily) or attempt to change states of clock event devices.
+	 *
+	 * This callback may point to the same function as ->enter if all of
+	 * the above requirements are met by it.
 	 */
-	void (*enter_s2idle) (struct cpuidle_device *dev,
-			      struct cpuidle_driver *drv,
-			      int index);
+	int (*enter_s2idle)(struct cpuidle_device *dev,
+			    struct cpuidle_driver *drv,
+			    int index);
 };
 
 /* Idle State Flags */
diff --git a/include/linux/cpuset.h b/include/linux/cpuset.h
index 04c20de66..7f1478c26 100644
--- a/include/linux/cpuset.h
+++ b/include/linux/cpuset.h
@@ -55,8 +55,6 @@ extern void cpuset_init_smp(void);
 extern void cpuset_force_rebuild(void);
 extern void cpuset_update_active_cpus(void);
 extern void cpuset_wait_for_hotplug(void);
-extern void cpuset_read_lock(void);
-extern void cpuset_read_unlock(void);
 extern void cpuset_cpus_allowed(struct task_struct *p, struct cpumask *mask);
 extern void cpuset_cpus_allowed_fallback(struct task_struct *p);
 extern nodemask_t cpuset_mems_allowed(struct task_struct *p);
@@ -178,9 +176,6 @@ static inline void cpuset_update_active_cpus(void)
 
 static inline void cpuset_wait_for_hotplug(void) { }
 
-static inline void cpuset_read_lock(void) { }
-static inline void cpuset_read_unlock(void) { }
-
 static inline void cpuset_cpus_allowed(struct task_struct *p,
 				       struct cpumask *mask)
 {
diff --git a/include/linux/dcache.h b/include/linux/dcache.h
index 10090f11a..48f86c805 100644
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -13,6 +13,7 @@
 #include <linux/lockref.h>
 #include <linux/stringhash.h>
 #include <linux/wait.h>
+#include <linux/android_kabi.h>
 
 struct path;
 struct vfsmount;
@@ -118,6 +119,9 @@ struct dentry {
 		struct hlist_bl_node d_in_lookup_hash;	/* only for in-lookup ones */
 	 	struct rcu_head d_rcu;
 	} d_u;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 } __randomize_layout;
 
 /*
@@ -147,6 +151,12 @@ struct dentry_operations {
 	struct vfsmount *(*d_automount)(struct path *);
 	int (*d_manage)(const struct path *, bool);
 	struct dentry *(*d_real)(struct dentry *, const struct inode *);
+	void (*d_canonical_path)(const struct path *, struct path *);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } ____cacheline_aligned;
 
 /*
diff --git a/include/linux/debugfs.h b/include/linux/debugfs.h
index 58424eb3b..798f0b9b4 100644
--- a/include/linux/debugfs.h
+++ b/include/linux/debugfs.h
@@ -54,6 +54,8 @@ static const struct file_operations __fops = {				\
 	.llseek  = no_llseek,						\
 }
 
+typedef struct vfsmount *(*debugfs_automount_t)(struct dentry *, void *);
+
 #if defined(CONFIG_DEBUG_FS)
 
 struct dentry *debugfs_lookup(const char *name, struct dentry *parent);
@@ -75,7 +77,6 @@ struct dentry *debugfs_create_dir(const char *name, struct dentry *parent);
 struct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,
 				      const char *dest);
 
-typedef struct vfsmount *(*debugfs_automount_t)(struct dentry *, void *);
 struct dentry *debugfs_create_automount(const char *name,
 					struct dentry *parent,
 					debugfs_automount_t f,
@@ -203,7 +204,7 @@ static inline struct dentry *debugfs_create_symlink(const char *name,
 
 static inline struct dentry *debugfs_create_automount(const char *name,
 					struct dentry *parent,
-					struct vfsmount *(*f)(void *),
+					debugfs_automount_t f,
 					void *data)
 {
 	return ERR_PTR(-ENODEV);
diff --git a/include/linux/device-mapper.h b/include/linux/device-mapper.h
index e4e1f5c1f..043e6df28 100644
--- a/include/linux/device-mapper.h
+++ b/include/linux/device-mapper.h
@@ -17,6 +17,7 @@
 struct dm_dev;
 struct dm_target;
 struct dm_table;
+struct dm_report_zones_args;
 struct mapped_device;
 struct bio_vec;
 
@@ -93,9 +94,9 @@ typedef int (*dm_message_fn) (struct dm_target *ti, unsigned argc, char **argv,
 
 typedef int (*dm_prepare_ioctl_fn) (struct dm_target *ti, struct block_device **bdev);
 
-typedef int (*dm_report_zones_fn) (struct dm_target *ti, sector_t sector,
-				   struct blk_zone *zones,
-				   unsigned int *nr_zones);
+typedef int (*dm_report_zones_fn) (struct dm_target *ti,
+				   struct dm_report_zones_args *args,
+				   unsigned int nr_zones);
 
 /*
  * These iteration functions are typically used to check (and combine)
@@ -316,6 +317,12 @@ struct dm_target {
 	 * whether or not its underlying devices have support.
 	 */
 	bool discards_supported:1;
+
+	/*
+	 * Set if inline crypto capabilities from this target's underlying
+	 * device(s) can be exposed via the device-mapper device.
+	 */
+	bool may_passthrough_inline_crypto:1;
 };
 
 /* Each target can link one of these into the table */
@@ -423,10 +430,23 @@ int dm_suspended(struct dm_target *ti);
 int dm_post_suspending(struct dm_target *ti);
 int dm_noflush_suspending(struct dm_target *ti);
 void dm_accept_partial_bio(struct bio *bio, unsigned n_sectors);
-void dm_remap_zone_report(struct dm_target *ti, sector_t start,
-			  struct blk_zone *zones, unsigned int *nr_zones);
 union map_info *dm_get_rq_mapinfo(struct request *rq);
 
+#ifdef CONFIG_BLK_DEV_ZONED
+struct dm_report_zones_args {
+	struct dm_target *tgt;
+	sector_t next_sector;
+
+	void *orig_data;
+	report_zones_cb orig_cb;
+	unsigned int zone_idx;
+
+	/* must be filled by ->report_zones before calling dm_report_zones_cb */
+	sector_t start;
+};
+int dm_report_zones_cb(struct blk_zone *zone, unsigned int idx, void *data);
+#endif /* CONFIG_BLK_DEV_ZONED */
+
 /*
  * Device mapper functions to parse and create devices specified by the
  * parameter "dm-mod.create="
diff --git a/include/linux/device.h b/include/linux/device.h
index 297239a08..659624b4e 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -26,6 +26,7 @@
 #include <linux/uidgid.h>
 #include <linux/gfp.h>
 #include <linux/overflow.h>
+#include <linux/android_kabi.h>
 #include <asm/device.h>
 
 struct device;
@@ -80,6 +81,13 @@ extern void bus_remove_file(struct bus_type *, struct bus_attribute *);
  *		that generate uevents to add the environment variables.
  * @probe:	Called when a new device or driver add to this bus, and callback
  *		the specific driver's probe to initial the matched device.
+ * @sync_state:	Called to sync device state to software state after all the
+ *		state tracking consumers linked to this device (present at
+ *		the time of late_initcall) have successfully bound to a
+ *		driver. If the device has no consumers, this function will
+ *		be called at late_initcall_sync level. If the device has
+ *		consumers that are never bound to a driver, this function
+ *		will never get called until they do.
  * @remove:	Called when a device removed from this bus.
  * @shutdown:	Called at shut-down time to quiesce the device.
  *
@@ -123,6 +131,7 @@ struct bus_type {
 	int (*match)(struct device *dev, struct device_driver *drv);
 	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 	int (*probe)(struct device *dev);
+	void (*sync_state)(struct device *dev);
 	int (*remove)(struct device *dev);
 	void (*shutdown)(struct device *dev);
 
@@ -144,6 +153,11 @@ struct bus_type {
 	struct lock_class_key lock_key;
 
 	bool need_parent_lock;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 extern int __must_check bus_register(struct bus_type *bus);
@@ -340,6 +354,13 @@ enum probe_type {
  * @probe:	Called to query the existence of a specific device,
  *		whether this driver can work with it, and bind the driver
  *		to a specific device.
+ * @sync_state:	Called to sync device state to software state after all the
+ *		state tracking consumers linked to this device (present at
+ *		the time of late_initcall) have successfully bound to a
+ *		driver. If the device has no consumers, this function will
+ *		be called at late_initcall_sync level. If the device has
+ *		consumers that are never bound to a driver, this function
+ *		will never get called until they do.
  * @remove:	Called when the device is removed from the system to
  *		unbind a device from this driver.
  * @shutdown:	Called at shut-down time to quiesce the device.
@@ -379,6 +400,7 @@ struct device_driver {
 	const struct acpi_device_id	*acpi_match_table;
 
 	int (*probe) (struct device *dev);
+	void (*sync_state)(struct device *dev);
 	int (*remove) (struct device *dev);
 	void (*shutdown) (struct device *dev);
 	int (*suspend) (struct device *dev, pm_message_t state);
@@ -390,6 +412,11 @@ struct device_driver {
 	void (*coredump) (struct device *dev);
 
 	struct driver_private *p;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 
@@ -594,6 +621,11 @@ struct class {
 	const struct dev_pm_ops *pm;
 
 	struct subsys_private *p;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct class_dev_iter {
@@ -1080,6 +1112,7 @@ enum device_link_state {
  * AUTOREMOVE_SUPPLIER: Remove the link automatically on supplier driver unbind.
  * AUTOPROBE_CONSUMER: Probe consumer driver automatically after supplier binds.
  * MANAGED: The core tracks presence of supplier/consumer drivers (internal).
+ * SYNC_STATE_ONLY: Link only affects sync_state() behavior.
  */
 #define DL_FLAG_STATELESS		BIT(0)
 #define DL_FLAG_AUTOREMOVE_CONSUMER	BIT(1)
@@ -1088,34 +1121,7 @@ enum device_link_state {
 #define DL_FLAG_AUTOREMOVE_SUPPLIER	BIT(4)
 #define DL_FLAG_AUTOPROBE_CONSUMER	BIT(5)
 #define DL_FLAG_MANAGED			BIT(6)
-
-/**
- * struct device_link - Device link representation.
- * @supplier: The device on the supplier end of the link.
- * @s_node: Hook to the supplier device's list of links to consumers.
- * @consumer: The device on the consumer end of the link.
- * @c_node: Hook to the consumer device's list of links to suppliers.
- * @status: The state of the link (with respect to the presence of drivers).
- * @flags: Link flags.
- * @rpm_active: Whether or not the consumer device is runtime-PM-active.
- * @kref: Count repeated addition of the same link.
- * @rcu_head: An RCU head to use for deferred execution of SRCU callbacks.
- * @supplier_preactivated: Supplier has been made active before consumer probe.
- */
-struct device_link {
-	struct device *supplier;
-	struct list_head s_node;
-	struct device *consumer;
-	struct list_head c_node;
-	enum device_link_state status;
-	u32 flags;
-	refcount_t rpm_active;
-	struct kref kref;
-#ifdef CONFIG_SRCU
-	struct rcu_head rcu_head;
-#endif
-	bool supplier_preactivated; /* Owned by consumer probe. */
-};
+#define DL_FLAG_SYNC_STATE_ONLY		BIT(7)
 
 /**
  * enum dl_dev_state - Device driver presence tracking information.
@@ -1135,12 +1141,25 @@ enum dl_dev_state {
  * struct dev_links_info - Device data related to device links.
  * @suppliers: List of links to supplier devices.
  * @consumers: List of links to consumer devices.
+ * @needs_suppliers: Hook to global list of devices waiting for suppliers.
+ * @defer_hook: Hook to global list of devices that have deferred sync_state or
+ *		deferred fw_devlink.
+ * @need_for_probe: If needs_suppliers is on a list, this indicates if the
+ *		    suppliers are needed for probe or not.
  * @status: Driver status information.
  */
 struct dev_links_info {
 	struct list_head suppliers;
 	struct list_head consumers;
+	struct list_head needs_suppliers;
+	struct list_head defer_hook;
+	bool need_for_probe;
 	enum dl_dev_state status;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 /**
@@ -1215,6 +1234,9 @@ struct dev_links_info {
  * @offline:	Set after successful invocation of bus type's .offline().
  * @of_node_reused: Set if the device-tree node is shared with an ancestor
  *              device.
+ * @state_synced: The hardware state of this device has been synced to match
+ *		  the software state of this device by calling the driver/bus
+ *		  sync_state() callback.
  * @dma_coherent: this particular device is dma coherent, even if the
  *		architecture supports non-coherent devices.
  *
@@ -1311,11 +1333,55 @@ struct device {
 	bool			offline_disabled:1;
 	bool			offline:1;
 	bool			of_node_reused:1;
+	bool			state_synced:1;
 #if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
 	bool			dma_coherent:1;
 #endif
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+	ANDROID_KABI_RESERVE(5);
+	ANDROID_KABI_RESERVE(6);
+	ANDROID_KABI_RESERVE(7);
+	ANDROID_KABI_RESERVE(8);
+};
+
+/**
+ * struct device_link - Device link representation.
+ * @supplier: The device on the supplier end of the link.
+ * @s_node: Hook to the supplier device's list of links to consumers.
+ * @consumer: The device on the consumer end of the link.
+ * @c_node: Hook to the consumer device's list of links to suppliers.
+ * @link_dev: device used to expose link details in sysfs
+ * @status: The state of the link (with respect to the presence of drivers).
+ * @flags: Link flags.
+ * @rpm_active: Whether or not the consumer device is runtime-PM-active.
+ * @kref: Count repeated addition of the same link.
+ * @rcu_head: An RCU head to use for deferred execution of SRCU callbacks.
+ * @supplier_preactivated: Supplier has been made active before consumer probe.
+ */
+struct device_link {
+	struct device *supplier;
+	struct list_head s_node;
+	struct device *consumer;
+	struct list_head c_node;
+	struct device link_dev;
+	enum device_link_state status;
+	u32 flags;
+	refcount_t rpm_active;
+	struct kref kref;
+#ifdef CONFIG_SRCU
+	struct rcu_head rcu_head;
+#endif
+	bool supplier_preactivated; /* Owned by consumer probe. */
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 static inline struct device *kobj_to_dev(struct kobject *kobj)
@@ -1489,6 +1555,17 @@ static inline struct device_node *dev_of_node(struct device *dev)
 	return dev->of_node;
 }
 
+static inline bool dev_has_sync_state(struct device *dev)
+{
+	if (!dev)
+		return false;
+	if (dev->driver && dev->driver->sync_state)
+		return true;
+	if (dev->bus && dev->bus->sync_state)
+		return true;
+	return false;
+}
+
 void driver_init(void);
 
 /*
@@ -1653,6 +1730,8 @@ struct device_link *device_link_add(struct device *consumer,
 				    struct device *supplier, u32 flags);
 void device_link_del(struct device_link *link);
 void device_link_remove(void *consumer, struct device *supplier);
+void device_links_supplier_sync_state_pause(void);
+void device_links_supplier_sync_state_resume(void);
 
 #ifndef dev_fmt
 #define dev_fmt(fmt) fmt
@@ -1746,7 +1825,8 @@ void _dev_info(const struct device *dev, const char *fmt, ...)
 #define dev_info(dev, fmt, ...)						\
 	_dev_info(dev, dev_fmt(fmt), ##__VA_ARGS__)
 
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 #define dev_dbg(dev, fmt, ...)						\
 	dynamic_dev_dbg(dev, dev_fmt(fmt), ##__VA_ARGS__)
 #elif defined(DEBUG)
@@ -1818,7 +1898,8 @@ do {									\
 	dev_level_ratelimited(dev_notice, dev, fmt, ##__VA_ARGS__)
 #define dev_info_ratelimited(dev, fmt, ...)				\
 	dev_level_ratelimited(dev_info, dev, fmt, ##__VA_ARGS__)
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 /* descriptor check is first to prevent flooding with "callbacks suppressed" */
 #define dev_dbg_ratelimited(dev, fmt, ...)				\
 do {									\
diff --git a/include/linux/dma-buf.h b/include/linux/dma-buf.h
index 12eac4293..fe97c0bc1 100644
--- a/include/linux/dma-buf.h
+++ b/include/linux/dma-buf.h
@@ -178,6 +178,41 @@ struct dma_buf_ops {
 	 */
 	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
 
+	/**
+	 * @begin_cpu_access_partial:
+	 *
+	 * This is called from dma_buf_begin_cpu_access_partial() and allows the
+	 * exporter to ensure that the memory specified in the range is
+	 * available for cpu access - the exporter might need to allocate or
+	 * swap-in and pin the backing storage.
+	 * The exporter also needs to ensure that cpu access is
+	 * coherent for the access direction. The direction can be used by the
+	 * exporter to optimize the cache flushing, i.e. access with a different
+	 * direction (read instead of write) might return stale or even bogus
+	 * data (e.g. when the exporter needs to copy the data to temporary
+	 * storage).
+	 *
+	 * This callback is optional.
+	 *
+	 * FIXME: This is both called through the DMA_BUF_IOCTL_SYNC command
+	 * from userspace (where storage shouldn't be pinned to avoid handing
+	 * de-factor mlock rights to userspace) and for the kernel-internal
+	 * users of the various kmap interfaces, where the backing storage must
+	 * be pinned to guarantee that the atomic kmap calls can succeed. Since
+	 * there's no in-kernel users of the kmap interfaces yet this isn't a
+	 * real problem.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success or a negative error code on failure. This can for
+	 * example fail when the backing storage can't be allocated. Can also
+	 * return -ERESTARTSYS or -EINTR when the call has been interrupted and
+	 * needs to be restarted.
+	 */
+	int (*begin_cpu_access_partial)(struct dma_buf *dmabuf,
+					enum dma_data_direction,
+					unsigned int offset, unsigned int len);
+
 	/**
 	 * @end_cpu_access:
 	 *
@@ -197,6 +232,28 @@ struct dma_buf_ops {
 	 */
 	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
 
+	/**
+	 * @end_cpu_access_partial:
+	 *
+	 * This is called from dma_buf_end_cpu_access_partial() when the
+	 * importer is done accessing the CPU. The exporter can use to limit
+	 * cache flushing to only the range specefied and to unpin any
+	 * resources pinned in @begin_cpu_access_umapped.
+	 * The result of any dma_buf kmap calls after end_cpu_access_partial is
+	 * undefined.
+	 *
+	 * This callback is optional.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success or a negative error code on failure. Can return
+	 * -ERESTARTSYS or -EINTR when the call has been interrupted and needs
+	 * to be restarted.
+	 */
+	int (*end_cpu_access_partial)(struct dma_buf *dmabuf,
+				      enum dma_data_direction,
+				      unsigned int offset, unsigned int len);
+
 	/**
 	 * @mmap:
 	 *
@@ -261,6 +318,35 @@ struct dma_buf_ops {
 
 	void *(*vmap)(struct dma_buf *);
 	void (*vunmap)(struct dma_buf *, void *vaddr);
+
+	/**
+	 * @get_uuid
+	 *
+	 * This is called by dma_buf_get_uuid to get the UUID which identifies
+	 * the buffer to virtio devices.
+	 *
+	 * This callback is optional.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success or a negative error code on failure. On success uuid
+	 * will be populated with the buffer's UUID.
+	 */
+	int (*get_uuid)(struct dma_buf *dmabuf, uuid_t *uuid);
+
+	/**
+	 * @get_flags:
+	 *
+	 * This is called by dma_buf_get_flags and is used to get the buffer's
+	 * flags.
+	 * This callback is optional.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success or a negative error code on failure. On success flags
+	 * will be populated with the buffer's flags.
+	 */
+	int (*get_flags)(struct dma_buf *dmabuf, unsigned long *flags);
 };
 
 /**
@@ -328,6 +414,8 @@ struct dma_buf {
  * @sgt: cached mapping.
  * @dir: direction of cached mapping.
  * @priv: exporter specific attachment data.
+ * @dma_map_attrs: DMA attributes to be used when the exporter maps the buffer
+ * through dma_buf_map_attachment.
  *
  * This structure holds the attachment information between the dma_buf buffer
  * and its user device(s). The list contains one attachment struct per device
@@ -345,6 +433,7 @@ struct dma_buf_attachment {
 	struct sg_table *sgt;
 	enum dma_data_direction dir;
 	void *priv;
+	unsigned long dma_map_attrs;
 };
 
 /**
@@ -412,8 +501,14 @@ void dma_buf_unmap_attachment(struct dma_buf_attachment *, struct sg_table *,
 				enum dma_data_direction);
 int dma_buf_begin_cpu_access(struct dma_buf *dma_buf,
 			     enum dma_data_direction dir);
+int dma_buf_begin_cpu_access_partial(struct dma_buf *dma_buf,
+				     enum dma_data_direction dir,
+				     unsigned int offset, unsigned int len);
 int dma_buf_end_cpu_access(struct dma_buf *dma_buf,
 			   enum dma_data_direction dir);
+int dma_buf_end_cpu_access_partial(struct dma_buf *dma_buf,
+				     enum dma_data_direction dir,
+				     unsigned int offset, unsigned int len);
 void *dma_buf_kmap(struct dma_buf *, unsigned long);
 void dma_buf_kunmap(struct dma_buf *, unsigned long, void *);
 
@@ -421,4 +516,7 @@ int dma_buf_mmap(struct dma_buf *, struct vm_area_struct *,
 		 unsigned long);
 void *dma_buf_vmap(struct dma_buf *);
 void dma_buf_vunmap(struct dma_buf *, void *vaddr);
+int dma_buf_get_flags(struct dma_buf *dmabuf, unsigned long *flags);
+int dma_buf_get_uuid(struct dma_buf *dmabuf, uuid_t *uuid);
+
 #endif /* __DMA_BUF_H__ */
diff --git a/include/linux/dma-iommu.h b/include/linux/dma-iommu.h
index 2112f21f7..f51561eda 100644
--- a/include/linux/dma-iommu.h
+++ b/include/linux/dma-iommu.h
@@ -37,6 +37,11 @@ void iommu_dma_compose_msi_msg(struct msi_desc *desc,
 
 void iommu_dma_get_resv_regions(struct device *dev, struct list_head *list);
 
+int iommu_dma_reserve_iova(struct device *dev, dma_addr_t base,
+			   u64 size);
+
+int iommu_dma_enable_best_fit_algo(struct device *dev);
+
 #else /* CONFIG_IOMMU_DMA */
 
 struct iommu_domain;
@@ -78,5 +83,16 @@ static inline void iommu_dma_get_resv_regions(struct device *dev, struct list_he
 {
 }
 
+static inline int iommu_dma_reserve_iova(struct device *dev, dma_addr_t base,
+					 u64 size)
+{
+	return -ENODEV;
+}
+
+static inline int iommu_dma_enable_best_fit_algo(struct device *dev)
+{
+	return -ENODEV;
+}
+
 #endif	/* CONFIG_IOMMU_DMA */
 #endif	/* __DMA_IOMMU_H */
diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h
index 4d450672b..3828573fa 100644
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@ -11,6 +11,7 @@
 #include <linux/scatterlist.h>
 #include <linux/bug.h>
 #include <linux/mem_encrypt.h>
+#include <linux/android_kabi.h>
 
 /**
  * List of possible attributes associated with a DMA mapping. The semantics
@@ -132,6 +133,11 @@ struct dma_map_ops {
 	u64 (*get_required_mask)(struct device *dev);
 	size_t (*max_mapping_size)(struct device *dev);
 	unsigned long (*get_merge_boundary)(struct device *dev);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 #define DMA_MAPPING_ERROR		(~(dma_addr_t)0)
diff --git a/include/linux/dma/sprd-dma.h b/include/linux/dma/sprd-dma.h
index ab82df646..d09c6f6f6 100644
--- a/include/linux/dma/sprd-dma.h
+++ b/include/linux/dma/sprd-dma.h
@@ -118,6 +118,9 @@ enum sprd_dma_int_type {
  * struct sprd_dma_linklist - DMA link-list address structure
  * @virt_addr: link-list virtual address to configure link-list node
  * @phy_addr: link-list physical address to link DMA transfer
+ * @wrap_addr: the wrap address for link-list mode, which means once the
+ * transfer address reaches the wrap address, the next transfer address
+ * will jump to the address specified by wrap_to register.
  *
  * The Spreadtrum DMA controller supports the link-list mode, that means slaves
  * can supply several groups configurations (each configuration represents one
@@ -181,6 +184,7 @@ enum sprd_dma_int_type {
 struct sprd_dma_linklist {
 	unsigned long virt_addr;
 	phys_addr_t phy_addr;
+	phys_addr_t wrap_addr;
 };
 
 #endif
diff --git a/include/linux/dynamic_debug.h b/include/linux/dynamic_debug.h
index 4cf02ecd6..abcd5fde3 100644
--- a/include/linux/dynamic_debug.h
+++ b/include/linux/dynamic_debug.h
@@ -48,7 +48,7 @@ struct _ddebug {
 
 
 
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG_CORE)
 int ddebug_add_module(struct _ddebug *tab, unsigned int n,
 				const char *modname);
 extern int ddebug_remove_module(const char *mod_name);
diff --git a/include/linux/ebc.h b/include/linux/ebc.h
new file mode 100644
index 000000000..92cea367d
--- /dev/null
+++ b/include/linux/ebc.h
@@ -0,0 +1,216 @@
+/*
+ * RK29 ebook control driver rk29_ebc.h
+ *
+ * Copyright (C) 2010 RockChip, Inc.
+ * Author: <Dai Lunxue> dlx@rock-chips.com
+ *	   <Hunag Lin> hl@rock-chips.com
+ *	   <Yang Kuankuan> ykk@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef RK29_EBC_H
+#define RK29_EBC_H
+
+#include <linux/wait.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+
+
+#define RKEBC_DRV_VERSION		"2.00"
+
+#define EBC_SUCCESS			(0)
+#define EBC_ERROR			(-1)
+
+//#define DIRECT_MODE
+#define AUTO_MODE_ENABLE
+
+/* Select WAVEFORM from nand or spi flash */
+#define NAND_WAVEFORM			(0)
+#define SPI_WAVEFORM			(1)
+
+/*SET END DISPLAY*/
+#define END_RESET			(0)
+#define END_PICTURE			(1)
+
+// ebc ioctl command
+#define GET_EBC_BUFFER (0x7000)
+#define SET_EBC_SEND_BUFFER (0x7001)
+#define GET_EBC_DRIVER_SN (0x7002)
+#define GET_EBC_BUFFER_INFO (0x7003)
+
+#define EBC_DRIVER_SN "RK29_EBC_DRIVER_VERSION_1.00"
+#define EBC_DRIVER_SN_LEN sizeof(EBC_DRIVER_SN)
+
+#define ebc_printk(dir_of_file, lev, fmt) ebc_dbg_printk(dir_of_file, lev, fmt)
+
+/*
+ * IMPORTANT: Those values is corresponding to android hardware program,
+ * so *FORBID* to changes bellow values, unless you know what you're doing.
+ * And if you want to add new refresh modes, please appended to the tail.
+ */
+enum epd_refresh_mode {
+	EPD_AUTO	= 0,
+	EPD_FULL	= 1,
+	EPD_A2		= 2,
+	EPD_PART	= 3,
+	EPD_FULL_DITHER = 4,
+	EPD_RESET	= 5,
+	EPD_BLACK_WHITE = 6,
+	EPD_TEXT	= 7,
+	EPD_BLOCK	= 8,
+	EPD_FULL_WIN	= 9,
+	EPD_OED_PART	= 10,
+	EPD_DIRECT_PART	= 11,
+	EPD_DIRECT_A2	= 12,
+};
+
+#define EBC_OFF      (0)
+#define EBC_ON        (1)
+struct logo_info {
+	int logo_pic_offset;
+	int logo_end_offset;
+	int logo_power_pic_offset;
+};
+
+//ebc panel info
+struct ebc_panel {
+	int    width;
+	int    height;
+	int    hsync_len;//refer to eink spec LSL
+	int    hstart_len;//refer to eink spec LBL
+	int    vsync_len;//refer to eink spec FSL
+	int    vend_len; //refer to eink spec FEL
+	int    frame_rate;
+	int    vir_width;
+	int    vir_height;
+	int	refcount;//fixme
+	int   fb_width;
+	int   fb_height;
+	int   color_panel;
+	int   rotate;
+	int   hend_len;//refer to eink spec LEL
+	int   vstart_len; //refer to eink spec FBL
+	int   gdck_sta;//refer to eink spec GDCK_STA
+	int   lgonl;//refer to eink spec LGONL
+};
+/*struct*/
+//ebc clocks info
+struct ebc_clk {
+	struct clk      *dclk;            //ebc dclk
+	struct clk      *dclk_parent;     //ebc dclk divider frequency source
+	int dclk_status;
+	int dclk_parent_status;
+
+	struct clk	*hclk;
+	struct clk	*hclk_lcdc;
+	struct clk	*aclk_lcdc;
+	struct clk      *hclk_disp_matrix;
+	int hclk_status;
+	int hclk_lcdc_status;
+	int aclk_lcdc_status;
+	int hclk_disp_matrix_status;
+
+	struct clk	*aclk_ddr_lcdc;   //DDR LCDC AXI clock disable.
+	struct clk	*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
+	struct clk	*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
+	struct clk	*pd_display;		// display power domain
+	int aclk_ddr_lcdc_status;
+	int aclk_disp_matrix_status;
+	int hclk_cpu_display_status;
+	int pd_display_status;
+
+	int pixclock;
+};
+
+struct ebc_platform_data {
+	int (*io_init)(void);
+	int (*io_deinit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	int (*vcom_power_on)(void);
+	int (*vcom_power_off)(void);
+	int (*suspend)(struct ebc_platform_data *ebc_data);
+	int (*resume)(struct ebc_platform_data *ebc_data);
+	const char *regulator;
+};
+struct ebc_pwr_ops {
+	int (*power_on)(void);
+	int (*power_down)(void);
+};
+struct ebc_temperateure_ops {
+	int (*temperature_get)(int *temp);
+};
+
+
+/*android use struct*/
+struct ebc_buf_info {
+	int offset;
+	int epd_mode;
+	int height;
+	int width;
+	int vir_height;
+	int vir_width;
+	int fb_width;
+	int fb_height;
+	int color_panel;
+	int win_x1;
+	int win_y1;
+	int win_x2;
+	int win_y2;
+	int rotate;
+};
+
+// ebc sn
+struct ebc_sn_info {
+	u32 key;
+	u32 sn_len;
+	char cip_sn[EBC_DRIVER_SN_LEN];
+};
+
+/* modiy for open ebc ioctl */
+extern int rkebc_register_notifier(struct notifier_block *nb);
+extern int rkebc_unregister_notifier(struct notifier_block *nb);
+#ifdef CONFIG_SOFTWARE_EBC
+extern void ebc_init_lcdc(struct rk29fb_screen *screen);
+#endif
+extern int register_ebc_pwr_ops(struct ebc_pwr_ops *ops);
+//extern int register_ebc_temp_ops(struct ebc_temperateure_ops *ops);
+extern int tps65185_temperature_get(int *temp);
+
+extern int rkebc_notify(unsigned long event);
+extern int rk29ebc_notify(unsigned long event);
+extern long ebc_io_ctl(struct file *file, unsigned int cmd, unsigned long arg);
+extern int ebc_sn_encode(char *sn, char *cip_sn, int sn_len, int key);
+
+
+/* public function */
+extern void set_epd_info(struct ebc_panel *panel, struct ebc_clk *epd_clk, int *height, int *width);
+extern int set_logo_info(struct logo_info *plogo_info);
+
+/* hooks for customs */
+void ebc_io_ctl_hook(unsigned int cmd, struct ebc_buf_info *info);
+
+extern int support_pvi_waveform(void);
+extern int get_lut_position(void);
+extern int set_end_display(void);
+extern int get_bootup_logo_cycle(void);
+extern int is_bootup_ani_loop(void);
+extern int is_need_show_lowpower_pic(void);
+extern int support_bootup_ani(void);
+extern int support_double_thread_calcu(void);
+extern int get_bootup_ani_mode(void);
+extern int support_tps_3v3_always_alive(void);
+
+#endif
diff --git a/include/linux/elevator.h b/include/linux/elevator.h
index 901bda352..054d7658e 100644
--- a/include/linux/elevator.h
+++ b/include/linux/elevator.h
@@ -4,6 +4,7 @@
 
 #include <linux/percpu.h>
 #include <linux/hashtable.h>
+#include <linux/android_kabi.h>
 
 #ifdef CONFIG_BLOCK
 
@@ -50,6 +51,11 @@ struct elevator_mq_ops {
 	struct request *(*next_request)(struct request_queue *, struct request *);
 	void (*init_icq)(struct io_cq *);
 	void (*exit_icq)(struct io_cq *);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 #define ELV_NAME_MAX	(16)
@@ -86,6 +92,9 @@ struct elevator_type
 	/* managed by elevator core */
 	char icq_cache_name[ELV_NAME_MAX + 6];	/* elvname + "_io_cq" */
 	struct list_head list;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 #define ELV_HASH_BITS 6
diff --git a/include/linux/elfnote.h b/include/linux/elfnote.h
index 7fdd7f355..69b136e4d 100644
--- a/include/linux/elfnote.h
+++ b/include/linux/elfnote.h
@@ -59,7 +59,7 @@
 	ELFNOTE_END
 
 #else	/* !__ASSEMBLER__ */
-#include <linux/elf.h>
+#include <uapi/linux/elf.h>
 /*
  * Use an anonymous structure which matches the shape of
  * Elf{32,64}_Nhdr, but includes the name and desc data.  The size and
diff --git a/include/linux/ethtool.h b/include/linux/ethtool.h
index 95991e430..75e0b0049 100644
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@ -15,6 +15,7 @@
 
 #include <linux/bitmap.h>
 #include <linux/compat.h>
+#include <linux/android_kabi.h>
 #include <uapi/linux/ethtool.h>
 
 #ifdef CONFIG_COMPAT
@@ -404,6 +405,11 @@ struct ethtool_ops {
 				      struct ethtool_fecparam *);
 	void	(*get_ethtool_phy_stats)(struct net_device *,
 					 struct ethtool_stats *, u64 *);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct ethtool_rx_flow_rule {
diff --git a/include/linux/export.h b/include/linux/export.h
index 941d075f0..9f5de83cc 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -129,7 +129,7 @@ struct kernel_symbol {
 #define __EXPORT_SYMBOL_NS(sym, sec, ns)
 #define __EXPORT_SYMBOL(sym, sec)
 
-#elif defined(CONFIG_TRIM_UNUSED_KSYMS)
+#elif defined(CONFIG_TRIM_UNUSED_KSYMS) && !defined(MODULE)
 
 #include <generated/autoksyms.h>
 
diff --git a/include/linux/extcon.h b/include/linux/extcon.h
index 2bdf643d8..345bd092b 100644
--- a/include/linux/extcon.h
+++ b/include/linux/extcon.h
@@ -76,6 +76,11 @@
 #define EXTCON_DISP_VGA		43	/* Video Graphics Array */
 #define EXTCON_DISP_DP		44	/* Display Port */
 #define EXTCON_DISP_HMD		45	/* Head-Mounted Display */
+#define EXTCON_DISP_CVBS        46
+#define EXTCON_DISP_TVD         47
+#define EXTCON_DISP_EDP         48
+
+
 
 /* Miscellaneous external connector */
 #define EXTCON_DOCK		60
@@ -286,6 +291,11 @@ static inline struct extcon_dev *extcon_get_edev_by_phandle(struct device *dev,
 {
 	return ERR_PTR(-ENODEV);
 }
+
+static inline const char *extcon_get_edev_name(struct extcon_dev *edev)
+{
+	return NULL;
+}
 #endif /* CONFIG_EXTCON */
 
 /*
diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 6bb6f718a..a5dbb57a6 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -23,6 +23,7 @@
 
 #define NULL_ADDR		((block_t)0)	/* used as block_t addresses */
 #define NEW_ADDR		((block_t)-1)	/* used as block_t addresses */
+#define COMPRESS_ADDR		((block_t)-2)	/* used as compressed data flag */
 
 #define F2FS_BYTES_TO_BLK(bytes)	((bytes) >> F2FS_BLKSIZE_BITS)
 #define F2FS_BLK_TO_BYTES(blk)		((blk) << F2FS_BLKSIZE_BITS)
@@ -37,9 +38,6 @@
 #define F2FS_MAX_QUOTAS		3
 
 #define F2FS_ENC_UTF8_12_1	1
-#define F2FS_ENC_STRICT_MODE_FL	(1 << 0)
-#define f2fs_has_strict_mode(sbi) \
-	(sbi->s_encoding_flags & F2FS_ENC_STRICT_MODE_FL)
 
 #define F2FS_IO_SIZE(sbi)	(1 << F2FS_OPTION(sbi).write_io_size_bits) /* Blocks */
 #define F2FS_IO_SIZE_KB(sbi)	(1 << (F2FS_OPTION(sbi).write_io_size_bits + 2)) /* KB */
@@ -272,6 +270,10 @@ struct f2fs_inode {
 			__le32 i_inode_checksum;/* inode meta checksum */
 			__le64 i_crtime;	/* creation time */
 			__le32 i_crtime_nsec;	/* creation time in nano scale */
+			__le64 i_compr_blocks;	/* # of compressed blocks */
+			__u8 i_compress_algorithm;	/* compress algorithm */
+			__u8 i_log_cluster_size;	/* log of cluster size */
+			__le16 i_padding;		/* padding */
 			__le32 i_extra_end[0];	/* for attribute size calculation */
 		} __packed;
 		__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */
diff --git a/include/linux/fb.h b/include/linux/fb.h
index 756706b66..0fc7f2900 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -148,7 +148,7 @@ struct fb_blit_caps {
 	u32 flags;
 };
 
-#ifdef CONFIG_FB_NOTIFY
+#if IS_ENABLED(CONFIG_FB_NOTIFY) || IS_ENABLED(CONFIG_FB)
 extern int fb_register_client(struct notifier_block *nb);
 extern int fb_unregister_client(struct notifier_block *nb);
 extern int fb_notifier_call_chain(unsigned long val, void *v);
diff --git a/include/linux/filter.h b/include/linux/filter.h
index 79830bc9e..4caaa97ac 100644
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -511,7 +511,12 @@ struct sock_fprog_kern {
 	struct sock_filter	*filter;
 };
 
+#define BPF_BINARY_HEADER_MAGIC	0x05de0e82
+
 struct bpf_binary_header {
+#ifdef CONFIG_CFI_CLANG
+	u32 magic;
+#endif
 	u32 pages;
 	/* Some arches need word alignment for their instructions */
 	u8 image[] __aligned(4);
@@ -553,20 +558,75 @@ struct sk_filter {
 
 DECLARE_STATIC_KEY_FALSE(bpf_stats_enabled_key);
 
+#if IS_ENABLED(CONFIG_BPF_JIT) && IS_ENABLED(CONFIG_CFI_CLANG)
+/*
+ * With JIT, the kernel makes an indirect call to dynamically generated
+ * code. Use bpf_call_func to perform additional validation of the call
+ * target to narrow down attack surface. Architectures implementing BPF
+ * JIT can override arch_bpf_jit_check_func for arch-specific checking.
+ */
+extern bool arch_bpf_jit_check_func(const struct bpf_prog *prog);
+
+static inline unsigned int __bpf_call_func(const struct bpf_prog *prog,
+					   const void *ctx)
+{
+	/* Call interpreter with CFI checking. */
+	return prog->bpf_func(ctx, prog->insnsi);
+}
+
+static inline struct bpf_binary_header *
+bpf_jit_binary_hdr(const struct bpf_prog *fp);
+
+static inline unsigned int __nocfi bpf_call_func(const struct bpf_prog *prog,
+						 const void *ctx)
+{
+	const struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);
+
+	if (!IS_ENABLED(CONFIG_BPF_JIT_ALWAYS_ON) && !prog->jited)
+		return __bpf_call_func(prog, ctx);
+
+	/*
+	 * We are about to call dynamically generated code. Check that the
+	 * page has bpf_binary_header with a valid magic to limit possible
+	 * call targets.
+	 */
+	BUG_ON(hdr->magic != BPF_BINARY_HEADER_MAGIC ||
+		!arch_bpf_jit_check_func(prog));
+
+	/* Call jited function without CFI checking. */
+	return prog->bpf_func(ctx, prog->insnsi);
+}
+
+static inline void bpf_jit_set_header_magic(struct bpf_binary_header *hdr)
+{
+	hdr->magic = BPF_BINARY_HEADER_MAGIC;
+}
+#else
+static inline unsigned int bpf_call_func(const struct bpf_prog *prog,
+					 const void *ctx)
+{
+	return prog->bpf_func(ctx, prog->insnsi);
+}
+
+static inline void bpf_jit_set_header_magic(struct bpf_binary_header *hdr)
+{
+}
+#endif
+
 #define BPF_PROG_RUN(prog, ctx)	({				\
 	u32 ret;						\
 	cant_sleep();						\
 	if (static_branch_unlikely(&bpf_stats_enabled_key)) {	\
 		struct bpf_prog_stats *stats;			\
 		u64 start = sched_clock();			\
-		ret = (*(prog)->bpf_func)(ctx, (prog)->insnsi);	\
+		ret = bpf_call_func(prog, ctx);			\
 		stats = this_cpu_ptr(prog->aux->stats);		\
 		u64_stats_update_begin(&stats->syncp);		\
 		stats->cnt++;					\
 		stats->nsecs += sched_clock() - start;		\
 		u64_stats_update_end(&stats->syncp);		\
 	} else {						\
-		ret = (*(prog)->bpf_func)(ctx, (prog)->insnsi);	\
+		ret = bpf_call_func(prog, ctx);			\
 	}							\
 	ret; })
 
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5bd384dbd..f97c1879a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -40,9 +40,11 @@
 #include <linux/fs_types.h>
 #include <linux/build_bug.h>
 #include <linux/stddef.h>
+#include <linux/android_kabi.h>
 
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
+#include <linux/android_vendor.h>
 
 struct backing_dev_info;
 struct bdi_writeback;
@@ -407,6 +409,11 @@ struct address_space_operations {
 	int (*swap_activate)(struct swap_info_struct *sis, struct file *file,
 				sector_t *span);
 	void (*swap_deactivate)(struct file *file);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 extern const struct address_space_operations empty_aops;
@@ -462,6 +469,11 @@ struct address_space {
 	spinlock_t		private_lock;
 	struct list_head	private_list;
 	void			*private_data;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } __attribute__((aligned(sizeof(long)))) __randomize_layout;
 	/*
 	 * On most architectures that alignment is already the case; but
@@ -506,6 +518,11 @@ struct block_device {
 	int			bd_fsfreeze_count;
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } __randomize_layout;
 
 /* XArray tags, for tagging dirty and writeback pages in the pagecache. */
@@ -736,6 +753,9 @@ struct inode {
 #endif
 
 	void			*i_private; /* fs or device private pointer */
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 } __randomize_layout;
 
 struct timespec64 timestamp_truncate(struct timespec64 t, struct inode *inode);
@@ -971,6 +991,9 @@ struct file {
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
 	errseq_t		f_wb_err;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_VENDOR_DATA(1);
 } __randomize_layout
   __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
 
@@ -1030,6 +1053,9 @@ struct file_lock;
 struct file_lock_operations {
 	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
 	void (*fl_release_private)(struct file_lock *);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 struct lock_manager_operations {
@@ -1040,6 +1066,9 @@ struct lock_manager_operations {
 	bool (*lm_break)(struct file_lock *);
 	int (*lm_change)(struct file_lock *, int, struct list_head *);
 	void (*lm_setup)(struct file_lock *, void **);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 struct lock_manager {
@@ -1113,6 +1142,10 @@ struct file_lock {
 			unsigned int	debug_id;
 		} afs;
 	} fl_u;
+
+	struct list_head android_reserved1;	/* not a macro as we might just need it as-is */
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 } __randomize_layout;
 
 struct file_lock_context {
@@ -1383,6 +1416,12 @@ extern int send_sigurg(struct fown_struct *fown);
 #define SB_ACTIVE	(1<<30)
 #define SB_NOUSER	(1<<31)
 
+/* These flags relate to encoding and casefolding */
+#define SB_ENC_STRICT_MODE_FL	(1 << 0)
+
+#define sb_has_enc_strict_mode(sb) \
+	(sb->s_encoding_flags & SB_ENC_STRICT_MODE_FL)
+
 /*
  *	Umount options
  */
@@ -1450,6 +1489,10 @@ struct super_block {
 #endif
 #ifdef CONFIG_FS_VERITY
 	const struct fsverity_operations *s_vop;
+#endif
+#ifdef CONFIG_UNICODE
+	struct unicode_map *s_encoding;
+	__u16 s_encoding_flags;
 #endif
 	struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
@@ -1549,6 +1592,11 @@ struct super_block {
 
 	spinlock_t		s_inode_wblist_lock;
 	struct list_head	s_inodes_wb;	/* writeback inodes */
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } __randomize_layout;
 
 /* Helper functions so that in most cases filesystems will
@@ -1859,6 +1907,11 @@ struct file_operations {
 				   struct file *file_out, loff_t pos_out,
 				   loff_t len, unsigned int remap_flags);
 	int (*fadvise)(struct file *, loff_t, loff_t, int);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } __randomize_layout;
 
 struct inode_operations {
@@ -1889,6 +1942,11 @@ struct inode_operations {
 			   umode_t create_mode);
 	int (*tmpfile) (struct inode *, struct dentry *, umode_t);
 	int (*set_acl)(struct inode *, struct posix_acl *, int);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } ____cacheline_aligned;
 
 static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,
@@ -1957,9 +2015,13 @@ struct super_operations {
 	int (*unfreeze_fs) (struct super_block *);
 	int (*statfs) (struct dentry *, struct kstatfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);
+	void *(*clone_mnt_data) (void *);
+	void (*copy_mnt_data) (void *, void *);
+	void (*update_mnt_data) (void *, struct fs_context *);
 	void (*umount_begin) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct dentry *);
+	int (*show_options2)(struct vfsmount *,struct seq_file *, struct dentry *);
 	int (*show_devname)(struct seq_file *, struct dentry *);
 	int (*show_path)(struct seq_file *, struct dentry *);
 	int (*show_stats)(struct seq_file *, struct dentry *);
@@ -1973,6 +2035,11 @@ struct super_operations {
 				  struct shrink_control *);
 	long (*free_cached_objects)(struct super_block *,
 				    struct shrink_control *);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 /*
@@ -2140,6 +2207,10 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
  *
  * I_CREATING		New object's inode in the middle of setting up.
  *
+ * I_SYNC_QUEUED	Inode is queued in b_io or b_more_io writeback lists.
+ *			Used to detect that mark_inode_dirty() should not move
+ * 			inode between dirty lists.
+ *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  */
 #define I_DIRTY_SYNC		(1 << 0)
@@ -2157,11 +2228,10 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 #define I_DIO_WAKEUP		(1 << __I_DIO_WAKEUP)
 #define I_LINKABLE		(1 << 10)
 #define I_DIRTY_TIME		(1 << 11)
-#define __I_DIRTY_TIME_EXPIRED	12
-#define I_DIRTY_TIME_EXPIRED	(1 << __I_DIRTY_TIME_EXPIRED)
 #define I_WB_SWITCH		(1 << 13)
 #define I_OVL_INUSE		(1 << 14)
 #define I_CREATING		(1 << 15)
+#define I_SYNC_QUEUED		(1 << 17)
 
 #define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)
 #define I_DIRTY (I_DIRTY_INODE | I_DIRTY_PAGES)
@@ -2228,6 +2298,7 @@ struct file_system_type {
 	const struct fs_parameter_description *parameters;
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
+	void *(*alloc_mnt_data) (void);
 	void (*kill_sb) (struct super_block *);
 	struct module *owner;
 	struct file_system_type * next;
@@ -2241,6 +2312,11 @@ struct file_system_type {
 	struct lock_class_key i_lock_key;
 	struct lock_class_key i_mutex_key;
 	struct lock_class_key i_mutex_dir_key;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 #define MODULE_ALIAS_FS(NAME) MODULE_ALIAS("fs-" NAME)
@@ -3345,6 +3421,20 @@ extern int generic_file_fsync(struct file *, loff_t, loff_t, int);
 
 extern int generic_check_addressable(unsigned, u64);
 
+#ifdef CONFIG_UNICODE
+extern int generic_ci_d_hash(const struct dentry *dentry, struct qstr *str);
+extern int generic_ci_d_compare(const struct dentry *dentry, unsigned int len,
+				const char *str, const struct qstr *name);
+extern bool needs_casefold(const struct inode *dir);
+#else
+static inline bool needs_casefold(const struct inode *dir)
+{
+	return 0;
+}
+#endif
+extern void generic_set_encrypted_ci_d_ops(struct inode *dir,
+					   struct dentry *dentry);
+
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,
 				struct page *, struct page *,
diff --git a/include/linux/fscrypt.h b/include/linux/fscrypt.h
index f622f7460..f226673dd 100644
--- a/include/linux/fscrypt.h
+++ b/include/linux/fscrypt.h
@@ -15,13 +15,15 @@
 
 #include <linux/fs.h>
 #include <linux/mm.h>
+#include <linux/parser.h>
 #include <linux/slab.h>
 #include <uapi/linux/fscrypt.h>
 
 #define FS_CRYPTO_BLOCK_SIZE		16
 
-struct fscrypt_ctx;
+union fscrypt_context;
 struct fscrypt_info;
+struct seq_file;
 
 struct fscrypt_str {
 	unsigned char *name;
@@ -51,30 +53,29 @@ struct fscrypt_name {
  */
 #define FS_CFLG_OWN_PAGES (1U << 1)
 
+#ifdef FSCRYPT_NEED_OPS
 /*
  * crypto operations for filesystems
  */
 struct fscrypt_operations {
 	unsigned int flags;
 	const char *key_prefix;
-	int (*get_context)(struct inode *, void *, size_t);
-	int (*set_context)(struct inode *, const void *, size_t, void *);
-	bool (*dummy_context)(struct inode *);
-	bool (*empty_dir)(struct inode *);
+	int (*get_context)(struct inode *inode, void *ctx, size_t len);
+	int (*set_context)(struct inode *inode, const void *ctx, size_t len,
+			   void *fs_data);
+	const union fscrypt_context *(*get_dummy_context)(
+		struct super_block *sb);
+	bool (*empty_dir)(struct inode *inode);
 	unsigned int max_namelen;
+	bool (*has_stable_inodes)(struct super_block *sb);
+	void (*get_ino_and_lblk_bits)(struct super_block *sb,
+				      int *ino_bits_ret, int *lblk_bits_ret);
+	bool (*inline_crypt_enabled)(struct super_block *sb);
+	int (*get_num_devices)(struct super_block *sb);
+	void (*get_devices)(struct super_block *sb,
+			    struct request_queue **devs);
 };
-
-/* Decryption work */
-struct fscrypt_ctx {
-	union {
-		struct {
-			struct bio *bio;
-			struct work_struct work;
-		};
-		struct list_head free_list;	/* Free list */
-	};
-	u8 flags;				/* Flags */
-};
+#endif
 
 static inline bool fscrypt_has_encryption_key(const struct inode *inode)
 {
@@ -82,11 +83,31 @@ static inline bool fscrypt_has_encryption_key(const struct inode *inode)
 	return READ_ONCE(inode->i_crypt_info) != NULL;
 }
 
-static inline bool fscrypt_dummy_context_enabled(struct inode *inode)
+/**
+ * fscrypt_needs_contents_encryption() - check whether an inode needs
+ *					 contents encryption
+ * @inode: the inode to check
+ *
+ * Return: %true iff the inode is an encrypted regular file and the kernel was
+ * built with fscrypt support.
+ *
+ * If you need to know whether the encrypt bit is set even when the kernel was
+ * built without fscrypt support, you must use IS_ENCRYPTED() directly instead.
+ */
+static inline bool fscrypt_needs_contents_encryption(const struct inode *inode)
+{
+	return IS_ENCRYPTED(inode) && S_ISREG(inode->i_mode);
+}
+
+#ifdef FSCRYPT_NEED_OPS
+static inline const union fscrypt_context *
+fscrypt_get_dummy_context(struct super_block *sb)
 {
-	return inode->i_sb->s_cop->dummy_context &&
-		inode->i_sb->s_cop->dummy_context(inode);
+	if (!sb->s_cop->get_dummy_context)
+		return NULL;
+	return sb->s_cop->get_dummy_context(sb);
 }
+#endif
 
 /*
  * When d_splice_alias() moves a directory's encrypted alias to its decrypted
@@ -101,24 +122,21 @@ static inline void fscrypt_handle_d_move(struct dentry *dentry)
 }
 
 /* crypto.c */
-extern void fscrypt_enqueue_decrypt_work(struct work_struct *);
-extern struct fscrypt_ctx *fscrypt_get_ctx(gfp_t);
-extern void fscrypt_release_ctx(struct fscrypt_ctx *);
-
-extern struct page *fscrypt_encrypt_pagecache_blocks(struct page *page,
-						     unsigned int len,
-						     unsigned int offs,
-						     gfp_t gfp_flags);
-extern int fscrypt_encrypt_block_inplace(const struct inode *inode,
-					 struct page *page, unsigned int len,
-					 unsigned int offs, u64 lblk_num,
-					 gfp_t gfp_flags);
-
-extern int fscrypt_decrypt_pagecache_blocks(struct page *page, unsigned int len,
-					    unsigned int offs);
-extern int fscrypt_decrypt_block_inplace(const struct inode *inode,
-					 struct page *page, unsigned int len,
-					 unsigned int offs, u64 lblk_num);
+void fscrypt_enqueue_decrypt_work(struct work_struct *);
+
+struct page *fscrypt_encrypt_pagecache_blocks(struct page *page,
+					      unsigned int len,
+					      unsigned int offs,
+					      gfp_t gfp_flags);
+int fscrypt_encrypt_block_inplace(const struct inode *inode, struct page *page,
+				  unsigned int len, unsigned int offs,
+				  u64 lblk_num, gfp_t gfp_flags);
+
+int fscrypt_decrypt_pagecache_blocks(struct page *page, unsigned int len,
+				     unsigned int offs);
+int fscrypt_decrypt_block_inplace(const struct inode *inode, struct page *page,
+				  unsigned int len, unsigned int offs,
+				  u64 lblk_num);
 
 static inline bool fscrypt_is_bounce_page(struct page *page)
 {
@@ -130,145 +148,91 @@ static inline struct page *fscrypt_pagecache_page(struct page *bounce_page)
 	return (struct page *)page_private(bounce_page);
 }
 
-extern void fscrypt_free_bounce_page(struct page *bounce_page);
+void fscrypt_free_bounce_page(struct page *bounce_page);
+int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags);
 
 /* policy.c */
-extern int fscrypt_ioctl_set_policy(struct file *, const void __user *);
-extern int fscrypt_ioctl_get_policy(struct file *, void __user *);
-extern int fscrypt_ioctl_get_policy_ex(struct file *, void __user *);
-extern int fscrypt_has_permitted_context(struct inode *, struct inode *);
-extern int fscrypt_inherit_context(struct inode *, struct inode *,
-					void *, bool);
+int fscrypt_ioctl_set_policy(struct file *filp, const void __user *arg);
+int fscrypt_ioctl_get_policy(struct file *filp, void __user *arg);
+int fscrypt_ioctl_get_policy_ex(struct file *filp, void __user *arg);
+int fscrypt_ioctl_get_nonce(struct file *filp, void __user *arg);
+int fscrypt_has_permitted_context(struct inode *parent, struct inode *child);
+int fscrypt_inherit_context(struct inode *parent, struct inode *child,
+			    void *fs_data, bool preload);
+
+struct fscrypt_dummy_context {
+	const union fscrypt_context *ctx;
+};
+
+int fscrypt_set_test_dummy_encryption(struct super_block *sb,
+				      const substring_t *arg,
+				      struct fscrypt_dummy_context *dummy_ctx);
+void fscrypt_show_test_dummy_encryption(struct seq_file *seq, char sep,
+					struct super_block *sb);
+static inline void
+fscrypt_free_dummy_context(struct fscrypt_dummy_context *dummy_ctx)
+{
+	kfree(dummy_ctx->ctx);
+	dummy_ctx->ctx = NULL;
+}
+
 /* keyring.c */
-extern void fscrypt_sb_free(struct super_block *sb);
-extern int fscrypt_ioctl_add_key(struct file *filp, void __user *arg);
-extern int fscrypt_ioctl_remove_key(struct file *filp, void __user *arg);
-extern int fscrypt_ioctl_remove_key_all_users(struct file *filp,
-					      void __user *arg);
-extern int fscrypt_ioctl_get_key_status(struct file *filp, void __user *arg);
+void fscrypt_sb_free(struct super_block *sb);
+int fscrypt_ioctl_add_key(struct file *filp, void __user *arg);
+int fscrypt_ioctl_remove_key(struct file *filp, void __user *arg);
+int fscrypt_ioctl_remove_key_all_users(struct file *filp, void __user *arg);
+int fscrypt_ioctl_get_key_status(struct file *filp, void __user *arg);
 
 /* keysetup.c */
-extern int fscrypt_get_encryption_info(struct inode *);
-extern void fscrypt_put_encryption_info(struct inode *);
-extern void fscrypt_free_inode(struct inode *);
-extern int fscrypt_drop_inode(struct inode *inode);
+int fscrypt_get_encryption_info(struct inode *inode);
+void fscrypt_put_encryption_info(struct inode *inode);
+void fscrypt_free_inode(struct inode *inode);
+int fscrypt_drop_inode(struct inode *inode);
 
 /* fname.c */
-extern int fscrypt_setup_filename(struct inode *, const struct qstr *,
-				int lookup, struct fscrypt_name *);
+int fscrypt_setup_filename(struct inode *inode, const struct qstr *iname,
+			   int lookup, struct fscrypt_name *fname);
 
 static inline void fscrypt_free_filename(struct fscrypt_name *fname)
 {
 	kfree(fname->crypto_buf.name);
 }
 
-extern int fscrypt_fname_alloc_buffer(const struct inode *, u32,
-				struct fscrypt_str *);
-extern void fscrypt_fname_free_buffer(struct fscrypt_str *);
-extern int fscrypt_fname_disk_to_usr(struct inode *, u32, u32,
-			const struct fscrypt_str *, struct fscrypt_str *);
-
-#define FSCRYPT_FNAME_MAX_UNDIGESTED_SIZE	32
-
-/* Extracts the second-to-last ciphertext block; see explanation below */
-#define FSCRYPT_FNAME_DIGEST(name, len)	\
-	((name) + round_down((len) - FS_CRYPTO_BLOCK_SIZE - 1, \
-			     FS_CRYPTO_BLOCK_SIZE))
-
-#define FSCRYPT_FNAME_DIGEST_SIZE	FS_CRYPTO_BLOCK_SIZE
-
-/**
- * fscrypt_digested_name - alternate identifier for an on-disk filename
- *
- * When userspace lists an encrypted directory without access to the key,
- * filenames whose ciphertext is longer than FSCRYPT_FNAME_MAX_UNDIGESTED_SIZE
- * bytes are shown in this abbreviated form (base64-encoded) rather than as the
- * full ciphertext (base64-encoded).  This is necessary to allow supporting
- * filenames up to NAME_MAX bytes, since base64 encoding expands the length.
- *
- * To make it possible for filesystems to still find the correct directory entry
- * despite not knowing the full on-disk name, we encode any filesystem-specific
- * 'hash' and/or 'minor_hash' which the filesystem may need for its lookups,
- * followed by the second-to-last ciphertext block of the filename.  Due to the
- * use of the CBC-CTS encryption mode, the second-to-last ciphertext block
- * depends on the full plaintext.  (Note that ciphertext stealing causes the
- * last two blocks to appear "flipped".)  This makes accidental collisions very
- * unlikely: just a 1 in 2^128 chance for two filenames to collide even if they
- * share the same filesystem-specific hashes.
- *
- * However, this scheme isn't immune to intentional collisions, which can be
- * created by anyone able to create arbitrary plaintext filenames and view them
- * without the key.  Making the "digest" be a real cryptographic hash like
- * SHA-256 over the full ciphertext would prevent this, although it would be
- * less efficient and harder to implement, especially since the filesystem would
- * need to calculate it for each directory entry examined during a search.
- */
-struct fscrypt_digested_name {
-	u32 hash;
-	u32 minor_hash;
-	u8 digest[FSCRYPT_FNAME_DIGEST_SIZE];
-};
-
-/**
- * fscrypt_match_name() - test whether the given name matches a directory entry
- * @fname: the name being searched for
- * @de_name: the name from the directory entry
- * @de_name_len: the length of @de_name in bytes
- *
- * Normally @fname->disk_name will be set, and in that case we simply compare
- * that to the name stored in the directory entry.  The only exception is that
- * if we don't have the key for an encrypted directory and a filename in it is
- * very long, then we won't have the full disk_name and we'll instead need to
- * match against the fscrypt_digested_name.
- *
- * Return: %true if the name matches, otherwise %false.
- */
-static inline bool fscrypt_match_name(const struct fscrypt_name *fname,
-				      const u8 *de_name, u32 de_name_len)
-{
-	if (unlikely(!fname->disk_name.name)) {
-		const struct fscrypt_digested_name *n =
-			(const void *)fname->crypto_buf.name;
-		if (WARN_ON_ONCE(fname->usr_fname->name[0] != '_'))
-			return false;
-		if (de_name_len <= FSCRYPT_FNAME_MAX_UNDIGESTED_SIZE)
-			return false;
-		return !memcmp(FSCRYPT_FNAME_DIGEST(de_name, de_name_len),
-			       n->digest, FSCRYPT_FNAME_DIGEST_SIZE);
-	}
-
-	if (de_name_len != fname->disk_name.len)
-		return false;
-	return !memcmp(de_name, fname->disk_name.name, fname->disk_name.len);
-}
+int fscrypt_fname_alloc_buffer(const struct inode *inode, u32 max_encrypted_len,
+			       struct fscrypt_str *crypto_str);
+void fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str);
+int fscrypt_fname_disk_to_usr(const struct inode *inode,
+			      u32 hash, u32 minor_hash,
+			      const struct fscrypt_str *iname,
+			      struct fscrypt_str *oname);
+bool fscrypt_match_name(const struct fscrypt_name *fname,
+			const u8 *de_name, u32 de_name_len);
+u64 fscrypt_fname_siphash(const struct inode *dir, const struct qstr *name);
 
 /* bio.c */
-extern void fscrypt_decrypt_bio(struct bio *);
-extern void fscrypt_enqueue_decrypt_bio(struct fscrypt_ctx *ctx,
-					struct bio *bio);
-extern int fscrypt_zeroout_range(const struct inode *, pgoff_t, sector_t,
-				 unsigned int);
+void fscrypt_decrypt_bio(struct bio *bio);
+int fscrypt_zeroout_range(const struct inode *inode, pgoff_t lblk,
+			  sector_t pblk, unsigned int len);
 
 /* hooks.c */
-extern int fscrypt_file_open(struct inode *inode, struct file *filp);
-extern int __fscrypt_prepare_link(struct inode *inode, struct inode *dir,
-				  struct dentry *dentry);
-extern int __fscrypt_prepare_rename(struct inode *old_dir,
-				    struct dentry *old_dentry,
-				    struct inode *new_dir,
-				    struct dentry *new_dentry,
-				    unsigned int flags);
-extern int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry,
-				    struct fscrypt_name *fname);
-extern int __fscrypt_prepare_symlink(struct inode *dir, unsigned int len,
-				     unsigned int max_len,
-				     struct fscrypt_str *disk_link);
-extern int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
-				     unsigned int len,
-				     struct fscrypt_str *disk_link);
-extern const char *fscrypt_get_symlink(struct inode *inode, const void *caddr,
-				       unsigned int max_size,
-				       struct delayed_call *done);
+int fscrypt_file_open(struct inode *inode, struct file *filp);
+int __fscrypt_prepare_link(struct inode *inode, struct inode *dir,
+			   struct dentry *dentry);
+int __fscrypt_prepare_rename(struct inode *old_dir, struct dentry *old_dentry,
+			     struct inode *new_dir, struct dentry *new_dentry,
+			     unsigned int flags);
+int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry,
+			     struct fscrypt_name *fname);
+int fscrypt_prepare_setflags(struct inode *inode,
+			     unsigned int oldflags, unsigned int flags);
+int __fscrypt_prepare_symlink(struct inode *dir, unsigned int len,
+			      unsigned int max_len,
+			      struct fscrypt_str *disk_link);
+int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
+			      unsigned int len, struct fscrypt_str *disk_link);
+const char *fscrypt_get_symlink(struct inode *inode, const void *caddr,
+				unsigned int max_size,
+				struct delayed_call *done);
 static inline void fscrypt_set_ops(struct super_block *sb,
 				   const struct fscrypt_operations *s_cop)
 {
@@ -281,28 +245,24 @@ static inline bool fscrypt_has_encryption_key(const struct inode *inode)
 	return false;
 }
 
-static inline bool fscrypt_dummy_context_enabled(struct inode *inode)
+static inline bool fscrypt_needs_contents_encryption(const struct inode *inode)
 {
 	return false;
 }
 
-static inline void fscrypt_handle_d_move(struct dentry *dentry)
+static inline const union fscrypt_context *
+fscrypt_get_dummy_context(struct super_block *sb)
 {
+	return NULL;
 }
 
-/* crypto.c */
-static inline void fscrypt_enqueue_decrypt_work(struct work_struct *work)
-{
-}
-
-static inline struct fscrypt_ctx *fscrypt_get_ctx(gfp_t gfp_flags)
+static inline void fscrypt_handle_d_move(struct dentry *dentry)
 {
-	return ERR_PTR(-EOPNOTSUPP);
 }
 
-static inline void fscrypt_release_ctx(struct fscrypt_ctx *ctx)
+/* crypto.c */
+static inline void fscrypt_enqueue_decrypt_work(struct work_struct *work)
 {
-	return;
 }
 
 static inline struct page *fscrypt_encrypt_pagecache_blocks(struct page *page,
@@ -370,6 +330,11 @@ static inline int fscrypt_ioctl_get_policy_ex(struct file *filp,
 	return -EOPNOTSUPP;
 }
 
+static inline int fscrypt_ioctl_get_nonce(struct file *filp, void __user *arg)
+{
+	return -EOPNOTSUPP;
+}
+
 static inline int fscrypt_has_permitted_context(struct inode *parent,
 						struct inode *child)
 {
@@ -383,6 +348,20 @@ static inline int fscrypt_inherit_context(struct inode *parent,
 	return -EOPNOTSUPP;
 }
 
+struct fscrypt_dummy_context {
+};
+
+static inline void fscrypt_show_test_dummy_encryption(struct seq_file *seq,
+						      char sep,
+						      struct super_block *sb)
+{
+}
+
+static inline void
+fscrypt_free_dummy_context(struct fscrypt_dummy_context *dummy_ctx)
+{
+}
+
 /* keyring.c */
 static inline void fscrypt_sb_free(struct super_block *sb)
 {
@@ -462,7 +441,7 @@ static inline void fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str)
 	return;
 }
 
-static inline int fscrypt_fname_disk_to_usr(struct inode *inode,
+static inline int fscrypt_fname_disk_to_usr(const struct inode *inode,
 					    u32 hash, u32 minor_hash,
 					    const struct fscrypt_str *iname,
 					    struct fscrypt_str *oname)
@@ -479,13 +458,15 @@ static inline bool fscrypt_match_name(const struct fscrypt_name *fname,
 	return !memcmp(de_name, fname->disk_name.name, fname->disk_name.len);
 }
 
-/* bio.c */
-static inline void fscrypt_decrypt_bio(struct bio *bio)
+static inline u64 fscrypt_fname_siphash(const struct inode *dir,
+					const struct qstr *name)
 {
+	WARN_ON_ONCE(1);
+	return 0;
 }
 
-static inline void fscrypt_enqueue_decrypt_bio(struct fscrypt_ctx *ctx,
-					       struct bio *bio)
+/* bio.c */
+static inline void fscrypt_decrypt_bio(struct bio *bio)
 {
 }
 
@@ -526,6 +507,13 @@ static inline int __fscrypt_prepare_lookup(struct inode *dir,
 	return -EOPNOTSUPP;
 }
 
+static inline int fscrypt_prepare_setflags(struct inode *inode,
+					   unsigned int oldflags,
+					   unsigned int flags)
+{
+	return 0;
+}
+
 static inline int __fscrypt_prepare_symlink(struct inode *dir,
 					    unsigned int len,
 					    unsigned int max_len,
@@ -558,8 +546,95 @@ static inline void fscrypt_set_ops(struct super_block *sb,
 
 #endif	/* !CONFIG_FS_ENCRYPTION */
 
+/* inline_crypt.c */
+#ifdef CONFIG_FS_ENCRYPTION_INLINE_CRYPT
+extern bool fscrypt_inode_uses_inline_crypto(const struct inode *inode);
+
+extern bool fscrypt_inode_uses_fs_layer_crypto(const struct inode *inode);
+
+extern void fscrypt_set_bio_crypt_ctx(struct bio *bio,
+				      const struct inode *inode,
+				      u64 first_lblk, gfp_t gfp_mask);
+
+extern void fscrypt_set_bio_crypt_ctx_bh(struct bio *bio,
+					 const struct buffer_head *first_bh,
+					 gfp_t gfp_mask);
+
+extern bool fscrypt_mergeable_bio(struct bio *bio, const struct inode *inode,
+				  u64 next_lblk);
+
+extern bool fscrypt_mergeable_bio_bh(struct bio *bio,
+				     const struct buffer_head *next_bh);
+
+bool fscrypt_dio_supported(struct kiocb *iocb, struct iov_iter *iter);
+
+int fscrypt_limit_dio_pages(const struct inode *inode, loff_t pos,
+			    int nr_pages);
+
+#else /* CONFIG_FS_ENCRYPTION_INLINE_CRYPT */
+static inline bool fscrypt_inode_uses_inline_crypto(const struct inode *inode)
+{
+	return false;
+}
+
+static inline bool fscrypt_inode_uses_fs_layer_crypto(const struct inode *inode)
+{
+	return IS_ENCRYPTED(inode) && S_ISREG(inode->i_mode);
+}
+
+static inline void fscrypt_set_bio_crypt_ctx(struct bio *bio,
+					     const struct inode *inode,
+					     u64 first_lblk, gfp_t gfp_mask) { }
+
+static inline void fscrypt_set_bio_crypt_ctx_bh(
+					 struct bio *bio,
+					 const struct buffer_head *first_bh,
+					 gfp_t gfp_mask) { }
+
+static inline bool fscrypt_mergeable_bio(struct bio *bio,
+					 const struct inode *inode,
+					 u64 next_lblk)
+{
+	return true;
+}
+
+static inline bool fscrypt_mergeable_bio_bh(struct bio *bio,
+					    const struct buffer_head *next_bh)
+{
+	return true;
+}
+
+static inline bool fscrypt_dio_supported(struct kiocb *iocb,
+					 struct iov_iter *iter)
+{
+	const struct inode *inode = file_inode(iocb->ki_filp);
+
+	return !fscrypt_needs_contents_encryption(inode);
+}
+
+static inline int fscrypt_limit_dio_pages(const struct inode *inode, loff_t pos,
+					  int nr_pages)
+{
+	return nr_pages;
+}
+#endif /* !CONFIG_FS_ENCRYPTION_INLINE_CRYPT */
+
+#if IS_ENABLED(CONFIG_FS_ENCRYPTION) && IS_ENABLED(CONFIG_DM_DEFAULT_KEY)
+static inline bool
+fscrypt_inode_should_skip_dm_default_key(const struct inode *inode)
+{
+	return IS_ENCRYPTED(inode) && S_ISREG(inode->i_mode);
+}
+#else
+static inline bool
+fscrypt_inode_should_skip_dm_default_key(const struct inode *inode)
+{
+	return false;
+}
+#endif
+
 /**
- * fscrypt_require_key - require an inode's encryption key
+ * fscrypt_require_key() - require an inode's encryption key
  * @inode: the inode we need the key for
  *
  * If the inode is encrypted, set up its encryption key if not already done.
@@ -585,7 +660,8 @@ static inline int fscrypt_require_key(struct inode *inode)
 }
 
 /**
- * fscrypt_prepare_link - prepare to link an inode into a possibly-encrypted directory
+ * fscrypt_prepare_link() - prepare to link an inode into a possibly-encrypted
+ *			    directory
  * @old_dentry: an existing dentry for the inode being linked
  * @dir: the target directory
  * @dentry: negative dentry for the target filename
@@ -612,7 +688,8 @@ static inline int fscrypt_prepare_link(struct dentry *old_dentry,
 }
 
 /**
- * fscrypt_prepare_rename - prepare for a rename between possibly-encrypted directories
+ * fscrypt_prepare_rename() - prepare for a rename between possibly-encrypted
+ *			      directories
  * @old_dir: source directory
  * @old_dentry: dentry for source file
  * @new_dir: target directory
@@ -645,7 +722,8 @@ static inline int fscrypt_prepare_rename(struct inode *old_dir,
 }
 
 /**
- * fscrypt_prepare_lookup - prepare to lookup a name in a possibly-encrypted directory
+ * fscrypt_prepare_lookup() - prepare to lookup a name in a possibly-encrypted
+ *			      directory
  * @dir: directory being searched
  * @dentry: filename being looked up
  * @fname: (output) the name to use to search the on-disk directory
@@ -656,8 +734,9 @@ static inline int fscrypt_prepare_rename(struct inode *old_dir,
  * filenames are presented in encrypted form.  Therefore, we'll try to set up
  * the directory's encryption key, but even without it the lookup can continue.
  *
- * This also installs a custom ->d_revalidate() method which will invalidate the
- * dentry if it was created without the key and the key is later added.
+ * After calling this function, a filesystem should ensure that it's dentry
+ * operations contain fscrypt_d_revalidate if DCACHE_ENCRYPTED_NAME was set,
+ * so that the dentry can be invalidated if the key is later added.
  *
  * Return: 0 on success; -ENOENT if key is unavailable but the filename isn't a
  * correctly formed encoded ciphertext name, so a negative dentry should be
@@ -678,7 +757,8 @@ static inline int fscrypt_prepare_lookup(struct inode *dir,
 }
 
 /**
- * fscrypt_prepare_setattr - prepare to change a possibly-encrypted inode's attributes
+ * fscrypt_prepare_setattr() - prepare to change a possibly-encrypted inode's
+ *			       attributes
  * @dentry: dentry through which the inode is being changed
  * @attr: attributes to change
  *
@@ -703,7 +783,7 @@ static inline int fscrypt_prepare_setattr(struct dentry *dentry,
 }
 
 /**
- * fscrypt_prepare_symlink - prepare to create a possibly-encrypted symlink
+ * fscrypt_prepare_symlink() - prepare to create a possibly-encrypted symlink
  * @dir: directory in which the symlink is being created
  * @target: plaintext symlink target
  * @len: length of @target excluding null terminator
@@ -725,13 +805,14 @@ static inline int fscrypt_prepare_setattr(struct dentry *dentry,
  * -ENOKEY if the encryption key is missing, or another -errno code if a problem
  * occurred while setting up the encryption key.
  */
+#ifdef FSCRYPT_NEED_OPS
 static inline int fscrypt_prepare_symlink(struct inode *dir,
 					  const char *target,
 					  unsigned int len,
 					  unsigned int max_len,
 					  struct fscrypt_str *disk_link)
 {
-	if (IS_ENCRYPTED(dir) || fscrypt_dummy_context_enabled(dir))
+	if (IS_ENCRYPTED(dir) || fscrypt_get_dummy_context(dir->i_sb) != NULL)
 		return __fscrypt_prepare_symlink(dir, len, max_len, disk_link);
 
 	disk_link->name = (unsigned char *)target;
@@ -740,9 +821,10 @@ static inline int fscrypt_prepare_symlink(struct inode *dir,
 		return -ENAMETOOLONG;
 	return 0;
 }
+#endif
 
 /**
- * fscrypt_encrypt_symlink - encrypt the symlink target if needed
+ * fscrypt_encrypt_symlink() - encrypt the symlink target if needed
  * @inode: symlink inode
  * @target: plaintext symlink target
  * @len: length of @target excluding null terminator
diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
index a2d5d175d..e018872b0 100644
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -262,6 +262,7 @@ static inline void fsnotify_modify(struct file *file)
 static inline void fsnotify_open(struct file *file)
 {
 	const struct path *path = &file->f_path;
+	struct path lower_path;
 	struct inode *inode = file_inode(file);
 	__u32 mask = FS_OPEN;
 
@@ -270,6 +271,12 @@ static inline void fsnotify_open(struct file *file)
 	if (file->f_flags & __FMODE_EXEC)
 		mask |= FS_OPEN_EXEC;
 
+	if (path->dentry->d_op && path->dentry->d_op->d_canonical_path) {
+		path->dentry->d_op->d_canonical_path(path, &lower_path);
+		fsnotify_parent(&lower_path, NULL, mask);
+		fsnotify(lower_path.dentry->d_inode, mask, &lower_path, FSNOTIFY_EVENT_PATH, NULL, 0);
+		path_put(&lower_path);
+	}
 	fsnotify_path(inode, path, mask);
 }
 
diff --git a/include/linux/fsverity.h b/include/linux/fsverity.h
index 3b6b8cceb..78201a6d3 100644
--- a/include/linux/fsverity.h
+++ b/include/linux/fsverity.h
@@ -77,6 +77,10 @@ struct fsverity_operations {
 	 *
 	 * @inode: the inode
 	 * @index: 0-based index of the page within the Merkle tree
+	 * @num_ra_pages: The number of Merkle tree pages that should be
+	 *		  prefetched starting at @index if the page at @index
+	 *		  isn't already cached.  Implementations may ignore this
+	 *		  argument; it's only a performance optimization.
 	 *
 	 * This can be called at any time on an open verity file, as well as
 	 * between ->begin_enable_verity() and ->end_enable_verity().  It may be
@@ -87,7 +91,8 @@ struct fsverity_operations {
 	 * Return: the page on success, ERR_PTR() on failure
 	 */
 	struct page *(*read_merkle_tree_page)(struct inode *inode,
-					      pgoff_t index);
+					      pgoff_t index,
+					      unsigned long num_ra_pages);
 
 	/**
 	 * Write a Merkle tree block to the given inode.
@@ -116,23 +121,23 @@ static inline struct fsverity_info *fsverity_get_info(const struct inode *inode)
 
 /* enable.c */
 
-extern int fsverity_ioctl_enable(struct file *filp, const void __user *arg);
+int fsverity_ioctl_enable(struct file *filp, const void __user *arg);
 
 /* measure.c */
 
-extern int fsverity_ioctl_measure(struct file *filp, void __user *arg);
+int fsverity_ioctl_measure(struct file *filp, void __user *arg);
 
 /* open.c */
 
-extern int fsverity_file_open(struct inode *inode, struct file *filp);
-extern int fsverity_prepare_setattr(struct dentry *dentry, struct iattr *attr);
-extern void fsverity_cleanup_inode(struct inode *inode);
+int fsverity_file_open(struct inode *inode, struct file *filp);
+int fsverity_prepare_setattr(struct dentry *dentry, struct iattr *attr);
+void fsverity_cleanup_inode(struct inode *inode);
 
 /* verify.c */
 
-extern bool fsverity_verify_page(struct page *page);
-extern void fsverity_verify_bio(struct bio *bio);
-extern void fsverity_enqueue_verify_work(struct work_struct *work);
+bool fsverity_verify_page(struct page *page);
+void fsverity_verify_bio(struct bio *bio);
+void fsverity_enqueue_verify_work(struct work_struct *work);
 
 #else /* !CONFIG_FS_VERITY */
 
@@ -195,6 +200,7 @@ static inline void fsverity_enqueue_verify_work(struct work_struct *work)
 
 /**
  * fsverity_active() - do reads from the inode need to go through fs-verity?
+ * @inode: inode to check
  *
  * This checks whether ->i_verity_info has been set.
  *
@@ -202,6 +208,8 @@ static inline void fsverity_enqueue_verify_work(struct work_struct *work)
  * be verified or not.  Don't use IS_VERITY() for this purpose; it's subject to
  * a race condition where the file is being read concurrently with
  * FS_IOC_ENABLE_VERITY completing.  (S_VERITY is set before ->i_verity_info.)
+ *
+ * Return: true if reads need to go through fs-verity, otherwise false
  */
 static inline bool fsverity_active(const struct inode *inode)
 {
diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index ababd6bc8..3ee8bbde1 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -10,6 +10,7 @@
 #define _LINUX_FWNODE_H_
 
 #include <linux/types.h>
+#include <linux/android_kabi.h>
 
 struct fwnode_operations;
 struct device;
@@ -17,6 +18,12 @@ struct device;
 struct fwnode_handle {
 	struct fwnode_handle *secondary;
 	const struct fwnode_operations *ops;
+	struct device *dev;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 /**
@@ -65,6 +72,44 @@ struct fwnode_reference_args {
  *			       endpoint node.
  * @graph_get_port_parent: Return the parent node of a port node.
  * @graph_parse_endpoint: Parse endpoint for port and endpoint id.
+ * @add_links:	Called after the device corresponding to the fwnode is added
+ *		using device_add(). The function is expected to create device
+ *		links to all the suppliers of the device that are available at
+ *		the time this function is called.  The function must NOT stop
+ *		at the first failed device link if other unlinked supplier
+ *		devices are present in the system.  This is necessary for the
+ *		driver/bus sync_state() callbacks to work correctly.
+ *
+ *		For example, say Device-C depends on suppliers Device-S1 and
+ *		Device-S2 and the dependency is listed in that order in the
+ *		firmware.  Say, S1 gets populated from the firmware after
+ *		late_initcall_sync().  Say S2 is populated and probed way
+ *		before that in device_initcall(). When C is populated, if this
+ *		add_links() function doesn't continue past a "failed linking to
+ *		S1" and continue linking C to S2, then S2 will get a
+ *		sync_state() callback before C is probed. This is because from
+ *		the perspective of S2, C was never a consumer when its
+ *		sync_state() evaluation is done. To avoid this, the add_links()
+ *		function has to go through all available suppliers of the
+ *		device (that corresponds to this fwnode) and link to them
+ *		before returning.
+ *
+ *		If some suppliers are not yet available (indicated by an error
+ *		return value), this function will be called again when other
+ *		devices are added to allow creating device links to any newly
+ *		available suppliers.
+ *
+ *		Return 0 if device links have been successfully created to all
+ *		the known suppliers of this device or if the supplier
+ *		information is not known.
+ *
+ *		Return -ENODEV if the suppliers needed for probing this device
+ *		have not been registered yet (because device links can only be
+ *		created to devices registered with the driver core).
+ *
+ *		Return -EAGAIN if some of the suppliers of this device have not
+ *		been registered yet, but none of those suppliers are necessary
+ *		for probing the device.
  */
 struct fwnode_operations {
 	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
@@ -102,6 +147,8 @@ struct fwnode_operations {
 	(*graph_get_port_parent)(struct fwnode_handle *fwnode);
 	int (*graph_parse_endpoint)(const struct fwnode_handle *fwnode,
 				    struct fwnode_endpoint *endpoint);
+	int (*add_links)(const struct fwnode_handle *fwnode,
+			 struct device *dev);
 };
 
 #define fwnode_has_op(fwnode, op)				\
@@ -123,5 +170,8 @@ struct fwnode_operations {
 		if (fwnode_has_op(fwnode, op))				\
 			(fwnode)->ops->op(fwnode, ## __VA_ARGS__);	\
 	} while (false)
+#define get_dev_from_fwnode(fwnode)	get_device((fwnode)->dev)
 
+void fw_devlink_pause(void);
+void fw_devlink_resume(void);
 #endif
diff --git a/include/linux/g2d_driver.h b/include/linux/g2d_driver.h
new file mode 100644
index 000000000..db038d364
--- /dev/null
+++ b/include/linux/g2d_driver.h
@@ -0,0 +1,530 @@
+/* g2d_driver.h
+ *
+ * Copyright (c)	2011 xxxx Electronics
+ *					2011 Yupu Tang
+ *
+ * @ F23 G2D driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __G2D_DRIVER_H
+#define __G2D_DRIVER_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+
+/* data format */
+typedef enum {
+	G2D_FORMAT_ARGB8888,
+	G2D_FORMAT_ABGR8888,
+	G2D_FORMAT_RGBA8888,
+	G2D_FORMAT_BGRA8888,
+	G2D_FORMAT_XRGB8888,
+	G2D_FORMAT_XBGR8888,
+	G2D_FORMAT_RGBX8888,
+	G2D_FORMAT_BGRX8888,
+	G2D_FORMAT_RGB888,
+	G2D_FORMAT_BGR888,
+	G2D_FORMAT_RGB565,
+	G2D_FORMAT_BGR565,
+	G2D_FORMAT_ARGB4444,
+	G2D_FORMAT_ABGR4444,
+	G2D_FORMAT_RGBA4444,
+	G2D_FORMAT_BGRA4444,
+	G2D_FORMAT_ARGB1555,
+	G2D_FORMAT_ABGR1555,
+	G2D_FORMAT_RGBA5551,
+	G2D_FORMAT_BGRA5551,
+	G2D_FORMAT_ARGB2101010,
+	G2D_FORMAT_ABGR2101010,
+	G2D_FORMAT_RGBA1010102,
+	G2D_FORMAT_BGRA1010102,
+
+	/* invailed for UI channel */
+	G2D_FORMAT_IYUV422_V0Y1U0Y0 = 0x20,
+	G2D_FORMAT_IYUV422_Y1V0Y0U0,
+	G2D_FORMAT_IYUV422_U0Y1V0Y0,
+	G2D_FORMAT_IYUV422_Y1U0Y0V0,
+
+	G2D_FORMAT_YUV422UVC_V1U1V0U0,
+	G2D_FORMAT_YUV422UVC_U1V1U0V0,
+	G2D_FORMAT_YUV422_PLANAR,
+
+	G2D_FORMAT_YUV420UVC_V1U1V0U0 = 0x28,
+	G2D_FORMAT_YUV420UVC_U1V1U0V0,
+	G2D_FORMAT_YUV420_PLANAR,
+
+	G2D_FORMAT_YUV411UVC_V1U1V0U0 = 0x2c,
+	G2D_FORMAT_YUV411UVC_U1V1U0V0,
+	G2D_FORMAT_YUV411_PLANAR,
+
+	G2D_FORMAT_Y8 = 0x30,
+
+	/* YUV 10bit format */
+	G2D_FORMAT_YVU10_P010 = 0x34,
+
+	G2D_FORMAT_YVU10_P210 = 0x36,
+
+	G2D_FORMAT_YVU10_444 = 0x38,
+	G2D_FORMAT_YUV10_444 = 0x39,
+	G2D_FORMAT_MAX,
+} g2d_fmt_enh;
+/* mixer data format */
+typedef enum {
+	/* share data format */
+	G2D_FMT_ARGB_AYUV8888	= (0x0),
+	G2D_FMT_BGRA_VUYA8888	= (0x1),
+	G2D_FMT_ABGR_AVUY8888	= (0x2),
+	G2D_FMT_RGBA_YUVA8888	= (0x3),
+
+	G2D_FMT_XRGB8888		= (0x4),
+	G2D_FMT_BGRX8888		= (0x5),
+	G2D_FMT_XBGR8888		= (0x6),
+	G2D_FMT_RGBX8888		= (0x7),
+
+	G2D_FMT_ARGB4444		= (0x8),
+	G2D_FMT_ABGR4444		= (0x9),
+	G2D_FMT_RGBA4444		= (0xA),
+	G2D_FMT_BGRA4444		= (0xB),
+
+	G2D_FMT_ARGB1555		= (0xC),
+	G2D_FMT_ABGR1555		= (0xD),
+	G2D_FMT_RGBA5551		= (0xE),
+	G2D_FMT_BGRA5551		= (0xF),
+
+	G2D_FMT_RGB565			= (0x10),
+	G2D_FMT_BGR565			= (0x11),
+
+	G2D_FMT_IYUV422			= (0x12),
+
+	G2D_FMT_8BPP_MONO		= (0x13),
+	G2D_FMT_4BPP_MONO		= (0x14),
+	G2D_FMT_2BPP_MONO		= (0x15),
+	G2D_FMT_1BPP_MONO		= (0x16),
+
+	G2D_FMT_PYUV422UVC		= (0x17),
+	G2D_FMT_PYUV420UVC		= (0x18),
+	G2D_FMT_PYUV411UVC		= (0x19),
+
+	/* just for output format */
+	G2D_FMT_PYUV422			= (0x1A),
+	G2D_FMT_PYUV420			= (0x1B),
+	G2D_FMT_PYUV411			= (0x1C),
+
+	/* just for input format */
+	G2D_FMT_8BPP_PALETTE	= (0x1D),
+	G2D_FMT_4BPP_PALETTE	= (0x1E),
+	G2D_FMT_2BPP_PALETTE	= (0x1F),
+	G2D_FMT_1BPP_PALETTE	= (0x20),
+
+	G2D_FMT_PYUV422UVC_MB16	= (0x21),
+	G2D_FMT_PYUV420UVC_MB16	= (0x22),
+	G2D_FMT_PYUV411UVC_MB16	= (0x23),
+	G2D_FMT_PYUV422UVC_MB32	= (0x24),
+	G2D_FMT_PYUV420UVC_MB32	= (0x25),
+	G2D_FMT_PYUV411UVC_MB32	= (0x26),
+	G2D_FMT_PYUV422UVC_MB64	= (0x27),
+	G2D_FMT_PYUV420UVC_MB64	= (0x28),
+	G2D_FMT_PYUV411UVC_MB64	= (0x29),
+	G2D_FMT_PYUV422UVC_MB128 = (0x2A),
+	G2D_FMT_PYUV420UVC_MB128 = (0x2B),
+	G2D_FMT_PYUV411UVC_MB128 = (0x2C),
+
+} g2d_data_fmt;
+
+/* pixel sequence in double word */
+typedef enum {
+	G2D_SEQ_NORMAL = 0x0,
+
+	/* for interleaved yuv422 */
+	G2D_SEQ_VYUY   = 0x1,			/* pixel 0�ڵ�16λ */
+	G2D_SEQ_YVYU   = 0x2,			/* pixel 1�ڵ�16λ */
+
+	/* for uv_combined yuv420 */
+	G2D_SEQ_VUVU   = 0x3,
+
+	/* for 16bpp rgb */
+	G2D_SEQ_P10    = 0x4,			/* pixel 0�ڵ�16λ */
+	G2D_SEQ_P01    = 0x5,			/* pixel 1�ڵ�16λ */
+
+	/* planar format or 8bpp rgb */
+	G2D_SEQ_P3210  = 0x6,			/* pixel 0�ڵ�8λ */
+	G2D_SEQ_P0123  = 0x7,			/* pixel 3�ڵ�8λ */
+
+	/* for 4bpp rgb */
+	G2D_SEQ_P76543210  = 0x8,			/* 7,6,5,4,3,2,1,0 */
+	G2D_SEQ_P67452301  = 0x9,			/* 6,7,4,5,2,3,0,1 */
+	G2D_SEQ_P10325476  = 0xA,			/* 1,0,3,2,5,4,7,6 */
+	G2D_SEQ_P01234567  = 0xB,			/* 0,1,2,3,4,5,6,7 */
+
+	/* for 2bpp rgb */
+	/* 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 */
+	G2D_SEQ_2BPP_BIG_BIG       = 0xC,
+	/* 12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3 */
+	G2D_SEQ_2BPP_BIG_LITTER    = 0xD,
+	/* 3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12 */
+	G2D_SEQ_2BPP_LITTER_BIG    = 0xE,
+	/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 */
+	G2D_SEQ_2BPP_LITTER_LITTER = 0xF,
+
+	/* for 1bpp rgb */
+	/* 31,30,29,28,27,26,25,24,23,22,21,20,
+	 * 19,18,17,16,15,14,13,12,11,10,9,8,7,
+	 * 6,5,4,3,2,1,0
+	 */
+	G2D_SEQ_1BPP_BIG_BIG       = 0x10,
+	/* 24,25,26,27,28,29,30,31,16,17,
+	 * 18,19,20,21,22,23,8,9,10,11,12,
+	 * 13,14,15,0,1,2,3,4,5,6,7
+	 */
+	G2D_SEQ_1BPP_BIG_LITTER    = 0x11,
+	/* 7,6,5,4,3,2,1,0,15,14,13,12,11,
+	 * 10,9,8,23,22,21,20,19,18,17,16,
+	 * 31,30,29,28,27,26,25,24
+	 */
+	G2D_SEQ_1BPP_LITTER_BIG    = 0x12,
+	/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,
+	 * 14,15,16,17,18,19,20,21,22,23,24,
+	 * 25,26,27,28,29,30,31
+	 */
+	G2D_SEQ_1BPP_LITTER_LITTER = 0x13,
+} g2d_pixel_seq;
+
+/*  */
+typedef enum {
+	G2D_BLT_NONE_H = 0x0,
+	G2D_BLT_BLACKNESS,
+	G2D_BLT_NOTMERGEPEN,
+	G2D_BLT_MASKNOTPEN,
+	G2D_BLT_NOTCOPYPEN,
+	G2D_BLT_MASKPENNOT,
+	G2D_BLT_NOT,
+	G2D_BLT_XORPEN,
+	G2D_BLT_NOTMASKPEN,
+	G2D_BLT_MASKPEN,
+	G2D_BLT_NOTXORPEN,
+	G2D_BLT_NOP,
+	G2D_BLT_MERGENOTPEN,
+	G2D_BLT_COPYPEN,
+	G2D_BLT_MERGEPENNOT,
+	G2D_BLT_MERGEPEN,
+	G2D_BLT_WHITENESS = 0x000000ff,
+
+	G2D_ROT_90  = 0x00000100,
+	G2D_ROT_180 = 0x00000200,
+	G2D_ROT_270 = 0x00000300,
+	G2D_ROT_0   = 0x00000400,
+	G2D_ROT_H = 0x00001000,
+	G2D_ROT_V = 0x00002000,
+
+/*	G2D_SM_TDLR_1  =    0x10000000, */
+	G2D_SM_DTLR_1 = 0x10000000,
+/*	G2D_SM_TDRL_1  =    0x20000000, */
+/*	G2D_SM_DTRL_1  =    0x30000000, */
+} g2d_blt_flags_h;
+
+/* ROP3 command */
+typedef enum {
+	G2D_ROP3_BLACKNESS = 0x00,
+	G2D_ROP3_NOTSRCERASE = 0x11,
+	G2D_ROP3_NOTSRCCOPY = 0x33,
+	G2D_ROP3_SRCERASE = 0x44,
+	G2D_ROP3_DSTINVERT = 0x55,
+	G2D_ROP3_PATINVERT = 0x5A,
+	G2D_ROP3_SRCINVERT = 0x66,
+	G2D_ROP3_SRCAND = 0x88,
+	G2D_ROP3_MERGEPAINT = 0xBB,
+	G2D_ROP3_MERGECOPY = 0xC0,
+	G2D_ROP3_SRCCOPY = 0xCC,
+	G2D_ROP3_SRCPAINT = 0xEE,
+	G2D_ROP3_PATCOPY = 0xF0,
+	G2D_ROP3_PATPAINT = 0xFB,
+	G2D_ROP3_WHITENESS = 0xFF,
+} g2d_rop3_cmd_flag;
+
+typedef enum {
+	G2D_FIL_NONE			= 0x00000000,
+	G2D_FIL_PIXEL_ALPHA		= 0x00000001,
+	G2D_FIL_PLANE_ALPHA		= 0x00000002,
+	G2D_FIL_MULTI_ALPHA		= 0x00000004,
+} g2d_fillrect_flags;
+
+typedef enum {
+	G2D_BLT_NONE			= 0x00000000,
+	G2D_BLT_PIXEL_ALPHA		= 0x00000001,
+	G2D_BLT_PLANE_ALPHA		= 0x00000002,
+	G2D_BLT_MULTI_ALPHA		= 0x00000004,
+	G2D_BLT_SRC_COLORKEY	= 0x00000008,
+	G2D_BLT_DST_COLORKEY	= 0x00000010,
+	G2D_BLT_FLIP_HORIZONTAL	= 0x00000020,
+	G2D_BLT_FLIP_VERTICAL	= 0x00000040,
+	G2D_BLT_ROTATE90		= 0x00000080,
+	G2D_BLT_ROTATE180		= 0x00000100,
+	G2D_BLT_ROTATE270		= 0x00000200,
+	G2D_BLT_MIRROR45		= 0x00000400,
+	G2D_BLT_MIRROR135		= 0x00000800,
+	G2D_BLT_SRC_PREMULTIPLY	= 0x00001000,
+	G2D_BLT_DST_PREMULTIPLY	= 0x00002000,
+} g2d_blt_flags;
+
+/* BLD LAYER ALPHA MODE*/
+typedef enum {
+	G2D_PIXEL_ALPHA,
+	G2D_GLOBAL_ALPHA,
+	G2D_MIXER_ALPHA,
+} g2d_alpha_mode_enh;
+
+/* flip rectangle struct */
+typedef struct {
+	__s32		x;		/* left top point coordinate x */
+	__s32		y;		/* left top point coordinate y */
+	__u32		w;		/* rectangle width */
+	__u32		h;		/* rectangle height */
+} g2d_rect;
+
+/* g2d color gamut */
+typedef enum {
+	G2D_BT601,
+	G2D_BT709,
+	G2D_BT2020,
+} g2d_color_gmt;
+
+/* image struct */
+typedef struct {
+	__u32		addr[3];/* base addr of image frame buffer in byte */
+	__u32		w;	/* width of image frame buffer in pixel */
+	__u32		h;	/* height of image frame buffer in pixel */
+	g2d_data_fmt	format;	/* pixel format of image frame buffer */
+	g2d_pixel_seq	pixel_seq;/* pixel sequence of image frame buffer */
+} g2d_image;
+
+typedef struct {
+	/* left point coordinate x of dst rect */
+	unsigned int x;
+	/* top point coordinate y of dst rect */
+	unsigned int y;
+} g2d_coor;
+
+enum color_range {
+	COLOR_RANGE_0_255 = 0,
+	COLOR_RANGE_16_235 = 1,
+};
+
+/* image struct */
+typedef struct {
+	int		 bbuff;
+	__u32		 color;
+	g2d_fmt_enh	 format;
+	__u32		 laddr[3];
+	__u32		 haddr[3];
+	__u32		 width;
+	__u32		 height;
+	__u32		 align[3];
+
+	g2d_rect	 clip_rect;
+	g2d_coor	 coor;
+
+	g2d_color_gmt	 gamut;
+	int		 bpremul;
+	__u8		 alpha;
+	g2d_alpha_mode_enh mode;
+	int		 fd;
+	__u32 use_phy_addr;
+	enum color_range color_range;
+} g2d_image_enh;
+
+/*
+ * 0:Top to down, Left to right
+ * 1:Top to down, Right to left
+ * 2:Down to top, Left to right
+ * 3:Down to top, Right to left
+ */
+enum g2d_scan_order {
+	G2D_SM_TDLR = 0x00000000,
+	G2D_SM_TDRL = 0x00000001,
+	G2D_SM_DTLR = 0x00000002,
+	G2D_SM_DTRL = 0x00000003,
+};
+
+typedef struct {
+	g2d_fillrect_flags	 flag;
+	g2d_image			 dst_image;
+	g2d_rect			 dst_rect;
+
+	__u32				 color;		/* fill color */
+	__u32				 alpha;		/* plane alpha value */
+
+} g2d_fillrect;
+
+typedef struct {
+	g2d_image_enh dst_image_h;
+} g2d_fillrect_h;
+
+typedef struct {
+	g2d_blt_flags		flag;
+	g2d_image		src_image;
+	g2d_rect		src_rect;
+
+	g2d_image		dst_image;
+	/* left top point coordinate x of dst rect */
+	__s32			dst_x;
+	/* left top point coordinate y of dst rect */
+	__s32			dst_y;
+
+	__u32			color;		/* colorkey color */
+	__u32			alpha;		/* plane alpha value */
+
+} g2d_blt;
+
+typedef struct {
+	g2d_blt_flags_h flag_h;
+	g2d_image_enh src_image_h;
+	g2d_image_enh dst_image_h;
+} g2d_blt_h;
+
+typedef struct {
+	g2d_blt_h blt;
+	__u32	lbc_cmp_ratio;
+	bool	enc_is_lossy;
+	bool	dec_is_lossy;
+} g2d_lbc_rot;
+
+typedef struct {
+	g2d_blt_flags			 flag;
+	g2d_image			 src_image;
+	g2d_rect			 src_rect;
+
+	g2d_image			 dst_image;
+	g2d_rect			 dst_rect;
+
+	__u32				 color;		/* colorkey color */
+	__u32				 alpha;		/* plane alpha value */
+
+
+} g2d_stretchblt;
+
+typedef struct {
+	g2d_rop3_cmd_flag back_flag;
+	g2d_rop3_cmd_flag fore_flag;
+
+	g2d_image_enh dst_image_h;
+	g2d_image_enh src_image_h;
+	g2d_image_enh ptn_image_h;
+	g2d_image_enh mask_image_h;
+
+} g2d_maskblt;
+
+/* Porter Duff BLD command*/
+typedef enum {
+	G2D_BLD_CLEAR = 0x00000001,
+	G2D_BLD_COPY = 0x00000002,
+	G2D_BLD_DST = 0x00000003,
+	G2D_BLD_SRCOVER = 0x00000004,
+	G2D_BLD_DSTOVER = 0x00000005,
+	G2D_BLD_SRCIN = 0x00000006,
+	G2D_BLD_DSTIN = 0x00000007,
+	G2D_BLD_SRCOUT = 0x00000008,
+	G2D_BLD_DSTOUT = 0x00000009,
+	G2D_BLD_SRCATOP = 0x0000000a,
+	G2D_BLD_DSTATOP = 0x0000000b,
+	G2D_BLD_XOR = 0x0000000c,
+	G2D_CK_SRC = 0x00010000,
+	G2D_CK_DST = 0x00020000,
+} g2d_bld_cmd_flag;
+
+typedef struct {
+	__u32		*pbuffer;
+	__u32		 size;
+
+} g2d_palette;
+
+
+
+typedef struct {
+	long	start;
+	long	end;
+} g2d_cache_range;
+
+/* CK PARA struct */
+typedef struct {
+	bool match_rule;
+/*	int match_rule; */
+	__u32 max_color;
+	__u32 min_color;
+} g2d_ck;
+
+typedef struct {
+	g2d_bld_cmd_flag bld_cmd;
+	g2d_image_enh dst_image;
+	g2d_image_enh src_image[4];/*now only ch0 and ch3*/
+	g2d_ck ck_para;
+} g2d_bld;			/* blending enhance */
+
+typedef enum {
+	OP_FILLRECT = 0x1,
+	OP_BITBLT = 0x2,
+	OP_BLEND = 0x4,
+	OP_MASK = 0x8,
+	OP_SPLIT_MEM = 0x10,
+} g2d_operation_flag;
+
+/**
+ * mixer_para
+ */
+struct mixer_para {
+	g2d_operation_flag op_flag;
+	g2d_blt_flags_h flag_h;
+	g2d_rop3_cmd_flag back_flag;
+	g2d_rop3_cmd_flag fore_flag;
+	g2d_bld_cmd_flag bld_cmd;
+	g2d_image_enh src_image_h;
+	g2d_image_enh dst_image_h;
+	g2d_image_enh ptn_image_h;
+	g2d_image_enh mask_image_h;
+	g2d_ck ck_para;
+};
+
+#define SUNXI_G2D_IOC_MAGIC 'G'
+#define SUNXI_G2D_IO(nr)          _IO(SUNXI_G2D_IOC_MAGIC, nr)
+#define SUNXI_G2D_IOR(nr, size)   _IOR(SUNXI_G2D_IOC_MAGIC, nr, size)
+#define SUNXI_G2D_IOW(nr, size)   _IOW(SUNXI_G2D_IOC_MAGIC, nr, size)
+#define SUNXI_G2D_IOWR(nr, size)  _IOWR(SUNXI_G2D_IOC_MAGIC, nr, size)
+
+typedef enum {
+	G2D_CMD_BITBLT			=	0x50,
+	G2D_CMD_FILLRECT		=	0x51,
+	G2D_CMD_STRETCHBLT		=	0x52,
+	G2D_CMD_PALETTE_TBL		=	0x53,
+	G2D_CMD_QUEUE			=	0x54,
+	G2D_CMD_BITBLT_H		=	0x55,
+	G2D_CMD_FILLRECT_H		=	0x56,
+	G2D_CMD_BLD_H			=	0x57,
+	G2D_CMD_MASK_H			=	0x58,
+
+	G2D_CMD_MEM_REQUEST		=	0x59,
+	G2D_CMD_MEM_RELEASE		=	0x5A,
+	G2D_CMD_MEM_GETADR		=	0x5B,
+	G2D_CMD_MEM_SELIDX		=	0x5C,
+	G2D_CMD_MEM_FLUSH_CACHE		=	0x5D,
+	G2D_CMD_INVERTED_ORDER		=	0x5E,
+	G2D_CMD_MIXER_TASK		=	0x5F,
+	G2D_CMD_LBC_ROT			=	0x60,
+	G2D_CMD_CREATE_TASK = SUNXI_G2D_IOW(0x1, struct mixer_para),
+	G2D_CMD_TASK_APPLY = SUNXI_G2D_IOW(0x2, struct mixer_para),
+	G2D_CMD_TASK_DESTROY = SUNXI_G2D_IOW(0x3, unsigned int),
+	G2D_CMD_TASK_GET_PARA = SUNXI_G2D_IOR(0x4, struct mixer_para),
+
+} g2d_cmd;
+
+#endif	/* __G2D_DRIVER_H */
+
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index 62a2ec9f1..b3dc87b3e 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -17,6 +17,7 @@
 #include <linux/percpu-refcount.h>
 #include <linux/uuid.h>
 #include <linux/blk_types.h>
+#include <linux/android_kabi.h>
 #include <asm/local.h>
 
 #ifdef CONFIG_BLOCK
@@ -131,6 +132,11 @@ struct hd_struct {
 #endif
 	struct percpu_ref ref;
 	struct rcu_work rcu_work;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 #define GENHD_FL_REMOVABLE			1
@@ -175,6 +181,9 @@ struct blk_integrity {
 	unsigned char				tuple_size;
 	unsigned char				interval_exp;
 	unsigned char				tag_size;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 #endif	/* CONFIG_BLK_DEV_INTEGRITY */
@@ -219,6 +228,12 @@ struct gendisk {
 	int node_id;
 	struct badblocks *bb;
 	struct lockdep_map lockdep_map;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+
 };
 
 static inline struct gendisk *part_to_disk(struct hd_struct *part)
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 61f2f6ff9..d8a9836e0 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -44,6 +44,7 @@ struct vm_area_struct;
 #else
 #define ___GFP_NOLOCKDEP	0
 #endif
+#define ___GFP_CMA		0x1000000u
 /* If the above are modified, __GFP_BITS_SHIFT may need updating */
 
 /*
@@ -57,6 +58,7 @@ struct vm_area_struct;
 #define __GFP_HIGHMEM	((__force gfp_t)___GFP_HIGHMEM)
 #define __GFP_DMA32	((__force gfp_t)___GFP_DMA32)
 #define __GFP_MOVABLE	((__force gfp_t)___GFP_MOVABLE)  /* ZONE_MOVABLE allowed */
+#define __GFP_CMA	((__force gfp_t)___GFP_CMA)
 #define GFP_ZONEMASK	(__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)
 
 /**
@@ -217,8 +219,13 @@ struct vm_area_struct;
 #define __GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)
 
 /* Room for N __GFP_FOO bits */
-#define __GFP_BITS_SHIFT (23 + IS_ENABLED(CONFIG_LOCKDEP))
+#define __GFP_BITS_SHIFT (25)
+#ifdef CONFIG_LOCKDEP
 #define __GFP_BITS_MASK ((__force gfp_t)((1 << __GFP_BITS_SHIFT) - 1))
+#else
+#define __GFP_BITS_MASK (((__force gfp_t)((1 << __GFP_BITS_SHIFT) - 1)) & \
+				~0x800000u)
+#endif
 
 /**
  * DOC: Useful GFP flag combinations
diff --git a/include/linux/hdmi.h b/include/linux/hdmi.h
index 9918a6c91..216e25ea0 100644
--- a/include/linux/hdmi.h
+++ b/include/linux/hdmi.h
@@ -155,7 +155,7 @@ enum hdmi_content_type {
 };
 
 enum hdmi_metadata_type {
-	HDMI_STATIC_METADATA_TYPE1 = 1,
+	HDMI_STATIC_METADATA_TYPE1 = 0,
 };
 
 enum hdmi_eotf {
diff --git a/include/linux/hid.h b/include/linux/hid.h
index 875f71132..c7044a142 100644
--- a/include/linux/hid.h
+++ b/include/linux/hid.h
@@ -959,34 +959,49 @@ static inline void hid_device_io_stop(struct hid_device *hid) {
  * @max: maximal valid usage->code to consider later (out parameter)
  * @type: input event type (EV_KEY, EV_REL, ...)
  * @c: code which corresponds to this usage and type
+ *
+ * The value pointed to by @bit will be set to NULL if either @type is
+ * an unhandled event type, or if @c is out of range for @type. This
+ * can be used as an error condition.
  */
 static inline void hid_map_usage(struct hid_input *hidinput,
 		struct hid_usage *usage, unsigned long **bit, int *max,
-		__u8 type, __u16 c)
+		__u8 type, unsigned int c)
 {
 	struct input_dev *input = hidinput->input;
-
-	usage->type = type;
-	usage->code = c;
+	unsigned long *bmap = NULL;
+	unsigned int limit = 0;
 
 	switch (type) {
 	case EV_ABS:
-		*bit = input->absbit;
-		*max = ABS_MAX;
+		bmap = input->absbit;
+		limit = ABS_MAX;
 		break;
 	case EV_REL:
-		*bit = input->relbit;
-		*max = REL_MAX;
+		bmap = input->relbit;
+		limit = REL_MAX;
 		break;
 	case EV_KEY:
-		*bit = input->keybit;
-		*max = KEY_MAX;
+		bmap = input->keybit;
+		limit = KEY_MAX;
 		break;
 	case EV_LED:
-		*bit = input->ledbit;
-		*max = LED_MAX;
+		bmap = input->ledbit;
+		limit = LED_MAX;
 		break;
 	}
+
+	if (unlikely(c > limit || !bmap)) {
+		pr_warn_ratelimited("%s: Invalid code %d type %d\n",
+				    input->name, c, type);
+		*bit = NULL;
+		return;
+	}
+
+	usage->type = type;
+	usage->code = c;
+	*max = limit;
+	*bit = bmap;
 }
 
 /**
@@ -1000,7 +1015,8 @@ static inline void hid_map_usage_clear(struct hid_input *hidinput,
 		__u8 type, __u16 c)
 {
 	hid_map_usage(hidinput, usage, bit, max, type, c);
-	clear_bit(c, *bit);
+	if (*bit)
+		clear_bit(usage->code, *bit);
 }
 
 /**
diff --git a/include/linux/highmem.h b/include/linux/highmem.h
index ea5cdbd8c..9d6afc38b 100644
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@ -205,7 +205,12 @@ static inline struct page *
 alloc_zeroed_user_highpage_movable(struct vm_area_struct *vma,
 					unsigned long vaddr)
 {
+#ifndef CONFIG_CMA
 	return __alloc_zeroed_user_highpage(__GFP_MOVABLE, vma, vaddr);
+#else
+	return __alloc_zeroed_user_highpage(__GFP_MOVABLE|__GFP_CMA, vma,
+						vaddr);
+#endif
 }
 
 static inline void clear_highpage(struct page *page)
diff --git a/include/linux/hrtimer.h b/include/linux/hrtimer.h
index 1f98b5211..8c50d7b00 100644
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -19,6 +19,7 @@
 #include <linux/percpu.h>
 #include <linux/timer.h>
 #include <linux/timerqueue.h>
+#include <linux/android_kabi.h>
 
 struct hrtimer_clock_base;
 struct hrtimer_cpu_base;
@@ -123,6 +124,8 @@ struct hrtimer {
 	u8				is_rel;
 	u8				is_soft;
 	u8				is_hard;
+
+	ANDROID_KABI_RESERVE(1);
 };
 
 /**
diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h
index 93d5cf0bc..1c9d7ed1f 100644
--- a/include/linux/huge_mm.h
+++ b/include/linux/huge_mm.h
@@ -309,6 +309,7 @@ static inline bool transhuge_vma_suitable(struct vm_area_struct *vma,
 }
 
 static inline void prep_transhuge_page(struct page *page) {}
+static inline void free_transhuge_page(struct page *page) {}
 
 #define transparent_hugepage_flags 0UL
 
diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h
index 624d2643b..a04858644 100644
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -2060,6 +2060,28 @@ ieee80211_he_ppe_size(u8 ppe_thres_hdr, const u8 *phy_cap_info)
 #define IEEE80211_HE_OPERATION_PARTIAL_BSS_COLOR		0x40000000
 #define IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED		0x80000000
 
+/**
+ * ieee80211_he_6ghz_oper - HE 6 GHz operation Information field
+ * @primary: primary channel
+ * @control: control flags
+ * @ccfs0: channel center frequency segment 0
+ * @ccfs1: channel center frequency segment 1
+ * @minrate: minimum rate (in 1 Mbps units)
+ */
+struct ieee80211_he_6ghz_oper {
+	u8 primary;
+#define IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH	0x3
+#define		IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_20MHZ	0
+#define		IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_40MHZ	1
+#define		IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_80MHZ	2
+#define		IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_160MHZ	3
+#define IEEE80211_HE_6GHZ_OPER_CTRL_DUP_BEACON	0x4
+	u8 control;
+	u8 ccfs0;
+	u8 ccfs1;
+	u8 minrate;
+} __packed;
+
 /*
  * ieee80211_he_oper_size - calculate 802.11ax HE Operations IE size
  * @he_oper_ie: byte data of the He Operations IE, stating from the the byte
@@ -2086,7 +2108,7 @@ ieee80211_he_oper_size(const u8 *he_oper_ie)
 	if (he_oper_params & IEEE80211_HE_OPERATION_CO_HOSTED_BSS)
 		oper_len++;
 	if (he_oper_params & IEEE80211_HE_OPERATION_6GHZ_OP_INFO)
-		oper_len += 4;
+		oper_len += sizeof(struct ieee80211_he_6ghz_oper);
 
 	/* Add the first byte (extension ID) to the total length */
 	oper_len++;
@@ -2094,6 +2116,34 @@ ieee80211_he_oper_size(const u8 *he_oper_ie)
 	return oper_len;
 }
 
+/**
+ * ieee80211_he_6ghz_oper - obtain 6 GHz operation field
+ * @he_oper: HE operation element (must be pre-validated for size)
+ *	but may be %NULL
+ *
+ * Return: a pointer to the 6 GHz operation field, or %NULL
+ */
+static inline const struct ieee80211_he_6ghz_oper *
+ieee80211_he_6ghz_oper(const struct ieee80211_he_operation *he_oper)
+{
+	const u8 *ret = (void *)&he_oper->optional;
+	u32 he_oper_params;
+
+	if (!he_oper)
+		return NULL;
+
+	he_oper_params = le32_to_cpu(he_oper->he_oper_params);
+
+	if (!(he_oper_params & IEEE80211_HE_OPERATION_6GHZ_OP_INFO))
+		return NULL;
+	if (he_oper_params & IEEE80211_HE_OPERATION_VHT_OPER_INFO)
+		ret += 3;
+	if (he_oper_params & IEEE80211_HE_OPERATION_CO_HOSTED_BSS)
+		ret++;
+
+	return (void *)ret;
+}
+
 /* HE Spatial Reuse defines */
 #define IEEE80211_HE_SPR_NON_SRG_OFFSET_PRESENT			0x4
 #define IEEE80211_HE_SPR_SRG_INFORMATION_PRESENT		0x8
@@ -2553,9 +2603,19 @@ enum ieee80211_eid_ext {
 	WLAN_EID_EXT_UORA = 37,
 	WLAN_EID_EXT_HE_MU_EDCA = 38,
 	WLAN_EID_EXT_HE_SPR = 39,
+	WLAN_EID_EXT_NDP_FEEDBACK_REPORT_PARAMSET = 41,
+	WLAN_EID_EXT_BSS_COLOR_CHG_ANN = 42,
+	WLAN_EID_EXT_QUIET_TIME_PERIOD_SETUP = 43,
+	WLAN_EID_EXT_ESS_REPORT = 45,
+	WLAN_EID_EXT_OPS = 46,
+	WLAN_EID_EXT_HE_BSS_LOAD = 47,
 	WLAN_EID_EXT_MAX_CHANNEL_SWITCH_TIME = 52,
 	WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION = 55,
 	WLAN_EID_EXT_NON_INHERITANCE = 56,
+	WLAN_EID_EXT_KNOWN_BSSID = 57,
+	WLAN_EID_EXT_SHORT_SSID_LIST = 58,
+	WLAN_EID_EXT_HE_6GHZ_CAPA = 59,
+	WLAN_EID_EXT_UL_MU_POWER_CAPA = 60,
 };
 
 /* Action category code */
@@ -3097,6 +3157,24 @@ struct ieee80211_tspec_ie {
 	__le16 medium_time;
 } __packed;
 
+struct ieee80211_he_6ghz_capa {
+	/* uses IEEE80211_HE_6GHZ_CAP_* below */
+	__le16 capa;
+} __packed;
+
+/* HE 6 GHz band capabilities */
+/* uses enum ieee80211_min_mpdu_spacing values */
+#define IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START	0x0007
+/* uses enum ieee80211_vht_max_ampdu_length_exp values */
+#define IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP	0x0038
+/* uses IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_* values */
+#define IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN	0x00c0
+/* WLAN_HT_CAP_SM_PS_* values */
+#define IEEE80211_HE_6GHZ_CAP_SM_PS		0x0600
+#define IEEE80211_HE_6GHZ_CAP_RD_RESPONDER	0x0800
+#define IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS	0x1000
+#define IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS	0x2000
+
 /**
  * ieee80211_get_qos_ctl - get pointer to qos control bytes
  * @hdr: the frame
diff --git a/include/linux/init.h b/include/linux/init.h
index 212fc9e2f..32633ea36 100644
--- a/include/linux/init.h
+++ b/include/linux/init.h
@@ -47,7 +47,7 @@
 
 /* These are for everybody (although not all archs will actually
    discard it in modules) */
-#define __init		__section(.init.text) __cold  __latent_entropy __noinitretpoline
+#define __init		__section(.init.text) __cold  __latent_entropy __noinitretpoline __nocfi
 #define __initdata	__section(.init.data)
 #define __initconst	__section(.init.rodata)
 #define __exitdata	__section(.exit.data)
@@ -192,10 +192,32 @@ extern bool initcall_debug;
 	    ".long	" #fn " - .			\n"	\
 	    ".previous					\n");
 #else
-#define ___define_initcall(fn, id, __sec) \
+#ifdef CONFIG_LTO_CLANG
+  /*
+   * With LTO, the compiler doesn't necessarily obey link order for
+   * initcalls, and the initcall variable needs to be globally unique
+   * to avoid naming collisions.  In order to preserve the correct
+   * order, we add each variable into its own section and generate a
+   * linker script (in scripts/link-vmlinux.sh) to ensure the order
+   * remains correct.  We also add a __COUNTER__ prefix to the name,
+   * so we can retain the order of initcalls within each compilation
+   * unit, and __LINE__ to make the names more unique.
+   */
+  #define ___lto_initcall(c, l, fn, id, __sec) \
+	static initcall_t __initcall_##c##_##l##_##fn##id __used \
+		__attribute__((__section__( #__sec \
+			__stringify(.init..##c##_##l##_##fn)))) = fn;
+  #define __lto_initcall(c, l, fn, id, __sec) \
+	___lto_initcall(c, l, fn, id, __sec)
+
+  #define ___define_initcall(fn, id, __sec) \
+	__lto_initcall(__COUNTER__, __LINE__, fn, id, __sec)
+#else
+  #define ___define_initcall(fn, id, __sec) \
 	static initcall_t __initcall_##fn##id __used \
 		__attribute__((__section__(#__sec ".init"))) = fn;
 #endif
+#endif
 
 #define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)
 
@@ -236,7 +258,7 @@ extern bool initcall_debug;
 #define __exitcall(fn)						\
 	static exitcall_t __exitcall_##fn __exit_call = fn
 
-#define console_initcall(fn)	___define_initcall(fn,, .con_initcall)
+#define console_initcall(fn)	___define_initcall(fn, con, .con_initcall)
 
 struct obs_kernel_param {
 	const char *str;
diff --git a/include/linux/io-pgtable.h b/include/linux/io-pgtable.h
index ec7a13405..89f660f50 100644
--- a/include/linux/io-pgtable.h
+++ b/include/linux/io-pgtable.h
@@ -46,6 +46,19 @@ struct iommu_flush_ops {
 			     unsigned long iova, size_t granule, void *cookie);
 };
 
+/**
+ * struct iommu_pgtable_ops - IOMMU callbacks for page table memory management.
+ *
+ * @alloc_pgtable: Allocate page table memory, and return a page-aligned
+ *                 cacheable linear mapping address of the start of a physically
+ *                 contiguous region of memory.
+ * @free_pgtable: Free page table memory.
+ */
+struct iommu_pgtable_ops {
+	void *(*alloc_pgtable)(void *cookie, int order, gfp_t gfp_mask);
+	void (*free_pgtable)(void *cookie, void *virt, int order);
+};
+
 /**
  * struct io_pgtable_cfg - Configuration data for a set of page tables.
  *
@@ -58,6 +71,8 @@ struct iommu_flush_ops {
  * @coherent_walk  A flag to indicate whether or not page table walks made
  *                 by the IOMMU are coherent with the CPU caches.
  * @tlb:           TLB management callbacks for this set of tables.
+ * @iommu_pgtable_ops: IOMMU page table memory management callbacks (optional;
+ *                     defaults to the buddy allocator if not present).
  * @iommu_dev:     The device representing the DMA configuration for the
  *                 page table walker.
  */
@@ -77,8 +92,8 @@ struct io_pgtable_cfg {
 	 *	TLB maintenance when mapping as well as when unmapping.
 	 *
 	 * IO_PGTABLE_QUIRK_ARM_MTK_EXT: (ARM v7s format) MediaTek IOMMUs extend
-	 *	to support up to 34 bits PA where the bit32 and bit33 are
-	 *	encoded in the bit9 and bit4 of the PTE respectively.
+	 *	to support up to 35 bits PA where the bit32, bit33 and bit34 are
+	 *	encoded in the bit9, bit4 and bit5 of the PTE respectively.
 	 *
 	 * IO_PGTABLE_QUIRK_NON_STRICT: Skip issuing synchronous leaf TLBIs
 	 *	on unmap, for DMA domains using the flush queue mechanism for
@@ -95,6 +110,7 @@ struct io_pgtable_cfg {
 	unsigned int			oas;
 	bool				coherent_walk;
 	const struct iommu_flush_ops	*tlb;
+	const struct iommu_pgtable_ops  *iommu_pgtable_ops;
 	struct device			*iommu_dev;
 
 	/* Low-level data specific to the table format */
@@ -166,6 +182,36 @@ struct io_pgtable_ops *alloc_io_pgtable_ops(enum io_pgtable_fmt fmt,
  */
 void free_io_pgtable_ops(struct io_pgtable_ops *ops);
 
+/**
+ * io_pgtable_alloc_pages - Allocate memory for page tables using an IOMMU
+ *                          driver's provided callback, or the buddy allocator.
+ *
+ * @cfg:      The page table configuration. This will be used to determine if
+ *            the page table memory should be allocated through the IOMMU
+ *            driver's callback, or the buddy allocator.
+ * @cookie:   An opaque pointer used by the IOMMU driver's callback.
+ * @order:    The order of the size of the allocation.
+ * @gfp_mask: The GFP mask to be used with the allocation
+ *
+ * Returns a cacheable linear mapping address to a physically contiguous region
+ * of memory. The start of the region must be page-aligned.
+ */
+void *io_pgtable_alloc_pages(struct io_pgtable_cfg *cfg, void *cookie,
+			     int order, gfp_t gfp_mask);
+
+/**
+ * io_pgtable_free_pages - Free memory for page tables using an IOMMU
+ *                         driver's provided callback, or the buddy allocator.
+ *
+ * @cfg:      The page table configuration. This will be used to determine if
+ *            the page table memory should be allocated through the IOMMU
+ *            driver's callback, or the buddy allocator.
+ * @cookie:   An opage pointer used by the IOMMU driver's callback.
+ * @virt:     The virtual address of the memory to free.
+ * @order:     The order of the size of the allocation.
+ */
+void io_pgtable_free_pages(struct io_pgtable_cfg *cfg, void *cookie, void *virt,
+			   int order);
 
 /*
  * Internal structures for page table allocator implementations.
diff --git a/include/linux/iomap.h b/include/linux/iomap.h
index 7aa5d6117..a6a32b215 100644
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@ -8,6 +8,7 @@
 #include <linux/types.h>
 #include <linux/mm_types.h>
 #include <linux/blkdev.h>
+#include <linux/android_kabi.h>
 
 struct address_space;
 struct fiemap_extent_info;
@@ -120,6 +121,9 @@ struct iomap_ops {
 	 */
 	int (*iomap_end)(struct inode *inode, loff_t pos, loff_t length,
 			ssize_t written, unsigned flags, struct iomap *iomap);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 /*
diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 29bac5345..a10efdf61 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -245,6 +245,7 @@ struct iommu_iotlb_gather {
  * @sva_get_pasid: Get PASID associated to a SVA handle
  * @page_response: handle page request response
  * @pgsize_bitmap: bitmap of all possible supported page sizes
+ * @owner: Driver module providing these ops
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
@@ -308,6 +309,7 @@ struct iommu_ops {
 			     struct iommu_page_response *msg);
 
 	unsigned long pgsize_bitmap;
+	struct module *owner;
 };
 
 /**
@@ -376,12 +378,19 @@ void iommu_device_sysfs_remove(struct iommu_device *iommu);
 int  iommu_device_link(struct iommu_device   *iommu, struct device *link);
 void iommu_device_unlink(struct iommu_device *iommu, struct device *link);
 
-static inline void iommu_device_set_ops(struct iommu_device *iommu,
-					const struct iommu_ops *ops)
+static inline void __iommu_device_set_ops(struct iommu_device *iommu,
+					  const struct iommu_ops *ops)
 {
 	iommu->ops = ops;
 }
 
+#define iommu_device_set_ops(iommu, ops)				\
+do {									\
+	struct iommu_ops *__ops = (struct iommu_ops *)(ops);		\
+	__ops->owner = THIS_MODULE;					\
+	__iommu_device_set_ops(iommu, __ops);				\
+} while (0)
+
 static inline void iommu_device_set_fwnode(struct iommu_device *iommu,
 					   struct fwnode_handle *fwnode)
 {
diff --git a/include/linux/ion.h b/include/linux/ion.h
new file mode 100644
index 000000000..80c6fdeb4
--- /dev/null
+++ b/include/linux/ion.h
@@ -0,0 +1,419 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ */
+
+#ifndef _ION_KERNEL_H
+#define _ION_KERNEL_H
+
+#include <linux/dma-buf.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/dma-direction.h>
+#include <linux/kref.h>
+#include <linux/mm_types.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/rbtree.h>
+#include <linux/sched.h>
+#include <linux/shrinker.h>
+#include <linux/types.h>
+#include <uapi/linux/ion.h>
+
+/**
+ * struct ion_buffer - metadata for a particular buffer
+ * @list:		element in list of deferred freeable buffers
+ * @heap:		back pointer to the heap the buffer came from
+ * @flags:		buffer specific flags
+ * @private_flags:	internal buffer specific flags
+ * @size:		size of the buffer
+ * @priv_virt:		private data to the buffer representable as
+ *			a void *
+ * @lock:		protects the buffers cnt fields
+ * @kmap_cnt:		number of times the buffer is mapped to the kernel
+ * @vaddr:		the kernel mapping if kmap_cnt is not zero
+ * @sg_table:		the sg table for the buffer
+ * @attachments:	list of devices attached to this buffer
+ */
+struct ion_buffer {
+	struct list_head list;
+	struct ion_heap *heap;
+	unsigned long flags;
+	unsigned long private_flags;
+	size_t size;
+	void *priv_virt;
+	struct mutex lock;
+	int kmap_cnt;
+	void *vaddr;
+	struct sg_table *sg_table;
+	struct list_head attachments;
+};
+
+/**
+ * struct ion_heap_ops - ops to operate on a given heap
+ * @allocate:		allocate memory
+ * @free:		free memory
+ * @get_pool_size:	get pool size in pages
+ *
+ * allocate returns 0 on success, -errno on error.
+ * map_dma and map_kernel return pointer on success, ERR_PTR on
+ * error. @free will be called with ION_PRIV_FLAG_SHRINKER_FREE set in
+ * the buffer's private_flags when called from a shrinker. In that
+ * case, the pages being free'd must be truly free'd back to the
+ * system, not put in a page pool or otherwise cached.
+ */
+struct ion_heap_ops {
+	int (*allocate)(struct ion_heap *heap,
+			struct ion_buffer *buffer, unsigned long len,
+			unsigned long flags);
+	void (*free)(struct ion_buffer *buffer);
+	int (*shrink)(struct ion_heap *heap, gfp_t gfp_mask, int nr_to_scan);
+	long (*get_pool_size)(struct ion_heap *heap);
+};
+
+/**
+ * heap flags - flags between the heaps and core ion code
+ */
+#define ION_HEAP_FLAG_DEFER_FREE BIT(0)
+
+/**
+ * private flags - flags internal to ion
+ */
+/*
+ * Buffer is being freed from a shrinker function. Skip any possible
+ * heap-specific caching mechanism (e.g. page pools). Guarantees that
+ * any buffer storage that came from the system allocator will be
+ * returned to the system allocator.
+ */
+#define ION_PRIV_FLAG_SHRINKER_FREE BIT(0)
+
+/**
+ * struct ion_heap - represents a heap in the system
+ * @node:		rb node to put the heap on the device's tree of heaps
+ * @type:		type of heap
+ * @ops:		ops struct as above
+ * @buf_ops:		dma_buf ops specific to the heap implementation.
+ * @flags:		flags
+ * @id:			id of heap, also indicates priority of this heap when
+ *			allocating.  These are specified by platform data and
+ *			MUST be unique
+ * @name:		used for debugging
+ * @owner:		kernel module that implements this heap
+ * @shrinker:		a shrinker for the heap
+ * @free_list:		free list head if deferred free is used
+ * @free_list_size	size of the deferred free list in bytes
+ * @lock:		protects the free list
+ * @waitqueue:		queue to wait on from deferred free thread
+ * @task:		task struct of deferred free thread
+ * @num_of_buffers	the number of currently allocated buffers
+ * @num_of_alloc_bytes	the number of allocated bytes
+ * @alloc_bytes_wm	the number of allocated bytes watermark
+ *
+ * Represents a pool of memory from which buffers can be made.  In some
+ * systems the only heap is regular system memory allocated via vmalloc.
+ * On others, some blocks might require large physically contiguous buffers
+ * that are allocated from a specially reserved heap.
+ */
+struct ion_heap {
+	struct plist_node node;
+	enum ion_heap_type type;
+	struct ion_heap_ops *ops;
+	struct dma_buf_ops buf_ops;
+	unsigned long flags;
+	unsigned int id;
+	const char *name;
+	struct module *owner;
+
+	/* deferred free support */
+	struct shrinker shrinker;
+	struct list_head free_list;
+	size_t free_list_size;
+	spinlock_t free_lock;
+	wait_queue_head_t waitqueue;
+	struct task_struct *task;
+
+	/* heap statistics */
+	u64 num_of_buffers;
+	u64 num_of_alloc_bytes;
+	u64 alloc_bytes_wm;
+
+	/* protect heap statistics */
+	spinlock_t stat_lock;
+
+	/* heap's debugfs root */
+	struct dentry *debugfs_dir;
+};
+
+#define ion_device_add_heap(heap) __ion_device_add_heap(heap, THIS_MODULE)
+
+/**
+ * struct ion_dma_buf_attachment - hold device-table attachment data for buffer
+ * @dev:	device attached to the buffer.
+ * @table:	cached mapping.
+ * @list:	list of ion_dma_buf_attachment.
+ */
+struct ion_dma_buf_attachment {
+	struct device *dev;
+	struct sg_table *table;
+	struct list_head list;
+	bool mapped:1;
+};
+
+#ifdef CONFIG_ION
+
+/**
+ * __ion_device_add_heap - adds a heap to the ion device
+ *
+ * @heap:               the heap to add
+ *
+ * Returns 0 on success, negative error otherwise.
+ */
+int __ion_device_add_heap(struct ion_heap *heap, struct module *owner);
+
+/**
+ * ion_device_remove_heap - removes a heap from ion device
+ *
+ * @heap:		pointer to the heap to be removed
+ */
+void ion_device_remove_heap(struct ion_heap *heap);
+
+/**
+ * ion_heap_init_shrinker
+ * @heap:		the heap
+ *
+ * If a heap sets the ION_HEAP_FLAG_DEFER_FREE flag or defines the shrink op
+ * this function will be called to setup a shrinker to shrink the freelists
+ * and call the heap's shrink op.
+ */
+int ion_heap_init_shrinker(struct ion_heap *heap);
+
+/**
+ * ion_heap_init_deferred_free -- initialize deferred free functionality
+ * @heap:		the heap
+ *
+ * If a heap sets the ION_HEAP_FLAG_DEFER_FREE flag this function will
+ * be called to setup deferred frees. Calls to free the buffer will
+ * return immediately and the actual free will occur some time later
+ */
+int ion_heap_init_deferred_free(struct ion_heap *heap);
+
+/**
+ * ion_heap_freelist_add - add a buffer to the deferred free list
+ * @heap:		the heap
+ * @buffer:		the buffer
+ *
+ * Adds an item to the deferred freelist.
+ */
+void ion_heap_freelist_add(struct ion_heap *heap, struct ion_buffer *buffer);
+
+/**
+ * ion_heap_freelist_drain - drain the deferred free list
+ * @heap:		the heap
+ * @size:		amount of memory to drain in bytes
+ *
+ * Drains the indicated amount of memory from the deferred freelist immediately.
+ * Returns the total amount freed.  The total freed may be higher depending
+ * on the size of the items in the list, or lower if there is insufficient
+ * total memory on the freelist.
+ */
+size_t ion_heap_freelist_drain(struct ion_heap *heap, size_t size);
+
+/**
+ * ion_heap_freelist_shrink - drain the deferred free
+ *				list, skipping any heap-specific
+ *				pooling or caching mechanisms
+ *
+ * @heap:		the heap
+ * @size:		amount of memory to drain in bytes
+ *
+ * Drains the indicated amount of memory from the deferred freelist immediately.
+ * Returns the total amount freed.  The total freed may be higher depending
+ * on the size of the items in the list, or lower if there is insufficient
+ * total memory on the freelist.
+ *
+ * Unlike with @ion_heap_freelist_drain, don't put any pages back into
+ * page pools or otherwise cache the pages. Everything must be
+ * genuinely free'd back to the system. If you're free'ing from a
+ * shrinker you probably want to use this. Note that this relies on
+ * the heap.ops.free callback honoring the ION_PRIV_FLAG_SHRINKER_FREE
+ * flag.
+ */
+size_t ion_heap_freelist_shrink(struct ion_heap *heap,
+				size_t size);
+
+/**
+ * ion_heap_freelist_size - returns the size of the freelist in bytes
+ * @heap:		the heap
+ */
+size_t ion_heap_freelist_size(struct ion_heap *heap);
+
+/**
+ * ion_heap_map_kernel - map the ion_buffer in kernel virtual address space.
+ *
+ * @heap:               the heap
+ * @buffer:             buffer to be mapped
+ *
+ * Maps the buffer using vmap(). The function respects cache flags for the
+ * buffer and creates the page table entries accordingly. Returns virtual
+ * address at the beginning of the buffer or ERR_PTR.
+ */
+void *ion_heap_map_kernel(struct ion_heap *heap, struct ion_buffer *buffer);
+
+/**
+ * ion_heap_unmap_kernel - unmap ion_buffer
+ *
+ * @buffer:             buffer to be unmapped
+ *
+ * ION wrapper for vunmap() of the ion buffer.
+ */
+void ion_heap_unmap_kernel(struct ion_heap *heap, struct ion_buffer *buffer);
+
+/**
+ * ion_heap_map_user - map given ion buffer in provided vma
+ *
+ * @heap:               the heap this buffer belongs to
+ * @buffer:             Ion buffer to be mapped
+ * @vma:                vma of the process where buffer should be mapped.
+ *
+ * Maps the buffer using remap_pfn_range() into specific process's vma starting
+ * with vma->vm_start. The vma size is expected to be >= ion buffer size.
+ * If not, a partial buffer mapping may be created. Returns 0 on success.
+ */
+int ion_heap_map_user(struct ion_heap *heap, struct ion_buffer *buffer,
+		      struct vm_area_struct *vma);
+
+/* ion_buffer_zero - zeroes out an ion buffer respecting the ION_FLAGs.
+ *
+ * @buffer:		ion_buffer to zero
+ *
+ * Returns 0 on success, negative error otherwise.
+ */
+int ion_buffer_zero(struct ion_buffer *buffer);
+
+/**
+ * ion_buffer_prep_noncached - flush cache before non-cached mapping
+ *
+ * @buffer:		ion_buffer to flush
+ *
+ * The memory allocated by the heap could be in the CPU cache. To map
+ * this memory as non-cached, we need to flush the associated cache
+ * first. Without the flush, it is possible for stale dirty cache lines
+ * to be evicted after the ION client started writing into this buffer,
+ * leading to data corruption.
+ */
+void ion_buffer_prep_noncached(struct ion_buffer *buffer);
+
+/**
+ * ion_alloc - Allocates an ion buffer of given size from given heap
+ *
+ * @len:               size of the buffer to be allocated.
+ * @heap_id_mask:      a bitwise maks of heap ids to allocate from
+ * @flags:             ION_BUFFER_XXXX flags for the new buffer.
+ *
+ * The function exports a dma_buf object for the new ion buffer internally
+ * and returns that to the caller. So, the buffer is ready to be used by other
+ * drivers immediately. Returns ERR_PTR in case of failure.
+ */
+struct dma_buf *ion_alloc(size_t len, unsigned int heap_id_mask,
+			  unsigned int flags);
+
+/**
+ * ion_free - Releases the ion buffer.
+ *
+ * @buffer:             ion buffer to be released
+ */
+int ion_free(struct ion_buffer *buffer);
+
+/**
+ * ion_query_heaps_kernel - Returns information about available heaps to
+ * in-kernel clients.
+ *
+ * @hdata:             pointer to array of struct ion_heap_data.
+ * @size:             size of @hdata array.
+ *
+ * Returns the number of available heaps and populates @hdata with information
+ * regarding the same. When invoked with @size as 0, the function with return
+ * the number of available heaps without modifying @hdata. When the number of
+ * available heaps is higher than @size, @size is returned instead of the
+ * actual number of available heaps.
+ */
+
+size_t ion_query_heaps_kernel(struct ion_heap_data *hdata, size_t size);
+#else
+
+static inline int __ion_device_add_heap(struct ion_heap *heap,
+				      struct module *owner)
+{
+	return -ENODEV;
+}
+
+static inline int ion_heap_init_shrinker(struct ion_heap *heap)
+{
+	return -ENODEV;
+}
+
+static inline int ion_heap_init_deferred_free(struct ion_heap *heap)
+{
+	return -ENODEV;
+}
+
+static inline void ion_heap_freelist_add(struct ion_heap *heap,
+					 struct ion_buffer *buffer) {}
+
+static inline size_t ion_heap_freelist_drain(struct ion_heap *heap, size_t size)
+{
+	return -ENODEV;
+}
+
+static inline size_t ion_heap_freelist_shrink(struct ion_heap *heap,
+					      size_t size)
+{
+	return -ENODEV;
+}
+
+static inline size_t ion_heap_freelist_size(struct ion_heap *heap)
+{
+	return -ENODEV;
+}
+
+static inline void *ion_heap_map_kernel(struct ion_heap *heap,
+					struct ion_buffer *buffer)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void ion_heap_unmap_kernel(struct ion_heap *heap,
+					 struct ion_buffer *buffer) {}
+
+static inline int ion_heap_map_user(struct ion_heap *heap,
+				    struct ion_buffer *buffer,
+				    struct vm_area_struct *vma)
+{
+	return -ENODEV;
+}
+
+static inline int ion_buffer_zero(struct ion_buffer *buffer)
+{
+	return -EINVAL;
+}
+
+static inline void ion_buffer_prep_noncached(struct ion_buffer *buffer) {}
+
+static inline struct dma_buf *ion_alloc(size_t len, unsigned int heap_id_mask,
+					unsigned int flags)
+{
+	return ERR_PTR(-ENOMEM);
+}
+
+static inline int ion_free(struct ion_buffer *buffer)
+{
+	return 0;
+}
+
+static inline size_t ion_query_heaps_kernel(struct ion_heap_data *hdata,
+					 size_t size)
+{
+	return 0;
+}
+#endif /* CONFIG_ION */
+#endif /* _ION_KERNEL_H */
diff --git a/include/linux/ioport.h b/include/linux/ioport.h
index fdc201d61..692e2c53d 100644
--- a/include/linux/ioport.h
+++ b/include/linux/ioport.h
@@ -13,6 +13,7 @@
 #include <linux/compiler.h>
 #include <linux/types.h>
 #include <linux/bits.h>
+#include <linux/android_kabi.h>
 /*
  * Resources are tree-like, allowing
  * nesting etc..
@@ -24,6 +25,11 @@ struct resource {
 	unsigned long flags;
 	unsigned long desc;
 	struct resource *parent, *sibling, *child;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 /*
diff --git a/include/linux/iova.h b/include/linux/iova.h
index a0637abff..58713bb72 100644
--- a/include/linux/iova.h
+++ b/include/linux/iova.h
@@ -95,6 +95,7 @@ struct iova_domain {
 						   flush-queues */
 	atomic_t fq_timer_on;			/* 1 when timer is active, 0
 						   when not */
+	bool best_fit;
 };
 
 static inline unsigned long iova_size(struct iova *iova)
diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h
index ea7c79065..abc5971bf 100644
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -3,6 +3,7 @@
 #define _IPV6_H
 
 #include <uapi/linux/ipv6.h>
+#include <linux/android_kabi.h>
 
 #define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)
 #define ipv6_authlen(p) (((p)->hdrlen+2) << 2)
@@ -42,6 +43,7 @@ struct ipv6_devconf {
 	__s32		accept_ra_rt_info_max_plen;
 #endif
 #endif
+	__s32		accept_ra_rt_table;
 	__s32		proxy_ndp;
 	__s32		accept_source_route;
 	__s32		accept_ra_from_local;
@@ -76,6 +78,11 @@ struct ipv6_devconf {
 	__s32           ndisc_tclass;
 
 	struct ctl_table_header *sysctl_header;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct ipv6_params {
diff --git a/include/linux/irq.h b/include/linux/irq.h
index e9e69c511..5e443f1cd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -641,6 +641,12 @@ extern int irq_chip_pm_put(struct irq_data *data);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 extern void handle_fasteoi_ack_irq(struct irq_desc *desc);
 extern void handle_fasteoi_mask_irq(struct irq_desc *desc);
+extern int irq_chip_set_parent_state(struct irq_data *data,
+				     enum irqchip_irq_state which,
+				     bool val);
+extern int irq_chip_get_parent_state(struct irq_data *data,
+				     enum irqchip_irq_state which,
+				     bool *state);
 extern void irq_chip_enable_parent(struct irq_data *data);
 extern void irq_chip_disable_parent(struct irq_data *data);
 extern void irq_chip_ack_parent(struct irq_data *data);
diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index e85f714a6..20b263dcc 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -35,6 +35,7 @@
 #include <linux/of.h>
 #include <linux/mutex.h>
 #include <linux/radix-tree.h>
+#include <linux/android_kabi.h>
 
 struct device_node;
 struct irq_domain;
@@ -83,6 +84,7 @@ enum irq_domain_bus_token {
 	DOMAIN_BUS_IPI,
 	DOMAIN_BUS_FSL_MC_MSI,
 	DOMAIN_BUS_TI_SCI_INTA_MSI,
+	DOMAIN_BUS_WAKEUP,
 };
 
 /**
@@ -176,6 +178,11 @@ struct irq_domain {
 	struct dentry		*debugfs_file;
 #endif
 
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+
 	/* reverse map data. The linear map gets appended to the irq_domain */
 	irq_hw_number_t hwirq_max;
 	unsigned int revmap_direct_max_irq;
diff --git a/include/linux/jiffies.h b/include/linux/jiffies.h
index 1b6d31da7..235f94c4b 100644
--- a/include/linux/jiffies.h
+++ b/include/linux/jiffies.h
@@ -8,6 +8,7 @@
 #include <linux/types.h>
 #include <linux/time.h>
 #include <linux/timex.h>
+#include <vdso/jiffies.h>
 #include <asm/param.h>			/* for HZ */
 #include <generated/timeconst.h>
 
@@ -59,9 +60,6 @@
 
 extern int register_refined_jiffies(long clock_tick_rate);
 
-/* TICK_NSEC is the time between ticks in nsec assuming SHIFTED_HZ */
-#define TICK_NSEC ((NSEC_PER_SEC+HZ/2)/HZ)
-
 /* TICK_USEC is the time between ticks in usec assuming SHIFTED_HZ */
 #define TICK_USEC ((USEC_PER_SEC + HZ/2) / HZ)
 
diff --git a/include/linux/kallsyms.h b/include/linux/kallsyms.h
index 1f96ce2b4..a45f5c0bc 100644
--- a/include/linux/kallsyms.h
+++ b/include/linux/kallsyms.h
@@ -14,7 +14,7 @@
 
 #include <asm/sections.h>
 
-#define KSYM_NAME_LEN 128
+#define KSYM_NAME_LEN 192
 #define KSYM_SYMBOL_LEN (sizeof("%s+%#lx/%#lx [%s]") + (KSYM_NAME_LEN - 1) + \
 			 2*(BITS_PER_LONG*3/10) + (MODULE_NAME_LEN - 1) + 1)
 
diff --git a/include/linux/kconfig.h b/include/linux/kconfig.h
index cc8fa109c..9d12c970f 100644
--- a/include/linux/kconfig.h
+++ b/include/linux/kconfig.h
@@ -2,6 +2,8 @@
 #ifndef __LINUX_KCONFIG_H
 #define __LINUX_KCONFIG_H
 
+/* CONFIG_CC_VERSION_TEXT (Do not delete this comment. See help in Kconfig) */
+
 #include <generated/autoconf.h>
 
 #ifdef CONFIG_CPU_BIG_ENDIAN
diff --git a/include/linux/kcov.h b/include/linux/kcov.h
index b76a18070..a10e84707 100644
--- a/include/linux/kcov.h
+++ b/include/linux/kcov.h
@@ -37,12 +37,35 @@ do {						\
 	(t)->kcov_mode &= ~KCOV_IN_CTXSW;	\
 } while (0)
 
+/* See Documentation/dev-tools/kcov.rst for usage details. */
+void kcov_remote_start(u64 handle);
+void kcov_remote_stop(void);
+u64 kcov_common_handle(void);
+
+static inline void kcov_remote_start_common(u64 id)
+{
+	kcov_remote_start(kcov_remote_handle(KCOV_SUBSYSTEM_COMMON, id));
+}
+
+static inline void kcov_remote_start_usb(u64 id)
+{
+	kcov_remote_start(kcov_remote_handle(KCOV_SUBSYSTEM_USB, id));
+}
+
 #else
 
 static inline void kcov_task_init(struct task_struct *t) {}
 static inline void kcov_task_exit(struct task_struct *t) {}
 static inline void kcov_prepare_switch(struct task_struct *t) {}
 static inline void kcov_finish_switch(struct task_struct *t) {}
+static inline void kcov_remote_start(u64 handle) {}
+static inline void kcov_remote_stop(void) {}
+static inline u64 kcov_common_handle(void)
+{
+	return 0;
+}
+static inline void kcov_remote_start_common(u64 id) {}
+static inline void kcov_remote_start_usb(u64 id) {}
 
 #endif /* CONFIG_KCOV */
 #endif /* _LINUX_KCOV_H */
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index d83d403da..909420466 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -533,6 +533,8 @@ extern int sysctl_panic_on_stackoverflow;
 
 extern bool crash_kexec_post_notifiers;
 
+extern int sunxi_dump;
+
 /*
  * panic_cpu is used for synchronizing panic() and crash_kexec() execution. It
  * holds a CPU number which is executing panic() currently. A value of
diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index f797ccc65..88293d22a 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -16,6 +16,7 @@
 #include <linux/atomic.h>
 #include <linux/uidgid.h>
 #include <linux/wait.h>
+#include <linux/android_kabi.h>
 
 struct file;
 struct dentry;
@@ -178,6 +179,11 @@ struct kernfs_syscall_ops {
 		      const char *new_name);
 	int (*show_path)(struct seq_file *sf, struct kernfs_node *kn,
 			 struct kernfs_root *root);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct kernfs_root {
@@ -271,6 +277,9 @@ struct kernfs_ops {
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lock_class_key	lockdep_key;
 #endif
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 /*
diff --git a/include/linux/keyslot-manager.h b/include/linux/keyslot-manager.h
new file mode 100644
index 000000000..f5e0eed46
--- /dev/null
+++ b/include/linux/keyslot-manager.h
@@ -0,0 +1,103 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 Google LLC
+ */
+
+#ifndef __LINUX_KEYSLOT_MANAGER_H
+#define __LINUX_KEYSLOT_MANAGER_H
+
+#include <linux/bio.h>
+
+/* Inline crypto feature bits.  Must set at least one. */
+enum {
+	/* Support for standard software-specified keys */
+	BLK_CRYPTO_FEATURE_STANDARD_KEYS = BIT(0),
+
+	/* Support for hardware-wrapped keys */
+	BLK_CRYPTO_FEATURE_WRAPPED_KEYS = BIT(1),
+};
+
+#ifdef CONFIG_BLK_INLINE_ENCRYPTION
+
+struct keyslot_manager;
+
+/**
+ * struct keyslot_mgmt_ll_ops - functions to manage keyslots in hardware
+ * @keyslot_program:	Program the specified key into the specified slot in the
+ *			inline encryption hardware.
+ * @keyslot_evict:	Evict key from the specified keyslot in the hardware.
+ *			The key is provided so that e.g. dm layers can evict
+ *			keys from the devices that they map over.
+ *			Returns 0 on success, -errno otherwise.
+ * @derive_raw_secret:	(Optional) Derive a software secret from a
+ *			hardware-wrapped key.  Returns 0 on success, -EOPNOTSUPP
+ *			if unsupported on the hardware, or another -errno code.
+ *
+ * This structure should be provided by storage device drivers when they set up
+ * a keyslot manager - this structure holds the function ptrs that the keyslot
+ * manager will use to manipulate keyslots in the hardware.
+ */
+struct keyslot_mgmt_ll_ops {
+	int (*keyslot_program)(struct keyslot_manager *ksm,
+			       const struct blk_crypto_key *key,
+			       unsigned int slot);
+	int (*keyslot_evict)(struct keyslot_manager *ksm,
+			     const struct blk_crypto_key *key,
+			     unsigned int slot);
+	int (*derive_raw_secret)(struct keyslot_manager *ksm,
+				 const u8 *wrapped_key,
+				 unsigned int wrapped_key_size,
+				 u8 *secret, unsigned int secret_size);
+};
+
+struct keyslot_manager *keyslot_manager_create(
+	struct device *dev,
+	unsigned int num_slots,
+	const struct keyslot_mgmt_ll_ops *ksm_ops,
+	unsigned int features,
+	const unsigned int crypto_mode_supported[BLK_ENCRYPTION_MODE_MAX],
+	void *ll_priv_data);
+
+void keyslot_manager_set_max_dun_bytes(struct keyslot_manager *ksm,
+				       unsigned int max_dun_bytes);
+
+int keyslot_manager_get_slot_for_key(struct keyslot_manager *ksm,
+				     const struct blk_crypto_key *key);
+
+void keyslot_manager_get_slot(struct keyslot_manager *ksm, unsigned int slot);
+
+void keyslot_manager_put_slot(struct keyslot_manager *ksm, unsigned int slot);
+
+bool keyslot_manager_crypto_mode_supported(struct keyslot_manager *ksm,
+					   enum blk_crypto_mode_num crypto_mode,
+					   unsigned int dun_bytes,
+					   unsigned int data_unit_size,
+					   bool is_hw_wrapped_key);
+
+int keyslot_manager_evict_key(struct keyslot_manager *ksm,
+			      const struct blk_crypto_key *key);
+
+void keyslot_manager_reprogram_all_keys(struct keyslot_manager *ksm);
+
+void *keyslot_manager_private(struct keyslot_manager *ksm);
+
+void keyslot_manager_destroy(struct keyslot_manager *ksm);
+
+struct keyslot_manager *keyslot_manager_create_passthrough(
+	struct device *dev,
+	const struct keyslot_mgmt_ll_ops *ksm_ops,
+	unsigned int features,
+	const unsigned int crypto_mode_supported[BLK_ENCRYPTION_MODE_MAX],
+	void *ll_priv_data);
+
+void keyslot_manager_intersect_modes(struct keyslot_manager *parent,
+				     const struct keyslot_manager *child);
+
+int keyslot_manager_derive_raw_secret(struct keyslot_manager *ksm,
+				      const u8 *wrapped_key,
+				      unsigned int wrapped_key_size,
+				      u8 *secret, unsigned int secret_size);
+
+#endif /* CONFIG_BLK_INLINE_ENCRYPTION */
+
+#endif /* __LINUX_KEYSLOT_MANAGER_H */
diff --git a/include/linux/kobject.h b/include/linux/kobject.h
index e2ca0a292..f249c005a 100644
--- a/include/linux/kobject.h
+++ b/include/linux/kobject.h
@@ -27,6 +27,7 @@
 #include <linux/atomic.h>
 #include <linux/workqueue.h>
 #include <linux/uidgid.h>
+#include <linux/android_kabi.h>
 
 #define UEVENT_HELPER_PATH_LEN		256
 #define UEVENT_NUM_ENVP			32	/* number of env pointers */
@@ -78,6 +79,11 @@ struct kobject {
 	unsigned int state_add_uevent_sent:1;
 	unsigned int state_remove_uevent_sent:1;
 	unsigned int uevent_suppress:1;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 extern __printf(2, 3)
@@ -144,6 +150,11 @@ struct kobj_type {
 	const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);
 	const void *(*namespace)(struct kobject *kobj);
 	void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct kobj_uevent_env {
@@ -195,6 +206,11 @@ struct kset {
 	spinlock_t list_lock;
 	struct kobject kobj;
 	const struct kset_uevent_ops *uevent_ops;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } __randomize_layout;
 
 extern void kset_init(struct kset *kset);
diff --git a/include/linux/ktime.h b/include/linux/ktime.h
index b2bb44f87..1fcfce97a 100644
--- a/include/linux/ktime.h
+++ b/include/linux/ktime.h
@@ -253,14 +253,7 @@ static inline __must_check bool ktime_to_timespec64_cond(const ktime_t kt,
 	}
 }
 
-/*
- * The resolution of the clocks. The resolution value is returned in
- * the clock_getres() system call to give application programmers an
- * idea of the (in)accuracy of timers. Timer values are rounded up to
- * this resolution values.
- */
-#define LOW_RES_NSEC		TICK_NSEC
-#define KTIME_LOW_RES		(LOW_RES_NSEC)
+#include <vdso/ktime.h>
 
 static inline ktime_t ns_to_ktime(u64 ns)
 {
diff --git a/include/linux/limits.h b/include/linux/limits.h
index 76afcd24f..7fc497ee1 100644
--- a/include/linux/limits.h
+++ b/include/linux/limits.h
@@ -4,19 +4,8 @@
 
 #include <uapi/linux/limits.h>
 #include <linux/types.h>
+#include <vdso/limits.h>
 
-#define USHRT_MAX	((unsigned short)~0U)
-#define SHRT_MAX	((short)(USHRT_MAX >> 1))
-#define SHRT_MIN	((short)(-SHRT_MAX - 1))
-#define INT_MAX		((int)(~0U >> 1))
-#define INT_MIN		(-INT_MAX - 1)
-#define UINT_MAX	(~0U)
-#define LONG_MAX	((long)(~0UL >> 1))
-#define LONG_MIN	(-LONG_MAX - 1)
-#define ULONG_MAX	(~0UL)
-#define LLONG_MAX	((long long)(~0ULL >> 1))
-#define LLONG_MIN	(-LLONG_MAX - 1)
-#define ULLONG_MAX	(~0ULL)
 #define SIZE_MAX	(~(size_t)0)
 #define PHYS_ADDR_MAX	(~(phys_addr_t)0)
 
diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index a37632475..20d8cf194 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -1818,6 +1818,14 @@ union security_list_options {
 	void (*bpf_prog_free_security)(struct bpf_prog_aux *aux);
 #endif /* CONFIG_BPF_SYSCALL */
 	int (*locked_down)(enum lockdown_reason what);
+#ifdef CONFIG_PERF_EVENTS
+	int (*perf_event_open)(struct perf_event_attr *attr, int type);
+	int (*perf_event_alloc)(struct perf_event *event);
+	void (*perf_event_free)(struct perf_event *event);
+	int (*perf_event_read)(struct perf_event *event);
+	int (*perf_event_write)(struct perf_event *event);
+
+#endif
 };
 
 struct security_hook_heads {
@@ -2060,6 +2068,13 @@ struct security_hook_heads {
 	struct hlist_head bpf_prog_free_security;
 #endif /* CONFIG_BPF_SYSCALL */
 	struct hlist_head locked_down;
+#ifdef CONFIG_PERF_EVENTS
+	struct hlist_head perf_event_open;
+	struct hlist_head perf_event_alloc;
+	struct hlist_head perf_event_free;
+	struct hlist_head perf_event_read;
+	struct hlist_head perf_event_write;
+#endif
 } __randomize_layout;
 
 /*
diff --git a/include/linux/math64.h b/include/linux/math64.h
index 65bef21cd..11a267413 100644
--- a/include/linux/math64.h
+++ b/include/linux/math64.h
@@ -3,6 +3,7 @@
 #define _LINUX_MATH64_H
 
 #include <linux/types.h>
+#include <vdso/math64.h>
 #include <asm/div64.h>
 
 #if BITS_PER_LONG == 64
@@ -142,25 +143,6 @@ static inline s64 div_s64(s64 dividend, s32 divisor)
 
 u32 iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder);
 
-static __always_inline u32
-__iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
-{
-	u32 ret = 0;
-
-	while (dividend >= divisor) {
-		/* The following asm() prevents the compiler from
-		   optimising this loop into a modulo operation.  */
-		asm("" : "+rm"(dividend));
-
-		dividend -= divisor;
-		ret++;
-	}
-
-	*remainder = dividend;
-
-	return ret;
-}
-
 #ifndef mul_u32_u32
 /*
  * Many a GCC version messes this up and generates a 64x64 mult :-(
diff --git a/include/linux/memcontrol.h b/include/linux/memcontrol.h
index fb5b2a41b..bb7dd481f 100644
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@ -330,7 +330,7 @@ struct mem_cgroup {
 	struct list_head event_list;
 	spinlock_t event_list_lock;
 
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_GKI_OPT_FEATURES)
 	struct deferred_split deferred_split_queue;
 #endif
 
diff --git a/include/linux/mfd/acx00-mfd.h b/include/linux/mfd/acx00-mfd.h
new file mode 100644
index 000000000..16a2ea0df
--- /dev/null
+++ b/include/linux/mfd/acx00-mfd.h
@@ -0,0 +1,133 @@
+/*
+ * include/linux/mfd/acx00-mfd.h -- Core interface for ACX00
+ *
+ * Copyright 2009 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef __ACX00_MFD_H__
+#define __ACX00_MFD_H__
+
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+
+/* GPIOs in the chip are numbered from 1-11 */
+#define ACX00_IRQ_GPIO(x) (x + ACX00_IRQ_TEMP_WARN)
+
+#define SYS_VERSION			0x0000
+#define SYS_CONTROL			0x0002
+#define SYS_IRQ_ENABLE		0x0004
+#define SYS_IRQ_STATUS		0x0006
+/*#define SYS_CLK_CTL			0x0008*/
+#define SYS_DLDO_OSC_CTL	0x000a
+#define SYS_PLL_CTL0		0x000c
+#define SYS_PLL_CTL1		0x000e
+#define SYS_AUDIO_CTL0		0x0010
+#define SYS_AUDIO_CTL1		0x0012
+#define SYS_EPHY_CTL0		0x0014
+#define SYS_EPHY_CTL1		0x0016
+#define SYS_TVE_CTL0		0x0018
+#define SYS_TVE_CTL1		0x001a
+
+/*SYS_VERSION:0x0000*/
+#define CHIP_PACKAGE		14
+#define CHIP_VERSION		0
+
+/*SYS_CONTROL:0x0002*/
+#define CIHP_RESET			0
+
+/*SYS_IRQ_ENABLE:0x0004*/
+#define INTB_OUTPUT_ENABLE	15
+#define INTB_OUTPUT_CFG		14
+#define RTC_IRQ_ENABLE		12
+#define EPHY_IRQ_ENABLE		8
+#define TVE_IRQ_ENABLE		4
+
+/*SYS_IRQ_STATUS:0x0006*/
+#define RTC_IRQ_STATUS		12
+#define EPHY_IRQ_STATUS		8
+#define TVE_IRQ_STATUS		4
+
+/*SYS_CLK_CTL:0x0008*/
+#define EFUSE_CLK_SEL		5
+#define SYS_CLK_SEL			4
+#define CKI_24M_ENABLE		2
+#define CKO_RTC_ENABLE		1
+#define CKO_32K_ENABLE		0
+
+/*SYS_DLDO_OSC_CTL:0x000a*/
+#define DLDOEN				15
+#define DLDOVOL				12
+#define ENBG				11
+#define RESBYPS				10
+#define OSCEN				3
+#define OSCSEL				0
+
+/*SYS_PLL_CTL0:0x000c*/
+#define PLL_ENABLE			15
+#define PLL_BIAS_EN			14
+#define PLL_LDO1_EN			11
+#define PLL_LDO_EN			10
+#define PLL_POST_DIV		9
+#define PLL_PRE_DIV_M		0
+
+/*SYS_PLL_CTL1:0x000e*/
+#define PLL_CS				10
+#define PLL_VCO_S			5
+#define PLL_CP_S			0
+
+/*SYS_AUDIO_CTL0:0x0010*/
+#define AC_MCLK_GATING		1
+#define AC_RESET_INVALID	0
+
+/*SYS_AUDIO_CTL1:0x0012*/
+#define AC_I2S_IO_EN		0
+
+/*SYS_EPHY_CTL0:0x0014*/
+#define EPHY_SYSCLK_GATING	1
+#define EPHY_RESET_INVALID	0
+
+/*SYS_EPHY_CTL1:0x0016*/
+#define EPHY_MII_IO_FOR_I2S	15
+#define EPHY_MII_IO_FOR_PLL	14
+#define E_DPX_LED_IO_EN		3
+#define E_SPD_LED_IO_EN		2
+#define E_LNK_LED_IO_EN		1
+#define EPHY_MII_IO_EN		0
+
+/*SYS_TVE_CTL0:0x0018*/
+#define TVE_SYSCLK_GATING	3
+#define TVE_SCLK_GATING		2
+#define TVE_DCLK_GATING		1
+#define TVE_RESET_INVALID	0
+
+/*SYS_TVE_CTL1:0x001a*/
+#define TVE_CCIR_CLK_IO_EN	1
+#define TVE_CCIR_SYNC_DATA_IO_EN 0
+
+struct acx00 {
+	struct mutex lock;
+
+	struct device *dev;
+	struct regmap *regmap;
+	struct pwm_device *pwm_ac200;
+	struct work_struct init_work;
+	int irq;
+};
+
+/* Device I/O API */
+int acx00_reg_read(struct acx00 *acx00, unsigned short reg);
+int acx00_reg_write(struct acx00 *acx00, unsigned short reg,
+		    unsigned short val);
+int acx00_enable(void);
+int acx00_set_bits(struct acx00 *acx00, unsigned short reg,
+		    unsigned short mask, unsigned short val);
+
+#endif
diff --git a/include/linux/mfd/axp2101.h b/include/linux/mfd/axp2101.h
new file mode 100644
index 000000000..e21041864
--- /dev/null
+++ b/include/linux/mfd/axp2101.h
@@ -0,0 +1,1689 @@
+/*
+ * Functions and registers to access AXP20X power management chip.
+ *
+ * Copyright (C) 2013, Carlo Caione <carlo@caione.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_MFD_AXP20X_H
+#define __LINUX_MFD_AXP20X_H
+
+#include <linux/regmap.h>
+
+enum {
+	AXP152_ID = 0,
+	AXP202_ID,
+	AXP209_ID,
+	AXP221_ID,
+	AXP223_ID,
+	AXP288_ID,
+	AXP806_ID,
+	AXP809_ID,
+	AXP2101_ID,
+	AXP15_ID,
+	AXP1530_ID,
+	AXP858_ID,
+	AXP803_ID,
+	AXP2202_ID,
+	AXP2585_ID,
+	NR_AXP20X_VARIANTS,
+};
+
+enum {
+	AXP_SPLY = 1U << 0,
+	AXP_REGU = 1U << 1,
+	AXP_INT  = 1U << 2,
+	AXP_CHG  = 1U << 3,
+	AXP_MISC = 1U << 4,
+};
+
+extern int axp_debug_mask;
+
+#define AXP20X_DATACACHE(m)		(0x04 + (m))
+
+/* Power supply */
+#define AXP152_PWR_OP_MODE		0x01
+#define AXP152_LDO3456_DC1234_CTRL	0x12
+#define AXP152_ALDO_OP_MODE		0x13
+#define AXP152_LDO0_CTRL		0x15
+#define AXP152_DCDC2_V_OUT		0x23
+#define AXP152_DCDC2_V_SCAL		0x25
+#define AXP152_DCDC1_V_OUT		0x26
+#define AXP152_DCDC3_V_OUT		0x27
+#define AXP152_ALDO12_V_OUT		0x28
+#define AXP152_DLDO1_V_OUT		0x29
+#define AXP152_DLDO2_V_OUT		0x2a
+#define AXP152_DCDC4_V_OUT		0x2b
+#define AXP152_V_OFF			0x31
+#define AXP152_OFF_CTRL			0x32
+#define AXP152_PEK_KEY			0x36
+#define AXP152_DCDC_FREQ		0x37
+#define AXP152_DCDC_MODE		0x80
+
+#define AXP20X_PWR_INPUT_STATUS		0x00
+#define AXP20X_PWR_OP_MODE		0x01
+#define AXP20X_USB_OTG_STATUS		0x02
+#define AXP20X_PWR_OUT_CTRL		0x12
+#define AXP20X_DCDC2_V_OUT		0x23
+#define AXP20X_DCDC2_LDO3_V_SCAL	0x25
+#define AXP20X_DCDC3_V_OUT		0x27
+#define AXP20X_LDO24_V_OUT		0x28
+#define AXP20X_LDO3_V_OUT		0x29
+#define AXP20X_VBUS_IPSOUT_MGMT		0x30
+#define AXP20X_V_OFF			0x31
+#define AXP20X_OFF_CTRL			0x32
+#define AXP20X_CHRG_CTRL1		0x33
+#define AXP20X_CHRG_CTRL2		0x34
+#define AXP20X_CHRG_BAK_CTRL		0x35
+#define AXP20X_PEK_KEY			0x36
+#define AXP20X_DCDC_FREQ		0x37
+#define AXP20X_V_LTF_CHRG		0x38
+#define AXP20X_V_HTF_CHRG		0x39
+#define AXP20X_APS_WARN_L1		0x3a
+#define AXP20X_APS_WARN_L2		0x3b
+#define AXP20X_V_LTF_DISCHRG		0x3c
+#define AXP20X_V_HTF_DISCHRG		0x3d
+
+#define AXP22X_PWR_OUT_CTRL1		0x10
+#define AXP22X_PWR_OUT_CTRL2		0x12
+#define AXP22X_PWR_OUT_CTRL3		0x13
+#define AXP22X_DLDO1_V_OUT		0x15
+#define AXP22X_DLDO2_V_OUT		0x16
+#define AXP22X_DLDO3_V_OUT		0x17
+#define AXP22X_DLDO4_V_OUT		0x18
+#define AXP22X_ELDO1_V_OUT		0x19
+#define AXP22X_ELDO2_V_OUT		0x1a
+#define AXP22X_ELDO3_V_OUT		0x1b
+#define AXP22X_DC5LDO_V_OUT		0x1c
+#define AXP22X_DCDC1_V_OUT		0x21
+#define AXP22X_DCDC2_V_OUT		0x22
+#define AXP22X_DCDC3_V_OUT		0x23
+#define AXP22X_DCDC4_V_OUT		0x24
+#define AXP22X_DCDC5_V_OUT		0x25
+#define AXP22X_DCDC23_V_RAMP_CTRL	0x27
+#define AXP22X_ALDO1_V_OUT		0x28
+#define AXP22X_ALDO2_V_OUT		0x29
+#define AXP22X_ALDO3_V_OUT		0x2a
+#define AXP22X_CHRG_CTRL3		0x35
+
+#define AXP806_STARTUP_SRC		0x00
+#define AXP806_CHIP_ID			0x03
+#define AXP806_PWR_OUT_CTRL1		0x10
+#define AXP806_PWR_OUT_CTRL2		0x11
+#define AXP806_DCDCA_V_CTRL		0x12
+#define AXP806_DCDCB_V_CTRL		0x13
+#define AXP806_DCDCC_V_CTRL		0x14
+#define AXP806_DCDCD_V_CTRL		0x15
+#define AXP806_DCDCE_V_CTRL		0x16
+#define AXP806_ALDO1_V_CTRL		0x17
+#define AXP806_ALDO2_V_CTRL		0x18
+#define AXP806_ALDO3_V_CTRL		0x19
+#define AXP806_DCDC_MODE_CTRL1		0x1a
+#define AXP806_DCDC_MODE_CTRL2		0x1b
+#define AXP806_DCDC_FREQ_CTRL		0x1c
+#define AXP806_BLDO1_V_CTRL		0x20
+#define AXP806_BLDO2_V_CTRL		0x21
+#define AXP806_BLDO3_V_CTRL		0x22
+#define AXP806_BLDO4_V_CTRL		0x23
+#define AXP806_CLDO1_V_CTRL		0x24
+#define AXP806_CLDO2_V_CTRL		0x25
+#define AXP806_CLDO3_V_CTRL		0x26
+#define AXP806_VREF_TEMP_WARN_L		0xf3
+
+#define AXP806_STARTUP_SOURCE      (0x00)
+#define AXP806_IC_TYPE             (0x03)
+#define AXP806_DATA_BUFFER1        (0x04)
+#define AXP806_DATA_BUFFER2        (0x05)
+#define AXP806_DATA_BUFFER3        (0x06)
+#define AXP806_DATA_BUFFER4        (0x07)
+#define AXP806_ONOFF_CTRL1         (0x10)
+#define AXP806_ONOFF_CTRL2         (0x11)
+#define AXP806_DCAOUT_VOL          (0x12)
+#define AXP806_DCBOUT_VOL          (0x13)
+#define AXP806_DCCOUT_VOL          (0x14)
+#define AXP806_DCDOUT_VOL          (0x15)
+#define AXP806_DCEOUT_VOL          (0x16)
+#define AXP806_ALDO1OUT_VOL        (0x17)
+#define AXP806_ALDO2OUT_VOL        (0x18)
+#define AXP806_ALDO3OUT_VOL        (0x19)
+#define AXP806_DCDC_DVM_CTRL       (0x1A)
+#define AXP806_DCDC_MODE_CTRL      (0x1B)
+#define AXP806_DCDC_FREQSET        (0x1C)
+#define AXP806_DCDC_MON_CTRL       (0x1D)
+#define AXP806_IFQ_PWROK_SET       (0x1F)
+#define AXP806_BLDO1OUT_VOL        (0x20)
+#define AXP806_BLDO2OUT_VOL        (0x21)
+#define AXP806_BLDO3OUT_VOL        (0x22)
+#define AXP806_BLDO4OUT_VOL        (0x23)
+#define AXP806_CLDO1OUT_VOL        (0x24)
+#define AXP806_CLDO2OUT_VOL        (0x25)
+#define AXP806_CLDO3OUT_VOL        (0x26)
+#define AXP806_VOFF_SET            (0x31)
+#define AXP806_OFF_CTL             (0x32)
+#define AXP806_WAKEUP_PIN_CTRL     (0x35)
+#define AXP806_POK_SET             (0x36)
+#define AXP806_INTERFACE_MODE      (0x3E)
+#define AXP806_SPECIAL_CTRL        (0x3F)
+
+#define AXP806_INTEN1              (0x40)
+#define AXP806_INTEN2              (0x41)
+#define AXP806_INTSTS1             (0x48)
+#define AXP806_INTSTS2             (0x49)
+#define AXP806_REG_ADDR_EXT		0xFF
+
+/* Interrupt */
+#define AXP152_IRQ1_EN			0x40
+#define AXP152_IRQ2_EN			0x41
+#define AXP152_IRQ3_EN			0x42
+#define AXP152_IRQ1_STATE		0x48
+#define AXP152_IRQ2_STATE		0x49
+#define AXP152_IRQ3_STATE		0x4a
+
+#define AXP20X_IRQ1_EN			0x40
+#define AXP20X_IRQ2_EN			0x41
+#define AXP20X_IRQ3_EN			0x42
+#define AXP20X_IRQ4_EN			0x43
+#define AXP20X_IRQ5_EN			0x44
+#define AXP20X_IRQ6_EN			0x45
+#define AXP20X_IRQ1_STATE		0x48
+#define AXP20X_IRQ2_STATE		0x49
+#define AXP20X_IRQ3_STATE		0x4a
+#define AXP20X_IRQ4_STATE		0x4b
+#define AXP20X_IRQ5_STATE		0x4c
+#define AXP20X_IRQ6_STATE		0x4d
+
+/* ADC */
+#define AXP20X_ACIN_V_ADC_H		0x56
+#define AXP20X_ACIN_V_ADC_L		0x57
+#define AXP20X_ACIN_I_ADC_H		0x58
+#define AXP20X_ACIN_I_ADC_L		0x59
+#define AXP20X_VBUS_V_ADC_H		0x5a
+#define AXP20X_VBUS_V_ADC_L		0x5b
+#define AXP20X_VBUS_I_ADC_H		0x5c
+#define AXP20X_VBUS_I_ADC_L		0x5d
+#define AXP20X_TEMP_ADC_H		0x5e
+#define AXP20X_TEMP_ADC_L		0x5f
+#define AXP20X_TS_IN_H			0x62
+#define AXP20X_TS_IN_L			0x63
+#define AXP20X_GPIO0_V_ADC_H		0x64
+#define AXP20X_GPIO0_V_ADC_L		0x65
+#define AXP20X_GPIO1_V_ADC_H		0x66
+#define AXP20X_GPIO1_V_ADC_L		0x67
+#define AXP20X_PWR_BATT_H		0x70
+#define AXP20X_PWR_BATT_M		0x71
+#define AXP20X_PWR_BATT_L		0x72
+#define AXP20X_BATT_V_H			0x78
+#define AXP20X_BATT_V_L			0x79
+#define AXP20X_BATT_CHRG_I_H		0x7a
+#define AXP20X_BATT_CHRG_I_L		0x7b
+#define AXP20X_BATT_DISCHRG_I_H		0x7c
+#define AXP20X_BATT_DISCHRG_I_L		0x7d
+#define AXP20X_IPSOUT_V_HIGH_H		0x7e
+#define AXP20X_IPSOUT_V_HIGH_L		0x7f
+
+/* Power supply */
+#define AXP20X_DCDC_MODE		0x80
+#define AXP20X_ADC_EN1			0x82
+#define AXP20X_ADC_EN2			0x83
+#define AXP20X_ADC_RATE			0x84
+#define AXP20X_GPIO10_IN_RANGE		0x85
+#define AXP20X_GPIO1_ADC_IRQ_RIS	0x86
+#define AXP20X_GPIO1_ADC_IRQ_FAL	0x87
+#define AXP20X_TIMER_CTRL		0x8a
+#define AXP20X_VBUS_MON			0x8b
+#define AXP20X_OVER_TMP			0x8f
+
+#define AXP22X_PWREN_CTRL1		0x8c
+#define AXP22X_PWREN_CTRL2		0x8d
+
+/* GPIO */
+#define AXP152_GPIO0_CTRL		0x90
+#define AXP152_GPIO1_CTRL		0x91
+#define AXP152_GPIO2_CTRL		0x92
+#define AXP152_GPIO3_CTRL		0x93
+#define AXP152_LDOGPIO2_V_OUT		0x96
+#define AXP152_GPIO_INPUT		0x97
+#define AXP152_PWM0_FREQ_X		0x98
+#define AXP152_PWM0_FREQ_Y		0x99
+#define AXP152_PWM0_DUTY_CYCLE		0x9a
+#define AXP152_PWM1_FREQ_X		0x9b
+#define AXP152_PWM1_FREQ_Y		0x9c
+#define AXP152_PWM1_DUTY_CYCLE		0x9d
+
+#define AXP20X_GPIO0_CTRL		0x90
+#define AXP20X_LDO5_V_OUT		0x91
+#define AXP20X_GPIO1_CTRL		0x92
+#define AXP20X_GPIO2_CTRL		0x93
+#define AXP20X_GPIO20_SS		0x94
+#define AXP20X_GPIO3_CTRL		0x95
+
+#define AXP22X_LDO_IO0_V_OUT		0x91
+#define AXP22X_LDO_IO1_V_OUT		0x93
+#define AXP22X_GPIO_STATE		0x94
+#define AXP22X_GPIO_PULL_DOWN		0x95
+
+/* Battery */
+#define AXP20X_CHRG_CC_31_24		0xb0
+#define AXP20X_CHRG_CC_23_16		0xb1
+#define AXP20X_CHRG_CC_15_8		0xb2
+#define AXP20X_CHRG_CC_7_0		0xb3
+#define AXP20X_DISCHRG_CC_31_24		0xb4
+#define AXP20X_DISCHRG_CC_23_16		0xb5
+#define AXP20X_DISCHRG_CC_15_8		0xb6
+#define AXP20X_DISCHRG_CC_7_0		0xb7
+#define AXP20X_CC_CTRL			0xb8
+#define AXP20X_FG_RES			0xb9
+
+/* OCV */
+#define AXP20X_RDC_H			0xba
+#define AXP20X_RDC_L			0xbb
+#define AXP20X_OCV(m)			(0xc0 + (m))
+#define AXP20X_OCV_MAX			0xf
+
+/* Hot shutdoen */
+
+#define AXP20X_OVER_TMP_VAL		0xf3
+
+/* AXP22X specific registers */
+#define AXP22X_BATLOW_THRES1		0xe6
+
+/* AXP288 specific registers */
+#define AXP288_PMIC_ADC_H               0x56
+#define AXP288_PMIC_ADC_L               0x57
+#define AXP288_ADC_TS_PIN_CTRL          0x84
+#define AXP288_PMIC_ADC_EN              0x84
+
+/* Fuel Gauge */
+#define AXP288_FG_RDC1_REG          0xba
+#define AXP288_FG_RDC0_REG          0xbb
+#define AXP288_FG_OCVH_REG          0xbc
+#define AXP288_FG_OCVL_REG          0xbd
+#define AXP288_FG_OCV_CURVE_REG     0xc0
+#define AXP288_FG_DES_CAP1_REG      0xe0
+#define AXP288_FG_DES_CAP0_REG      0xe1
+#define AXP288_FG_CC_MTR1_REG       0xe2
+#define AXP288_FG_CC_MTR0_REG       0xe3
+#define AXP288_FG_OCV_CAP_REG       0xe4
+#define AXP288_FG_CC_CAP_REG        0xe5
+#define AXP288_FG_LOW_CAP_REG       0xe6
+#define AXP288_FG_TUNE0             0xe8
+#define AXP288_FG_TUNE1             0xe9
+#define AXP288_FG_TUNE2             0xea
+#define AXP288_FG_TUNE3             0xeb
+#define AXP288_FG_TUNE4             0xec
+#define AXP288_FG_TUNE5             0xed
+
+#define AXP2101_COMM_STAT0      (0x00)
+#define AXP2101_COMM_STAT1      (0x01)
+#define AXP2101_CHIP_ID         (0x03)
+#define AXP2101_DATA_BUFFER0    (0x04)
+#define AXP2101_DATA_BUFFER1    (0x05)
+#define AXP2101_DATA_BUFFER2    (0x06)
+#define AXP2101_DATA_BUFFER3    (0x07)
+#define AXP2101_COMM_FAULT      (0x08)
+#define AXP2101_COMM_CFG        (0X10)
+#define AXP2101_BATFET_CTRL     (0X12)
+#define AXP2101_DIE_TEMP_CFG    (0X13)
+#define AXP2101_VSYS_MIN        (0x14)
+#define AXP2101_VINDPM_CFG      (0x15)
+#define AXP2101_IIN_LIM         (0x16)
+#define AXP2101_RESET_CFG       (0x17)
+#define AXP2101_MODULE_EN       (0x18)
+#define AXP2101_WATCHDOG_CFG    (0x19)
+#define AXP2101_GAUGE_THLD      (0x1A)
+#define AXP2101_GPIO12_CTRL     (0x1B)
+#define AXP2101_GPIO34_CTRL     (0x1C)
+#define AXP2101_BUS_MODE_SEL    (0x1D)
+#define AXP2101_PWRON_STAT      (0x20)
+#define AXP2101_PWROFF_STAT     (0x21)
+#define AXP2101_PWROFF_EN       (0x22)
+#define AXP2101_DCDC_PWROFF_EN  (0x23)
+#define AXP2101_VOFF_THLD       (0x24)
+#define AXP2101_PWR_TIME_CTRL   (0x25)
+#define AXP2101_SLEEP_CFG       (0x26)
+#define AXP2101_PONLEVEL        (0x27)
+#define AXP2101_FAST_PWRON_CFG0 (0x28)
+#define AXP2101_FAST_PWRON_CFG1 (0x29)
+#define AXP2101_FAST_PWRON_CFG2 (0x2A)
+#define AXP2101_FAST_PWRON_CFG3 (0x2B)
+#define AXP2101_ADC_CH_EN0      (0x30)
+#define AXP2101_ADC_CH_EN1      (0x31)
+#define AXP2101_ADC_CH_EN2      (0x32)
+#define AXP2101_ADC_CH_EN3      (0x33)
+#define AXP2101_VBAT_H          (0x34)
+#define AXP2101_VBAT_L          (0x35)
+#define AXP2101_TS_H            (0x36)
+#define AXP2101_TS_L            (0x37)
+#define AXP2101_VBUS_H          (0x38)
+#define AXP2101_VBUS_L          (0x39)
+#define AXP2101_VSYS_H          (0x3A)
+#define AXP2101_VSYS_L          (0x3B)
+#define AXP2101_TDIE_H          (0x3C)
+#define AXP2101_TDIE_L          (0x3D)
+#define AXP2101_GPADC_H         (0x3E)
+#define AXP2101_GPADC_L         (0x3F)
+#define AXP2101_INTEN1          (0x40)
+#define AXP2101_INTEN2          (0x41)
+#define AXP2101_INTEN3          (0x42)
+#define AXP2101_INTSTS1         (0x48)
+#define AXP2101_INTSTS2         (0x49)
+#define AXP2101_INTSTS3         (0x4A)
+#define AXP2101_TS_CFG          (0x50)
+
+#define AXP2101_TS_HYSHL2H      (0x52)
+#define AXP2101_TS_HYSH21       (0x53)
+#define AXP2101_VLTF_CHG        (0x54)
+#define AXP2101_VHTF_CHG        (0x55)
+#define AXP2101_VLTF_WORK       (0x56)
+#define AXP2101_VHTF_WORK       (0x57)
+#define AXP2101_JEITA_CFG       (0x58)
+#define AXP2101_JEITA_CV_CFG    (0x59)
+#define AXP2101_JEITA_COOL      (0x5A)
+#define AXP2101_JEITA_WARM      (0x5B)
+#define AXP2101_TS_CFG_DATA_H   (0x5C)
+#define AXP2101_TS_CFG_DATA_L   (0x5D)
+#define AXP2101_CHG_CFG         (0x60)
+#define AXP2101_IPRECHG_CFG     (0x61)
+#define AXP2101_ICC_CFG         (0x62)
+#define AXP2101_ITERM_CFG       (0x63)
+#define AXP2101_CHG_V_CFG       (0x64)
+#define AXP2101_TREGU_THLD      (0x65)
+#define AXP2101_CHG_FREQ        (0x66)
+#define AXP2101_CHG_TMR_CFG     (0x67)
+#define AXP2101_BAT_DET         (0x68)
+#define AXP2101_CHGLED_CFG      (0x69)
+#define AXP2101_BTN_CHG_CFG     (0x6A)
+#define AXP2101_SW_TEST_CFG     (0x7B)
+#define AXP2101_DCDC_CFG0       (0x80)
+#define AXP2101_DCDC_CFG1       (0x81)
+#define AXP2101_DCDC1_CFG       (0x82)
+#define AXP2101_DCDC2_CFG       (0x83)
+#define AXP2101_DCDC3_CFG       (0x84)
+#define AXP2101_DCDC4_CFG       (0x85)
+#define AXP2101_DCDC5_CFG       (0x86)
+#define AXP2101_DCDC_OC_CFG     (0x87)
+#define AXP2101_LDO_EN_CFG0     (0x90)
+#define AXP2101_LDO_EN_CFG1     (0x91)
+#define AXP2101_ALDO1_CFG       (0x92)
+#define AXP2101_ALDO2_CFG       (0x93)
+#define AXP2101_ALDO3_CFG       (0x94)
+#define AXP2101_ALDO4_CFG       (0x95)
+#define AXP2101_BLDO1_CFG       (0x96)
+#define AXP2101_BLDO2_CFG       (0x97)
+#define AXP2101_CPUSLD_CFG      (0x98)
+#define AXP2101_DLDO1_CFG       (0x99)
+#define AXP2101_DLDO2_CFG       (0x9A)
+#define AXP2101_IP_VER          (0xA0)
+#define AXP2101_BROM            (0xA1)
+#define AXP2101_CONFIG          (0xA2)
+#define AXP2101_TEMPERATURE     (0xA3)
+#define AXP2101_SOC             (0xA4)
+#define AXP2101_TIME2EMPTY_H    (0xA6)
+#define AXP2101_TIME2EMPTY_L    (0xA7)
+#define AXP2101_TIME2FULL_H     (0xA8)
+#define AXP2101_TIME2FULL_L     (0xA9)
+#define AXP2101_FW_VERSION      (0xAB)
+#define AXP2101_INT0_FLAG       (0xAC)
+#define AXP2101_COUTER_PERIOD   (0xAD)
+#define AXP2101_BG_TRIM         (0xAE)
+#define AXP2101_OSC_TRIM        (0xAF)
+#define AXP2101_FG_ADDR         (0xB0)
+#define AXP2101_FG_DATA_H       (0xB2)
+#define AXP2101_FG_DATA_L       (0xB3)
+#define AXP2101_RAM_MBIST       (0xB4)
+#define AXP2101_ROM_TEST        (0xB5)
+#define AXP2101_ROM_TEST_RT0    (0xB6)
+#define AXP2101_ROM_TEST_RT1    (0xB7)
+#define AXP2101_ROM_TEST_RT2    (0xB8)
+#define AXP2101_ROM_TEST_RT3    (0xB9)
+#define AXP2101_WD_CLR_DIS      (0xBA)
+
+#define AXP2101_BUFFERC         (0xff)
+#define AXP2101_COMM_CFG0       (0x100)
+
+/* For AXP15 */
+#define AXP15_STATUS              (0x00)
+#define AXP15_MODE_CHGSTATUS      (0x01)
+#define AXP15_OTG_STATUS          (0x02)
+#define AXP15_IC_TYPE             (0x03)
+#define AXP15_DATA_BUFFER1        (0x04)
+#define AXP15_DATA_BUFFER2        (0x05)
+#define AXP15_DATA_BUFFER3        (0x06)
+#define AXP15_DATA_BUFFER4        (0x07)
+#define AXP15_DATA_BUFFER5        (0x08)
+#define AXP15_DATA_BUFFER6        (0x09)
+#define AXP15_DATA_BUFFER7        (0x0A)
+#define AXP15_DATA_BUFFER8        (0x0B)
+#define AXP15_DATA_BUFFER9        (0x0C)
+#define AXP15_DATA_BUFFERA        (0x0D)
+#define AXP15_DATA_BUFFERB        (0x0E)
+#define AXP15_DATA_BUFFERC        (0x0F)
+#define AXP15_LDO3456_DC1234_CTL  (0x12)
+#define AXP15_LDO0OUT_VOL         (0x15)
+#define AXP15_DC2OUT_VOL          (0x23)
+#define AXP15_DCDC2_DVM_CTRL      (0x25)
+#define AXP15_DC1OUT_VOL          (0x26)
+#define AXP15_DC3OUT_VOL          (0x27)
+#define AXP15_LDO34OUT_VOL        (0x28)
+#define AXP15_LDO5OUT_VOL         (0x29)
+#define AXP15_LDO6OUT_VOL         (0x2A)
+#define AXP15_DC4OUT_VOL          (0x2B)
+#define AXP15_IPS_SET             (0x30)
+#define AXP15_VOFF_SET            (0x31)
+#define AXP15_OFF_CTL             (0x32)
+#define AXP15_CHARGE1             (0x33)
+#define AXP15_CHARGE2             (0x34)
+#define AXP15_BACKUP_CHG          (0x35)
+#define AXP15_POK_SET             (0x36)
+#define AXP15_DCDC_FREQSET        (0x37)
+#define AXP15_VLTF_CHGSET         (0x38)
+#define AXP15_VHTF_CHGSET         (0x39)
+#define AXP15_APS_WARNING1        (0x3A)
+#define AXP15_APS_WARNING2        (0x3B)
+#define AXP15_TLTF_DISCHGSET      (0x3C)
+#define AXP15_THTF_DISCHGSET      (0x3D)
+#define AXP15_INTEN1              (0x40)
+#define AXP15_INTEN2              (0x41)
+#define AXP15_INTEN3              (0x42)
+#define AXP15_INTSTS1             (0x48)
+#define AXP15_INTSTS2             (0x49)
+#define AXP15_INTSTS3             (0x4A)
+#define AXP15_DCDC_MODESET        (0x80)
+#define AXP15_ADC_EN1             (0x82)
+#define AXP15_ADC_EN2             (0x83)
+#define AXP15_ADC_SPEED           (0x84)
+#define AXP15_ADC_INPUTRANGE      (0x85)
+#define AXP15_ADC_IRQ_RETFSET     (0x86)
+#define AXP15_ADC_IRQ_FETFSET     (0x87)
+#define AXP15_TIMER_CTL           (0x8A)
+#define AXP15_VBUS_DET_SRP        (0x8B)
+#define AXP15_HOTOVER_CTL         (0x8F)
+#define AXP15_GPIO0_CTL           (0x90)
+#define AXP15_GPIO1_CTL           (0x91)
+#define AXP15_GPIO2_CTL           (0x92)
+#define AXP15_GPIO3_CTL           (0x93)
+#define AXP15_GPIO012_SIGNAL      (0x94)
+#define AXP15_GPIO0_VOL           (0x96)
+#define AXP15_GPIO0123_SIGNAL     (0x97)
+
+/* For AXP1530 */
+#define AXP1530_ON_INDICATE          (0x00)
+#define AXP1530_OFF_INDICATE         (0x01)
+#define AXP1530_IC_TYPE              (0x03)
+#define AXP1530_OUTPUT_CONTROL       (0x10)
+#define AXP1530_DCDC_DVM_PWM         (0x12)
+#define AXP1530_DCDC1_CONRTOL        (0x13)
+#define AXP1530_DCDC2_CONRTOL        (0x14)
+#define AXP1530_DCDC3_CONRTOL        (0x15)
+#define AXP1530_ALDO1_CONRTOL        (0x16)
+#define AXP1530_DLDO1_CONRTOL        (0x17)
+#define AXP1530_POWER_STATUS         (0x1A)
+#define AXP1530_PWROK_SET            (0x1B)
+#define AXP1530_WAKEUP_CONRTOL       (0x1C)
+#define AXP1530_OUTOUT_MONITOR       (0x1D)
+#define AXP1530_POK_CONRTOL          (0x1E)
+#define AXP1530_IRQ_ENABLE1          (0x20)
+#define AXP1530_IRQ_STATUS1          (0x21)
+#define AXP1530_LOCK_REG71           (0x70)
+#define AXP1530_EPROM_SET            (0x71)
+#define AXP1530_DCDC12_DEFAULT       (0x80)
+#define AXP1530_DCDC3_A1D1_DEFAULT   (0x81)
+#define AXP1530_STARTUP_SEQ          (0x82)
+#define AXP1530_STARTUP_RTCLDO       (0x83)
+#define AXP1530_BIAS_I2C_ADDR        (0x84)
+#define AXP1530_VREF_VRPN            (0x85)
+#define AXP1530_VREF_VOL             (0x86)
+#define AXP1530_FREQUENCY            (0x87)
+
+/* For AXP858 */
+#define AXP858_ON_INDICATE          (0x00)
+#define AXP858_OFF_INDICATE         (0x01)
+#define AXP858_IC_TYPE              (0x03)
+#define AXP858_DATA_BUFFER1        (0x04)
+#define AXP858_DATA_BUFFER2        (0x05)
+#define AXP858_DATA_BUFFER3        (0x06)
+#define AXP858_DATA_BUFFER4        (0x07)
+
+#define AXP858_OUTPUT_CONTROL1       (0x10)
+#define AXP858_OUTPUT_CONTROL2      (0x11)
+#define AXP858_OUTPUT_CONTROL3        (0x12)
+#define AXP858_DCDC1_CONTROL        (0x13)
+#define AXP858_DCDC2_CONTROL        (0x14)
+#define AXP858_DCDC3_CONTROL        (0x15)
+#define AXP858_DCDC4_CONTROL        (0x16)
+#define AXP858_DCDC5_CONTROL         (0x17)
+#define AXP858_DCDC6_CONTROL            (0x18)
+#define AXP858_ALDO1_CONTROL       (0x19)
+#define AXP858_DCDC_MODE1       (0x1A)
+#define AXP858_DCDC_MODE2          (0x1B)
+#define AXP858_DCDC_MODE3          (0x1C)
+#define AXP858_DCDC_FREQUENCY          (0x1D)
+#define AXP858_OUTPUT_MONITOR           (0x1E)
+#define AXP858_IRQ_PWROK_VOFF            (0x1F)
+#define AXP858_ALDO2_CTL       (0x20)
+#define AXP858_ALDO3_CTL   (0x21)
+#define AXP858_ALDO4_CTL          (0x22)
+#define AXP858_ALDO5_CTL       (0x23)
+#define AXP858_BLDO1_CTL        (0x24)
+#define AXP858_BLDO2_CTL            (0x25)
+#define AXP858_BLDO3_CTL             (0x26)
+#define AXP858_BLDO4_CTL            (0x27)
+#define AXP858_BLDO5_CTL            (0x28)
+#define AXP858_CLDO1_CTL            (0x29)
+#define AXP858_CLDO2_CTL            (0x2A)
+#define AXP858_CLDO3_GPIO1_CTL            (0x2B)
+#define AXP858_CLDO4_GPIO2_CTL            (0x2C)
+#define AXP858_CLDO4_CTL            (0x2D)
+#define AXP858_CPUSLDO_CTL            (0x2E)
+#define AXP858_WKP_CTL_OC_IRQ            (0x31)
+#define AXP858_POWER_DOWN_DIS            (0x32)
+#define AXP858_POK_SET            (0x36)
+#define AXP858_TWI_OR_RSB            (0x3E)
+#define AXP858_IRQ_EN1            (0x40)
+#define AXP858_IRQ_EN2            (0x41)
+#define AXP858_IRQ_STS1            (0x48)
+#define AXP858_IRQ_STS2            (0x49)
+#define AXP858_DIGITAL_PAT1            (0xF0)
+#define AXP858_DIGITAL_PAT2            (0xF1)
+#define AXP858_EPROM_SET            (0xF2)
+#define AXP858_VREF_TEM_SET            (0xF3)
+#define AXP858_LOCK_F0125            (0xF4)
+#define AXP858_EPROM_TUNE            (0xF5)
+#define AXP858_ADDR_EXTEN            (0xFF)
+#define AXP858_DCDC1_PWRON_DEF          (0x100)
+#define AXP858_DCDC2_DEF          (0x101)
+#define AXP858_DCDC3_DEF          (0x102)
+#define AXP858_DCDC4_DEF          (0x103)
+#define AXP858_DCDC5_DEF          (0x104)
+#define AXP858_DCDC6_DEF          (0x105)
+#define AXP858_ALDO12_DEF          (0x106)
+#define AXP858_ALDO23_DEF          (0x107)
+#define AXP858_ALDO45_DEF          (0x108)
+#define AXP858_ALDO5_BLDO1_DEF          (0x109)
+#define AXP858_BLDO12_DEF          (0x10A)
+#define AXP858_BLDO23_DEF          (0x10B)
+#define AXP858_BLDO45_DEF          (0x10C)
+#define AXP858_BLDO5_CLDO1_DEF          (0x10D)
+#define AXP858_CLDO23_DEF          (0x10E)
+#define AXP858_CLDO34_DEF          (0x10F)
+#define AXP858_START_DCDC123          (0x110)
+#define AXP858_START_DCDC456          (0x111)
+#define AXP858_START_ALDO12          (0x112)
+#define AXP858_START_ALDO345          (0x113)
+#define AXP858_START_BLDO123          (0x114)
+#define AXP858_START_BLDO45          (0x115)
+#define AXP858_START_CLDO123          (0x116)
+#define AXP858_START_CLDO34_CPUS          (0x117)
+#define AXP858_TWI_RSB_SET1          (0x118)
+#define AXP858_TWI_RSB_SET2          (0x119)
+#define AXP858_TWI_SET          (0x11A)
+#define AXP858_VREF_TC_ALDO3          (0x140)
+#define AXP858_VREF_VOL          (0x141)
+#define AXP858_INTERNAL_ALDO2          (0x142)
+#define AXP858_FREQUENCY_ALDO2          (0x143)
+
+/* For AXP803 */
+#define AXP803_STATUS              (0x00)
+#define AXP803_MODE_CHGSTATUS      (0x01)
+#define AXP803_IC_TYPE             (0x03)
+#define AXP803_BUFFER1             (0x04)
+#define AXP803_BUFFER2             (0x05)
+#define AXP803_BUFFER3             (0x06)
+#define AXP803_BUFFER4             (0x07)
+#define AXP803_BUFFER5             (0x08)
+#define AXP803_BUFFER6             (0x09)
+#define AXP803_BUFFER7             (0x0A)
+#define AXP803_BUFFER8             (0x0B)
+#define AXP803_BUFFER9             (0x0C)
+#define AXP803_BUFFERA             (0x0D)
+#define AXP803_BUFFERB             (0x0E)
+#define AXP803_BUFFERC             (0x0F)
+#define AXP803_LDO_DC_EN1          (0X10)
+#define AXP803_LDO_DC_EN2          (0X12)
+#define AXP803_LDO_DC_EN3          (0X13)
+#define AXP803_DLDO1OUT_VOL        (0x15)
+#define AXP803_DLDO2OUT_VOL        (0x16)
+#define AXP803_DLDO3OUT_VOL        (0x17)
+#define AXP803_DLDO4OUT_VOL        (0x18)
+#define AXP803_ELDO1OUT_VOL        (0x19)
+#define AXP803_ELDO2OUT_VOL        (0x1A)
+#define AXP803_ELDO3OUT_VOL        (0x1B)
+#define AXP803_FLDO1OUT_VOL        (0x1C)
+#define AXP803_FLDO2OUT_VOL        (0x1D)
+#define AXP803_DC1OUT_VOL          (0x20)
+#define AXP803_DC2OUT_VOL          (0x21)
+#define AXP803_DC3OUT_VOL          (0x22)
+#define AXP803_DC4OUT_VOL          (0x23)
+#define AXP803_DC5OUT_VOL          (0x24)
+#define AXP803_DC6OUT_VOL          (0x25)
+#define AXP803_DC7OUT_VOL          (0x26)
+#define AXP803_DCDC_DVM_CTL        (0x27)
+#define AXP803_ALDO1OUT_VOL        (0x28)
+#define AXP803_ALDO2OUT_VOL        (0x29)
+#define AXP803_ALDO3OUT_VOL        (0x2A)
+#define AXP803_BC_CTL              (0X2C)
+#define AXP803_IPS_SET             (0x30)
+#define AXP803_VOFF_SET            (0x31)
+#define AXP803_OFF_CTL             (0x32)
+#define AXP803_CHARGE1             (0x33)
+#define AXP803_CHARGE2             (0x34)
+#define AXP803_CHARGE3             (0x35)
+#define AXP803_POK_SET             (0x36)
+#define AXP803_VLTF_CHARGE         (0x38)
+#define AXP803_VHTF_CHARGE         (0x39)
+#define AXP803_CHARGE_AC_SET       (0x3A)
+#define AXP803_DCDC_FREQSET        (0x3B)
+#define AXP803_VLTF_WORK           (0x3C)
+#define AXP803_VHTF_WORK           (0x3D)
+#define AXP803_INTEN1              (0x40)
+#define AXP803_INTEN2              (0x41)
+#define AXP803_INTEN3              (0x42)
+#define AXP803_INTEN4              (0x43)
+#define AXP803_INTEN5              (0x44)
+#define AXP803_INTEN6              (0x45)
+#define AXP803_INTSTS1             (0x48)
+#define AXP803_INTSTS2             (0x49)
+#define AXP803_INTSTS3             (0x4A)
+#define AXP803_INTSTS4             (0x4B)
+#define AXP803_INTSTS5             (0x4C)
+#define AXP803_INTSTS6             (0x4D)
+#define AXP803_INTTEMP             (0x56)
+#define AXP803_VTS_RES             (0x58)
+#define AXP803_VBATH_RES           (0x78)
+#define AXP803_VBATL_RES           (0x79)
+#define AXP803_IBATH_REG           (0x7A)
+#define AXP803_DISIBATH_REG        (0x7C)
+#define AXP803_DCDC_MODESET        (0x80)
+#define AXP803_ADC_EN              (0x82)
+#define AXP803_ADC_SPEED_SET       (0x85)
+#define AXP803_HOTOVER_CTL         (0x8F)
+#define AXP803_GPIO0_CTL           (0x90)
+#define AXP803_GPIO0LDOOUT_VOL     (0x91)
+#define AXP803_GPIO1_CTL           (0x92)
+#define AXP803_GPIO1LDOOUT_VOL     (0x93)
+#define AXP803_GPIO01_SIGNAL       (0x94)
+#define AXP803_BAT_CHGCOULOMB3     (0xB0)
+#define AXP803_BAT_CHGCOULOMB2     (0xB1)
+#define AXP803_BAT_CHGCOULOMB1     (0xB2)
+#define AXP803_BAT_CHGCOULOMB0     (0xB3)
+#define AXP803_BAT_DISCHGCOULOMB3  (0xB4)
+#define AXP803_BAT_DISCHGCOULOMB2  (0xB5)
+#define AXP803_BAT_DISCHGCOULOMB1  (0xB6)
+#define AXP803_BAT_DISCHGCOULOMB0  (0xB7)
+#define AXP803_COULOMB_CTL         (0xB8)
+#define AXP803_CAP                 (0xB9)
+#define AXP803_RDC0                (0xBA)
+#define AXP803_RDC1                (0xBB)
+#define AXP803_OCVBATH_RES         (0xBC)
+#define AXP803_OCVBATL_RES         (0xBD)
+#define AXP803_OCVCAP              (0xC0)
+#define AXP803_BATCAP0             (0xE0)
+#define AXP803_BATCAP1             (0xE1)
+#define AXP803_COUCNT0             (0xE2)
+#define AXP803_COUCNT1             (0xE3)
+#define AXP803_OCV_PERCENT         (0xE4)
+#define AXP803_COU_PERCENT         (0xE5)
+#define AXP803_WARNING_LEVEL       (0xE6)
+#define AXP803_ADJUST_PARA         (0xE8)
+#define AXP803_ADJUST_PARA1        (0xE9)
+#define AXP803_HOTOVER_VAL         (0xF3)
+#define AXP803_REG_ADDR_EXT        (0xFF)
+
+/*
+ * axp2202 define
+ */
+#define AXP2202_COMM_STAT0          (0x00)
+#define AXP2202_COMM_STAT1          (0x01)
+#define AXP2202_CHIP_ID             (0x03)
+#define AXP2202_CHIP_VER            (0x04)
+#define AXP2202_BC_DECT             (0x05)
+#define AXP2202_ILIM_TYPE           (0x06)
+#define AXP2202_COMM_FAULT          (0x08)
+#define AXP2202_ICO_CFG             (0x0a)
+#define AXP2202_CLK_EN              (0x0b)
+
+#define AXP2202_COMM_CFG            (0x10)
+#define AXP2202_BATFET_CTRL         (0x12)
+#define AXP2202_RBFET_CTRL          (0x13)
+#define AXP2202_DIE_TEMP_CFG        (0x14)
+#define AXP2202_VSYS_MIN            (0x15)
+#define AXP2202_VIMDPM_CFG          (0x16)
+#define AXP2202_IIN_LIM             (0x17)
+#define AXP2202_RESET_CFG           (0x18)
+#define AXP2202_MODULE_EN           (0x19)
+#define AXP2202_WATCHDOG_CFG        (0x1a)
+#define AXP2202_GAUGE_THLD          (0x1b)
+#define AXP2202_GPIO_CTRL           (0x1c)
+#define AXP2202_LOW_POWER_CFG       (0x1d)
+#define AXP2202_BST_CFG0            (0x1e)
+#define AXP2202_BST_CFG1            (0x1f)
+
+#define AXP2202_PWRON_STAT          (0x20)
+#define AXP2202_PWROFF_STAT         (0x21)
+#define AXP2202_PWROFF_EN           (0x22)
+#define AXP2202_DCDC_PWROFF_EN      (0x23)
+#define AXP2202_PWR_TIME_CTRL       (0x24)
+#define AXP2202_SLEEP_CFG           (0x25)
+#define AXP2202_PONLEVEL            (0x26)
+#define AXP2202_SOFT_PWROFF         (0x27)
+#define AXP2202_AUTO_SLP_MAP0       (0x28)
+#define AXP2202_AUTOSLP_MAP1        (0x29)
+#define AXP2202_AUTOSLP_MAP2        (0x2a)
+#define AXP2202_FAST_PWRON_CFG0     (0x2b)
+#define AXP2202_FAST_PWRON_CFG1     (0x2c)
+#define AXP2202_FAST_PWRON_CFG2     (0x2d)
+#define AXP2202_FAST_PWRON_CFG3     (0x2e)
+#define AXP2202_FAST_PWRON_CFG4     (0x2f)
+#define AXP2202_I2C_CFG             (0x30)
+#define AXP2202_BUS_MODE_SEL        (0x3e)
+
+#define AXP2202_IRQ_EN0             (0x40)
+#define AXP2202_IRQ_EN1             (0x41)
+#define AXP2202_IRQ_EN2             (0x42)
+#define AXP2202_IRQ_EN3             (0x43)
+#define AXP2202_IRQ_EN4             (0x44)
+#define AXP2202_IRQ0                (0x48)
+#define AXP2202_IRQ1                (0x49)
+#define AXP2202_IRQ2                (0x4a)
+#define AXP2202_IRQ3                (0x4b)
+#define AXP2202_IRQ4                (0x4c)
+
+#define AXP2202_TS_CFG              (0x50)
+#define AXP2202_TS_HYSL2H           (0x52)
+#define AXP2202_TS_HYSH2L           (0x53)
+#define AXP2202_VLTF_CHG            (0x54)
+#define AXP2202_VHTF_CHG            (0x55)
+#define AXP2202_VLTF_WORK           (0x56)
+#define AXP2202_VHTF_WORK           (0x57)
+#define AXP2202_JEITA_CFG           (0x58)
+#define AXP2202_JEITA_CV_CFG        (0x59)
+#define AXP2202_JEITA_COOL          (0x5a)
+#define AXP2202_JEITA_WARM          (0x5b)
+#define AXP2202_TS_CFG_DATA_H       (0x5c)
+#define AXP2202_TS_CFG_DATA_L       (0x5d)
+
+#define AXP2202_RECHG_CFG           (0x60)
+#define AXP2202_IPRECHG_CFG         (0x61)
+#define AXP2202_ICC_CFG             (0x62)
+#define AXP2202_ITERM_CFG           (0x63)
+#define AXP2202_VTERM_CFG           (0x64)
+#define AXP2202_TREGU_THLD          (0x65)
+#define AXP2202_CHG_FREQ            (0x66)
+#define AXP2202_CHG_TMR_CFG         (0x67)
+#define AXP2202_BAT_DET             (0x68)
+#define AXP2202_IR_COMP             (0x69)
+#define AXP2202_BTN_CHG_CFG         (0x6a)
+#define AXP2202_SW_TEST_CFG         (0x6b)
+
+#define AXP2202_CHGLED_CFG          (0x70)
+#define AXP2202_LOW_NUM             (0x72)
+#define AXP2202_HIGH_NUM            (0x73)
+#define AXP2202_TRANS_NUM           (0x74)
+#define AXP2202_DUTY_STEP           (0x76)
+#define AXP2202_DUTY_MIN            (0x77)
+#define AXP2202_PWN_PERIOD          (0x78)
+
+#define AXP2202_DCDC_CFG0           (0x80)
+#define AXP2202_DCDC_CFG1           (0x81)
+#define AXP2202_DCDC_CFG2           (0x82)
+#define AXP2202_DCDC1_CFG           (0x83)
+#define AXP2202_DCDC2_CFG           (0x84)
+#define AXP2202_DCDC3_CFG           (0x85)
+#define AXP2202_DCDC4_CFG           (0x86)
+#define AXP2202_DVM_STAT            (0x87)
+#define AXP2202_DCDC_OC_CFG         (0x88)
+#define AXP2202_DCDC_VDSDT_ADJ      (0x89)
+
+#define AXP2202_LDO_EN_CFG0         (0x90)
+#define AXP2202_LDO_EN_CFG1         (0x91)
+#define AXP2202_ALDO1_CFG           (0x93)
+#define AXP2202_ALDO2_CFG           (0x94)
+#define AXP2202_ALDO3_CFG           (0x95)
+#define AXP2202_ALDO4_CFG           (0x96)
+#define AXP2202_BLDO1_CFG           (0x97)
+#define AXP2202_BLDO2_CFG           (0x98)
+#define AXP2202_BLDO3_CFG           (0x99)
+#define AXP2202_BLDO4_CFG           (0x9a)
+#define AXP2202_CLDO1_CFG           (0x9b)
+#define AXP2202_CLDO2_CFG           (0x9c)
+#define AXP2202_CLDO3_CFG           (0x9d)
+#define AXP2202_CLDO4_CFG           (0x9e)
+#define AXP2202_CPUSLDO_CFG         (0x9f)
+
+#define AXP2202_GAUGE_IP_VER        (0xa0)
+#define AXP2202_GAUGE_BROM          (0xa1)
+#define AXP2202_GAUGE_CONFIG        (0xa2)
+#define AXP2202_GAUGE_TEMPERATURE   (0xa3)
+#define AXP2202_GAUGE_SOC           (0xa4)
+#define AXP2202_GAUGE_TIME2EMPTY_H  (0xa6)
+#define AXP2202_GAUGE_TIME2EMPTY_L  (0xa7)
+#define AXP2202_GAUGE_TIME2FULL_H   (0xa8)
+#define AXP2202_GAUGE_TIME2FULL_L   (0xa9)
+#define AXP2202_GAUGE_FW_VERSION    (0xab)
+#define AXP2202_GAUGE_INT0_FLAG     (0xac)
+#define AXP2202_GAUGE_COUTER_PERIOD (0xad)
+#define AXP2202_GAUGE_FG_ADDR       (0xb0)
+#define AXP2202_GAUGE_FG_DATA_H     (0xb2)
+#define AXP2202_GAUGE_FG_DATA_L     (0xb3)
+#define AXP2202_GAUGE_RAM_MBIST     (0xb4)
+#define AXP2202_GAUGE_ROM_TEST      (0xb5)
+#define AXP2202_GAUGE_ROM_TEST_RT0  (0xb6)
+#define AXP2202_GAUGE_ROM_TEST_RT1  (0xb7)
+#define AXP2202_GAUGE_ROM_TEST_RT2  (0xb8)
+#define AXP2202_GAUGE_ROM_TEST_RT3  (0xb9)
+#define AXP2202_GAUGE_WD_CLR_DIS    (0xba)
+
+#define AXP2202_ADC_CH_EN0          (0xc0)
+#define AXP2202_ADC_CH_EN1          (0xc1)
+#define AXP2202_ADC_CH_EN2          (0xc2)
+#define AXP2202_ADC_CH_EN3          (0xc3)
+#define AXP2202_VBAT_H              (0xc4)
+#define AXP2202_VBAT_L              (0xc5)
+#define AXP2202_VBUS_H              (0xc6)
+#define AXP2202_VBUS_L              (0xc7)
+#define AXP2202_VSYS_H              (0xc8)
+#define AXP2202_VSYS_L              (0xc9)
+#define AXP2202_ICHG_H              (0xca)
+#define AXP2202_ICHG_L              (0xcb)
+#define AXP2202_CH_DBG_SEL          (0xcc)
+#define AXP2202_ADC_DATA_SEL        (0xcd)
+#define AXP2202_ADC_DATA_H          (0xce)
+#define AXP2202_ADC_DATA_L          (0xcf)
+
+#define AXP2202_BC_CFG0             (0xd0)
+#define AXP2202_BC_CFG1             (0xd1)
+#define AXP2202_BC_CFG2             (0xd2)
+#define AXP2202_BC_CFG3             (0xd3)
+
+#define AXP2202_CC_VERSION          (0xe0)
+#define AXP2202_CC_GLB_CTRL         (0xe1)
+#define AXP2202_CC_LP_CTRL          (0xe2)
+#define AXP2202_CC_MODE_CTRL        (0xe3)
+#define AXP2202_CC_TGL_CTRL0        (0xe4)
+#define AXP2202_CC_TGL_CTRL1        (0xe5)
+#define AXP2202_CC_ANA_CTRL         (0xe6)
+#define AXP2202_CC_STAT0            (0xe7)
+#define AXP2202_CC_STAT1            (0xe8)
+#define AXP2202_CC_STAT2            (0xe9)
+#define AXP2202_CC_STAT3            (0xea)
+#define AXP2202_CC_STAT4            (0xeb)
+#define AXP2202_CC_ANA_STAT0        (0xec)
+#define AXP2202_CC_ANA_STAT1        (0xed)
+#define AXP2202_CC_ANA_STAT2        (0xee)
+
+#define AXP2202_EFUS_OP_CFG         (0xf0)
+#define AXP2202_EFREG_CTRL          (0xf1)
+#define AXP2202_TWI_ADDR_EXT        (0xff)
+/*
+ * end of define axp2202
+ */
+
+/* For axp2585 */
+#define AXP2585_STATUS              (0x00)
+#define AXP2585_IC_TYPE             (0x03)
+#define AXP2585_ILIMIT              (0x10)
+#define AXP2585_RBFET_SET           (0x11)
+#define AXP2585_POK_SET             (0x15)
+#define AXP2585_GPIO1_CTL           (0x18)
+#define AXP2585_GPIO2_CTL           (0x19)
+#define AXP2585_GPIO1_SIGNAL        (0x1A)
+#define AXP2585_CC_EN               (0x22)
+#define AXP2585_ADC_EN              (0x24)
+#define AXP2585_OFF_CTL             (0x28)
+#define AXP2585_CC_LOW_POWER_CTRL   (0x32)
+#define AXP2585_CC_MODE_CTRL        (0x33)
+#define AXP2585_CC_STATUS0          (0x37)
+#define AXP2585_INTEN1              (0x40)
+#define AXP2585_INTEN2              (0x41)
+#define AXP2585_INTEN3              (0x42)
+#define AXP2585_INTEN4              (0x43)
+#define AXP2585_INTEN5              (0x44)
+#define AXP2585_INTEN6              (0x45)
+#define AXP2585_INTSTS1             (0x48)
+#define AXP2585_INTSTS2             (0x49)
+#define AXP2585_INTSTS3             (0x4A)
+#define AXP2585_INTSTS4             (0x4B)
+#define AXP2585_INTSTS5             (0x4C)
+#define AXP2585_INTSTS6             (0x4D)
+#define AXP2585_VBATH_REG           (0x78)
+#define AXP2585_IBATH_REG           (0x7A)
+#define AXP2585_DISIBATH_REG        (0x7c)
+#define AXP2585_ADC_CONTROL         (0x80)
+#define AXP2585_TS_PIN_CONTROL      (0x81)
+#define AXP2585_VLTF_CHARGE         (0x84)
+#define AXP2585_VHTF_CHARGE         (0x85)
+#define AXP2585_VLTF_WORK           (0x86)
+#define AXP2585_VHTF_WORK           (0x87)
+#define AXP2585_ICC_CFG             (0x8B)
+#define AXP2585_CHARGE_CONTROL2     (0x8C)
+#define AXP2585_TIMER2_SET          (0x8E)
+#define AXP2585_COULOMB_CTL         (0xB8)
+#define AXP2585_CAP                 (0xB9)
+#define AXP2585_RDC0                (0xBA)
+#define AXP2585_RDC1               (0xBB)
+#define AXP2585_BATCAP0             (0xE0)
+#define AXP2585_BATCAP1             (0xE1)
+#define AXP2585_WARNING_LEVEL       (0xE6)
+#define AXP2585_ADJUST_PARA         (0xE8)
+#define AXP2585_ADJUST_PARA1        (0xE9)
+#define AXP2585_ADDR_EXTENSION      (0xFF)
+
+/* Regulators IDs */
+enum {
+	AXP152_DCDC1 = 0,
+	AXP152_DCDC2,
+	AXP152_DCDC3,
+	AXP152_DCDC4,
+	AXP152_ALDO1,
+	AXP152_ALDO2,
+	AXP152_DLDO1,
+	AXP152_DLDO2,
+	AXP152_LDO0,
+	AXP152_GPIO2_LDO,
+	AXP152_RTC13,
+	AXP152_RTC18,
+	AXP152_REG_ID_MAX,
+};
+
+enum {
+	AXP20X_LDO1 = 0,
+	AXP20X_LDO2,
+	AXP20X_LDO3,
+	AXP20X_LDO4,
+	AXP20X_LDO5,
+	AXP20X_DCDC2,
+	AXP20X_DCDC3,
+	AXP20X_REG_ID_MAX,
+};
+
+enum {
+	AXP22X_DCDC1 = 0,
+	AXP22X_DCDC2,
+	AXP22X_DCDC3,
+	AXP22X_DCDC4,
+	AXP22X_DCDC5,
+	AXP22X_DC1SW,
+	AXP22X_DC5LDO,
+	AXP22X_ALDO1,
+	AXP22X_ALDO2,
+	AXP22X_ALDO3,
+	AXP22X_ELDO1,
+	AXP22X_ELDO2,
+	AXP22X_ELDO3,
+	AXP22X_DLDO1,
+	AXP22X_DLDO2,
+	AXP22X_DLDO3,
+	AXP22X_DLDO4,
+	AXP22X_RTC_LDO,
+	AXP22X_LDO_IO0,
+	AXP22X_LDO_IO1,
+	AXP22X_REG_ID_MAX,
+};
+
+enum {
+	AXP806_DCDCA = 0,
+	AXP806_DCDCB,
+	AXP806_DCDCC,
+	AXP806_DCDCD,
+	AXP806_DCDCE,
+	AXP806_ALDO1,
+	AXP806_ALDO2,
+	AXP806_ALDO3,
+	AXP806_BLDO1,
+	AXP806_BLDO2,
+	AXP806_BLDO3,
+	AXP806_BLDO4,
+	AXP806_CLDO1,
+	AXP806_CLDO2,
+	AXP806_CLDO3,
+	AXP806_SW,
+	AXP806_REG_ID_MAX,
+};
+
+enum {
+	AXP809_DCDC1 = 0,
+	AXP809_DCDC2,
+	AXP809_DCDC3,
+	AXP809_DCDC4,
+	AXP809_DCDC5,
+	AXP809_DC1SW,
+	AXP809_DC5LDO,
+	AXP809_ALDO1,
+	AXP809_ALDO2,
+	AXP809_ALDO3,
+	AXP809_ELDO1,
+	AXP809_ELDO2,
+	AXP809_ELDO3,
+	AXP809_DLDO1,
+	AXP809_DLDO2,
+	AXP809_RTC_LDO,
+	AXP809_LDO_IO0,
+	AXP809_LDO_IO1,
+	AXP809_SW,
+	AXP809_REG_ID_MAX,
+};
+
+enum {
+	AXP2101_DCDC1 = 0,
+	AXP2101_DCDC2,
+	AXP2101_DCDC3,
+	AXP2101_DCDC4,
+	AXP2101_DCDC5,
+	AXP2101_LDO1,  /* RTCLDO */
+	AXP2101_LDO2,  /* RTCLDO1 */
+	AXP2101_LDO3,  /* ALDO1 */
+	AXP2101_LDO4,  /* ALDO2 */
+	AXP2101_LDO5,  /* ALDO3 */
+	AXP2101_LDO6,  /* ALDO4 */
+	AXP2101_LDO7,  /* BLDO1 */
+	AXP2101_LDO8,  /* BLDO2 */
+	AXP2101_LDO9,  /* DLDO1 */
+	AXP2101_LDO10, /* DLDO2 */
+	AXP2101_LDO11, /* CPULDOS */
+	AXP2101_REG_ID_MAX,
+};
+
+enum {
+	AXP15_DCDC1 = 0,
+	AXP15_DCDC2,
+	AXP15_DCDC3,
+	AXP15_DCDC4,
+	AXP15_DCDC5,
+	AXP15_LDO1,  /* RTCLDO */
+	AXP15_LDO2,  /* RTCLDO1 */
+	AXP15_LDO3,  /* ALDO1 */
+	AXP15_LDO4,  /* ALDO2 */
+	AXP15_LDO5,  /* ALDO3 */
+	AXP15_LDO6,  /* ALDO4 */
+	AXP15_LDO7,  /* BLDO1 */
+	AXP15_REG_ID_MAX,
+};
+
+enum {
+	AXP1530_DCDC1 = 0,
+	AXP1530_DCDC2,
+	AXP1530_DCDC3,
+	AXP1530_LDO1,  /* RTCLDO */
+	AXP1530_LDO2,  /* RTCLDO1 */
+	AXP1530_REG_ID_MAX,
+};
+
+enum {
+	AXP858_DCDC1 = 0,
+	AXP858_DCDC2,
+	AXP858_DCDC3,
+	AXP858_DCDC4,
+	AXP858_DCDC5,
+	AXP858_DCDC6,
+	AXP858_ALDO1,
+	AXP858_ALDO2,
+	AXP858_ALDO3,
+	AXP858_ALDO4,
+	AXP858_ALDO5,
+	AXP858_BLDO1,
+	AXP858_BLDO2,
+	AXP858_BLDO3,
+	AXP858_BLDO4,
+	AXP858_BLDO5,
+	AXP858_CLDO1,
+	AXP858_CLDO2,
+	AXP858_CLDO3,
+	AXP858_CLDO4,
+	AXP858_CPUSLDO,
+	AXP858_DC1SW,
+	AXP858_REG_ID_MAX,
+};
+
+enum {
+	AXP803_DCDC1 = 0,
+	AXP803_DCDC2,
+	AXP803_DCDC3,
+	AXP803_DCDC4,
+	AXP803_DCDC5,
+	AXP803_DCDC6,
+	AXP803_DCDC7,
+	AXP803_RTCLDO,
+	AXP803_ALDO1,
+	AXP803_ALDO2,
+	AXP803_ALDO3,
+	AXP803_DLDO1,
+	AXP803_DLDO2,
+	AXP803_DLDO3,
+	AXP803_DLDO4,
+	AXP803_ELDO1,
+	AXP803_ELDO2,
+	AXP803_ELDO3,
+	AXP803_FLDO1,
+	AXP803_FLDO2,
+	AXP803_LDOIO0,
+	AXP803_LDOIO1,
+	AXP803_DC1SW,
+	AXP803_REG_ID_MAX,
+};
+
+enum {
+	AXP2585_REG_ID_MAX = 0,
+};
+
+/* IRQs */
+enum {
+	AXP152_IRQ_LDO0IN_CONNECT = 1,
+	AXP152_IRQ_LDO0IN_REMOVAL,
+	AXP152_IRQ_ALDO0IN_CONNECT,
+	AXP152_IRQ_ALDO0IN_REMOVAL,
+	AXP152_IRQ_DCDC1_V_LOW,
+	AXP152_IRQ_DCDC2_V_LOW,
+	AXP152_IRQ_DCDC3_V_LOW,
+	AXP152_IRQ_DCDC4_V_LOW,
+	AXP152_IRQ_PEK_SHORT,
+	AXP152_IRQ_PEK_LONG,
+	AXP152_IRQ_TIMER,
+	AXP152_IRQ_PEK_RIS_EDGE,
+	AXP152_IRQ_PEK_FAL_EDGE,
+	AXP152_IRQ_GPIO3_INPUT,
+	AXP152_IRQ_GPIO2_INPUT,
+	AXP152_IRQ_GPIO1_INPUT,
+	AXP152_IRQ_GPIO0_INPUT,
+};
+
+enum {
+	AXP20X_IRQ_ACIN_OVER_V = 1,
+	AXP20X_IRQ_ACIN_PLUGIN,
+	AXP20X_IRQ_ACIN_REMOVAL,
+	AXP20X_IRQ_VBUS_OVER_V,
+	AXP20X_IRQ_VBUS_PLUGIN,
+	AXP20X_IRQ_VBUS_REMOVAL,
+	AXP20X_IRQ_VBUS_V_LOW,
+	AXP20X_IRQ_BATT_PLUGIN,
+	AXP20X_IRQ_BATT_REMOVAL,
+	AXP20X_IRQ_BATT_ENT_ACT_MODE,
+	AXP20X_IRQ_BATT_EXIT_ACT_MODE,
+	AXP20X_IRQ_CHARG,
+	AXP20X_IRQ_CHARG_DONE,
+	AXP20X_IRQ_BATT_TEMP_HIGH,
+	AXP20X_IRQ_BATT_TEMP_LOW,
+	AXP20X_IRQ_DIE_TEMP_HIGH,
+	AXP20X_IRQ_CHARG_I_LOW,
+	AXP20X_IRQ_DCDC1_V_LONG,
+	AXP20X_IRQ_DCDC2_V_LONG,
+	AXP20X_IRQ_DCDC3_V_LONG,
+	AXP20X_IRQ_PEK_SHORT = 22,
+	AXP20X_IRQ_PEK_LONG,
+	AXP20X_IRQ_N_OE_PWR_ON,
+	AXP20X_IRQ_N_OE_PWR_OFF,
+	AXP20X_IRQ_VBUS_VALID,
+	AXP20X_IRQ_VBUS_NOT_VALID,
+	AXP20X_IRQ_VBUS_SESS_VALID,
+	AXP20X_IRQ_VBUS_SESS_END,
+	AXP20X_IRQ_LOW_PWR_LVL1,
+	AXP20X_IRQ_LOW_PWR_LVL2,
+	AXP20X_IRQ_TIMER,
+	AXP20X_IRQ_PEK_RIS_EDGE,
+	AXP20X_IRQ_PEK_FAL_EDGE,
+	AXP20X_IRQ_GPIO3_INPUT,
+	AXP20X_IRQ_GPIO2_INPUT,
+	AXP20X_IRQ_GPIO1_INPUT,
+	AXP20X_IRQ_GPIO0_INPUT,
+};
+
+enum axp22x_irqs {
+	AXP22X_IRQ_ACIN_OVER_V = 1,
+	AXP22X_IRQ_ACIN_PLUGIN,
+	AXP22X_IRQ_ACIN_REMOVAL,
+	AXP22X_IRQ_VBUS_OVER_V,
+	AXP22X_IRQ_VBUS_PLUGIN,
+	AXP22X_IRQ_VBUS_REMOVAL,
+	AXP22X_IRQ_VBUS_V_LOW,
+	AXP22X_IRQ_BATT_PLUGIN,
+	AXP22X_IRQ_BATT_REMOVAL,
+	AXP22X_IRQ_BATT_ENT_ACT_MODE,
+	AXP22X_IRQ_BATT_EXIT_ACT_MODE,
+	AXP22X_IRQ_CHARG,
+	AXP22X_IRQ_CHARG_DONE,
+	AXP22X_IRQ_BATT_TEMP_HIGH,
+	AXP22X_IRQ_BATT_TEMP_LOW,
+	AXP22X_IRQ_DIE_TEMP_HIGH,
+	AXP22X_IRQ_PEK_SHORT,
+	AXP22X_IRQ_PEK_LONG,
+	AXP22X_IRQ_LOW_PWR_LVL1,
+	AXP22X_IRQ_LOW_PWR_LVL2,
+	AXP22X_IRQ_TIMER,
+	AXP22X_IRQ_PEK_RIS_EDGE,
+	AXP22X_IRQ_PEK_FAL_EDGE,
+	AXP22X_IRQ_GPIO1_INPUT,
+	AXP22X_IRQ_GPIO0_INPUT,
+};
+
+enum axp288_irqs {
+	AXP288_IRQ_VBUS_FALL     = 2,
+	AXP288_IRQ_VBUS_RISE,
+	AXP288_IRQ_OV,
+	AXP288_IRQ_FALLING_ALT,
+	AXP288_IRQ_RISING_ALT,
+	AXP288_IRQ_OV_ALT,
+	AXP288_IRQ_DONE          = 10,
+	AXP288_IRQ_CHARGING,
+	AXP288_IRQ_SAFE_QUIT,
+	AXP288_IRQ_SAFE_ENTER,
+	AXP288_IRQ_ABSENT,
+	AXP288_IRQ_APPEND,
+	AXP288_IRQ_QWBTU,
+	AXP288_IRQ_WBTU,
+	AXP288_IRQ_QWBTO,
+	AXP288_IRQ_WBTO,
+	AXP288_IRQ_QCBTU,
+	AXP288_IRQ_CBTU,
+	AXP288_IRQ_QCBTO,
+	AXP288_IRQ_CBTO,
+	AXP288_IRQ_WL2,
+	AXP288_IRQ_WL1,
+	AXP288_IRQ_GPADC,
+	AXP288_IRQ_OT            = 31,
+	AXP288_IRQ_GPIO0,
+	AXP288_IRQ_GPIO1,
+	AXP288_IRQ_POKO,
+	AXP288_IRQ_POKL,
+	AXP288_IRQ_POKS,
+	AXP288_IRQ_POKN,
+	AXP288_IRQ_POKP,
+	AXP288_IRQ_TIMER,
+	AXP288_IRQ_MV_CHNG,
+	AXP288_IRQ_BC_USB_CHNG,
+};
+
+enum axp806_irqs {
+	AXP806_IRQ_DIE_TEMP_HIGH_LV1,
+	AXP806_IRQ_DIE_TEMP_HIGH_LV2,
+	AXP806_IRQ_DCDCA_V_LOW = 3,
+	AXP806_IRQ_DCDCB_V_LOW,
+	AXP806_IRQ_DCDCC_V_LOW,
+	AXP806_IRQ_DCDCD_V_LOW,
+	AXP806_IRQ_DCDCE_V_LOW,
+	AXP806_IRQ_PWROK_LONG,
+	AXP806_IRQ_PWROK_SHORT,
+	AXP806_IRQ_WAKEUP = 12,
+	AXP806_IRQ_PWROK_FALL,
+	AXP806_IRQ_PWROK_RISE,
+};
+
+enum axp809_irqs {
+	AXP809_IRQ_ACIN_OVER_V = 1,
+	AXP809_IRQ_ACIN_PLUGIN,
+	AXP809_IRQ_ACIN_REMOVAL,
+	AXP809_IRQ_VBUS_OVER_V,
+	AXP809_IRQ_VBUS_PLUGIN,
+	AXP809_IRQ_VBUS_REMOVAL,
+	AXP809_IRQ_VBUS_V_LOW,
+	AXP809_IRQ_BATT_PLUGIN,
+	AXP809_IRQ_BATT_REMOVAL,
+	AXP809_IRQ_BATT_ENT_ACT_MODE,
+	AXP809_IRQ_BATT_EXIT_ACT_MODE,
+	AXP809_IRQ_CHARG,
+	AXP809_IRQ_CHARG_DONE,
+	AXP809_IRQ_BATT_CHG_TEMP_HIGH,
+	AXP809_IRQ_BATT_CHG_TEMP_HIGH_END,
+	AXP809_IRQ_BATT_CHG_TEMP_LOW,
+	AXP809_IRQ_BATT_CHG_TEMP_LOW_END,
+	AXP809_IRQ_BATT_ACT_TEMP_HIGH,
+	AXP809_IRQ_BATT_ACT_TEMP_HIGH_END,
+	AXP809_IRQ_BATT_ACT_TEMP_LOW,
+	AXP809_IRQ_BATT_ACT_TEMP_LOW_END,
+	AXP809_IRQ_DIE_TEMP_HIGH,
+	AXP809_IRQ_LOW_PWR_LVL1,
+	AXP809_IRQ_LOW_PWR_LVL2,
+	AXP809_IRQ_TIMER,
+	AXP809_IRQ_PEK_RIS_EDGE,
+	AXP809_IRQ_PEK_FAL_EDGE,
+	AXP809_IRQ_PEK_SHORT,
+	AXP809_IRQ_PEK_LONG,
+	AXP809_IRQ_PEK_OVER_OFF,
+	AXP809_IRQ_GPIO1_INPUT,
+	AXP809_IRQ_GPIO0_INPUT,
+};
+
+enum axp2101_irqs {
+	/* irq0 */
+	AXP2101_IRQ_BWUT,
+	AXP2101_IRQ_BWOT,
+	AXP2101_IRQ_BCUT,
+	AXP2101_IRQ_BCOT,
+	AXP2101_IRQ_NEWSOC,
+	AXP2101_IRQ_GWDT,
+	AXP2101_IRQ_SOCWL1,
+	AXP2101_IRQ_SOCWL2,
+	/* irq1 */
+	AXP2101_IRQ_PONP,
+	AXP2101_IRQ_PONN,
+	AXP2101_IRQ_PONL,
+	AXP2101_IRQ_PONS,
+	AXP2101_IRQ_BREMOV,
+	AXP2101_IRQ_BINSERT,
+	AXP2101_IRQ_VREMOV,
+	AXP2101_IRQ_VINSET,
+	/* irq2 */
+	AXP2101_IRQ_BOVP,
+	AXP2101_IRQ_CHGTE,
+	AXP2101_IRQ_DOTL1,
+	AXP2101_IRQ_CHGST,
+	AXP2101_IRQ_CHGDN,
+	AXP2101_IRQ_BOCP,
+	AXP2101_IRQ_LDOOC,
+	AXP2101_IRQ_WDEXP,
+};
+
+enum axp15_irqs {
+	/* irq0 */
+	AXP15_IRQ_ALDOIN_H2L = 2,
+	AXP15_IRQ_ALDOIN_L2H,
+	AXP15_IRQ_LDO0IN_H2L = 5,
+	AXP15_IRQ_LDO0IN_L2H,
+	/* irq1 */
+	AXP15_IRQ_PEKLO = 8,
+	AXP15_IRQ_PEKSH,
+	AXP15_IRQ_DCDC4_V_LOW,
+	AXP15_IRQ_DCDC3_V_LOW,
+	AXP15_IRQ_DCDC2_V_LOW,
+	AXP15_IRQ_DCDC1_V_LOW,
+
+	/* irq2 */
+	AXP15_IRQ_GPIO0 = 16,
+	AXP15_IRQ_GPIO1,
+	AXP15_IRQ_GPIO2,
+	AXP15_IRQ_GPIO3,
+	AXP15_IRQ_PEKFE = 21,
+	AXP15_IRQ_PEKRE,
+	AXP15_IRQ_EVENT_TIMEOUT,
+};
+
+enum axp1530_irqs {
+	/* irq0 */
+	AXP1530_IRQ_TEMP_OVER,
+	AXP1530_IRQ_DCDC2_UNDER = 2,
+	AXP1530_IRQ_DCDC3_UNDER,
+	AXP1530_IRQ_POKLIRQ_EN,
+	AXP1530_IRQ_POKSIRQ_EN,
+	AXP1530_IRQ_KEY_L2H_EN,
+	AXP1530_IRQ_KEY_H2L_EN,
+};
+
+enum axp858_irqs {
+	/* irq0 */
+	AXP858_IRQ_TEMP_OVER1 = 0,
+	AXP858_IRQ_TEMP_OVER2,
+	AXP858_IRQ_DCDC1_UNDER,
+	AXP858_IRQ_DCDC2_UNDER,
+	AXP858_IRQ_DCDC3_UNDER,
+	AXP858_IRQ_DCDC4_UNDER,
+	AXP858_IRQ_DCDC5_UNDER,
+	AXP858_IRQ_DCDC6_UNDER,
+	/* irq1 */
+	AXP858_IRQ_POKLIRQ_EN,
+	AXP858_IRQ_POKSIRQ_EN,
+	AXP858_IRQ_GPIO1_EN,
+	AXP858_IRQ_POKNIRQ_EN,
+	AXP858_IRQ_POKPIRQ_EN,
+	AXP858_IRQ_GPIO2_EN,
+	AXP858_IRQ_DCDC2_CUR_OVER,
+	AXP858_IRQ_DCDC3_CUR_OVER,
+};
+
+enum axp803_irqs {
+	/* irq0 */
+	AXP803_IRQ_USBRE = 2,
+	AXP803_IRQ_USBIN,
+	AXP803_IRQ_USBOV,
+	AXP803_IRQ_ACRE,
+	AXP803_IRQ_ACIN,
+	AXP803_IRQ_ACOV,
+	/* irq1 */
+	AXP803_IRQ_CHAOV = 10,
+	AXP803_IRQ_CHAST,
+	AXP803_IRQ_BATATOU,
+	AXP803_IRQ_BATATIN,
+	AXP803_IRQ_BATRE,
+	AXP803_IRQ_BATIN,
+	/* irq2 */
+	AXP803_IRQ_QBATINWORK,
+	AXP803_IRQ_BATINWORK,
+	AXP803_IRQ_QBATOVWORK,
+	AXP803_IRQ_BATOVWORK,
+	AXP803_IRQ_QBATINCHG,
+	AXP803_IRQ_BATINCHG,
+	AXP803_IRQ_QBATOVCHG,
+	AXP803_IRQ_BATOVCHG,
+	/* irq3 */
+	AXP803_IRQ_LOWN2,
+	AXP803_IRQ_LOWN1,
+	/* irq4 */
+	AXP803_IRQ_GPIO0 = 32,
+	AXP803_IRQ_GPIO1,
+	AXP803_IRQ_POKLO = 35,
+	AXP803_IRQ_POKSH,
+	AXP803_IRQ_PEKFE,
+	AXP803_IRQ_PEKRE,
+	AXP803_IRQ_TIMER,
+};
+
+enum {
+	AXP2202_DCDC1 = 0,
+	AXP2202_DCDC2,
+	AXP2202_DCDC3,
+	AXP2202_CPUSLDO,
+	AXP2202_ALDO1,
+	AXP2202_ALDO2,
+	AXP2202_ALDO3,
+	AXP2202_ALDO4,
+	AXP2202_BLDO1,
+	AXP2202_BLDO2,
+	AXP2202_BLDO3,
+	AXP2202_BLDO4,
+	AXP2202_CLDO1,
+	AXP2202_CLDO2,
+	AXP2202_CLDO3,
+	AXP2202_CLDO4,
+	AXP2202_REG_ID_MAX,
+	AXP2202_VBUS,
+};
+
+enum axp2202_irqs {
+	/* irq0 */
+	AXP2202_IRQ_SOCWL2,
+	AXP2202_IRQ_SOCWL1,
+	AXP2202_IRQ_GWDT,
+	AXP2202_IRQ_NEWSOC,
+	AXP2202_IRQ_BST_OV,
+	AXP2202_IRQ_VBUS_OV,
+	AXP2202_IRQ_VBUS_FAULT,
+	/* irq1 */
+	AXP2202_IRQ_VINSERT,
+	AXP2202_IRQ_VREMOVE,
+	AXP2202_IRQ_BINSERT,
+	AXP2202_IRQ_BREMOVE,
+	AXP2202_IRQ_PONS,
+	AXP2202_IRQ_PONL,
+	AXP2202_IRQ_PONN,
+	AXP2202_IRQ_PONP,
+	/* irq2 */
+	AXP2202_IRQ_WDEXP,
+	AXP2202_IRQ_LDOOC,
+	AXP2202_IRQ_BOCP,
+	AXP2202_IRQ_CHGDN,
+	AXP2202_IRQ_CHGST,
+	AXP2202_IRQ_DOTL1,
+	AXP2202_IRQ_CHGTE,
+	AXP2202_IRQ_BOVP,
+	/* irq3 */
+	AXP2202_IRQ_BC_DONE,
+	AXP2202_IRQ_BC_CHNG,
+	AXP2202_IRQ_RID_CHNG,
+	AXP2202_IRQ_BCOTQ,
+	AXP2202_IRQ_BCOT,
+	AXP2202_IRQ_BCUT,
+	AXP2202_IRQ_BWOT,
+	AXP2202_IRQ_BWUT,
+	/* irq4 */
+	AXP2202_IRQ_CREMOVE,
+	AXP2202_IRQ_CINSERT,
+	AXP2202_IRQ_TOGGLE_DONE,
+	AXP2202_IRQ_VBUS_SAFE5V,
+	AXP2202_IRQ_VBUS_SAFE0V,
+	AXP2202_IRQ_ERR_GEN,
+	AXP2202_IRQ_PWR_CHNG,
+
+};
+
+enum axp2585_irqs {
+	AXP2585_IRQ_Q_DROP2,  //7l2
+	AXP2585_IRQ_Q_DROP1,  //6l1
+	AXP2585_IRQ_Q_CHANGE,
+	AXP2585_IRQ_Q_GOOD,
+	AXP2585_IRQ_BAT_DECT,
+	AXP2585_IRQ_BOOST_OVP,
+	AXP2585_IRQ_BOOST_OCP,
+	AXP2585_IRQ_BAT_OCP,
+	AXP2585_IRQ_BCOT,       //15
+	AXP2585_IRQ_QBCOT,      //14
+	AXP2585_IRQ_BCUT,       //13
+	AXP2585_IRQ_QBCUT,
+	AXP2585_IRQ_BWOT,       //11
+	AXP2585_IRQ_QBWOT,
+	AXP2585_IRQ_BWUT,       //9
+	AXP2585_IRQ_QBWUT,
+	AXP2585_IRQ_VBUS_INSERT,  //23ac
+	AXP2585_IRQ_VBUS_REMOVE,  //22ac
+	AXP2585_IRQ_BAT_INSERT,  //21
+	AXP2585_IRQ_BAT_REMOVE,  //20
+	AXP2585_IRQ_BAT_DB2GD,
+	AXP2585_IRQ_TJ_OTP,
+	AXP2585_IRQ_BAT_SMODE,
+	AXP2585_IRQ_VBUS_OVP,
+	AXP2585_IRQ_SIRQ,
+	AXP2585_IRQ_LIRQ,
+	AXP2585_IRQ_NIRQ,       //29
+	AXP2585_IRQ_PIRQ,       //28
+	AXP2585_IRQ_GPADC_BWOT,
+	AXP2585_IRQ_GPADC_QBWOT,
+	AXP2585_IRQ_GPADC_BWUT,
+	AXP2585_IRQ_GPADC_QBWUT,
+	AXP2585_IRQ_CHGBG,     //39
+	AXP2585_IRQ_CHGDONE,   //38
+	AXP2585_IRQ_BC_OK,
+	AXP2585_IRQ_BC_CHANGE,
+	AXP2585_IRQ_RID_CHANGE,
+	AXP2585_IRQ_BAT_OVP,
+	AXP2585_IRQ_REMOVE,  //47tc
+	AXP2585_IRQ_INSERT,  //46tc
+	AXP2585_IRQ_TOGGLE_DONE,
+	AXP2585_IRQ_VBUS_SAFE5V,
+	AXP2585_IRQ_ERROR_GEN,
+	AXP2585_IRQ_POW_CHNG,
+};
+#define AXP288_TS_ADC_H		0x58
+#define AXP288_TS_ADC_L		0x59
+#define AXP288_GP_ADC_H		0x5a
+#define AXP288_GP_ADC_L		0x5b
+
+struct axp20x_dev {
+	struct device			*dev;
+	int				irq;
+	struct regmap			*regmap;
+	struct regmap_irq_chip_data	*regmap_irqc;
+	long				variant;
+	int                             nr_cells;
+	struct mfd_cell                 *cells;
+	const struct regmap_config	*regmap_cfg;
+	const struct regmap_irq_chip	*regmap_irq_chip;
+	void (*dts_parse)(struct axp20x_dev *);
+};
+
+#define BATTID_LEN				64
+#define OCV_CURVE_SIZE			32
+#define MAX_THERM_CURVE_SIZE	25
+#define PD_DEF_MIN_TEMP			0
+#define PD_DEF_MAX_TEMP			55
+
+struct axp20x_fg_pdata {
+	char battid[BATTID_LEN + 1];
+	int design_cap;
+	int min_volt;
+	int max_volt;
+	int max_temp;
+	int min_temp;
+	int cap1;
+	int cap0;
+	int rdc1;
+	int rdc0;
+	int ocv_curve[OCV_CURVE_SIZE];
+	int tcsz;
+	int thermistor_curve[MAX_THERM_CURVE_SIZE][2];
+};
+
+struct axp20x_chrg_pdata {
+	int max_cc;
+	int max_cv;
+	int def_cc;
+	int def_cv;
+};
+
+struct axp288_extcon_pdata {
+	/* GPIO pin control to switch D+/D- lines b/w PMIC and SOC */
+	struct gpio_desc *gpio_mux_cntl;
+};
+
+/* generic helper function for reading 9-16 bit wide regs */
+static inline int axp20x_read_variable_width(struct regmap *regmap,
+	unsigned int reg, unsigned int width)
+{
+	unsigned int reg_val, result;
+	int err;
+
+	err = regmap_read(regmap, reg, &reg_val);
+	if (err)
+		return err;
+
+	result = reg_val << (width - 8);
+
+	err = regmap_read(regmap, reg + 1, &reg_val);
+	if (err)
+		return err;
+
+	result |= reg_val;
+
+	return result;
+}
+
+/**
+ * axp20x_match_device(): Setup axp20x variant related fields
+ *
+ * @axp20x: axp20x device to setup (.dev field must be set)
+ * @dev: device associated with this axp20x device
+ *
+ * This lets the axp20x core configure the mfd cells and register maps
+ * for later use.
+ */
+int axp20x_match_device(struct axp20x_dev *axp20x);
+
+/**
+ * axp20x_device_probe(): Probe a configured axp20x device
+ *
+ * @axp20x: axp20x device to probe (must be configured)
+ *
+ * This function lets the axp20x core register the axp20x mfd devices
+ * and irqchip. The axp20x device passed in must be fully configured
+ * with axp20x_match_device, its irq set, and regmap created.
+ */
+int axp20x_device_probe(struct axp20x_dev *axp20x);
+
+/**
+ * axp20x_device_probe(): Remove a axp20x device
+ *
+ * @axp20x: axp20x device to remove
+ *
+ * This tells the axp20x core to remove the associated mfd devices
+ */
+int axp20x_device_remove(struct axp20x_dev *axp20x);
+
+#endif /* __LINUX_MFD_AXP20X_H */
diff --git a/include/linux/mfd/sc27xx-pmic.h b/include/linux/mfd/sc27xx-pmic.h
new file mode 100644
index 000000000..57e45c0b3
--- /dev/null
+++ b/include/linux/mfd/sc27xx-pmic.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __LINUX_MFD_SC27XX_PMIC_H
+#define __LINUX_MFD_SC27XX_PMIC_H
+
+extern enum usb_charger_type sprd_pmic_detect_charger_type(struct device *dev);
+
+#endif /* __LINUX_MFD_SC27XX_PMIC_H */
diff --git a/include/linux/mfd/syscon.h b/include/linux/mfd/syscon.h
index 112dc6626..7f20e9b50 100644
--- a/include/linux/mfd/syscon.h
+++ b/include/linux/mfd/syscon.h
@@ -23,6 +23,11 @@ extern struct regmap *syscon_regmap_lookup_by_compatible(const char *s);
 extern struct regmap *syscon_regmap_lookup_by_phandle(
 					struct device_node *np,
 					const char *property);
+extern struct regmap *syscon_regmap_lookup_by_phandle_args(
+					struct device_node *np,
+					const char *property,
+					int arg_count,
+					unsigned int *out_args);
 #else
 static inline struct regmap *device_node_to_regmap(struct device_node *np)
 {
@@ -45,6 +50,15 @@ static inline struct regmap *syscon_regmap_lookup_by_phandle(
 {
 	return ERR_PTR(-ENOTSUPP);
 }
+
+static inline struct regmap *syscon_regmap_lookup_by_phandle_args(
+					struct device_node *np,
+					const char *property,
+					int arg_count,
+					unsigned int *out_args)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
 #endif
 
 #endif /* __LINUX_MFD_SYSCON_H__ */
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 3285dae06..39bb339d4 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -27,6 +27,8 @@
 #include <linux/memremap.h>
 #include <linux/overflow.h>
 #include <linux/sizes.h>
+#include <linux/android_kabi.h>
+#include <linux/android_vendor.h>
 
 struct mempolicy;
 struct anon_vma;
@@ -114,6 +116,14 @@ extern int mmap_rnd_compat_bits __read_mostly;
 #define __pa_symbol(x)  __pa(RELOC_HIDE((unsigned long)(x), 0))
 #endif
 
+#ifndef __va_function
+#define __va_function(x) (x)
+#endif
+
+#ifndef __pa_function
+#define __pa_function(x) __pa_symbol(x)
+#endif
+
 #ifndef page_to_virt
 #define page_to_virt(x)	__va(PFN_PHYS(page_to_pfn(x)))
 #endif
@@ -450,6 +460,10 @@ struct vm_fault {
 					 * page table to avoid allocation from
 					 * atomic context.
 					 */
+	unsigned long vma_flags;	/* Speculative Page Fault field */
+	pgprot_t vma_page_prot;		/* Speculative Page Fault field */
+	ANDROID_VENDOR_DATA(1);
+	ANDROID_VENDOR_DATA(2);
 };
 
 /* page entry size for vm->huge_fault() */
@@ -524,6 +538,11 @@ struct vm_operations_struct {
 	 */
 	struct page *(*find_special_page)(struct vm_area_struct *vma,
 					  unsigned long addr);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 static inline void vma_init(struct vm_area_struct *vma, struct mm_struct *mm)
@@ -780,7 +799,7 @@ enum compound_dtor_id {
 #ifdef CONFIG_HUGETLB_PAGE
 	HUGETLB_PAGE_DTOR,
 #endif
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_GKI_OPT_FEATURES)
 	TRANSHUGE_PAGE_DTOR,
 #endif
 	NR_COMPOUND_DTORS,
@@ -1655,19 +1674,28 @@ static inline unsigned long get_mm_counter(struct mm_struct *mm, int member)
 	return (unsigned long)val;
 }
 
+void mm_trace_rss_stat(struct mm_struct *mm, int member, long count,
+		       long value);
+
 static inline void add_mm_counter(struct mm_struct *mm, int member, long value)
 {
-	atomic_long_add(value, &mm->rss_stat.count[member]);
+	long count = atomic_long_add_return(value, &mm->rss_stat.count[member]);
+
+	mm_trace_rss_stat(mm, member, count, value);
 }
 
 static inline void inc_mm_counter(struct mm_struct *mm, int member)
 {
-	atomic_long_inc(&mm->rss_stat.count[member]);
+	long count = atomic_long_inc_return(&mm->rss_stat.count[member]);
+
+	mm_trace_rss_stat(mm, member, count, 1);
 }
 
 static inline void dec_mm_counter(struct mm_struct *mm, int member)
 {
-	atomic_long_dec(&mm->rss_stat.count[member]);
+	long count = atomic_long_dec_return(&mm->rss_stat.count[member]);
+
+	mm_trace_rss_stat(mm, member, count, -1);
 }
 
 /* Optimized variant when page is already known not to be PageAnon */
@@ -2285,7 +2313,7 @@ static inline int vma_adjust(struct vm_area_struct *vma, unsigned long start,
 extern struct vm_area_struct *vma_merge(struct mm_struct *,
 	struct vm_area_struct *prev, unsigned long addr, unsigned long end,
 	unsigned long vm_flags, struct anon_vma *, struct file *, pgoff_t,
-	struct mempolicy *, struct vm_userfaultfd_ctx);
+	struct mempolicy *, struct vm_userfaultfd_ctx, const char __user *);
 extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *);
 extern int __split_vma(struct mm_struct *, struct vm_area_struct *,
 	unsigned long addr, int new_below);
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 270aa8fd2..0e4e1407d 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -14,6 +14,8 @@
 #include <linux/uprobes.h>
 #include <linux/page-flags-layout.h>
 #include <linux/workqueue.h>
+#include <linux/android_kabi.h>
+#include <linux/android_vendor.h>
 
 #include <asm/mmu.h>
 
@@ -318,11 +320,18 @@ struct vm_area_struct {
 	/*
 	 * For areas with an address space and backing store,
 	 * linkage into the address_space->i_mmap interval tree.
+	 *
+	 * For private anonymous mappings, a pointer to a null terminated string
+	 * in the user process containing the name given to the vma, or NULL
+	 * if unnamed.
 	 */
-	struct {
-		struct rb_node rb;
-		unsigned long rb_subtree_last;
-	} shared;
+	union {
+		struct {
+			struct rb_node rb;
+			unsigned long rb_subtree_last;
+		} shared;
+		const char __user *anon_name;
+	};
 
 	/*
 	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
@@ -353,6 +362,12 @@ struct vm_area_struct {
 	struct mempolicy *vm_policy;	/* NUMA policy for the VMA */
 #endif
 	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+	ANDROID_VENDOR_DATA(1);
 } __randomize_layout;
 
 struct core_thread {
@@ -492,7 +507,8 @@ struct mm_struct {
 #ifdef CONFIG_MMU_NOTIFIER
 		struct mmu_notifier_mm *mmu_notifier_mm;
 #endif
-#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
+#if (defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_GKI_OPT_FEATURES)) && \
+    !USE_SPLIT_PMD_PTLOCKS
 		pgtable_t pmd_huge_pte; /* protected by page_table_lock */
 #endif
 #ifdef CONFIG_NUMA_BALANCING
@@ -524,6 +540,7 @@ struct mm_struct {
 		atomic_long_t hugetlb_usage;
 #endif
 		struct work_struct async_put_work;
+		ANDROID_VENDOR_DATA(1);
 	} __randomize_layout;
 
 	/*
@@ -754,4 +771,13 @@ typedef struct {
 	unsigned long val;
 } swp_entry_t;
 
+/* Return the name for an anonymous mapping or NULL for a file-backed mapping */
+static inline const char __user *vma_get_anon_name(struct vm_area_struct *vma)
+{
+	if (vma->vm_file)
+		return NULL;
+
+	return vma->anon_name;
+}
+
 #endif /* _LINUX_MM_TYPES_H */
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index b7ba8810a..e7f316538 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -165,8 +165,25 @@ struct mmc_request {
 	bool			cap_cmd_during_tfr;
 
 	int			tag;
+#ifdef CONFIG_MMC_CRYPTO
+	int crypto_key_slot;
+	u64 data_unit_num;
+	const struct blk_crypto_key *crypto_key;
+#endif
 };
 
+#ifdef CONFIG_MMC_CRYPTO
+static inline bool mmc_request_crypto_enabled(const struct mmc_request *mrq)
+{
+	return mrq->crypto_key != NULL;
+}
+#else
+static inline bool mmc_request_crypto_enabled(const struct mmc_request *mrq)
+{
+	return false;
+}
+#endif
+
 struct mmc_card;
 
 void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq);
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4c5eb3aa8..956e5d699 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -92,6 +92,9 @@ struct mmc_host_ops {
 			    int err);
 	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
+	/* Submit one request to host in atomic context. */
+	int	(*request_atomic)(struct mmc_host *host,
+				  struct mmc_request *req);
 
 	/*
 	 * Avoid calling the next three functions too often or in a "fast
@@ -370,6 +373,7 @@ struct mmc_host {
 #define MMC_CAP2_CQE_DCMD	(1 << 24)	/* CQE can issue a direct command */
 #define MMC_CAP2_AVOID_3_3V	(1 << 25)	/* Host must negotiate down from 3.3V */
 #define MMC_CAP2_MERGE_CAPABLE	(1 << 26)	/* Host can merge a segment over the segment size */
+#define MMC_CAP2_CRYPTO		(1 << 27)	/* Host supports inline encryption */
 
 	int			fixed_drv_type;	/* fixed driver type for non-removable media */
 
@@ -462,6 +466,13 @@ struct mmc_host {
 	int			cqe_qdepth;
 	bool			cqe_enabled;
 	bool			cqe_on;
+#ifdef CONFIG_MMC_CRYPTO
+	struct keyslot_manager	*ksm;
+	void *crypto_DO_NOT_USE[7];
+#endif /* CONFIG_MMC_CRYPTO */
+
+	/* Host Software Queue support */
+	bool			hsq_enabled;
 
 	unsigned long		private[0] ____cacheline_aligned;
 };
diff --git a/include/linux/mmc/pm.h b/include/linux/mmc/pm.h
index 3549f8045..1d554b858 100644
--- a/include/linux/mmc/pm.h
+++ b/include/linux/mmc/pm.h
@@ -23,5 +23,6 @@ typedef unsigned int mmc_pm_flag_t;
 
 #define MMC_PM_KEEP_POWER	(1 << 0)	/* preserve card power during suspend */
 #define MMC_PM_WAKE_SDIO_IRQ	(1 << 1)	/* wake up host system on SDIO IRQ assertion */
+#define MMC_PM_IGNORE_PM_NOTIFY	(1 << 2)	/* ignore mmc pm notify */
 
 #endif /* LINUX_MMC_PM_H */
diff --git a/include/linux/mmu_notifier.h b/include/linux/mmu_notifier.h
index 1bd8e6a09..ca953d581 100644
--- a/include/linux/mmu_notifier.h
+++ b/include/linux/mmu_notifier.h
@@ -6,6 +6,7 @@
 #include <linux/spinlock.h>
 #include <linux/mm_types.h>
 #include <linux/srcu.h>
+#include <linux/android_kabi.h>
 
 struct mmu_notifier;
 struct mmu_notifier_ops;
@@ -228,6 +229,11 @@ struct mmu_notifier_ops {
 	 */
 	struct mmu_notifier *(*alloc_notifier)(struct mm_struct *mm);
 	void (*free_notifier)(struct mmu_notifier *mn);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 /*
@@ -247,6 +253,9 @@ struct mmu_notifier {
 	struct mm_struct *mm;
 	struct rcu_head rcu;
 	unsigned int users;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 static inline int mm_has_notifiers(struct mm_struct *mm)
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index 85804ba62..07e884fe9 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -20,6 +20,7 @@
 #include <linux/atomic.h>
 #include <linux/mm_types.h>
 #include <linux/page-flags.h>
+#include <linux/android_kabi.h>
 #include <asm/page.h>
 
 /* Free memory management - zoned buddy allocator.  */
@@ -42,8 +43,6 @@ enum migratetype {
 	MIGRATE_UNMOVABLE,
 	MIGRATE_MOVABLE,
 	MIGRATE_RECLAIMABLE,
-	MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */
-	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,
 #ifdef CONFIG_CMA
 	/*
 	 * MIGRATE_CMA migration type is designed to mimic the way
@@ -60,6 +59,8 @@ enum migratetype {
 	 */
 	MIGRATE_CMA,
 #endif
+	MIGRATE_PCPTYPES, /* the number of types on the pcp lists */
+	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,
 #ifdef CONFIG_MEMORY_ISOLATION
 	MIGRATE_ISOLATE,	/* can't allocate from here */
 #endif
@@ -72,9 +73,11 @@ extern const char * const migratetype_names[MIGRATE_TYPES];
 #ifdef CONFIG_CMA
 #  define is_migrate_cma(migratetype) unlikely((migratetype) == MIGRATE_CMA)
 #  define is_migrate_cma_page(_page) (get_pageblock_migratetype(_page) == MIGRATE_CMA)
+#  define get_cma_migrate_type() MIGRATE_CMA
 #else
 #  define is_migrate_cma(migratetype) false
 #  define is_migrate_cma_page(_page) false
+#  define get_cma_migrate_type() MIGRATE_MOVABLE
 #endif
 
 static inline bool is_migrate_movable(int mt)
@@ -200,6 +203,9 @@ enum zone_stat_item {
 	NR_MLOCK,		/* mlock()ed pages found and moved off LRU */
 	NR_PAGETABLE,		/* used for pagetables */
 	NR_KERNEL_STACK_KB,	/* measured in KiB */
+#if IS_ENABLED(CONFIG_SHADOW_CALL_STACK)
+	NR_KERNEL_SCS_BYTES,	/* measured in bytes */
+#endif
 	/* Second 128 byte cacheline */
 	NR_BOUNCE,
 #if IS_ENABLED(CONFIG_ZSMALLOC)
@@ -440,6 +446,10 @@ struct zone {
 	struct pglist_data	*zone_pgdat;
 	struct per_cpu_pageset __percpu *pageset;
 
+#ifdef CONFIG_CMA
+	bool			cma_alloc;
+#endif
+
 #ifndef CONFIG_SPARSEMEM
 	/*
 	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.
@@ -561,6 +571,11 @@ struct zone {
 	/* Zone statistics */
 	atomic_long_t		vm_stat[NR_VM_ZONE_STAT_ITEMS];
 	atomic_long_t		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } ____cacheline_internodealigned_in_smp;
 
 enum pgdat_flags {
@@ -678,7 +693,7 @@ struct zonelist {
 extern struct page *mem_map;
 #endif
 
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_GKI_OPT_FEATURES)
 struct deferred_split {
 	spinlock_t split_queue_lock;
 	struct list_head split_queue;
@@ -766,7 +781,7 @@ typedef struct pglist_data {
 	unsigned long first_deferred_pfn;
 #endif /* CONFIG_DEFERRED_STRUCT_PAGE_INIT */
 
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_GKI_OPT_FEATURES)
 	struct deferred_split deferred_split_queue;
 #endif
 
diff --git a/include/linux/mod_devicetable.h b/include/linux/mod_devicetable.h
index 4c56404e5..e045fc8e8 100644
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@ -318,7 +318,7 @@ struct pcmcia_device_id {
 #define INPUT_DEVICE_ID_LED_MAX		0x0f
 #define INPUT_DEVICE_ID_SND_MAX		0x07
 #define INPUT_DEVICE_ID_FF_MAX		0x7f
-#define INPUT_DEVICE_ID_SW_MAX		0x10
+#define INPUT_DEVICE_ID_SW_MAX		0x3f
 #define INPUT_DEVICE_ID_PROP_MAX	0x1f
 
 #define INPUT_DEVICE_ID_MATCH_BUS	1
diff --git a/include/linux/module.h b/include/linux/module.h
index 6d20895e7..4f71785d6 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -22,6 +22,8 @@
 #include <linux/error-injection.h>
 #include <linux/tracepoint-defs.h>
 #include <linux/srcu.h>
+#include <linux/cfi.h>
+#include <linux/android_kabi.h>
 
 #include <linux/percpu.h>
 #include <asm/module.h>
@@ -365,6 +367,10 @@ struct module {
 	const s32 *crcs;
 	unsigned int num_syms;
 
+#ifdef CONFIG_CFI_CLANG
+	cfi_check_fn cfi_check;
+#endif
+
 	/* Kernel parameters. */
 #ifdef CONFIG_SYSFS
 	struct mutex param_lock;
@@ -376,6 +382,7 @@ struct module {
 	unsigned int num_gpl_syms;
 	const struct kernel_symbol *gpl_syms;
 	const s32 *gpl_crcs;
+	bool using_gplonly_symbols;
 
 #ifdef CONFIG_UNUSED_SYMBOLS
 	/* unused exported symbols. */
@@ -389,10 +396,12 @@ struct module {
 	const s32 *unused_gpl_crcs;
 #endif
 
-#ifdef CONFIG_MODULE_SIG
-	/* Signature was verified. */
+	/*
+	 * Signature was verified. Unconditionally compiled in Android to
+	 * preserve ABI compatibility between kernels without module
+	 * signing enabled and signed modules.
+	 */
 	bool sig_ok;
-#endif
 
 	bool async_probe_requested;
 
@@ -507,6 +516,10 @@ struct module {
 	struct error_injection_entry *ei_funcs;
 	unsigned int num_ei_funcs;
 #endif
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } ____cacheline_aligned __randomize_layout;
 #ifndef MODULE_ARCH_INIT
 #define MODULE_ARCH_INIT {}
@@ -561,34 +574,14 @@ struct module *find_module(const char *name);
 struct symsearch {
 	const struct kernel_symbol *start, *stop;
 	const s32 *crcs;
-	enum {
+	enum mod_license {
 		NOT_GPL_ONLY,
 		GPL_ONLY,
 		WILL_BE_GPL_ONLY,
-	} licence;
+	} license;
 	bool unused;
 };
 
-/*
- * Search for an exported symbol by name.
- *
- * Must be called with module_mutex held or preemption disabled.
- */
-const struct kernel_symbol *find_symbol(const char *name,
-					struct module **owner,
-					const s32 **crc,
-					bool gplok,
-					bool warn);
-
-/*
- * Walk the exported symbol table
- *
- * Must be called with module_mutex held or preemption disabled.
- */
-bool each_symbol_section(bool (*fn)(const struct symsearch *arr,
-				    struct module *owner,
-				    void *data), void *data);
-
 /* Returns 0 and fills in value, defined and namebuf, or -ERANGE if
    symnum out of range. */
 int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
@@ -636,7 +629,6 @@ static inline void __module_get(struct module *module)
 #define symbol_put_addr(p) do { } while (0)
 
 #endif /* CONFIG_MODULE_UNLOAD */
-int ref_module(struct module *a, struct module *b);
 
 /* This is a #define so the string doesn't get put in every .o file */
 #define module_name(mod)			\
diff --git a/include/linux/mount.h b/include/linux/mount.h
index bf8cc4108..40714c604 100644
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -16,6 +16,7 @@
 #include <linux/spinlock.h>
 #include <linux/seqlock.h>
 #include <linux/atomic.h>
+#include <linux/android_kabi.h>
 
 struct super_block;
 struct vfsmount;
@@ -69,6 +70,11 @@ struct vfsmount {
 	struct dentry *mnt_root;	/* root of the mounted tree */
 	struct super_block *mnt_sb;	/* pointer to superblock */
 	int mnt_flags;
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+	void *data;
 } __randomize_layout;
 
 struct file; /* forward dec */
diff --git a/include/linux/mtd/aw-rawnand.h b/include/linux/mtd/aw-rawnand.h
new file mode 100644
index 000000000..34c0e48d0
--- /dev/null
+++ b/include/linux/mtd/aw-rawnand.h
@@ -0,0 +1,1315 @@
+/**
+ * SPDX-License-Identifier: GPL-2.0+
+ *
+ * (C) Copyright 2020 - 2021
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * cuizhikui <cuizhikui@allwinnertech.com>
+ *
+ */
+#ifndef __AW_RAWNAND_H__
+#define __AW_RAWNAND_H__
+
+#include <linux/mtd/mtd.h>
+#include <linux/mutex.h>
+
+/* aw rawnand warning messages */
+#define awrawnand_warn(fmt, ...) pr_warn("awrawnand(mtd):warning: %s: " fmt, \
+					__func__, ##__VA_ARGS__)
+/* aw rawnand error messages */
+#define awrawnand_err(fmt, ...) pr_err("awrawnand(mtd):error: %s: " fmt, \
+				      __func__, ##__VA_ARGS__)
+
+/* aw rawnand info messages */
+#define awrawnand_info(fmt, ...) pr_info("awrawnand(mtd):info:" fmt, \
+					##__VA_ARGS__)
+
+/* aw rawnand debug messages */
+#define awrawnand_dbg(fmt, ...) pr_debug("awrawnand(mtd): dbg:" fmt, \
+					##__VA_ARGS__)
+
+
+/* aw rawnand messages */
+#define awrawnand_print(fmt, ...) pr_err("awrawnand(mtd):" fmt, ##__VA_ARGS__)
+//#define DBG
+#ifdef DBG
+#define AWRAWNAND_TRACE(fmt, ...) pr_err("awrawnand(mtd):" fmt, ##__VA_ARGS__)
+#else
+#define AWRAWNAND_TRACE(fmt, ...)
+#endif
+
+//#define DBG_NFC
+#ifdef DBG_NFC
+#define AWRAWNAND_TRACE_NFC(fmt, ...) pr_err("awrawnand(mtd):" fmt, ##__VA_ARGS__)
+#else
+#define AWRAWNAND_TRACE_NFC(fmt, ...)
+#endif
+
+//#define DBG_CHIP
+#ifdef DBG_CHIP
+#define awrawnand_chip_trace(fmt, ...) pr_err(fmt,  ##__VA_ARGS__)
+#else
+#define awrawnand_chip_trace(fmt, ...)
+#endif
+
+//#define TRACE_UBI_MTD
+#ifdef TRACE_UBI_MTD
+#define awrawnand_ubi_trace(fmt, ...) pr_err("aw-mtd:" fmt, ##__VA_ARGS__)
+#else
+#define awrawnand_ubi_trace(fmt, ...)
+#endif
+
+//#define TRACE_MTD
+#ifdef TRACE_MTD
+#define awrawnand_mtd_trace(fmt, ...) pr_err(fmt, ##__VA_ARGS__)
+#else
+#define awrawnand_mtd_trace(fmt, ...)
+#endif
+
+/*
+ *  rawnand  multiplane.
+ *
+ * Merge pages in two adjacent blocks with the same page num to super page.
+ * Merge adjacent blocs to super block.
+ *
+ *   phy-block0   phy-block1    = super block 0
+ * |------------|------------|
+ * | phy-page 0 | phy-page 0 |  = super page 0 on super block 0
+ * | phy-page 1 | phy-page 1 |  = super page 1 on super block 0
+ * |     ...    |     ...    |
+ * |------------|------------|
+ *
+ */
+#define SIMULATE_MULTIPLANE (1)
+
+/* ecc status */
+#define ECC_GOOD	(0 << 4)
+#define ECC_LIMIT	(1 << 4)
+#define ECC_ERR		(2 << 4)
+#define ECC_BLANK_PAGE	(3 << 4)
+
+#define MAX_CYCLE (5)
+#define RAWNAND_MAX_ID_LEN (8U)
+
+
+#define UBOOT_START_BLOCK_SMALLNAND 8
+#define UBOOT_START_BLOCK_BIGNAND 4
+#define AW_RAWNAND_RESERVED_PHY_BLK_FOR_SECURE_STORAGE 8
+#define PHY_BLKS_FOR_SECURE_STORAGE AW_RAWNAND_RESERVED_PHY_BLK_FOR_SECURE_STORAGE
+#define PSTORE_SIZE_KB	512
+
+/*
+ * Standard NAND flash commands
+ */
+#define RAWNAND_CMD_READ0		0
+#define RAWNAND_CMD_READ1		1
+#define RAWNAND_CMD_RNDOUT		5
+#define RAWNAND_CMD_PAGEPROG		0x10
+#define RAWNAND_CMD_READOOB		0x50
+#define RAWNAND_CMD_ERASE1		0x60
+#define RAWNAND_CMD_STATUS		0x70
+#define RAWNAND_CMD_SEQIN		0x80
+#define RAWNAND_CMD_RNDIN		0x85
+#define RAWNAND_CMD_READID		0x90
+#define RAWNAND_CMD_ERASE2		0xd0
+#define RAWNAND_CMD_PARAM		0xec
+#define RAWNAND_CMD_GET_FEATURES	0xee
+#define RAWNAND_CMD_SET_FEATURES	0xef
+#define RAWNAND_CMD_RESET		0xff
+
+/* Extended commands for large page devices */
+#define RAWNAND_CMD_READSTART		0x30
+#define RAWNAND_CMD_RNDOUTSTART		0xE0
+#define RAWNAND_CMD_CACHEDPROG		0x15
+#define RAWNAND_CMD_MULTIPROG		0x11
+#define RAWNAND_CMD_MULTIPREADSTART	0x32
+#define RAWNAND_CMD_MULTIERASE		0xd1
+
+#define TOGGLE_INTERFACE_CHANGE_ADDR	(0x80)
+
+/* Status bits */
+#define RAWNAND_STATUS_FAIL	0x01
+#define RAWNAND_STATUS_FAIL_N1	0x02
+#define RAWNAND_STATUS_TRUE_READY	0x20
+#define RAWNAND_STATUS_READY	0x40
+#define RAWNAND_STATUS_WP		0x80
+
+#define DEV_IO_READY	(0x1)
+#define DEV_ARRAY_READY	(0x2)
+#define DEV_READY	(0x3)
+
+#define FEATURES_PARA_LEN (4)
+
+/*idtab options bitmap*/
+
+/* Device interface*/
+#define RAWNAND_ITF_SDR		BIT(0)
+#define RAWNAND_ITF_ONFI_DDR	BIT(1)
+#define RAWNAND_ITF_ONFI_DDR2	BIT(2)
+#define RAWNAND_ITF_TOGGLE_DDR	BIT(3)
+#define RAWNAND_ITF_TOGGLE_DDR2	BIT(4)
+
+/* TOGGLE only support*/
+#define RAWNAND_TOGGLE_SUPPORT_ONLY	BIT(5)
+/* ONFI timing mode, used in both asynchronous and synchronous mode */
+#define RAWNAND_ONFI_TIMING_MODE	BIT(6)
+/* ONFI features */
+#define RAWNAND_ONFI_FEATURE_EXT_PARAM_PAGE	BIT(7)
+
+
+/* Chip has cache program function */
+#define RAWNAND_CACHEPRG	BIT(8)
+/* Chip has copy back function */
+#define RAWNAND_COPYBACK	BIT(9)
+
+/* Chip allow multi writes */
+#define RAWNAND_MULTI_WRITE	BIT(10)
+
+
+/* Chip allow multi reads */
+#define RAWNAND_MULTI_READ	BIT(11)
+
+/* Chip allow multi erase 60h-60h-d0h*/
+#define RAWNAND_MULTI_ERASE	BIT(12)
+
+/* Chip allow onfi multi erase 60h-d1h -- 60h- d0h*/
+#define RAWNAND_MULTI_ONFI_ERASE	BIT(13)
+
+/* Device needs 3rd row address cycle */
+#define RAWNAND_ROW_ADDR_3	BIT(16)
+
+/* Default Toggle DDR1.0 , SDR need to set*/
+#define RAWNAND_TOGGLE_DDR_TO_SDR	BIT(29)
+/* Open nfc randomizer */
+#define RAWNAND_NFC_RANDOM	BIT(30)
+
+
+
+/* Macros to identify the above */
+#define RAWNAND_HAS_ITF_SDR(chip) ((chip->options & RAWNAND_ITF_SDR))
+#define RAWNAND_HAS_ITF_ONFI_DDR(chip) ((chip->options & RAWNAND_ITF_ONFI_DDR))
+#define RAWNAND_HAS_ITF_ONFI_DDR2(chip) ((chip->options & RAWNAND_ITF_ONFI_DDR2))
+#define RAWNAND_HAS_ITF_TOGGLE_DDR(chip) ((chip->options & RAWNAND_ITF_TOGGLE_DDR))
+#define RAWNAND_HAS_ITF_TOGGLE_DDR2(chip) ((chip->options & RAWNAND_ITF_TOGGLE_DDR2))
+#define RAWNAND_HAS_CACHEPROG(chip) ((chip->options & RAWNAND_CACHEPRG))
+#define RAWNAND_HAS_MULTI_WRITE(chip) ((chip)->options & RAWNAND_MULTI_WRITE)
+#define RAWNAND_HAS_MULTI_READ(chip) ((chip->options & RAWNAND_MULTI_READ))
+#define RAWNAND_HAS_MULTI_ERASE(chip) ((chip->options & RAWNAND_MULTI_ERASE))
+#define RAWNAND_HAS_MULTI_ONFI_ERASE(chip) ((chip->options & RAWNAND_MULTI_ONFI_ERASE))
+#define RAWNAND_HAS_ONLY_TOGGLE(chip) ((chip->options & RAWNAND_TOGGLE_SUPPORT_ONLY))
+#define RAWNAND_NEED_CHANGE_TO_SDR(chip) ((chip->options & RAWNAND_TOGGLE_DDR_TO_SDR))
+#define RAWNAND_NFC_NEED_RANDOM(chip) ((chip->options & RAWNAND_NFC_RANDOM))
+
+
+
+/*
+ * RAW NAND Flash Manufacturer ID Codes
+ */
+#define RAWNAND_MFR_TOSHIBA	0x98
+#define RAWNAND_MFR_SAMSUNG	0xec
+#define RAWNAND_MFR_FUJITSU	0x04
+#define RAWNAND_MFR_NATIONAL	0x8f
+#define RAWNAND_MFR_RENESAS	0x07
+#define RAWNAND_MFR_STMICRO	0x20
+#define RAWNAND_MFR_HYNIX	0xad
+#define RAWNAND_MFR_MICRON	0x2c
+#define RAWNAND_MFR_AMD		0x01
+#define RAWNAND_MFR_MACRONIX	0xc2
+#define RAWNAND_MFR_EON		0x92
+#define RAWNAND_MFR_SANDISK	0x45
+#define RAWNAND_MFR_INTEL	0x89
+#define RAWNAND_MFR_ATO		0x9b
+#define RAWNAND_MFR_SPANSION	0x01
+#define RAWNAND_MFR_ESMT	0xc8
+#define RAWNAND_MFR_GIGA	0xc8
+#define RAWNAND_MFR_MXIC	0xc2
+#define RAWNAND_MFR_FORESEE	0xec
+#define RAWNAND_MFR_WINBOND	0xef
+
+/*
+ * RAWNAND Flash Manufacture name
+ * */
+#define SPANSION_NAME "spansion"
+#define ATO_NAME "ato"
+#define EON_NAME "eon"
+#define ESMT_NAME "esmt"
+#define FUJITSU_NAME "fujitsu"
+#define HYNIX_NAME "hynix"
+#define INTEL_NAME "intel"
+#define MACRONIX_NAME "macronix"
+#define GIGA_NAME "giga"
+#define MXIC_NAME "mxic"
+#define MICRON_NAME "micron"
+#define NATIONAL_NAME "national"
+#define RENESAS_NAME "renesas"
+#define SAMSUNG_NAME "samsung"
+#define SANDISK_NAME "sandisk"
+#define STMICRO_NAME "stmicro"
+#define TOSHIBA_NAME "toshiba"
+#define WINBOND_NAME "winbond"
+#define FORESEE_NAME "foresee"
+
+
+#define PE_CYCLES_1K	(1000)
+#define PE_CYCLES_2K	(2000)
+#define PE_CYCLES_3K	(3000)
+#define PE_CYCLES_4K	(4000)
+#define PE_CYCLES_5K	(5000)
+#define PE_CYCLES_6K	(6000)
+#define PE_CYCLES_7K	(7000)
+#define PE_CYCLES_8K	(8000)
+#define PE_CYCLES_9K	(9000)
+#define PE_CYCLES_10K	(10000)
+#define PE_CYCLES_20K	(20000)
+#define PE_CYCLES_30K	(30000)
+#define PE_CYCLES_40K	(40000)
+#define PE_CYCLES_50K	(50000)
+#define PE_CYCLES_60K	(60000)
+#define PE_CYCLES_70K	(70000)
+#define PE_CYCLES_80K	(80000)
+#define PE_CYCLES_90K	(90000)
+#define PE_CYCLES_100K	(100000)
+#define PE_CYCLES_200K	(200000)
+#define PE_CYCLES_300K	(300000)
+#define PE_CYCLES_500K	(500000)
+#define PE_CYCLES_600K	(600000)
+#define PE_CYCLES_700K	(700000)
+#define PE_CYCLES_800K	(800000)
+#define PE_CYCLES_900K	(900000)
+#define PE_CYCLES_1000K	(1000000)
+
+
+#define BCH_NO	(-1)
+#define BCH_16	(0)
+#define BCH_24	(1)
+#define BCH_28	(2)
+#define BCH_32	(3)
+#define BCH_40	(4)
+#define BCH_44	(5)
+#define BCH_48	(6)
+#define BCH_52	(7)
+#define BCH_56	(8)
+#define BCH_60	(9)
+#define BCH_64	(10)
+#define BCH_68	(11)
+#define BCH_72	(12)
+#define BCH_76	(13)
+#define BCH_80	(14)
+
+#define B_TO_KB(x)	((x) >> 10)
+#define MOD(x, y)	((x) % (y))
+
+#define MAX_CHIPS (4U)
+enum error_management {
+/*first spare area location on first page of each block*/
+	FIRST_PAGE = 0x1,
+/*first spare area location on first page and second page of each block*/
+	FIRST_TWO_PAGES = 0x11,
+/*first spare area location on last page of each block*/
+	LAST_PAGE = 0x2,
+/*first spare area location on last two page of each block*/
+	LAST_TWO_PAGES = 0x22,
+};
+
+struct aw_nand_flash_dev {
+	char *name;
+	union {
+		struct {
+			uint8_t mfr_id;
+			uint8_t dev_id;
+		};
+		uint8_t id[RAWNAND_MAX_ID_LEN];
+	};
+	int id_len;
+	unsigned int dies_per_chip;
+	/*main data size, eg. Page Size:(2K+64)byte ==> pagesize=2K byte,
+	 * sparesize=64byte*/
+	unsigned int pagesize;
+	unsigned int sparesize;
+	unsigned int pages_per_blk;
+	unsigned int blks_per_die;
+	unsigned int access_freq;
+	enum error_management badblock_flag_pos;
+	unsigned int pe_cycles;
+	unsigned int options;
+};
+
+
+struct rawnand_manufacture {
+	u8 id;
+	char *name;
+	struct aw_nand_flash_dev *dev;
+	int ndev;
+};
+#define RAWNAND_MANUFACTURE(_id, _name, _mfr)		\
+	{							\
+		.id = _id,					\
+		.name = _name,					\
+		.dev = _mfr,					\
+		.ndev = (sizeof(_mfr) / sizeof(_mfr[0])),	\
+	}
+
+struct aw_nand_manufactures {
+	struct rawnand_manufacture *manuf;
+	int nm;
+};
+
+#define AW_NAND_MANUFACTURE(_aw_nand, _manufs)			\
+		struct aw_nand_manufactures _aw_nand = {		\
+			.manuf = _manufs,				\
+			.nm = (sizeof(_manufs) / sizeof(_manufs[0])),	\
+		}
+
+struct aw_nand_chip;
+struct mtd_info;
+extern struct aw_nand_chip awnand_chip;
+extern struct aw_nand_manufactures aw_nand_manufs;
+extern struct aw_nand_sec_sto rawnand_sec_sto;
+
+struct nfc_reg {
+	volatile unsigned int *ctl;			/*0x0000 NDFC Control Register*/
+	volatile unsigned int *sta;			/*0x0004 NDFC Status Register*/
+	volatile unsigned int *int_ctl;			/*0x0008 NDFC Interrupt and DMA Enable Register*/
+	volatile unsigned int *timing_ctl;		/*0x000C NDFC Timing Control Register*/
+	volatile unsigned int *timing_cfg;		/*0x0010 NDFC Timing Configure Register*/
+	volatile unsigned int *addr_low;		/*0x0014 NDFC Address Low Word Register*/
+	volatile unsigned int *addr_high;		/*0x0018 NDFC Address High Word Register*/
+	volatile unsigned int *data_block_mask;		/*0x001C NDFC Data Block Mask Register*/
+	volatile unsigned int *cnt;			/*0x0020 NDFC Data Block Mask Register*/
+	volatile unsigned int *cmd;			/*0x0024 NDFC Command IO Register*/
+	volatile unsigned int *read_cmd_set;		/*0x0028 NDFC Command Set Register 0*/
+	volatile unsigned int *write_cmd_set;		/*0x002C NDFC Command Set Register 1*/
+	volatile unsigned int *ecc_ctl;			/*0x0034 NDFC ECC Control Register*/
+	volatile unsigned int *ecc_sta;			/*0x0038 NDFC ECC Status Register*/
+	volatile unsigned int *data_pattern_sta;	/*0x003C NDFC Data Pattern Status Register*/
+	volatile unsigned int *efr;			/*0x0040 NDFC Enhanced Featur Register*/
+	volatile unsigned int *rdata_sta_ctl;		/*0x0044 NDFC Read Data Status Control Register*/
+	volatile unsigned int *rdata_sta_0;		/*0x0048 NDFC Read Data Status Register 0*/
+	volatile unsigned int *rdata_sta_1;		/*0x004C NDFC Read Data Status Register 1*/
+#define MAX_ERR_CNT (8U)
+	volatile unsigned int *err_cnt[MAX_ERR_CNT];	/*0x0050 NDFC Error Counter Register 0*/
+#define MAX_USER_DATA_LEN (4U)
+	volatile unsigned int *user_data_len_base;	/*0x0070 NDFC User Data Length Register X*/
+#define MAX_USER_DATA (32U)
+	volatile unsigned int *user_data_base;		/*0x0080 NDFC User Data Register X*/
+	volatile unsigned int *efnand_sta;		/*0x0110 NDFC EFNAND STATUS Register*/
+	volatile unsigned int *spare_area;		/*0x0114 NDFC Spare Aera Register*/
+	volatile unsigned int *pat_id;			/*0x0118 NDFC Pattern ID Register*/
+	volatile unsigned int *ddr2_spec_ctl;		/*0x011C NDFC DDR2 Specific Control Register*/
+	volatile unsigned int *ndma_mode_ctl;		/*0x0120 NDFC Normal DMA Mode Control Register*/
+	volatile unsigned int *mbus_dma_dlba;		/*0x0200 NDFC MBUS DMA Descriptor List Base Address Register in no.1 version*/
+	volatile unsigned int *mbus_dma_sta;		/*0x0204 NDFC MBUS DMA Interrupt Status Register in no.1 version*/
+	volatile unsigned int *mdma_int_mask;		/*0x0208 NDFC MBUS DMA Interrupt Enable Register in no.1 version*/
+	volatile unsigned int *mdma_cur_desc_addr;	/*0x020C NDFC MBUS DMA Current Descriptor Address Register in no.1 version*/
+	volatile unsigned int *mdma_cur_buf_addr;	/*0x0210 NDFC MBUS DMA Current Buffer Address Register in no.1 version*/
+	volatile unsigned int *dma_cnt;			/*0x0214 NDFC Normal DMA Byte Counter Register*/
+	volatile unsigned int *ver;			/*0x02F0 NDFC Version Number Register*/
+	volatile unsigned int *ram0_base;		/*0x0400 NDFC Control Register*/
+	volatile unsigned int *ram1_base;		/*0x0800 NDFC Control Register*/
+};
+
+enum op_type {
+	FLASH_READ = 0,
+	FLASH_WRITE,
+	FLASH_CACHE_READ,
+	FLASH_CACHE_WRITE,
+	FLASH_MULTI_READ,
+	FLASH_MULTI_WRITE,
+	FLASH_ULTI_CACHE_READ,
+	FLASH_MULTI_CACHE_WRITE,
+};
+enum normal_req_type {
+	CMD = 0,
+	/*e.g. erase block*/
+	CMD_WITH_ADDR,
+	/*e.g. set/get feature/read page parameter/read id/read status (addr_cycles is 0)*/
+	CMD_WITH_ADDR_DATA,
+};
+enum ecc_layout {
+	INTERLEAVE = 0,
+	SEQUENCE,
+};
+
+enum data_type {
+	MAINSPARE = 0,
+	ONLY_SPARE,
+};
+
+enum plane_ab {
+	PLANE_A = 0,
+	PLANE_B,
+};
+
+struct aw_nfc_normal_req {
+	enum normal_req_type type;
+	bool wait_rb;
+	union {
+		struct {
+			uint8_t code;
+		} cmd;
+
+		struct {
+			uint8_t code;
+			uint8_t addr[MAX_CYCLE];
+			/*valid address number*/
+			uint8_t addr_cycles;
+		} cmd_with_addr;
+
+		struct {
+			/*read status*/
+			uint8_t code;
+			int len;
+			uint8_t *in;
+		} cmd_with_data;
+
+		struct {
+			uint8_t code;
+			uint8_t addr[MAX_CYCLE];
+			/*valid address number*/
+			uint8_t addr_cycles;
+			uint8_t direct;
+			int len;
+			uint8_t *in;
+			uint8_t *out;
+		} cmd_with_addr_data;
+	} op;
+};
+
+#define NORMAL_REQ_CMD_WITH_ADDR1_DATA_OUT(_req, _cmd, _addr, _data, _len)	\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD_WITH_ADDR_DATA,				\
+	.op = {					\
+		.cmd_with_addr_data = {		\
+			.code = _cmd,		\
+			.addr[0] = _addr,		\
+			.addr_cycles = 1,	\
+			.direct = FLASH_WRITE,	\
+			.len = _len,		\
+			.out = _data,		\
+		}				\
+	}					\
+}
+
+#define NORMAL_REQ_CMD_WITH_ADDR0_DATA_IN(_req, _cmd, _data, _len)	\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD_WITH_ADDR_DATA,				\
+	.op = {					\
+		.cmd_with_addr_data = {		\
+			.code = _cmd,		\
+			.addr_cycles = 0,	\
+			.direct = FLASH_READ,	\
+			.len = _len,		\
+			.in = _data,		\
+		}				\
+	}					\
+}
+
+
+#define NORMAL_REQ_CMD_WITH_ADDR1_DATA_IN(_req, _cmd, _addr, _data, _len)	\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD_WITH_ADDR_DATA,				\
+	.op = {					\
+		.cmd_with_addr_data = {		\
+			.code = _cmd,		\
+			.addr[0] = _addr,	\
+			.addr_cycles = 1,	\
+			.direct = FLASH_READ,		\
+			.len = _len,		\
+			.in = _data,		\
+		}				\
+	}					\
+}
+
+#define NORMAL_REQ_CMD(_req, _cmd_code)		\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD,				\
+	.wait_rb = 0,				\
+	.op = {					\
+		.cmd = {			\
+			.code = _cmd_code,	\
+		}				\
+	}					\
+}
+
+#define NORMAL_REQ_CMD_WAIT_RB(_req, _cmd_code)		\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD,				\
+	.wait_rb = 1,				\
+	.op = {					\
+		.cmd = {			\
+			.code = _cmd_code,	\
+		}				\
+	}					\
+}
+
+
+#define NORMAL_REQ_CMD_WITH_ADDR_N1(_req, _cmd_code, _addr)	\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD_WITH_ADDR,			\
+	.wait_rb = 0,				\
+	.op = {					\
+		.cmd_with_addr = {		\
+			.code = _cmd_code,	\
+			.addr[0] = _addr,	\
+			.addr_cycles = 1,	\
+		}				\
+	}					\
+}
+
+#define NORMAL_REQ_CMD_WITH_ADDR_N2(_req, _cmd_code, _addr1, _addr2)	\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD_WITH_ADDR,			\
+	.op = {					\
+		.cmd_with_addr = {		\
+			.code = _cmd_code,	\
+			.addr[0] = _addr1,	\
+			.addr[1] = _addr2,	\
+			.addr_cycles = 2,	\
+		}				\
+	}					\
+}
+
+#define NORMAL_REQ_CMD_WITH_ADDR_N3(_req, _cmd_code, _addr1, _addr2, _addr3)	\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD_WITH_ADDR,			\
+	.op = {					\
+		.cmd_with_addr = {		\
+			.code = _cmd_code,	\
+			.addr[0] = _addr1,	\
+			.addr[1] = _addr2,	\
+			.addr[2] = _addr3,	\
+			.addr_cycles = 3,	\
+		}				\
+	}					\
+}
+
+#define NORMAL_REQ_CMD_WITH_ADDR_N4(_req, _cmd_code, _addr1, _addr2, _addr3, _addr4)	\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD_WITH_ADDR,			\
+	.op = {					\
+		.cmd_with_addr = {		\
+			.code = _cmd_code,	\
+			.addr[0] = _addr1,	\
+			.addr[1] = _addr2,	\
+			.addr[2] = _addr3,	\
+			.addr[3] = _addr4,	\
+			.addr_cycles = 4,	\
+		}				\
+	}					\
+}
+
+#define NORMAL_REQ_CMD_WITH_ADDR_N5(_req, _cmd_code, _addr1, _addr2, _addr3, _addr4, _addr5)	\
+struct aw_nfc_normal_req _req = {		\
+	.type = CMD_WITH_ADDR,			\
+	.op = {					\
+		.cmd_with_addr = {		\
+			.code = _cmd_code,	\
+			.addr[0] = _addr1,	\
+			.addr[1] = _addr2,	\
+			.addr[2] = _addr3,	\
+			.addr[3] = _addr4,	\
+			.addr[4] = _addr5,	\
+			.addr[5] = _addr5,	\
+			.addr_cycles = 5,	\
+		}				\
+	}					\
+}
+
+
+#define NORMAL_REQ_GET_ADDR(__p_req, __p_addr_low, __p_addr_high)	\
+	int i = 0;							\
+									\
+	for (i = 0; i < __p_req->addr_cycles; i++) {			\
+		if (i < 4)						\
+			(*__p_addr_low) |= req->addr[i] << (i * 8);	\
+		else							\
+			(*__p_addr_high) |= req->addr[i] << ((i - 4) * 8);	\
+	}								\
+
+
+struct aw_nfc_batch_req {
+	enum op_type type;
+	enum ecc_layout layout;
+	enum plane_ab plane;
+	union {
+		struct {
+			uint8_t first;
+			uint8_t snd;
+			uint8_t rnd1;
+			uint8_t rnd2;
+		} val;
+		struct {
+			/*page read*/
+			uint8_t READ0;
+			uint8_t READSTART;
+			uint8_t RNOUT;
+			uint8_t RNOUTSTART;
+		} r;
+
+		struct {
+			/*page program/write*/
+			uint8_t SEQIN;
+			uint8_t PAGEPROG;
+			uint8_t RNDIN;
+		} w;
+
+		struct {
+			/*page cache write*/
+			uint8_t SEQIN;
+			uint8_t CACHEDPROG;
+			uint8_t RNDIN;
+		} cw;
+
+		struct {
+			/*multi-plane page write*/
+			uint8_t SEQIN;
+			uint8_t MULTIPROG;
+			uint8_t RNDIN;
+		} mw;
+
+		struct {
+			/*page read*/
+			uint8_t READ0;
+			uint8_t MULTIREADSTART;
+			uint8_t RNOUT;
+			uint8_t RNOUTSTART;
+		} mr;
+
+	} cmd;
+
+	struct {
+		uint32_t page;
+		uint8_t row_cycles;
+	} addr;
+
+	struct {
+		enum data_type type;
+		/*main_len align with ecc_block(1KB)*/
+		/*spare_len == chip->avalid_sparesize*/
+		int main_len;
+		int spare_len;
+		uint8_t *main;
+		uint8_t *spare;
+	} data;
+};
+
+#define BATCH_REQ_READ(_req, _page, _row_cycles, _mdata, _mlen, _sdata, _slen)	\
+	struct aw_nfc_batch_req _req = {					\
+		.type = FLASH_READ,						\
+		.layout = INTERLEAVE,						\
+		.cmd.r = {							\
+			.READ0 = RAWNAND_CMD_READ0,				\
+			.READSTART = RAWNAND_CMD_READSTART,			\
+			.RNOUT = RAWNAND_CMD_RNDOUT,				\
+			.RNOUTSTART = RAWNAND_CMD_RNDOUTSTART,			\
+		},								\
+		.addr = {							\
+			.page = _page,						\
+			.row_cycles = _row_cycles,				\
+		},								\
+		.data = {							\
+			.type = MAINSPARE,					\
+			.main_len = _mlen,					\
+			.spare_len = _slen,					\
+			.main = _mdata,					\
+			.spare = _sdata,					\
+		},								\
+	}
+
+#define BATCH_REQ_MULTI_READ(_req, _page, _row_cycles, _mdata, _mlen, _sdata, _slen)	\
+	struct aw_nfc_batch_req _req = {						\
+		.type = FLASH_MULTI_READ,						\
+		.layout = INTERLEAVE,						\
+		.cmd.mr = {							\
+			.READ0 = RAWNAND_CMD_READ0,				\
+			.MULTIREADSTART = RAWNAND_CMD_MULTIPREADSTART,		\
+			.RNOUT = RAWNAND_CMD_RNDOUT,				\
+			.RNOUTSTART = RAWNAND_CMD_RNDOUTSTART,			\
+		},								\
+		.addr = {							\
+			.page = _page,						\
+			.row_cycles = _row_cycles,				\
+		},								\
+		.data = {							\
+			.type = MAINSPARE,					\
+			.main_len = _mlen,					\
+			.spare_len = _slen,					\
+			.main = _mdata,					\
+			.spare = _sdata,					\
+		},								\
+	}
+
+#define BATCH_REQ_READ_SEQ(_req, _page, _row_cycles, _mdata, _mlen, _sdata, _slen)	\
+	struct aw_nfc_batch_req _req = {						\
+		.type = FLASH_READ,							\
+		.layout = SEQUENCE,						\
+		.cmd.r = {							\
+			.READ0 = RAWNAND_CMD_READ0,				\
+			.READSTART = RAWNAND_CMD_READSTART,			\
+			.RNOUT = RAWNAND_CMD_RNDOUT,				\
+			.RNOUTSTART = RAWNAND_CMD_RNDOUTSTART,			\
+		},								\
+		.addr = {							\
+			.page = _page,						\
+			.row_cycles = _row_cycles,				\
+		},								\
+		.data = {							\
+			.type = MAINSPARE,					\
+			.main_len = _mlen,					\
+			.spare_len = _slen,					\
+			.main = _mdata,					\
+			.spare = _sdata,					\
+		},								\
+	}
+
+
+#define BATCH_REQ_READ_ONLY_SPARE(_req, _page, _row_cycles, _sdata, _slen)	\
+	struct aw_nfc_batch_req _req = {						\
+		.type = FLASH_READ,							\
+		.layout = INTERLEAVE,						\
+		.cmd.r = {							\
+			.READ0 = RAWNAND_CMD_READ0,				\
+			.READSTART = RAWNAND_CMD_READSTART,			\
+			.RNOUT = RAWNAND_CMD_RNDOUT,				\
+			.RNOUTSTART = RAWNAND_CMD_RNDOUTSTART,			\
+		},								\
+		.addr = {							\
+			.page = _page,						\
+			.row_cycles = _row_cycles,				\
+		},								\
+		.data = {							\
+			.type = ONLY_SPARE,					\
+			.main_len = 0,						\
+			.spare_len = _slen,					\
+			.main = NULL,					\
+			.spare = _sdata,					\
+		},								\
+	}
+
+
+
+#define BATCH_REQ_WRITE(_req, _page, _row_cycles, _mdata, _mlen, _sdata, _slen)	\
+	struct aw_nfc_batch_req _req = {						\
+		.type = FLASH_WRITE,							\
+		.layout = INTERLEAVE,						\
+		.cmd.w = {							\
+			.SEQIN = RAWNAND_CMD_SEQIN,				\
+			.PAGEPROG = RAWNAND_CMD_PAGEPROG,			\
+			.RNDIN = RAWNAND_CMD_RNDIN,				\
+		},								\
+		.addr = {							\
+			.page = _page,						\
+			.row_cycles = _row_cycles,				\
+		},								\
+		.data = {							\
+			.type = MAINSPARE,					\
+			.main_len = _mlen,					\
+			.spare_len = _slen,					\
+			.main = _mdata,					\
+			.spare = _sdata,					\
+		},								\
+	}
+
+#define BATCH_REQ_MULTI_WRITE(_req, _page, _row_cycles, _mdata, _mlen, _sdata, _slen, _plane)	\
+	struct aw_nfc_batch_req _req = {					\
+		.type = FLASH_MULTI_WRITE,					\
+		.layout = INTERLEAVE,						\
+		.plane = _plane,						\
+		.cmd.mw = {							\
+			.SEQIN = RAWNAND_CMD_SEQIN,				\
+			.MULTIPROG = RAWNAND_CMD_MULTIPROG,			\
+			.RNDIN = RAWNAND_CMD_RNDIN,				\
+		},								\
+		.addr = {							\
+			.page = _page,						\
+			.row_cycles = _row_cycles,				\
+		},								\
+		.data = {							\
+			.type = MAINSPARE,					\
+			.main_len = _mlen,					\
+			.spare_len = _slen,					\
+			.main = _mdata,					\
+			.spare = _sdata,					\
+		},								\
+	}
+
+#define BATCH_REQ_CACHE_WRITE(_req, _page, _row_cycles, _mdata, _mlen, _sdata, _slen)	\
+	struct aw_nfc_batch_req _req = {						\
+		.type = FLASH_CACHE_WRITE,						\
+		.layout = INTERLEAVE,						\
+		.cmd.cw = {							\
+			.SEQIN = RAWNAND_CMD_SEQIN,				\
+			.CACHEDPROG = RAWNAND_CMD_CACHEDPROG,			\
+			.RNDIN = RAWNAND_CMD_RNDIN,				\
+		},								\
+		.addr = {							\
+			.page = _page,						\
+			.row_cycles = _row_cycles,				\
+		},								\
+		.data = {							\
+			.type = MAINSPARE,					\
+			.main_len = _mlen,					\
+			.spare_len = _slen,					\
+			.main = _mdata,					\
+			.spare = _sdata,					\
+		},								\
+	}
+
+#define BATCH_REQ_WRITE_SEQ(_req, _page, _row_cycles, _mdata, _mlen, _sdata, _slen)	\
+	struct aw_nfc_batch_req _req = {						\
+		.type = FLASH_WRITE,							\
+		.layout = SEQUENCE,						\
+		.cmd.w = {							\
+			.SEQIN = RAWNAND_CMD_SEQIN,				\
+			.PAGEPROG = RAWNAND_CMD_PAGEPROG,			\
+			.RNDIN = RAWNAND_CMD_RNDIN,				\
+		},								\
+		.addr = {							\
+			.page = _page,						\
+			.row_cycles = _row_cycles,				\
+		},								\
+		.data = {							\
+			.type = MAINSPARE,					\
+			.main_len = _mlen,					\
+			.spare_len = _slen,					\
+			.main = _mdata,					\
+			.spare = _sdata,					\
+		},								\
+	}
+
+
+/**
+ * enum nand_data_interface_type - NAND interface timing type
+ * @NAND_SDR_IFACE:	Single Data Rate interface
+ */
+enum rawnand_data_interface_type {
+	RAWNAND_SDR_IFACE = 0,
+	RAWNAND_ONFI_DDR = 0x2,
+	RAWNAND_ONFI_DDR2 = 0x12,
+	RAWNAND_TOGGLE_DDR = 0x3,
+	RAWNAND_TOGGLE_DDR2 = 0x13,
+};
+
+enum dma_type {
+	GENERIC_DMA = 0,
+	MBUS_DMA,
+};
+
+
+#define NFC_DESC_FIRST_FLAG (0x1 << 3)
+#define NFC_DESC_LAST_FLAG (0x1 << 2)
+#define NFC_DMA_DESC_MAX_NUM (32)
+#define NFC_DESC_BSIZE(bsize)	((bsize)&0xFFFF) /*in order to ndfc spec BUFF_SIZE 16bits valid*/
+struct aw_nfc_dma_desc {
+	unsigned int cfg;
+	unsigned int bcnt;
+	unsigned int buff;
+	struct aw_nfc_dma_desc *next;
+};
+struct aw_nand_host {
+	struct device *dev;
+	struct pinctrl *pinctrl;
+	void __iomem *base;
+	struct nfc_reg nfc_reg;
+
+	struct clk *pclk;	/*pll clock*/
+	struct clk *mdclk;	/*nand module clock*/
+	struct clk *mcclk;	/*nand ecc engine clock*/
+#ifndef __UBOOT__
+	struct regulator *vcc_nand;
+	struct regulator *vcc_io;
+#endif
+	unsigned int mdclk_val;
+	unsigned int mcclk_val;
+	bool init;
+
+	unsigned long clk_rate;
+	unsigned int timing_ctl;
+	unsigned int timing_cfg;
+	enum rawnand_data_interface_type nf_type;
+
+	u8 cs[4];
+	u8 rb[4];
+
+	/*1: use b2r int when rb signal from busy to ready; 0: don't use b2r int*/
+	uint8_t use_rb_int;
+	uint8_t rb_ready_flag;
+
+	uint8_t use_dma;
+	enum dma_type dma_type;
+	dma_addr_t dma_addr;
+	dma_addr_t desc_addr; /*descripte dma addr*/
+	/*1: use dma int when dma is completed; 0: don't use dma int*/
+	uint8_t use_dma_int;
+	uint8_t dma_ready_flag;
+
+	uint8_t bitflips;
+
+#define MAX_SPARE_SIZE	(64)
+	uint8_t *spare_default;
+
+	struct aw_nfc_dma_desc *nfc_dma_desc;	/*physic addr*/
+	struct aw_nfc_dma_desc *nfc_dma_desc_cpu; /*virtual addr*/
+
+	int (*normal_op)(struct aw_nand_chip *chip, struct aw_nfc_normal_req *req);
+	int (*batch_op)(struct aw_nand_chip *chip, struct aw_nfc_batch_req *req);
+	bool (*rb_ready)(struct aw_nand_chip *chip, struct aw_nand_host *host);
+
+	void *priv;
+
+};
+
+
+#define NAND_DATA_ITF_TYPE_TOGGLE_DDR1_2(chip)	\
+	((chip->data_interface.type == RAWNAND_TOGGLE_DDR) || \
+	 (chip->data_interface.type == RAWNAND_TOGGLE_DDR2))
+
+/**
+ * struct nand_data_interface - NAND interface timing
+ * @type:	type of the timing
+ * @timings:	The timing, type according to @type
+ */
+struct rawnand_data_interface {
+	enum rawnand_data_interface_type type;
+
+	int (*set_feature)(struct aw_nand_chip *chip,
+			int feature_addr, uint8_t *feature_para);
+	int (*get_feature)(struct aw_nand_chip *chip,
+			int feature_addr, uint8_t *feature_para);
+};
+
+struct ce_info {
+	int ce_no;
+	int relate_rb_no;
+};
+
+struct select_chip {
+	int chip_no;
+	struct ce_info ceinfo[MAX_CHIPS];
+};
+
+struct aw_nand_chip_cache {
+#define INVALID_CACHE (-1)
+	uint32_t pageno;
+	uint32_t oobno;
+	int page_len;
+	uint8_t *pagebuf;
+	int oob_len;
+	uint8_t *oobbuf;
+	uint8_t bitflips;
+	int sub_page_len;
+};
+
+struct aw_nand_chip {
+	struct mutex lock;
+	/**************************
+	 *  mtd layer
+	 *------------------------
+	 *  simu chip
+	 *------------------------
+	 *     chip
+	 *| --blkn----|--blkn+1--|
+	 *|  (planeA) |  (planeB)|
+	 * ************************/
+	struct mtd_info mtd;
+#define SLC_NAND	(0)
+#define MLC_NAND	(1)
+	int type;
+
+	uint8_t id[RAWNAND_MAX_ID_LEN];
+	unsigned int dies;
+#define MAX_DIES (2U)
+	unsigned int diesize[MAX_DIES];
+	int chips;
+	uint64_t chipsize;
+	uint64_t simu_chipsize;
+	int chip_shift;
+	int simu_chip_shift;
+	int chip_pages;
+	/*simulation is for multi, see line@48 rawnand  multiplane layout.*/
+	int simu_chip_pages;
+	int chip_pages_mask;
+	int simu_chip_pages_mask;
+
+	/*main data size*/
+	int pagesize;
+	int simu_pagesize;
+	/*main data size shift*/
+	unsigned int pagesize_shift;
+	unsigned int simu_pagesize_shift;
+	int pagesize_mask;
+	int simu_pagesize_mask;
+	/*main data size + spare data size*/
+	int real_pagesize;
+	unsigned int erasesize;
+	unsigned int simu_erasesize;
+	unsigned int erase_shift;
+	unsigned int simu_erase_shift;
+	unsigned int erasesize_mask;
+	unsigned int simu_erasesize_mask;
+	unsigned int pages_per_blk_shift;
+	unsigned int simu_pages_per_blk_shift;
+	unsigned int pages_per_blk_mask;
+	unsigned int simu_pages_per_blk_mask;
+	int avalid_sparesize;
+	int ecc_mode;
+	int random;
+	int row_cycles;
+	enum error_management badblock_mark_pos;
+	unsigned int pe_cycles;
+
+	unsigned int options;
+	int clk_rate;
+
+	int operate_boot0;
+	int boot0_ecc_mode;
+	int uboot_end;
+
+	struct select_chip selected_chip;
+	struct ce_info ceinfo[MAX_CHIPS];
+
+	struct aw_nand_chip_cache buffer;
+
+	struct rawnand_data_interface data_interface;
+#define BBT_B_INVALID	(2)
+#define BBT_B_BAD	(1)
+#define BBT_B_GOOD	(0)
+	uint8_t *bbt;
+	/*mark whether the corresponding bbt bit is updated*/
+	uint8_t *bbtd;
+
+	uint8_t bitflips;
+
+	void (*select_chip)(struct mtd_info *mtd, int chip);
+	bool  (*dev_ready_wait)(struct mtd_info *mtd);
+	int  (*dev_status)(struct mtd_info *mtd);
+
+
+	int (*block_bad)(struct mtd_info *mtd, int block);
+	int (*simu_block_bad)(struct mtd_info *mtd, int block);
+	int (*block_markbad)(struct mtd_info *mtd, int block);
+	int (*simu_block_markbad)(struct mtd_info *mtd, int block);
+	/*scan device to update bbt*/
+	int (*scan_bbt)(struct mtd_info *mtd);
+
+	int (*erase)(struct mtd_info *mtd, int page);
+	int (*multi_erase)(struct mtd_info *mtd, int page);
+
+	int (*write_page)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+	int (*multi_write_page)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+	int (*cache_write_page)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+	int (*read_page)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+	int (*multi_read_page)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+	int (*read_page_spare)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *sdata, int slen, int page);
+
+	int (*write_boot0_page)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+	int (*read_boot0_page)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+
+	int (*setup_read_retry)(struct mtd_info *mtd, struct aw_nand_chip *chip);
+	int (*setup_data_interface)(struct mtd_info *mtd, struct aw_nand_chip *chip,
+			int chipnr, const struct rawnand_data_interface *conf);
+
+
+	struct aw_nand_flash_dev *dev;
+
+	void *priv;
+	struct list_head node;
+};
+
+
+struct aw_nand_sec_sto {
+	struct aw_nand_chip *chip;
+	/*initialized before read/write*/
+	unsigned int startblk;
+	unsigned int endblk;
+
+	unsigned int blk[2];
+	int init_end;
+};
+
+static inline struct aw_nand_host *awnand_chip_to_host(struct aw_nand_chip *chip)
+{
+	return (struct aw_nand_host *)chip->priv;
+}
+
+static inline struct aw_nand_chip *awnand_host_to_chip(struct aw_nand_host *host)
+{
+	return (struct aw_nand_chip *)host->priv;
+}
+
+static inline struct mtd_info *awnand_chip_to_mtd(struct aw_nand_chip *chip)
+{
+	return (struct mtd_info *)&chip->mtd;
+}
+
+static inline struct aw_nand_chip *awnand_mtd_to_chip(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct aw_nand_chip, mtd);
+	//return (struct aw_nand_chip *)container_of(mtd, struct aw_nand_chip, mtd);
+}
+
+static inline struct aw_nand_host *awnand_nfc_to_host(struct nfc_reg *nfc)
+{
+	return container_of(nfc, struct aw_nand_host, nfc_reg);
+}
+
+static inline struct aw_nand_chip *get_rawnand(void)
+{
+	return &awnand_chip;
+}
+
+static inline struct aw_nand_sec_sto *get_rawnand_sec_sto(void)
+{
+	return &rawnand_sec_sto;
+}
+
+/**
+ * check_offs_len - check mtd->_erase requset legality
+ * */
+static inline int check_offs_len(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	struct aw_nand_chip *chip = awnand_mtd_to_chip(mtd);
+	int ret = 0;
+
+	/*check align to block and exceed the mtd size*/
+	if ((ofs & chip->erasesize_mask) ||
+		(len & chip->erasesize_mask) ||
+		((ofs + len) > mtd->size)) {
+		awrawnand_err("unaligned address@%llu len@%llu\n", ofs, len);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/**
+ * check_ofs_mtd_oob_ops - use to check _read/write_oob requeset legality
+ * @rw: 0: read , 1: write
+ * */
+static inline int check_ofs_mtd_oob_ops(struct mtd_info *mtd, loff_t ofs, struct mtd_oob_ops *ops,
+		int rw)
+{
+
+	struct aw_nand_chip *chip = awnand_mtd_to_chip(mtd);
+
+	/*check boundary*/
+	if (ops->datbuf && (ofs + ops->len) > mtd->size) {
+		awrawnand_err("attemp to %s to@%llu len@%lu beyond end of device@%llu\n",
+				rw ? "write" : "read", ofs, ops->len, mtd->size);
+		return -EINVAL;
+	}
+
+	/*chec spare boundary*/
+	if (ops->oobbuf && ((ops->ooboffs + ops->ooblen) > mtd->oobsize)) {
+		awrawnand_err("attemp to %s ooblen@%lu beyond end of avalid_sparesize@%d\n",
+				rw ? "write" : "read", ops->ooblen, chip->avalid_sparesize);
+		return -EINVAL;
+	}
+
+	/*check align*/
+	if ((ofs & chip->pagesize_mask) || (ops->len & chip->pagesize_mask)) {
+		awrawnand_print("attemp to %s to@%llu len@%lu  non pagesize@%d aligned data\n",
+				rw ? "write" : "read", ofs, ops->len, chip->pagesize);
+		return 0;
+	}
+
+	return 0;
+}
+
+/**
+ * check_from_len - check mtd->_read request legality
+ * */
+static inline int check_from_len(struct mtd_info *mtd, loff_t from, size_t len)
+{
+	struct aw_nand_chip *chip = awnand_mtd_to_chip(mtd);
+	/*check boundary*/
+	if ((from + len) > mtd->size) {
+		awrawnand_err("attemp to read from@0x%llx len@0x%lx  beyond end of device@0x%llx\n",
+				from, len, mtd->size);
+		return -EINVAL;
+	}
+
+	if (from & chip->pagesize_mask) {
+		awrawnand_err("attemp to read from@%llu not align to pagesize@%u\n",
+				from, chip->pagesize);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * check_to_len - check mtd->_write request legality
+ * */
+static inline int check_to_len(struct mtd_info *mtd, loff_t to, size_t len)
+{
+	struct aw_nand_chip *chip = awnand_mtd_to_chip(mtd);
+	/*check boundary*/
+	if ((to + len) > mtd->size) {
+		awrawnand_err("attemp to write to@0x%llx len@0x%lx  beyond end of device@0x%llx\n",
+				to, len, mtd->size);
+		return -EINVAL;
+	}
+
+	if ((to & chip->pagesize_mask) || (len & chip->pagesize_mask)) {
+		awrawnand_err("attemp to write to@%llu not align to phy-pagesize@%u\n",
+				to, chip->pagesize);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+extern bool support_rawnand(void);
+extern int aw_rawnand_secure_storage_read(struct aw_nand_sec_sto *sec_sto,
+		int item, char *buf, unsigned int len);
+
+extern int aw_rawnand_secure_storage_write(struct aw_nand_sec_sto *sec_sto,
+		int item, char *buf, unsigned int len);
+
+extern void rawnand_uboot_blknum(unsigned int *start, unsigned int *end);
+
+extern int rawnand_mtd_download_uboot(unsigned int len, void *buf);
+extern int rawnand_mtd_download_boot0(unsigned int len, void *buf);
+extern int rawnand_mtd_secure_storage_write(int item, char *buf, unsigned int len);
+extern int rawnand_mtd_secure_storage_read(int item, char *buf, unsigned int len);
+
+
+extern int aw_rawnand_chip_block_bad(struct mtd_info *mtd, int block);
+extern int aw_rawnand_chip_block_markbad(struct mtd_info *mtd, int block);
+extern int aw_rawnand_chip_scan_bbt(struct mtd_info *mtd);
+
+
+extern int aw_host_init(struct device *dev);
+extern void aw_host_exit(struct aw_nand_host *host);
+extern int aw_host_init_tail(struct aw_nand_host *host);
+extern int rawnand_mtd_init(void);
+extern void rawnand_mtd_exit(void);
+extern int rawnand_mtd_flush(void);
+extern int rawnand_mtd_attach_mtd(void);
+extern unsigned rawnand_mtd_size(void);
+extern int rawnand_mtd_erase(int flag);
+extern int rawnand_mtd_force_erase(void);
+
+extern int rawnand_mtd_read(unsigned int start, unsigned int sects, void *buf);
+extern int rawnand_mtd_write(unsigned int start, unsigned int sects, void *buf);
+extern int rawnand_mtd_write_end(void);
+extern int rawnand_mtd_get_flash_info(void *data, unsigned int len);
+extern int rawnand_mtd_update_ubi_env(void);
+extern int rawnand_mtd_set_last_vol_sects(unsigned int sects);
+
+extern int rawslcnand_write_boot0_page(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+extern int rawslcnand_read_boot0_page(struct mtd_info *mtd, struct aw_nand_chip *chip,
+		uint8_t *mdata, int mlen, uint8_t *sdata, int slen, int page);
+extern void rawnand_uboot_blknum(unsigned int *start, unsigned int *end);
+
+
+#endif /*AW_RAWNAND_H*/
diff --git a/include/linux/mtd/aw-spinand-nftl.h b/include/linux/mtd/aw-spinand-nftl.h
new file mode 100644
index 000000000..f30f2cb70
--- /dev/null
+++ b/include/linux/mtd/aw-spinand-nftl.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __AW_SPINAND_NFTL_H__
+#define __AW_SPINAND_NFTL_H__
+
+#include <linux/sunxi-boot.h>
+
+#define AW_NFTL_OOB_LEN (16)
+
+enum AW_NFTL_ECC_STATUS {
+	AW_NFTL_ECC_ERR = -2,
+	AW_NFTL_ECC_LIMIT = 10
+};
+
+
+unsigned int spinand_nftl_get_super_page_size(int type);
+unsigned int spinand_nftl_get_super_block_size(int type);
+unsigned int spinand_nftl_get_single_page_size(int type);
+unsigned int spinand_nftl_get_single_block_size(int type);
+unsigned int spinand_nftl_get_chip_size(int type);
+unsigned int spinand_nftl_get_die_size(int type);
+unsigned int spinand_nftl_get_die_cnt(void);
+unsigned int spinand_nftl_get_chip_cnt(void);
+unsigned int spinand_nftl_get_max_erase_times(void);
+unsigned int spinand_nftl_get_multi_plane_flag(void);
+unsigned int spinand_nftl_get_operation_opt(void);
+void spinand_nftl_get_chip_id(unsigned char *id);
+
+int spinand_nftl_read_super_page(unsigned short dienum, unsigned short blocknum,
+		unsigned short pagenum, unsigned short sectorbitmap,
+		void *rmbuf, void *rspare);
+
+int spinand_nftl_write_super_page(unsigned short dienum, unsigned short blocknum,
+		unsigned short pagenum, unsigned short sectorbitmap,
+		void *wmbuf, void *wspare);
+int spinand_nftl_erase_super_block(unsigned short dienum, unsigned short blocknum);
+int spinand_nftl_super_badblock_check(unsigned short dienum, unsigned short blocknum);
+int spinand_nftl_super_badblock_mark(unsigned short dienum, unsigned short blocknum);
+
+int spinand_nftl_read_single_page(unsigned short dienum, unsigned short blocknum,
+		unsigned short pagenum, unsigned short sectorbitmap,
+		void *rmbuf, void *rspare);
+
+int spinand_nftl_write_single_page(unsigned short dienum, unsigned short blocknum,
+		unsigned short pagenum, unsigned short sectorbitmap,
+		void *wmbuf, void *wspare);
+int spinand_nftl_erase_single_block(unsigned short dienum, unsigned short blocknum);
+
+int spinand_nftl_single_block_copy(unsigned int from_chip,
+		unsigned int from_block, unsigned int to_chip,
+		unsigned int to_block);
+int spinand_nftl_single_badblock_check(unsigned short chipnum, unsigned short blocknum);
+int spinand_nftl_single_badblock_mark(unsigned short chipnum, unsigned short blocknum);
+
+#endif /*AW_SPINAND_NFTL_H*/
diff --git a/include/linux/mtd/aw-spinand.h b/include/linux/mtd/aw-spinand.h
new file mode 100644
index 000000000..c53364374
--- /dev/null
+++ b/include/linux/mtd/aw-spinand.h
@@ -0,0 +1,363 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __AW_SPINAND_H
+#define __AW_SPINAND_H
+
+#include <linux/mutex.h>
+#include <linux/spi/spi.h>
+
+#define AW_OOB_SIZE_PER_PHY_PAGE (16)
+/**
+ * In order to fix for nftl nand, make they has the same address
+ * for saving crc16
+ */
+#define AW_CRC16_OOB_OFFSET (12)
+
+#define SBROM_TOC0_HEAD_SPACE  (0x80)
+#define STORAGE_BUFFER_SIZE    (256)
+#define STAMP_VALUE             0x5F0A6C39
+#define MAX_ID_LEN 8
+
+/* ecc status */
+#define ECC_GOOD	(0 << 4)
+#define ECC_LIMIT	(1 << 4)
+#define ECC_ERR		(2 << 4)
+
+#define SECBLK_READ		_IO('V', 20)
+#define SECBLK_WRITE		_IO('V', 21)
+#define SECBLK_IOCTL		_IO('V', 22)
+
+#define BLKBURNBOOT0		_IO('v', 127)
+#define BLKBURNBOOT1		_IO('v', 128)
+
+struct aw_spinand_ecc;
+struct aw_spinand_info;
+struct aw_spinand_phy_info;
+struct aw_spinand_chip_ops;
+
+struct aw_spinand_chip {
+	struct aw_spinand_chip_ops *ops;
+	struct aw_spinand_ecc *ecc;
+	struct aw_spinand_cache *cache;
+	struct aw_spinand_info *info;
+	struct aw_spinand_bbt *bbt;
+	struct spi_device *spi;
+	unsigned int rx_bit;
+	unsigned int tx_bit;
+	unsigned int freq;
+	void *priv;
+};
+
+struct aw_spinand_chip_request {
+	unsigned int block;
+	unsigned int page;
+	unsigned int pageoff;
+	unsigned int ooblen;
+	unsigned int datalen;
+	void *databuf;
+	void *oobbuf;
+
+	unsigned int oobleft;
+	unsigned int dataleft;
+};
+
+struct aw_spinand_chip_ops {
+	int (*get_block_lock)(struct aw_spinand_chip *chip, u8 *reg_val);
+	int (*set_block_lock)(struct aw_spinand_chip *chip, u8 reg_val);
+	int (*get_otp)(struct aw_spinand_chip *chip, u8 *reg_val);
+	int (*set_otp)(struct aw_spinand_chip *chip, u8 reg_val);
+	int (*get_driver_level)(struct aw_spinand_chip *chip, u8 *reg_val);
+	int (*set_driver_level)(struct aw_spinand_chip *chip, u8 reg_val);
+	int (*reset)(struct aw_spinand_chip *chip);
+	int (*read_status)(struct aw_spinand_chip *chip, u8 *status);
+	int (*read_id)(struct aw_spinand_chip *chip, void *id, int len,
+			int dummy);
+	int (*read_reg)(struct aw_spinand_chip *chip, u8 cmd, u8 reg, u8 *val);
+	int (*write_reg)(struct aw_spinand_chip *chip, u8 cmd, u8 reg, u8 val);
+	int (*is_bad)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*mark_bad)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*erase_block)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*write_page)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*read_page)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*phy_is_bad)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*phy_mark_bad)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*phy_erase_block)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*phy_write_page)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*phy_read_page)(struct aw_spinand_chip *chip,
+			struct aw_spinand_chip_request *req);
+	int (*phy_copy_block)(struct aw_spinand_chip *chip,
+			unsigned int from_blk, unsigned int to_blk);
+};
+
+struct aw_spinand_info {
+	const char *(*model)(struct aw_spinand_chip *chip);
+	const char *(*manufacture)(struct aw_spinand_chip *chip);
+	void (*nandid)(struct aw_spinand_chip *chip, unsigned char *id, int cnt);
+	unsigned int (*die_cnt)(struct aw_spinand_chip *chip);
+	unsigned int (*oob_size)(struct aw_spinand_chip *chip);
+	unsigned int (*sector_size)(struct aw_spinand_chip *chip);
+	unsigned int (*page_size)(struct aw_spinand_chip *chip);
+	unsigned int (*block_size)(struct aw_spinand_chip *chip);
+	unsigned int (*phy_oob_size)(struct aw_spinand_chip *chip);
+	unsigned int (*phy_page_size)(struct aw_spinand_chip *chip);
+	unsigned int (*phy_block_size)(struct aw_spinand_chip *chip);
+	unsigned int (*total_size)(struct aw_spinand_chip *chip);
+	int (*operation_opt)(struct aw_spinand_chip *chip);
+	int (*max_erase_times)(struct aw_spinand_chip *chip);
+
+	/* private data */
+	struct aw_spinand_phy_info *phy_info;
+};
+
+typedef struct {
+	__u8        ChipCnt;                 /* the count of the total nand flash chips are currently connecting on the CE pin */
+	__u8        ConnectMode;             /* the rb connect  mode */
+	__u8        BankCntPerChip;          /* the count of the banks in one nand chip, multiple banks can support Inter-Leave */
+	__u8        DieCntPerChip;           /* the count of the dies in one nand chip, block management is based on Die */
+	__u8        PlaneCntPerDie;          /* the count of planes in one die, multiple planes can support multi-plane operation */
+	__u8        SectorCntPerPage;        /* the count of sectors in one single physic page, one sector is 0.5k */
+	__u16       ChipConnectInfo;         /* chip connect information, bit == 1 means there is a chip connecting on the CE pin */
+	__u32       PageCntPerPhyBlk;        /* the count of physic pages in one physic block */
+	__u32       BlkCntPerDie;            /* the count of the physic blocks in one die, include valid block and invalid block */
+	__u32       OperationOpt;            /* the mask of the operation types which current nand flash can support support */
+	__u32       FrequencePar;            /* the parameter of the hardware access clock, based on 'MHz' */
+	__u32       SpiMode;                 /* spi nand mode, 0:mode 0, 3:mode 3 */
+	__u8        NandChipId[8];           /* the nand chip id of current connecting nand chip */
+	__u32       pagewithbadflag;         /* bad block flag was written at the first byte of spare area of this page */
+	__u32       MultiPlaneBlockOffset;   /* the value of the block number offset between the two plane block */
+	__u32       MaxEraseTimes;           /* the max erase times of a physic block */
+	__u32       MaxEccBits;              /* the max ecc bits that nand support */
+	__u32       EccLimitBits;            /* the ecc limit flag for tne nand */
+	__u32       uboot_start_block;
+	__u32       uboot_next_block;
+	__u32       logic_start_block;
+	__u32       nand_specialinfo_page;
+	__u32       nand_specialinfo_offset;
+	__u32       physic_block_reserved;
+	__u32	    sample_mode;
+	__u32	    sample_delay;
+	__u32       Reserved[4];
+} boot_spinand_para_t;
+
+typedef struct {
+	unsigned int ChannelCnt;
+	/*count of total nand chips are currently connecting on the CE pin*/
+	unsigned int ChipCnt;
+	/*chip connect info, bit=1 means one chip connecting on the CE pin*/
+	unsigned int ChipConnectInfo;
+	unsigned int RbCnt;
+	/*connect info of all rb  chips are connected*/
+	unsigned int RbConnectInfo;
+	unsigned int RbConnectMode;	/*rb connect mode*/
+	/*count of banks in one nand chip, multi banks can support Inter-Leave*/
+	unsigned int BankCntPerChip;
+	/*count of dies in one nand chip, block management is based on Die*/
+	unsigned int DieCntPerChip;
+	/*count of planes in one die, >1 can support multi-plane operation*/
+	unsigned int PlaneCntPerDie;
+	/*count of sectors in one single physic page, one sector is 0.5k*/
+	unsigned int SectorCntPerPage;
+	/*count of physic pages in one physic block*/
+	unsigned int PageCntPerPhyBlk;
+	/*count of physic blocks in one die, include valid and invalid blocks*/
+	unsigned int BlkCntPerDie;
+	/*mask of operation types which current nand flash can support support*/
+	unsigned int OperationOpt;
+	/*parameter of hardware access clock, based on 'MHz'*/
+	unsigned int FrequencePar;
+	/*Ecc Mode for nand chip, 0: bch-16, 1:bch-28, 2:bch_32*/
+	unsigned int EccMode;
+	/*nand chip id of current connecting nand chip*/
+	unsigned char NandChipId[8];
+	/*ratio of valid physical blocks, based on 1024*/
+	unsigned int ValidBlkRatio;
+	unsigned int good_block_ratio; /*good block ratio get from hwscan*/
+	unsigned int ReadRetryType; /*read retry type*/
+	unsigned int DDRType;
+	unsigned int Reserved[32];
+} boot_nand_para_t;
+
+typedef struct _normal_gpio_cfg {
+	unsigned char port;
+	unsigned char port_num;
+	char mul_sel;
+	char pull;
+	char drv_level;
+	char data;
+	unsigned char reserved[2];
+} normal_gpio_cfg;
+
+/******************************************************************************/
+/*                              head of Boot0                                 */
+/******************************************************************************/
+typedef struct _boot0_private_head_t {
+	unsigned int prvt_head_size;
+	char prvt_head_vsn[4];        /* the version of boot0_private_head_t */
+	unsigned int dram_para[32];   /* Original values is arbitrary */
+	int uart_port;
+	normal_gpio_cfg uart_ctrl[2];
+	int enable_jtag;              /* 1 : enable,  0 : disable */
+	normal_gpio_cfg jtag_gpio[5];
+	normal_gpio_cfg storage_gpio[32];
+	char storage_data[512 - sizeof(normal_gpio_cfg) * 32];
+}
+boot0_private_head_t;
+
+typedef struct standard_Boot_file_head {
+	unsigned int jump_instruction;  /* one intruction jumping to real code */
+	unsigned char magic[8];         /* ="eGON.BT0" or "eGON.BT1",  not C-style string */
+	unsigned int check_sum;         /* generated by PC */
+	unsigned int length;            /* generated by PC */
+	unsigned int pub_head_size;     /* size of boot_file_head_t */
+	unsigned char pub_head_vsn[4];  /* version of boot_file_head_t */
+	unsigned char file_head_vsn[4]; /* version of boot0_file_head_t or boot1_file_head_t */
+	unsigned char Boot_vsn[4];      /* Boot version */
+	unsigned char eGON_vsn[4];      /* eGON version */
+	unsigned char platform[8];      /* platform information */
+} standard_boot_file_head_t;
+
+typedef struct _boot0_file_head_t {
+	standard_boot_file_head_t boot_head;
+	boot0_private_head_t prvt_head;
+} boot0_file_head_t;
+
+typedef struct _boot_core_para_t {
+	unsigned int user_set_clock;
+	unsigned int user_set_core_vol;
+	unsigned int vol_threshold;
+} boot_core_para_t;
+
+/******************************************************************************/
+/*                                   head of Boot1                            */
+/******************************************************************************/
+typedef struct _boot1_private_head_t {
+	unsigned int dram_para[32];
+	int run_clock;		/* Mhz*/
+	int run_core_vol;	/* mV*/
+	int uart_port;
+	normal_gpio_cfg uart_gpio[2];
+	int twi_port;
+	normal_gpio_cfg twi_gpio[2];
+	int work_mode;
+	int storage_type;	/* 0nand   1sdcard    2: spinor*/
+	normal_gpio_cfg nand_gpio[32];
+	char nand_spare_data[256];
+	normal_gpio_cfg sdcard_gpio[32];
+	char sdcard_spare_data[256];
+	int reserved[6];
+} boot1_private_head_t;
+
+typedef struct _Boot_file_head {
+	unsigned int jump_instruction; /* one intruction jumping to real code */
+	unsigned char magic[8];        /* ="u-boot" */
+	unsigned int check_sum;        /* generated by PC */
+	unsigned int align_size;       /* align size in byte */
+	unsigned int length;           /* the size of all file */
+	unsigned int uboot_length;     /* the size of uboot */
+	unsigned char version[8];      /* uboot version */
+	unsigned char platform[8];     /* platform information */
+	int reserved[1];               /* stamp space, 16bytes align */
+} boot_file_head_t;
+
+typedef struct _boot1_file_head_t {
+	boot_file_head_t boot_head;
+	boot1_private_head_t prvt_head;
+} boot1_file_head_t;
+
+typedef struct sbrom_toc0_config {
+	unsigned char config_vsn[4];
+	unsigned int dram_para[32];
+	int uart_port;
+	normal_gpio_cfg uart_ctrl[2];
+	int enable_jtag;
+	normal_gpio_cfg jtag_gpio[5];
+	normal_gpio_cfg storage_gpio[50];
+	char storage_data[384];
+	unsigned int secure_dram_mbytes;
+	unsigned int drm_start_mbytes;
+	unsigned int drm_size_mbytes;
+	unsigned int res[8];
+} sbrom_toc0_config_t;
+
+typedef struct {
+	u8 name[8];
+	u32 magic;
+	u32 check_sum;
+
+	u32 serial_num;
+	u32 status;
+
+	u32 items_nr;
+	u32 length;
+	u8 platform[4];
+	u32 reserved[2];
+	u32 end;
+
+} toc0_private_head_t;
+
+
+int addr_to_req(struct aw_spinand_chip *chip, struct aw_spinand_chip_request *req,
+		unsigned int addr);
+int aw_spinand_chip_init(struct spi_device *spi, struct aw_spinand_chip *chip);
+void aw_spinand_chip_exit(struct aw_spinand_chip *chip);
+
+#define aw_spinand_hexdump(level, prefix, buf, len)			\
+	print_hex_dump(level, prefix, DUMP_PREFIX_OFFSET, 16, 1,	\
+			buf, len, true)
+#define aw_spinand_reqdump(func, note, req)				\
+	do {								\
+		func("%s(%d): %s\n", __func__, __LINE__, note);		\
+		func("\tblock: %u\n", (req)->block);			\
+		func("\tpage: %u\n", (req)->page);			\
+		func("\tpageoff: %u\n", (req)->pageoff);		\
+		if ((req)->databuf)					\
+			func("\tdatabuf: 0x%p\n", (req)->databuf);	\
+		else							\
+			func("\tdatabuf: NULL\n");			\
+		func("\tdatalen: %u\n", (req)->datalen);		\
+		func("\tdataleft: %u\n", (req)->dataleft);		\
+		if ((req)->oobbuf)					\
+			func("\toobbuf: 0x%p\n", (req)->oobbuf);	\
+		else							\
+			func("\toobbuf: NULL\n");			\
+		func("\tooblen: %u\n", (req)->ooblen);			\
+		func("\toobleft: %u\n", (req)->oobleft);		\
+		func("\n");						\
+	} while (0)
+
+#if IS_ENABLED(CONFIG_AW_SPINAND_SECURE_STORAGE)
+struct aw_spinand_sec_sto {
+	/* the follow three must be initialized by the caller before read/write */
+	unsigned int startblk;
+	unsigned int endblk;
+	struct aw_spinand_chip *chip;
+
+	unsigned int blk[2];
+	int init_end;
+};
+
+int aw_spinand_secure_storage_read(struct aw_spinand_sec_sto *sec_sto,
+		int item, char *buf, unsigned int len);
+int aw_spinand_secure_storage_write(struct aw_spinand_sec_sto *sec_sto,
+		int item, char *buf, unsigned int len);
+int aw_spinand_mtd_read_secure_storage(struct mtd_info *mtd,
+		int item, void *buf, unsigned int len);
+int aw_spinand_mtd_write_secure_storage(struct mtd_info *mtd,
+		int item, void *buf, unsigned int len);
+#endif
+
+int aw_spinand_mtd_download_boot0(struct mtd_info *mtd,
+		unsigned int len, void *buf);
+int aw_spinand_mtd_download_uboot(struct mtd_info *mtd,
+		unsigned int len, void *buf);
+
+#endif
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 249e8d9bf..95fa2a02a 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -17,6 +17,12 @@
 
 #include <asm/div64.h>
 
+#define MTD_ERASE_PENDING	0x01
+#define MTD_ERASING		0x02
+#define MTD_ERASE_SUSPEND	0x04
+#define MTD_ERASE_DONE		0x08
+#define MTD_ERASE_FAILED	0x10
+
 #define MTD_FAIL_ADDR_UNKNOWN -1LL
 
 struct mtd_info;
@@ -27,9 +33,18 @@ struct mtd_info;
  * or was not specific to any particular block.
  */
 struct erase_info {
+	struct mtd_info *mtd;
 	uint64_t addr;
 	uint64_t len;
 	uint64_t fail_addr;
+	u_long time;
+	u_long retries;
+	unsigned dev;
+	unsigned cell;
+	void (*callback) (struct erase_info *self);
+	u_long priv;
+	u_char state;
+	struct erase_info *next;
 };
 
 struct mtd_erase_region_info {
@@ -277,6 +292,10 @@ struct mtd_info {
 	int (*_point) (struct mtd_info *mtd, loff_t from, size_t len,
 		       size_t *retlen, void **virt, resource_size_t *phys);
 	int (*_unpoint) (struct mtd_info *mtd, loff_t from, size_t len);
+	unsigned long (*_get_unmapped_area) (struct mtd_info *mtd,
+					     unsigned long len,
+					     unsigned long offset,
+					     unsigned long flags);
 	int (*_read) (struct mtd_info *mtd, loff_t from, size_t len,
 		      size_t *retlen, u_char *buf);
 	int (*_write) (struct mtd_info *mtd, loff_t to, size_t len,
@@ -325,6 +344,8 @@ struct mtd_info {
 	 */
 	bool oops_panic_write;
 
+	struct backing_dev_info *backing_dev_info;
+
 	struct notifier_block reboot_notifier;  /* default mode before reboot */
 
 	/* ECC status information */
@@ -582,6 +603,8 @@ extern void register_mtd_user (struct mtd_notifier *new);
 extern int unregister_mtd_user (struct mtd_notifier *old);
 void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size);
 
+void mtd_erase_callback(struct erase_info *instr);
+
 static inline int mtd_is_bitflip(int err) {
 	return err == -EUCLEAN;
 }
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index fc0b4b19c..ace3a625b 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -26,6 +26,13 @@
 #define SNOR_MFR_SPANSION	CFI_MFR_AMD
 #define SNOR_MFR_SST		CFI_MFR_SST
 #define SNOR_MFR_WINBOND	0xef /* Also used by some Spansion */
+#define SNOR_MFR_ADESTO		0x1f /* Also used by some Spansion0 */
+#define SNOR_MFR_XMC		0x20
+#define SNOR_MFR_XTX		0x0b
+#define SNOR_MFR_PUYA		0x85
+#define SNOR_MFR_ZETTA		0xba
+#define SNOR_MFR_BOYA		0x68
+#define SNOR_MFR_FM             0xa1
 
 /*
  * Note on opcode nomenclature: some opcodes have a format like
@@ -62,6 +69,7 @@
 #define SPINOR_OP_RDID		0x9f	/* Read JEDEC ID */
 #define SPINOR_OP_RDSFDP	0x5a	/* Read SFDP */
 #define SPINOR_OP_RDCR		0x35	/* Read configuration register */
+#define SPINOR_OP_WRCR		0x31	/* Write configuration register */
 #define SPINOR_OP_RDFSR		0x70	/* Read flag status register */
 #define SPINOR_OP_CLFSR		0x50	/* Clear flag status register */
 #define SPINOR_OP_RDEAR		0xc8	/* Read Extended Address Register */
@@ -146,6 +154,7 @@
 
 /* Configuration Register bits. */
 #define CR_QUAD_EN_SPAN		BIT(1)	/* Spansion Quad I/O */
+#define CR_QUAD_EN_GD		BIT(1)  /* Gd Quad I/O */
 
 /* Status Register 2 bits. */
 #define SR2_QUAD_EN_BIT7	BIT(7)
@@ -395,6 +404,7 @@ struct spi_nor_hwcaps {
 #define SNOR_HWCAPS_PP_8_8_8	BIT(22)
 
 #define SNOR_HWCAPS_X_X_X	(SNOR_HWCAPS_READ_2_2_2 |	\
+				 SNOR_HWCAPS_READ_1_4_4 |	\
 				 SNOR_HWCAPS_READ_4_4_4 |	\
 				 SNOR_HWCAPS_READ_8_8_8 |	\
 				 SNOR_HWCAPS_PP_4_4_4 |		\
diff --git a/include/linux/net.h b/include/linux/net.h
index 9cafb5f35..1d73cfc53 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -21,6 +21,7 @@
 #include <linux/rcupdate.h>
 #include <linux/once.h>
 #include <linux/fs.h>
+#include <linux/android_kabi.h>
 
 #include <uapi/linux/net.h>
 
@@ -202,6 +203,11 @@ struct proto_ops {
 	int		(*sendmsg_locked)(struct sock *sk, struct msghdr *msg,
 					  size_t size);
 	int		(*set_rcvlowat)(struct sock *sk, int val);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 #define DECLARE_SOCKADDR(type, dst, src)	\
@@ -263,7 +269,8 @@ do {								\
 	net_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)
 #define net_info_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 #define net_dbg_ratelimited(fmt, ...)					\
 do {									\
 	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\
diff --git a/include/linux/netdev_features.h b/include/linux/netdev_features.h
index 4b19c544c..34d050bb1 100644
--- a/include/linux/netdev_features.h
+++ b/include/linux/netdev_features.h
@@ -53,8 +53,9 @@ enum {
 	NETIF_F_GSO_ESP_BIT,		/* ... ESP with TSO */
 	NETIF_F_GSO_UDP_BIT,		/* ... UFO, deprecated except tuntap */
 	NETIF_F_GSO_UDP_L4_BIT,		/* ... UDP payload GSO (not UFO) */
+	NETIF_F_GSO_FRAGLIST_BIT,		/* ... Fraglist GSO */
 	/**/NETIF_F_GSO_LAST =		/* last bit, see GSO_MASK */
-		NETIF_F_GSO_UDP_L4_BIT,
+		NETIF_F_GSO_FRAGLIST_BIT,
 
 	NETIF_F_FCOE_CRC_BIT,		/* FCoE CRC32 */
 	NETIF_F_SCTP_CRC_BIT,		/* SCTP checksum offload */
@@ -80,6 +81,7 @@ enum {
 
 	NETIF_F_GRO_HW_BIT,		/* Hardware Generic receive offload */
 	NETIF_F_HW_TLS_RECORD_BIT,	/* Offload TLS record */
+	NETIF_F_GRO_FRAGLIST_BIT,	/* Fraglist GRO */
 
 	/*
 	 * Add your fresh new feature above and remember to update
@@ -150,6 +152,8 @@ enum {
 #define NETIF_F_GSO_UDP_L4	__NETIF_F(GSO_UDP_L4)
 #define NETIF_F_HW_TLS_TX	__NETIF_F(HW_TLS_TX)
 #define NETIF_F_HW_TLS_RX	__NETIF_F(HW_TLS_RX)
+#define NETIF_F_GRO_FRAGLIST	__NETIF_F(GRO_FRAGLIST)
+#define NETIF_F_GSO_FRAGLIST	__NETIF_F(GSO_FRAGLIST)
 
 /* Finds the next feature with the highest number of the range of start till 0.
  */
@@ -226,6 +230,9 @@ static inline int find_next_netdev_feature(u64 feature, unsigned long start)
 /* changeable features with no special hardware requirements */
 #define NETIF_F_SOFT_FEATURES	(NETIF_F_GSO | NETIF_F_GRO)
 
+/* Changeable features with no special hardware requirements that defaults to off. */
+#define NETIF_F_SOFT_FEATURES_OFF	NETIF_F_GRO_FRAGLIST
+
 #define NETIF_F_VLAN_FEATURES	(NETIF_F_HW_VLAN_CTAG_FILTER | \
 				 NETIF_F_HW_VLAN_CTAG_RX | \
 				 NETIF_F_HW_VLAN_CTAG_TX | \
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index ec3081ab0..97c1c5d54 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -48,6 +48,7 @@
 #include <uapi/linux/if_bonding.h>
 #include <uapi/linux/pkt_cls.h>
 #include <linux/hashtable.h>
+#include <linux/android_kabi.h>
 
 struct netpoll_info;
 struct device;
@@ -273,6 +274,9 @@ struct header_ops {
 				const unsigned char *haddr);
 	bool	(*validate)(const char *ll_header, unsigned int len);
 	__be16	(*parse_protocol)(const struct sk_buff *skb);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 /* These flag bits are private to the generic network queueing
@@ -340,6 +344,11 @@ struct napi_struct {
 	struct list_head	dev_list;
 	struct hlist_node	napi_hash_node;
 	unsigned int		napi_id;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 enum {
@@ -628,6 +637,11 @@ struct netdev_queue {
 #ifdef CONFIG_BQL
 	struct dql		dql;
 #endif
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } ____cacheline_aligned_in_smp;
 
 extern int sysctl_fb_tunnels_only_for_init_net;
@@ -746,6 +760,11 @@ struct netdev_rx_queue {
 #ifdef CONFIG_XDP_SOCKETS
 	struct xdp_umem                 *umem;
 #endif
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } ____cacheline_aligned_in_smp;
 
 /*
@@ -916,6 +935,11 @@ struct xfrmdev_ops {
 	bool	(*xdo_dev_offload_ok) (struct sk_buff *skb,
 				       struct xfrm_state *x);
 	void	(*xdo_dev_state_advance_esn) (struct xfrm_state *x);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 #endif
 
@@ -1442,6 +1466,15 @@ struct net_device_ops {
 	int			(*ndo_xsk_wakeup)(struct net_device *dev,
 						  u32 queue_id, u32 flags);
 	struct devlink_port *	(*ndo_get_devlink_port)(struct net_device *dev);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+	ANDROID_KABI_RESERVE(5);
+	ANDROID_KABI_RESERVE(6);
+	ANDROID_KABI_RESERVE(7);
+	ANDROID_KABI_RESERVE(8);
 };
 
 /**
@@ -2066,6 +2099,16 @@ struct net_device {
 	struct lock_class_key	addr_list_lock_key;
 	bool			proto_down;
 	unsigned		wol_enabled:1;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+	ANDROID_KABI_RESERVE(5);
+	ANDROID_KABI_RESERVE(6);
+	ANDROID_KABI_RESERVE(7);
+	ANDROID_KABI_RESERVE(8);
+
 };
 #define to_net_dev(d) container_of(d, struct net_device, dev)
 
@@ -2307,7 +2350,8 @@ struct napi_gro_cb {
 	/* Number of gro_receive callbacks this packet already went through */
 	u8 recursion_counter:4;
 
-	/* 1 bit hole */
+	/* GRO is done by frag_list pointer chaining. */
+	u8	is_flist:1;
 
 	/* used to support CHECKSUM_COMPLETE for tunneling protocols */
 	__wsum	csum;
@@ -2367,6 +2411,11 @@ struct packet_type {
 					    struct sock *sk);
 	void			*af_packet_priv;
 	struct list_head	list;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct offload_callbacks {
@@ -2657,6 +2706,7 @@ struct net_device *dev_get_by_napi_id(unsigned int napi_id);
 int netdev_get_name(struct net *net, char *name, int ifindex);
 int dev_restart(struct net_device *dev);
 int skb_gro_receive(struct sk_buff *p, struct sk_buff *skb);
+int skb_gro_receive_list(struct sk_buff *p, struct sk_buff *skb);
 
 static inline unsigned int skb_gro_offset(const struct sk_buff *skb)
 {
@@ -4524,6 +4574,7 @@ static inline bool net_gso_ok(netdev_features_t features, int gso_type)
 	BUILD_BUG_ON(SKB_GSO_ESP != (NETIF_F_GSO_ESP >> NETIF_F_GSO_SHIFT));
 	BUILD_BUG_ON(SKB_GSO_UDP != (NETIF_F_GSO_UDP >> NETIF_F_GSO_SHIFT));
 	BUILD_BUG_ON(SKB_GSO_UDP_L4 != (NETIF_F_GSO_UDP_L4 >> NETIF_F_GSO_SHIFT));
+	BUILD_BUG_ON(SKB_GSO_FRAGLIST != (NETIF_F_GSO_FRAGLIST >> NETIF_F_GSO_SHIFT));
 
 	return (features & feature) == feature;
 }
@@ -4753,7 +4804,8 @@ do {								\
 #define MODULE_ALIAS_NETDEV(device) \
 	MODULE_ALIAS("netdev-" device)
 
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 #define netdev_dbg(__dev, format, args...)			\
 do {								\
 	dynamic_netdev_dbg(__dev, format, ##args);		\
@@ -4823,7 +4875,8 @@ do {								\
 #define netif_info(priv, type, dev, fmt, args...)		\
 	netif_level(info, priv, type, dev, fmt, ##args)
 
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 #define netif_dbg(priv, type, netdev, format, args...)		\
 do {								\
 	if (netif_msg_##type(priv))				\
diff --git a/include/linux/netfilter/xt_quota2.h b/include/linux/netfilter/xt_quota2.h
new file mode 100644
index 000000000..a3918718c
--- /dev/null
+++ b/include/linux/netfilter/xt_quota2.h
@@ -0,0 +1,26 @@
+#ifndef _XT_QUOTA_H
+#define _XT_QUOTA_H
+#include <linux/types.h>
+
+enum xt_quota_flags {
+	XT_QUOTA_INVERT    = 1 << 0,
+	XT_QUOTA_GROW      = 1 << 1,
+	XT_QUOTA_PACKET    = 1 << 2,
+	XT_QUOTA_NO_CHANGE = 1 << 3,
+	XT_QUOTA_MASK      = 0x0F,
+};
+
+struct xt_quota_counter;
+
+struct xt_quota_mtinfo2 {
+	char name[15];
+	u_int8_t flags;
+
+	/* Comparison-invariant */
+	aligned_u64 quota;
+
+	/* Used internally by the kernel */
+	struct xt_quota_counter *master __attribute__((aligned(8)));
+};
+
+#endif /* _XT_QUOTA_H */
diff --git a/include/linux/of_address.h b/include/linux/of_address.h
index 30e40fb69..3ecc3fb71 100644
--- a/include/linux/of_address.h
+++ b/include/linux/of_address.h
@@ -12,6 +12,7 @@ struct of_pci_range_parser {
 	const __be32 *end;
 	int np;
 	int pna;
+	bool dma;
 };
 
 struct of_pci_range {
@@ -55,8 +56,6 @@ extern int of_pci_dma_range_parser_init(struct of_pci_range_parser *parser,
 extern struct of_pci_range *of_pci_range_parser_one(
 					struct of_pci_range_parser *parser,
 					struct of_pci_range *range);
-extern int of_dma_get_range(struct device_node *np, u64 *dma_addr,
-				u64 *paddr, u64 *size);
 extern bool of_dma_is_coherent(struct device_node *np);
 #else /* CONFIG_OF_ADDRESS */
 static inline void __iomem *of_io_request_and_map(struct device_node *device,
@@ -104,12 +103,6 @@ static inline struct of_pci_range *of_pci_range_parser_one(
 	return NULL;
 }
 
-static inline int of_dma_get_range(struct device_node *np, u64 *dma_addr,
-				u64 *paddr, u64 *size)
-{
-	return -ENODEV;
-}
-
 static inline bool of_dma_is_coherent(struct device_node *np)
 {
 	return false;
diff --git a/include/linux/of_fdt.h b/include/linux/of_fdt.h
index acf820e88..9bbd5c06c 100644
--- a/include/linux/of_fdt.h
+++ b/include/linux/of_fdt.h
@@ -58,6 +58,27 @@ extern int of_flat_dt_is_compatible(unsigned long node, const char *name);
 extern unsigned long of_get_flat_dt_root(void);
 extern uint32_t of_get_flat_dt_phandle(unsigned long node);
 
+/*
+ * early_init_dt_scan_chosen - scan the device tree for ramdisk and bootargs
+ *
+ * The boot arguments will be placed into the memory pointed to by @data.
+ * That memory should be COMMAND_LINE_SIZE big and initialized to be a valid
+ * (possibly empty) string.  Logic for what will be in @data after this
+ * function finishes:
+ *
+ * - CONFIG_CMDLINE_FORCE=true
+ *     CONFIG_CMDLINE
+ * - CONFIG_CMDLINE_EXTEND=true, @data is non-empty string
+ *     @data + dt bootargs (even if dt bootargs are empty)
+ * - CONFIG_CMDLINE_EXTEND=true, @data is empty string
+ *     CONFIG_CMDLINE + dt bootargs (even if dt bootargs are empty)
+ * - CMDLINE_FROM_BOOTLOADER=true, dt bootargs=non-empty:
+ *     dt bootargs
+ * - CMDLINE_FROM_BOOTLOADER=true, dt bootargs=empty, @data is non-empty string
+ *     @data is left unchanged
+ * - CMDLINE_FROM_BOOTLOADER=true, dt bootargs=empty, @data is empty string
+ *     CONFIG_CMDLINE (or "" if that's not defined)
+ */
 extern int early_init_dt_scan_chosen(unsigned long node, const char *uname,
 				     int depth, void *data);
 extern int early_init_dt_scan_memory(unsigned long node, const char *uname,
diff --git a/include/linux/oom.h b/include/linux/oom.h
index c696c265f..b9df34326 100644
--- a/include/linux/oom.h
+++ b/include/linux/oom.h
@@ -55,6 +55,7 @@ struct oom_control {
 };
 
 extern struct mutex oom_lock;
+extern struct mutex oom_adj_mutex;
 
 static inline void set_current_oom_origin(void)
 {
diff --git a/include/linux/parser.h b/include/linux/parser.h
index 12fc3482f..89e2b23fb 100644
--- a/include/linux/parser.h
+++ b/include/linux/parser.h
@@ -7,7 +7,8 @@
  * but could potentially be used anywhere else that simple option=arg
  * parsing is required.
  */
-
+#ifndef _LINUX_PARSER_H
+#define _LINUX_PARSER_H
 
 /* associates an integer enumerator with a pattern string. */
 struct match_token {
@@ -34,3 +35,5 @@ int match_hex(substring_t *, int *result);
 bool match_wildcard(const char *pattern, const char *str);
 size_t match_strlcpy(char *, const substring_t *, size_t);
 char *match_strdup(const substring_t *);
+
+#endif /* _LINUX_PARSER_H */
diff --git a/include/linux/pci.h b/include/linux/pci.h
index f39f22f9e..1bb6b7c17 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -41,6 +41,7 @@
 #include <uapi/linux/pci.h>
 
 #include <linux/pci_ids.h>
+#include <linux/android_kabi.h>
 
 /*
  * The PCI interface treats multi-function devices as independent
@@ -468,6 +469,11 @@ struct pci_dev {
 	char		*driver_override; /* Driver name to force a match */
 
 	unsigned long	priv_flags;	/* Private flags for the PCI driver */
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 static inline struct pci_dev *pci_physfn(struct pci_dev *dev)
@@ -601,6 +607,11 @@ struct pci_bus {
 	struct bin_attribute	*legacy_io;	/* Legacy I/O for this bus */
 	struct bin_attribute	*legacy_mem;	/* Legacy mem */
 	unsigned int		is_added:1;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 #define to_pci_bus(n)	container_of(n, struct pci_bus, dev)
@@ -838,6 +849,11 @@ struct pci_driver {
 	const struct attribute_group **groups;
 	struct device_driver	driver;
 	struct pci_dynids	dynids;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 #define	to_pci_driver(drv) container_of(drv, struct pci_driver, driver)
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 0ad57693f..99542a258 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2423,6 +2423,8 @@
 #define PCI_VENDOR_ID_LENOVO		0x17aa
 
 #define PCI_VENDOR_ID_QCOM		0x17cb
+#define PCIE_DEVICE_ID_QCOM_PCIE20	0x0106
+#define PCIE_DEVICE_ID_QCOM_PCIE30	0x0107
 
 #define PCI_VENDOR_ID_CDNS		0x17cd
 
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 68ccc5b19..4f77b22d4 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -56,6 +56,7 @@ struct perf_guest_info_callbacks {
 #include <linux/perf_regs.h>
 #include <linux/cgroup.h>
 #include <linux/refcount.h>
+#include <linux/security.h>
 #include <asm/local.h>
 
 struct perf_callchain_entry {
@@ -721,6 +722,9 @@ struct perf_event {
 	struct perf_cgroup		*cgrp; /* cgroup event is attach to */
 #endif
 
+#ifdef CONFIG_SECURITY
+	void *security;
+#endif
 	struct list_head		sb_list;
 #endif /* CONFIG_PERF_EVENTS */
 };
@@ -1241,19 +1245,41 @@ extern int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,
 int perf_event_max_stack_handler(struct ctl_table *table, int write,
 				 void __user *buffer, size_t *lenp, loff_t *ppos);
 
-static inline bool perf_paranoid_tracepoint_raw(void)
+/* Access to perf_event_open(2) syscall. */
+#define PERF_SECURITY_OPEN		0
+
+/* Finer grained perf_event_open(2) access control. */
+#define PERF_SECURITY_CPU		1
+#define PERF_SECURITY_KERNEL		2
+#define PERF_SECURITY_TRACEPOINT	3
+
+static inline int perf_is_paranoid(void)
 {
 	return sysctl_perf_event_paranoid > -1;
 }
 
-static inline bool perf_paranoid_cpu(void)
+static inline int perf_allow_kernel(struct perf_event_attr *attr)
 {
-	return sysctl_perf_event_paranoid > 0;
+	if (sysctl_perf_event_paranoid > 1 && !capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	return security_perf_event_open(attr, PERF_SECURITY_KERNEL);
 }
 
-static inline bool perf_paranoid_kernel(void)
+static inline int perf_allow_cpu(struct perf_event_attr *attr)
 {
-	return sysctl_perf_event_paranoid > 1;
+	if (sysctl_perf_event_paranoid > 0 && !capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	return security_perf_event_open(attr, PERF_SECURITY_CPU);
+}
+
+static inline int perf_allow_tracepoint(struct perf_event_attr *attr)
+{
+	if (sysctl_perf_event_paranoid > -1 && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	return security_perf_event_open(attr, PERF_SECURITY_TRACEPOINT);
 }
 
 extern void perf_event_init(void);
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 80750783b..2b3726ff9 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -21,6 +21,7 @@
 #include <linux/timer.h>
 #include <linux/workqueue.h>
 #include <linux/mod_devicetable.h>
+#include <linux/android_kabi.h>
 
 #include <linux/atomic.h>
 
@@ -442,6 +443,11 @@ struct phy_device {
 
 	void (*phy_link_change)(struct phy_device *, bool up, bool do_carrier);
 	void (*adjust_link)(struct net_device *dev);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 #define to_phy_device(d) container_of(to_mdio_device(d), \
 				      struct phy_device, mdio)
@@ -631,6 +637,10 @@ struct phy_driver {
 			    struct ethtool_tunable *tuna,
 			    const void *data);
 	int (*set_loopback)(struct phy_device *dev, bool enable);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+
 };
 #define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
 				      struct phy_driver, mdiodrv)
diff --git a/include/linux/pinctrl/pinctrl-sunxi.h b/include/linux/pinctrl/pinctrl-sunxi.h
new file mode 100644
index 000000000..e4ed069d9
--- /dev/null
+++ b/include/linux/pinctrl/pinctrl-sunxi.h
@@ -0,0 +1,32 @@
+/*
+ * include/linux/pinctrl/pinctrl-sunxi.h
+ *
+ * (C) Copyright 2015-2020
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Martin Wu <wuyan@allwinnertech.com>
+ *
+ * sunxi pinctrl apis
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __API_PINCTRL_SUNXI_H
+#define __API_PINCTRL_SUNXI_H
+
+#include <linux/pinctrl/pinconf-generic.h>
+
+/*
+ * PIN_CONFIG_PARAM_MAX - max available value of 'enum pin_config_param'.
+ * see include/linux/pinctrl/pinconf-generic.h
+ */
+#define PIN_CONFIG_PARAM_MAX    PIN_CONFIG_PERSIST_STATE
+enum sunxi_pin_config_param {
+	SUNXI_PINCFG_TYPE_FUNC = PIN_CONFIG_PARAM_MAX + 1,
+	SUNXI_PINCFG_TYPE_DAT,
+	SUNXI_PINCFG_TYPE_PUD,
+	SUNXI_PINCFG_TYPE_DRV,
+};
+#endif
diff --git a/include/linux/pm_qos.h b/include/linux/pm_qos.h
index 24a6263c9..19eafca56 100644
--- a/include/linux/pm_qos.h
+++ b/include/linux/pm_qos.h
@@ -34,6 +34,8 @@ enum pm_qos_flags_status {
 #define PM_QOS_RESUME_LATENCY_NO_CONSTRAINT	PM_QOS_LATENCY_ANY
 #define PM_QOS_RESUME_LATENCY_NO_CONSTRAINT_NS	PM_QOS_LATENCY_ANY_NS
 #define PM_QOS_LATENCY_TOLERANCE_DEFAULT_VALUE	0
+#define PM_QOS_MIN_FREQUENCY_DEFAULT_VALUE	0
+#define PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE	FREQ_QOS_MAX_DEFAULT_VALUE
 #define PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT	(-1)
 
 #define PM_QOS_FLAG_NO_POWER_OFF	(1 << 0)
@@ -49,21 +51,6 @@ struct pm_qos_flags_request {
 	s32 flags;	/* Do not change to 64 bit */
 };
 
-enum dev_pm_qos_req_type {
-	DEV_PM_QOS_RESUME_LATENCY = 1,
-	DEV_PM_QOS_LATENCY_TOLERANCE,
-	DEV_PM_QOS_FLAGS,
-};
-
-struct dev_pm_qos_request {
-	enum dev_pm_qos_req_type type;
-	union {
-		struct plist_node pnode;
-		struct pm_qos_flags_request flr;
-	} data;
-	struct device *dev;
-};
-
 enum pm_qos_type {
 	PM_QOS_UNITIALIZED,
 	PM_QOS_MAX,		/* return the largest value */
@@ -90,9 +77,51 @@ struct pm_qos_flags {
 	s32 effective_flags;	/* Do not change to 64 bit */
 };
 
+
+#define FREQ_QOS_MIN_DEFAULT_VALUE	0
+#define FREQ_QOS_MAX_DEFAULT_VALUE	S32_MAX
+
+enum freq_qos_req_type {
+	FREQ_QOS_MIN = 1,
+	FREQ_QOS_MAX,
+};
+
+struct freq_constraints {
+	struct pm_qos_constraints min_freq;
+	struct blocking_notifier_head min_freq_notifiers;
+	struct pm_qos_constraints max_freq;
+	struct blocking_notifier_head max_freq_notifiers;
+};
+
+struct freq_qos_request {
+	enum freq_qos_req_type type;
+	struct plist_node pnode;
+	struct freq_constraints *qos;
+};
+
+
+enum dev_pm_qos_req_type {
+	DEV_PM_QOS_RESUME_LATENCY = 1,
+	DEV_PM_QOS_LATENCY_TOLERANCE,
+	DEV_PM_QOS_MIN_FREQUENCY,
+	DEV_PM_QOS_MAX_FREQUENCY,
+	DEV_PM_QOS_FLAGS,
+};
+
+struct dev_pm_qos_request {
+	enum dev_pm_qos_req_type type;
+	union {
+		struct plist_node pnode;
+		struct pm_qos_flags_request flr;
+		struct freq_qos_request freq;
+	} data;
+	struct device *dev;
+};
+
 struct dev_pm_qos {
 	struct pm_qos_constraints resume_latency;
 	struct pm_qos_constraints latency_tolerance;
+	struct freq_constraints freq;
 	struct pm_qos_flags flags;
 	struct dev_pm_qos_request *resume_latency_req;
 	struct dev_pm_qos_request *latency_tolerance_req;
@@ -191,6 +220,10 @@ static inline s32 dev_pm_qos_read_value(struct device *dev,
 	switch (type) {
 	case DEV_PM_QOS_RESUME_LATENCY:
 		return PM_QOS_RESUME_LATENCY_NO_CONSTRAINT;
+	case DEV_PM_QOS_MIN_FREQUENCY:
+		return PM_QOS_MIN_FREQUENCY_DEFAULT_VALUE;
+	case DEV_PM_QOS_MAX_FREQUENCY:
+		return PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE;
 	default:
 		WARN_ON(1);
 		return 0;
@@ -255,27 +288,6 @@ static inline s32 dev_pm_qos_raw_resume_latency(struct device *dev)
 }
 #endif
 
-#define FREQ_QOS_MIN_DEFAULT_VALUE	0
-#define FREQ_QOS_MAX_DEFAULT_VALUE	S32_MAX
-
-enum freq_qos_req_type {
-	FREQ_QOS_MIN = 1,
-	FREQ_QOS_MAX,
-};
-
-struct freq_constraints {
-	struct pm_qos_constraints min_freq;
-	struct blocking_notifier_head min_freq_notifiers;
-	struct pm_qos_constraints max_freq;
-	struct blocking_notifier_head max_freq_notifiers;
-};
-
-struct freq_qos_request {
-	enum freq_qos_req_type type;
-	struct plist_node pnode;
-	struct freq_constraints *qos;
-};
-
 static inline int freq_qos_request_active(struct freq_qos_request *req)
 {
 	return !IS_ERR_OR_NULL(req->qos);
@@ -291,6 +303,8 @@ int freq_qos_add_request(struct freq_constraints *qos,
 			 enum freq_qos_req_type type, s32 value);
 int freq_qos_update_request(struct freq_qos_request *req, s32 new_value);
 int freq_qos_remove_request(struct freq_qos_request *req);
+int freq_qos_apply(struct freq_qos_request *req,
+		   enum pm_qos_req_action action, s32 value);
 
 int freq_qos_add_notifier(struct freq_constraints *qos,
 			  enum freq_qos_req_type type,
diff --git a/include/linux/pmic.h b/include/linux/pmic.h
new file mode 100644
index 000000000..565f48191
--- /dev/null
+++ b/include/linux/pmic.h
@@ -0,0 +1,185 @@
+/*
+ * PMIC management for epaper power control HAL
+ *
+ *      Copyright (C) 2009 Dimitar Dimitrov, MM Solutions
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ */
+
+#ifndef PMIC_H
+#define PMIC_H
+
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/workqueue.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+
+
+struct pmic_sess;
+
+#define PMIC_DEFAULT_DWELL_TIME_MS	1111
+#define PMIC_DEFAULT_VCOMOFF_TIME_MS	20
+#define PMIC_DEFAULT_V3P3OFF_TIME_MS	-1
+
+#if defined(FB_OMAP3EP_PAPYRUS_PM_VZERO)
+  #define PAPYRUS_STANDBY_DWELL_TIME	4 /*sec*/
+#else
+  #define PAPYRUS_STANDBY_DWELL_TIME	0
+#endif
+
+#define	SEQ_VDD(index)		((index % 4) << 6)
+#define SEQ_VPOS(index)		((index % 4) << 4)
+#define SEQ_VEE(index)		((index % 4) << 2)
+#define SEQ_VNEG(index)		((index % 4) << 0)
+
+/* power up seq delay time */
+#define UDLY_3ms(index)		(0x00 << ((index%4) * 2))
+#define UDLY_6ms(index)		(0x01 << ((index%4) * 2))
+#define UDLY_9ms(index)		(0x10 << ((index%4) * 2))
+#define UDLY_12ms(index)	(0x11 << ((index%4) * 2))
+
+/* power down seq delay time */
+#define DDLY_6ms(index)		(0x00 << ((index%4) * 2))
+#define DDLY_12ms(index)	(0x01 << ((index%4) * 2))
+#define DDLY_24ms(index)	(0x10 << ((index%4) * 2))
+#define DDLY_48ms(index)	(0x11 << ((index%4) * 2))
+
+
+#define NUMBER_PMIC_REGS	10
+
+struct pmic_driver {
+	const char *id;
+
+	int vcom_min;
+	int vcom_max;
+	int vcom_step;
+
+	int (*hw_read_temperature)(struct pmic_sess *sess, int *t);
+	bool (*hw_power_ack)(struct pmic_sess *sess);
+	void (*hw_power_req)(struct pmic_sess *sess, bool up);
+
+	int (*set_enable)(struct pmic_sess *sess, int enable);
+	int (*set_vcom_voltage)(struct pmic_sess *sess, int vcom_mv);
+	int (*set_vcom1)(struct pmic_sess *sess, uint8_t vcom1);
+	int (*set_vcom2)(struct pmic_sess *sess, uint8_t vcom2);
+	int (*set_vadj)(struct pmic_sess *sess, uint8_t vadj);
+	int (*set_int_en1)(struct pmic_sess *sess, uint8_t int_en1);
+	int (*set_int_en2)(struct pmic_sess *sess, uint8_t int_en2);
+	int (*set_upseq0)(struct pmic_sess *sess, uint8_t upseq0);
+	int (*set_upseq1)(struct pmic_sess *sess, uint8_t upseq1);
+	int (*set_dwnseq0)(struct pmic_sess *sess, uint8_t dwnseq0);
+	int (*set_dwnseq1)(struct pmic_sess *sess, uint8_t dwnseq1);
+	int (*set_tmst1)(struct pmic_sess *sess, uint8_t tmst1);
+	int (*set_tmst2)(struct pmic_sess *sess, uint8_t tmst2);
+
+	int (*set_vp_adjust)(struct pmic_sess *sess, uint8_t vp_adjust);
+	int (*set_vn_adjust)(struct pmic_sess *sess, uint8_t vn_adjust);
+	int (*set_vcom_adjust)(struct pmic_sess *sess, uint8_t vcom_adjust);
+	int (*set_pwr_seq0)(struct pmic_sess *sess, uint8_t pwr_seq0);
+	int (*set_pwr_seq1)(struct pmic_sess *sess, uint8_t pwr_seq1);
+	int (*set_pwr_seq2)(struct pmic_sess *sess, uint8_t pwr_seq2);
+	int (*set_tmst_config)(struct pmic_sess *sess, uint8_t tmst_config);
+	int (*set_tmst_os)(struct pmic_sess *sess, uint8_t tmst_os);
+	int (*set_tmst_hyst)(struct pmic_sess *sess, uint8_t tmst_hyst);
+
+	int (*hw_vcom_switch)(struct pmic_sess *sess, bool state);
+
+	int (*hw_set_dvcom)(struct pmic_sess *sess, int state);
+
+//	int (*hw_init)(struct pmic_sess *pmsess, struct pmic_config *config, struct i2c_client *client);
+	void (*hw_cleanup)(struct pmic_sess *sess);
+
+	bool (*hw_standby_dwell_time_ready)(struct pmic_sess *sess);
+	int (*hw_pm_sleep)(struct pmic_sess *sess);
+	int (*hw_pm_resume)(struct pmic_sess *sess);
+
+
+};
+
+typedef enum {
+	MASTER_PMIC_ID = 0,
+	SLAVE_PMIC_ID = 1,
+	MAX_PMIC_NUM = 2
+} PMIC_ID;
+
+
+struct pmic_sess {
+	PMIC_ID id;
+	bool powered;
+	struct delayed_work powerdown_work;
+	unsigned int dwell_time_ms;
+	struct delayed_work vcomoff_work;
+	unsigned int vcomoff_time_ms;
+	int v3p3off_time_ms;
+	const struct pmic_driver *drv;
+	void *drvpar;
+	int temp_man_offset;
+	int revision;
+	int is_inited;
+};
+
+struct pmic_config {
+	u32 used_flag;
+	char name[64];
+	u32 twi_id;
+	u32 twi_addr;
+	struct device *dev;
+	struct gpio_config wake_up_pin;
+	struct gpio_config vcom_ctl_pin;
+	struct gpio_config power_up_pin;
+	struct gpio_config power_good_pin;
+	struct gpio_config int_pin;
+	char pmic_power_name[64];
+};
+
+struct pmic_mgr {
+	struct pmic_config config[MAX_PMIC_NUM];
+	struct pmic_sess sess[MAX_PMIC_NUM];
+};
+
+extern int pmic_probe(struct pmic_sess **sess, const char *id,
+					unsigned int dwell_time_ms,
+					unsigned int vcomoff_time_ms,
+					int v3p3_time_ms);
+
+extern void pmic_remove(struct pmic_sess **sess);
+
+extern int pmic_set_registers_papyrus_1(struct pmic_sess *sess, uint8_t *vals);
+extern int pmic_set_registers_papyrus_2(struct pmic_sess *sess, uint8_t *vals);
+/*
+ * Set VCOM voltage, in millivolts.
+ * NB! Change will take effect with the next pmic power up!
+ */
+extern int pmic_set_vcom_voltage(struct pmic_sess *sess, int vcom_mv);
+
+/*Runtame Change VCOM state */
+extern int pmic_set_dvcom(struct pmic_sess *sess, int state);
+
+/* Request asynchronous power up. */
+extern int pmic_req_powerup(struct pmic_sess *sess);
+
+/* Ensure that power is OK. Called after a pmic_req_powerup(). */
+extern int pmic_sync_powerup(struct pmic_sess *sess);
+
+/* Get pmic temperature sensor measurement. */
+extern int pmic_get_temperature(struct pmic_sess *sess, int *t);
+
+/*
+ * Asynchronously release the power up requirement. Power may go down
+ * up to a few seconds after this call in order to avoid power up/down
+ * cycles with frequent screen updates.
+ */
+extern void pmic_release_powerup_req(struct pmic_sess *sess);
+
+/* Get that enough delay between standby and sleep*/
+extern bool pmic_standby_dwell_time_ready(struct pmic_sess *sess);
+
+extern void pmic_pm_sleep(struct pmic_sess *sess);
+
+extern void pmic_pm_resume(struct pmic_sess *sess);
+#endif	/* PMIC_H */
diff --git a/include/linux/power/charger-manager.h b/include/linux/power/charger-manager.h
index ad19e68e1..ae94dcebd 100644
--- a/include/linux/power/charger-manager.h
+++ b/include/linux/power/charger-manager.h
@@ -248,7 +248,7 @@ struct charger_manager {
 	u64 charging_end_time;
 };
 
-#ifdef CONFIG_CHARGER_MANAGER
+#if IS_ENABLED(CONFIG_CHARGER_MANAGER)
 extern void cm_notify_event(struct power_supply *psy,
 				enum cm_event_types type, char *msg);
 #else
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
index 28413f737..28f503e50 100644
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -61,6 +61,10 @@ enum {
 	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE,
 	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE,
 	POWER_SUPPLY_HEALTH_OVERCURRENT,
+	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED,
+	POWER_SUPPLY_HEALTH_WARM,
+	POWER_SUPPLY_HEALTH_COOL,
+	POWER_SUPPLY_HEALTH_HOT,
 };
 
 enum {
@@ -139,6 +143,7 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_CAPACITY, /* in percents! */
 	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN, /* in percents! */
 	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX, /* in percents! */
+	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN, /* in percents! */
 	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
 	POWER_SUPPLY_PROP_TEMP,
 	POWER_SUPPLY_PROP_TEMP_MAX,
@@ -158,10 +163,17 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_PRECHARGE_CURRENT,
 	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,
 	POWER_SUPPLY_PROP_CALIBRATE,
+	POWER_SUPPLY_PROP_MANUFACTURE_YEAR,
+	POWER_SUPPLY_PROP_MANUFACTURE_MONTH,
+	POWER_SUPPLY_PROP_MANUFACTURE_DAY,
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+	POWER_SUPPLY_PROP_QUICK_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_TX_ADAPTER,
+	POWER_SUPPLY_PROP_SIGNAL_STRENGTH,
+	POWER_SUPPLY_PROP_REVERSE_CHG_MODE,
 };
 
 enum power_supply_type {
@@ -177,6 +189,11 @@ enum power_supply_type {
 	POWER_SUPPLY_TYPE_USB_PD,		/* Power Delivery Port */
 	POWER_SUPPLY_TYPE_USB_PD_DRP,		/* PD Dual Role Port */
 	POWER_SUPPLY_TYPE_APPLE_BRICK_ID,	/* Apple Charging Method */
+	POWER_SUPPLY_TYPE_WIRELESS,		/* Wireless */
+	POWER_SUPPLY_TYPE_USB_HVDCP,		/* High Voltage DCP */
+	POWER_SUPPLY_TYPE_USB_HVDCP_3,		/* Efficient High Voltage DCP */
+	POWER_SUPPLY_TYPE_USB_HVDCP_3P5,	/* Efficient High Voltage DCP */
+	POWER_SUPPLY_TYPE_USB_FLOAT,		/* Floating charger */
 };
 
 enum power_supply_usb_type {
@@ -192,6 +209,33 @@ enum power_supply_usb_type {
 	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID,	/* Apple Charging Method */
 };
 
+enum power_supply_quick_charge_type {
+	QUICK_CHARGE_NORMAL = 0,		/* Charging Power <= 10W */
+	QUICK_CHARGE_FAST,			/* 10W < Charging Power <= 20W */
+	QUICK_CHARGE_FLASH,			/* 20W < Charging Power <= 30W */
+	QUICK_CHARGE_TURBE,			/* 30W < Charging Power <= 50W */
+	QUICK_CHARGE_SUPER,			/* Charging Power > 50W */
+	QUICK_CHARGE_MAX,
+};
+
+enum power_supply_tx_adapter_type {
+	ADAPTER_NONE = 0,			/* Nothing Attached */
+	ADAPTER_SDP,				/* Standard Downstream Port */
+	ADAPTER_CDP,				/* Charging Downstream Port */
+	ADAPTER_DCP,				/* Dedicated Charging Port */
+	ADAPTER_OCP,				/* Other Charging Port */
+	ADAPTER_QC2,				/* Qualcomm Charge 2.0 */
+	ADAPTER_QC3,				/* Qualcomm Charge 3.0 */
+	ADAPTER_PD,				/* Power Delivery Port */
+	ADAPTER_AUTH_FAILED,			/* Authenticated Failed Adapter */
+	ADAPTER_PRIVATE_QC3,			/* Qualcomm Charge 3.0 with Private Protocol */
+	ADAPTER_PRIVATE_PD,			/* PD Adapter with Private Protocol */
+	ADAPTER_CAR_POWER,			/* Wireless Car Charger */
+	ADAPTER_PRIVATE_PD_40W,			/* 40W PD Adapter with Private Protocol */
+	ADAPTER_VOICE_BOX,			/* Voice Box which Support Wireless Charger */
+	ADAPTER_PRIVATE_PD_50W,			/* 50W PD Adapter with Private Protocol */
+};
+
 enum power_supply_notifier_events {
 	PSY_EVENT_PROP_CHANGED,
 };
@@ -325,6 +369,11 @@ struct power_supply_battery_ocv_table {
 	int capacity;	/* percent */
 };
 
+struct power_supply_resistance_temp_table {
+	int temp;	/* celsius */
+	int resistance;	/* internal resistance percent */
+};
+
 #define POWER_SUPPLY_OCV_TEMP_MAX 20
 
 /*
@@ -349,6 +398,8 @@ struct power_supply_battery_info {
 	int ocv_temp[POWER_SUPPLY_OCV_TEMP_MAX];/* celsius */
 	struct power_supply_battery_ocv_table *ocv_table[POWER_SUPPLY_OCV_TEMP_MAX];
 	int ocv_table_size[POWER_SUPPLY_OCV_TEMP_MAX];
+	struct power_supply_resistance_temp_table *resist_table;
+	int resist_table_size;
 };
 
 extern struct atomic_notifier_head power_supply_notifier;
@@ -381,6 +432,9 @@ power_supply_find_ocv2cap_table(struct power_supply_battery_info *info,
 				int temp, int *table_len);
 extern int power_supply_batinfo_ocv2cap(struct power_supply_battery_info *info,
 					int ocv, int temp);
+extern int
+power_supply_temp2resist_simple(struct power_supply_resistance_temp_table *table,
+				int table_len, int temp);
 extern void power_supply_changed(struct power_supply *psy);
 extern int power_supply_am_i_supplied(struct power_supply *psy);
 extern int power_supply_set_input_current_limit_from_supplier(
diff --git a/include/linux/printk.h b/include/linux/printk.h
index 3b5cb66d8..2efa60209 100644
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -286,8 +286,9 @@ extern int kptr_restrict;
 /*
  * These can be used to print at the various log levels.
  * All of these will print unconditionally, although note that pr_debug()
- * and other debug macros are compiled out unless either DEBUG is defined
- * or CONFIG_DYNAMIC_DEBUG is set.
+ * and other debug macros are compiled out unless either DEBUG is defined,
+ * CONFIG_DYNAMIC_DEBUG is set, or CONFIG_DYNAMIC_DEBUG_CORE is set when
+ * DYNAMIC_DEBUG_MODULE being defined for any modules.
  */
 #define pr_emerg(fmt, ...) \
 	printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)
@@ -323,7 +324,8 @@ extern int kptr_restrict;
 
 
 /* If you are writing a driver, please use dev_dbg instead */
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 #include <linux/dynamic_debug.h>
 
 /* dynamic_pr_debug() uses pr_fmt() internally so we don't need it here */
@@ -449,7 +451,8 @@ extern int kptr_restrict;
 #endif
 
 /* If you are writing a driver, please use dev_dbg instead */
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 /* descriptor check is first to prevent flooding with "callbacks suppressed" */
 #define pr_debug_ratelimited(fmt, ...)					\
 do {									\
@@ -496,7 +499,8 @@ static inline void print_hex_dump_bytes(const char *prefix_str, int prefix_type,
 
 #endif
 
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 #define print_hex_dump_debug(prefix_str, prefix_type, rowsize,	\
 			     groupsize, buf, len, ascii)	\
 	dynamic_hex_dump(prefix_str, prefix_type, rowsize,	\
diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index b2c9c4609..af59e3c17 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -39,7 +39,7 @@ enum pwm_polarity {
  * current PWM hardware state.
  */
 struct pwm_args {
-	unsigned int period;
+	u64 period;
 	enum pwm_polarity polarity;
 };
 
@@ -48,6 +48,17 @@ enum {
 	PWMF_EXPORTED = 1 << 1,
 };
 
+/**
+ * enum pwm_output_type - output type of the PWM signal
+ * @PWM_OUTPUT_FIXED: PWM output is fixed until a change request
+ * @PWM_OUTPUT_MODULATED: PWM output is modulated in hardware
+ * autonomously with a predefined pattern
+ */
+enum pwm_output_type {
+	PWM_OUTPUT_FIXED = 1 << 0,
+	PWM_OUTPUT_MODULATED = 1 << 1,
+};
+
 /*
  * struct pwm_state - state of a PWM channel
  * @period: PWM period (in nanoseconds)
@@ -56,9 +67,10 @@ enum {
  * @enabled: PWM enabled status
  */
 struct pwm_state {
-	unsigned int period;
-	unsigned int duty_cycle;
+	u64 period;
+	u64 duty_cycle;
 	enum pwm_polarity polarity;
+	enum pwm_output_type output_type;
 	bool enabled;
 };
 
@@ -105,13 +117,13 @@ static inline bool pwm_is_enabled(const struct pwm_device *pwm)
 	return state.enabled;
 }
 
-static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)
+static inline void pwm_set_period(struct pwm_device *pwm, u64 period)
 {
 	if (pwm)
 		pwm->state.period = period;
 }
 
-static inline unsigned int pwm_get_period(const struct pwm_device *pwm)
+static inline u64 pwm_get_period(const struct pwm_device *pwm)
 {
 	struct pwm_state state;
 
@@ -126,7 +138,7 @@ static inline void pwm_set_duty_cycle(struct pwm_device *pwm, unsigned int duty)
 		pwm->state.duty_cycle = duty;
 }
 
-static inline unsigned int pwm_get_duty_cycle(const struct pwm_device *pwm)
+static inline u64 pwm_get_duty_cycle(const struct pwm_device *pwm)
 {
 	struct pwm_state state;
 
@@ -144,6 +156,16 @@ static inline enum pwm_polarity pwm_get_polarity(const struct pwm_device *pwm)
 	return state.polarity;
 }
 
+static inline enum pwm_output_type pwm_get_output_type(
+		const struct pwm_device *pwm)
+{
+	struct pwm_state state;
+
+	pwm_get_state(pwm, &state);
+
+	return state.output_type;
+}
+
 static inline void pwm_get_args(const struct pwm_device *pwm,
 				struct pwm_args *args)
 {
@@ -250,6 +272,7 @@ pwm_set_relative_duty_cycle(struct pwm_state *state, unsigned int duty_cycle,
  * @get_state: get the current PWM state. This function is only
  *	       called once per PWM device when the PWM chip is
  *	       registered.
+ * @get_output_type_supported: get the supported output type of this PWM
  * @owner: helps prevent removal of modules exporting active PWMs
  * @config: configure duty cycles and period length for this PWM
  * @set_polarity: configure the polarity of this PWM
@@ -265,6 +288,8 @@ struct pwm_ops {
 		     const struct pwm_state *state);
 	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
 			  struct pwm_state *state);
+	int (*get_output_type_supported)(struct pwm_chip *chip,
+			struct pwm_device *pwm);
 	struct module *owner;
 
 	/* Only used by legacy drivers */
@@ -308,8 +333,8 @@ struct pwm_chip {
  * @duty_cycle: duty cycle of the PWM signal (in nanoseconds)
  */
 struct pwm_capture {
-	unsigned int period;
-	unsigned int duty_cycle;
+	u64 period;
+	u64 duty_cycle;
 };
 
 #if IS_ENABLED(CONFIG_PWM)
@@ -319,6 +344,24 @@ void pwm_free(struct pwm_device *pwm);
 int pwm_apply_state(struct pwm_device *pwm, const struct pwm_state *state);
 int pwm_adjust_config(struct pwm_device *pwm);
 
+/**
+ * pwm_get_output_type_supported() - obtain output type of a PWM device.
+ * @pwm: PWM device
+ *
+ * Returns:  output type supported by the PWM device
+ */
+static inline int pwm_get_output_type_supported(struct pwm_device *pwm)
+{
+	if (!pwm)
+		return -EINVAL;
+
+	if (pwm->chip->ops->get_output_type_supported)
+		return pwm->chip->ops->get_output_type_supported(pwm->chip,
+				pwm);
+
+	return PWM_OUTPUT_FIXED;
+}
+
 /**
  * pwm_config() - change a PWM device configuration
  * @pwm: PWM device
@@ -437,6 +480,11 @@ static inline int pwm_adjust_config(struct pwm_device *pwm)
 	return -ENOTSUPP;
 }
 
+static inline int pwm_get_output_type_supported(struct pwm_device *pwm)
+{
+	return -EINVAL;
+}
+
 static inline int pwm_config(struct pwm_device *pwm, int duty_ns,
 			     int period_ns)
 {
diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 2d5eff506..ffd72b3b1 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -58,6 +58,7 @@ extern int qcom_scm_set_remote_state(u32 state, u32 id);
 extern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);
 extern int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size);
 extern int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare);
+extern int qcom_scm_qsmmu500_wait_safe_toggle(bool en);
 extern int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val);
 extern int qcom_scm_io_writel(phys_addr_t addr, unsigned int val);
 #else
@@ -97,6 +98,7 @@ qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
 static inline int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare) { return -ENODEV; }
 static inline int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size) { return -ENODEV; }
 static inline int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare) { return -ENODEV; }
+static inline int qcom_scm_qsmmu500_wait_safe_toggle(bool en) { return -ENODEV; }
 static inline int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val) { return -ENODEV; }
 static inline int qcom_scm_io_writel(phys_addr_t addr, unsigned int val) { return -ENODEV; }
 #endif
diff --git a/include/linux/quota.h b/include/linux/quota.h
index 27aab84fc..3088ac929 100644
--- a/include/linux/quota.h
+++ b/include/linux/quota.h
@@ -316,6 +316,9 @@ struct quota_format_ops {
 	int (*commit_dqblk)(struct dquot *dquot);	/* Write structure for one user */
 	int (*release_dqblk)(struct dquot *dquot);	/* Called when last reference to dquot is being dropped */
 	int (*get_next_id)(struct super_block *sb, struct kqid *qid);	/* Get next ID with existing structure in the quota file */
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 /* Operations working with dquots */
@@ -335,6 +338,9 @@ struct dquot_operations {
 	int (*get_inode_usage) (struct inode *, qsize_t *);
 	/* Get next ID with active quota structure */
 	int (*get_next_id) (struct super_block *sb, struct kqid *qid);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 struct path;
@@ -438,6 +444,9 @@ struct quotactl_ops {
 	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
 	int (*get_state)(struct super_block *, struct qc_state *);
 	int (*rm_xquota)(struct super_block *, unsigned int);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 struct quota_format_type {
diff --git a/include/linux/random.h b/include/linux/random.h
index 5b3ec7d27..0efabaaf1 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -118,29 +118,21 @@ unsigned long randomize_page(unsigned long start, unsigned long range);
 #ifdef CONFIG_ARCH_RANDOM
 # include <asm/archrandom.h>
 #else
-static inline bool arch_get_random_long(unsigned long *v)
+static inline bool __must_check arch_get_random_long(unsigned long *v)
 {
-	return 0;
+	return false;
 }
-static inline bool arch_get_random_int(unsigned int *v)
+static inline bool __must_check arch_get_random_int(unsigned int *v)
 {
-	return 0;
+	return false;
 }
-static inline bool arch_has_random(void)
+static inline bool __must_check arch_get_random_seed_long(unsigned long *v)
 {
-	return 0;
+	return false;
 }
-static inline bool arch_get_random_seed_long(unsigned long *v)
+static inline bool __must_check arch_get_random_seed_int(unsigned int *v)
 {
-	return 0;
-}
-static inline bool arch_get_random_seed_int(unsigned int *v)
-{
-	return 0;
-}
-static inline bool arch_has_random_seed(void)
-{
-	return 0;
+	return false;
 }
 #endif
 
diff --git a/include/linux/rpmsg.h b/include/linux/rpmsg.h
index 9fe156d1c..c4dbb4708 100644
--- a/include/linux/rpmsg.h
+++ b/include/linux/rpmsg.h
@@ -2,6 +2,7 @@
 /*
  * Remote processor messaging
  *
+ * Copyright (c) 2018 The Linux Foundation.
  * Copyright (C) 2011 Texas Instruments, Inc.
  * Copyright (C) 2011 Google, Inc.
  * All rights reserved.
@@ -60,6 +61,7 @@ struct rpmsg_device {
 };
 
 typedef int (*rpmsg_rx_cb_t)(struct rpmsg_device *, void *, int, void *, u32);
+typedef int (*rpmsg_rx_sig_t)(struct rpmsg_device *, void *, u32, u32);
 
 /**
  * struct rpmsg_endpoint - binds a local rpmsg address to its user
@@ -67,6 +69,7 @@ typedef int (*rpmsg_rx_cb_t)(struct rpmsg_device *, void *, int, void *, u32);
  * @refcount: when this drops to zero, the ept is deallocated
  * @cb: rx callback handler
  * @cb_lock: must be taken before accessing/changing @cb
+ * @sig_cb: rx serial signal handler
  * @addr: local rpmsg address
  * @priv: private data for the driver's use
  *
@@ -89,6 +92,7 @@ struct rpmsg_endpoint {
 	struct kref refcount;
 	rpmsg_rx_cb_t cb;
 	struct mutex cb_lock;
+	rpmsg_rx_sig_t sig_cb;
 	u32 addr;
 	void *priv;
 
@@ -102,6 +106,7 @@ struct rpmsg_endpoint {
  * @probe: invoked when a matching rpmsg channel (i.e. device) is found
  * @remove: invoked when the rpmsg channel is removed
  * @callback: invoked when an inbound message is received on the channel
+ * @signals: invoked when a serial signal change is received on the channel
  */
 struct rpmsg_driver {
 	struct device_driver drv;
@@ -109,6 +114,8 @@ struct rpmsg_driver {
 	int (*probe)(struct rpmsg_device *dev);
 	void (*remove)(struct rpmsg_device *dev);
 	int (*callback)(struct rpmsg_device *, void *, int, void *, u32);
+	int (*signals)(struct rpmsg_device *rpdev,
+		       void *priv, u32 old, u32 new);
 };
 
 #if IS_ENABLED(CONFIG_RPMSG)
@@ -135,6 +142,9 @@ int rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst,
 __poll_t rpmsg_poll(struct rpmsg_endpoint *ept, struct file *filp,
 			poll_table *wait);
 
+int rpmsg_get_signals(struct rpmsg_endpoint *ept);
+int rpmsg_set_signals(struct rpmsg_endpoint *ept, u32 set, u32 clear);
+
 #else
 
 static inline int register_rpmsg_device(struct rpmsg_device *dev)
@@ -242,6 +252,23 @@ static inline __poll_t rpmsg_poll(struct rpmsg_endpoint *ept,
 	return 0;
 }
 
+static inline int rpmsg_get_signals(struct rpmsg_endpoint *ept)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return -ENXIO;
+}
+
+static inline int rpmsg_set_signals(struct rpmsg_endpoint *ept,
+				    u32 set, u32 clear)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return -ENXIO;
+}
+
 #endif /* IS_ENABLED(CONFIG_RPMSG) */
 
 /* use a macro to avoid include chaining to get THIS_MODULE */
diff --git a/include/linux/rwsem.h b/include/linux/rwsem.h
index 00d605468..cf27ef69c 100644
--- a/include/linux/rwsem.h
+++ b/include/linux/rwsem.h
@@ -19,6 +19,7 @@
 #ifdef CONFIG_RWSEM_SPIN_ON_OWNER
 #include <linux/osq_lock.h>
 #endif
+#include <linux/android_vendor.h>
 
 /*
  * For an uncontended rwsem, count and owner are the only fields a task
@@ -51,6 +52,7 @@ struct rw_semaphore {
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	dep_map;
 #endif
+	ANDROID_VENDOR_DATA(1);
 };
 
 /*
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 5710b80f8..54a511a71 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -31,6 +31,8 @@
 #include <linux/task_io_accounting.h>
 #include <linux/posix-timers.h>
 #include <linux/rseq.h>
+#include <linux/android_kabi.h>
+#include <linux/android_vendor.h>
 
 /* task_struct member predeclarations (sorted alphabetically): */
 struct audit_context;
@@ -476,6 +478,11 @@ struct sched_entity {
 	 */
 	struct sched_avg		avg;
 #endif
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct sched_rt_entity {
@@ -494,6 +501,11 @@ struct sched_rt_entity {
 	/* rq "owned" by this entity/group: */
 	struct rt_rq			*my_q;
 #endif
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } __randomize_layout;
 
 struct sched_dl_entity {
@@ -841,6 +853,10 @@ struct task_struct {
 	u64				stimescaled;
 #endif
 	u64				gtime;
+#ifdef CONFIG_CPU_FREQ_TIMES
+	u64				*time_in_state;
+	unsigned int			max_state;
+#endif
 	struct prev_cputime		prev_cputime;
 #ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
 	struct vtime			vtime;
@@ -1205,6 +1221,8 @@ struct task_struct {
 #endif /* CONFIG_TRACING */
 
 #ifdef CONFIG_KCOV
+	/* See kernel/kcov.c for more details. */
+
 	/* Coverage collection mode enabled for this task (0 if disabled): */
 	unsigned int			kcov_mode;
 
@@ -1216,6 +1234,12 @@ struct task_struct {
 
 	/* KCOV descriptor wired with this task or NULL: */
 	struct kcov			*kcov;
+
+	/* KCOV common handle for remote coverage collection: */
+	u64				kcov_handle;
+
+	/* KCOV sequence number: */
+	int				kcov_sequence;
 #endif
 
 #ifdef CONFIG_MEMCG
@@ -1268,6 +1292,17 @@ struct task_struct {
 	unsigned long			prev_lowest_stack;
 #endif
 
+	ANDROID_VENDOR_DATA_ARRAY(1, 3);
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+	ANDROID_KABI_RESERVE(5);
+	ANDROID_KABI_RESERVE(6);
+	ANDROID_KABI_RESERVE(7);
+	ANDROID_KABI_RESERVE(8);
+
 	/*
 	 * New fields for task_struct should be added above here, so that
 	 * they are included in the randomized portion of task_struct.
diff --git a/include/linux/sched/coredump.h b/include/linux/sched/coredump.h
index ecdc65420..dfd82eab2 100644
--- a/include/linux/sched/coredump.h
+++ b/include/linux/sched/coredump.h
@@ -72,6 +72,7 @@ static inline int get_dumpable(struct mm_struct *mm)
 #define MMF_DISABLE_THP		24	/* disable THP for all VMAs */
 #define MMF_OOM_VICTIM		25	/* mm is the oom victim */
 #define MMF_OOM_REAP_QUEUED	26	/* mm was queued for oom_reaper */
+#define MMF_MULTIPROCESS	27	/* mm is shared between processes */
 #define MMF_DISABLE_THP_MASK	(1 << MMF_DISABLE_THP)
 
 #define MMF_INIT_MASK		(MMF_DUMPABLE_MASK | MMF_DUMP_FILTER_MASK |\
diff --git a/include/linux/sched/signal.h b/include/linux/sched/signal.h
index 88050259c..f7d3466b4 100644
--- a/include/linux/sched/signal.h
+++ b/include/linux/sched/signal.h
@@ -10,6 +10,7 @@
 #include <linux/cred.h>
 #include <linux/refcount.h>
 #include <linux/posix-timers.h>
+#include <linux/android_kabi.h>
 
 /*
  * Types defining task->signal and task->sighand and APIs using them:
@@ -225,6 +226,10 @@ struct signal_struct {
 	struct mutex cred_guard_mutex;	/* guard against foreign influences on
 					 * credential calculations
 					 * (notably. ptrace) */
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 } __randomize_layout;
 
 /*
diff --git a/include/linux/sched/topology.h b/include/linux/sched/topology.h
index f341163fe..509c0d1b9 100644
--- a/include/linux/sched/topology.h
+++ b/include/linux/sched/topology.h
@@ -3,6 +3,7 @@
 #define _LINUX_SCHED_TOPOLOGY_H
 
 #include <linux/topology.h>
+#include <linux/android_kabi.h>
 
 #include <linux/sched/idle.h>
 
@@ -135,6 +136,10 @@ struct sched_domain {
 	struct sched_domain_shared *shared;
 
 	unsigned int span_weight;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+
 	/*
 	 * Span of all CPUs in this domain.
 	 *
diff --git a/include/linux/sched/user.h b/include/linux/sched/user.h
index 917d88edb..573b448e0 100644
--- a/include/linux/sched/user.h
+++ b/include/linux/sched/user.h
@@ -6,6 +6,7 @@
 #include <linux/atomic.h>
 #include <linux/refcount.h>
 #include <linux/ratelimit.h>
+#include <linux/android_kabi.h>
 
 /*
  * Some day this will be a full-fledged user tracking system..
@@ -39,6 +40,9 @@ struct user_struct {
 
 	/* Miscellaneous per-user rate limit */
 	struct ratelimit_state ratelimit;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 extern int uids_sysfs_init(void);
diff --git a/include/linux/sched/xacct.h b/include/linux/sched/xacct.h
index c078f0a94..9544c9d9d 100644
--- a/include/linux/sched/xacct.h
+++ b/include/linux/sched/xacct.h
@@ -28,6 +28,11 @@ static inline void inc_syscw(struct task_struct *tsk)
 {
 	tsk->ioac.syscw++;
 }
+
+static inline void inc_syscfs(struct task_struct *tsk)
+{
+	tsk->ioac.syscfs++;
+}
 #else
 static inline void add_rchar(struct task_struct *tsk, ssize_t amt)
 {
@@ -44,6 +49,10 @@ static inline void inc_syscr(struct task_struct *tsk)
 static inline void inc_syscw(struct task_struct *tsk)
 {
 }
+
+static inline void inc_syscfs(struct task_struct *tsk)
+{
+}
 #endif
 
 #endif /* _LINUX_SCHED_XACCT_H */
diff --git a/include/linux/scs.h b/include/linux/scs.h
new file mode 100644
index 000000000..f8c8beff7
--- /dev/null
+++ b/include/linux/scs.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Shadow Call Stack support.
+ *
+ * Copyright (C) 2019 Google LLC
+ */
+
+#ifndef _LINUX_SCS_H
+#define _LINUX_SCS_H
+
+#include <linux/gfp.h>
+#include <linux/sched.h>
+#include <asm/page.h>
+
+#ifdef CONFIG_SHADOW_CALL_STACK
+
+#ifdef CONFIG_SHADOW_CALL_STACK_VMAP
+#define SCS_SIZE	PAGE_SIZE
+#else
+/*
+ * In testing, 1 KiB shadow stack size (i.e. 128 stack frames on a 64-bit
+ * architecture) provided ~40% safety margin on stack usage while keeping
+ * memory allocation overhead reasonable.
+ */
+#define SCS_SIZE	1024UL
+#endif
+
+#define GFP_SCS		(GFP_KERNEL | __GFP_ZERO)
+
+/*
+ * A random number outside the kernel's virtual address space to mark the
+ * end of the shadow stack.
+ */
+#define SCS_END_MAGIC	0xaf0194819b1635f6UL
+
+#define task_scs(tsk)	(task_thread_info(tsk)->shadow_call_stack)
+
+static inline void task_set_scs(struct task_struct *tsk, void *s)
+{
+	task_scs(tsk) = s;
+}
+
+extern void scs_init(void);
+extern void scs_task_reset(struct task_struct *tsk);
+extern int scs_prepare(struct task_struct *tsk, int node);
+extern bool scs_corrupted(struct task_struct *tsk);
+extern void scs_release(struct task_struct *tsk);
+
+#else /* CONFIG_SHADOW_CALL_STACK */
+
+#define task_scs(tsk)	NULL
+
+static inline void task_set_scs(struct task_struct *tsk, void *s) {}
+static inline void scs_init(void) {}
+static inline void scs_task_reset(struct task_struct *tsk) {}
+static inline int scs_prepare(struct task_struct *tsk, int node) { return 0; }
+static inline bool scs_corrupted(struct task_struct *tsk) { return false; }
+static inline void scs_release(struct task_struct *tsk) {}
+
+#endif /* CONFIG_SHADOW_CALL_STACK */
+
+#endif /* _LINUX_SCS_H */
diff --git a/include/linux/security.h b/include/linux/security.h
index fd022768e..3e8d4bacd 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1897,5 +1897,42 @@ static inline void security_bpf_prog_free(struct bpf_prog_aux *aux)
 #endif /* CONFIG_SECURITY */
 #endif /* CONFIG_BPF_SYSCALL */
 
-#endif /* ! __LINUX_SECURITY_H */
+#ifdef CONFIG_PERF_EVENTS
+struct perf_event_attr;
+struct perf_event;
+
+#ifdef CONFIG_SECURITY
+extern int security_perf_event_open(struct perf_event_attr *attr, int type);
+extern int security_perf_event_alloc(struct perf_event *event);
+extern void security_perf_event_free(struct perf_event *event);
+extern int security_perf_event_read(struct perf_event *event);
+extern int security_perf_event_write(struct perf_event *event);
+#else
+static inline int security_perf_event_open(struct perf_event_attr *attr,
+					   int type)
+{
+	return 0;
+}
+
+static inline int security_perf_event_alloc(struct perf_event *event)
+{
+	return 0;
+}
+
+static inline void security_perf_event_free(struct perf_event *event)
+{
+}
+
+static inline int security_perf_event_read(struct perf_event *event)
+{
+	return 0;
+}
 
+static inline int security_perf_event_write(struct perf_event *event)
+{
+	return 0;
+}
+#endif /* CONFIG_SECURITY */
+#endif /* CONFIG_PERF_EVENTS */
+
+#endif /* ! __LINUX_SECURITY_H */
diff --git a/include/linux/serdev.h b/include/linux/serdev.h
index 9f14f9c12..54df861c6 100644
--- a/include/linux/serdev.h
+++ b/include/linux/serdev.h
@@ -165,9 +165,21 @@ int serdev_device_add(struct serdev_device *);
 void serdev_device_remove(struct serdev_device *);
 
 struct serdev_controller *serdev_controller_alloc(struct device *, size_t);
-int serdev_controller_add(struct serdev_controller *);
+int serdev_controller_add_platform(struct serdev_controller *, bool);
 void serdev_controller_remove(struct serdev_controller *);
 
+/**
+ * serdev_controller_add() - Add an serdev controller
+ * @ctrl:	controller to be registered.
+ *
+ * Register a controller previously allocated via serdev_controller_alloc() with
+ * the serdev core.
+ */
+static inline int serdev_controller_add(struct serdev_controller *ctrl)
+{
+	return serdev_controller_add_platform(ctrl, false);
+}
+
 static inline void serdev_controller_write_wakeup(struct serdev_controller *ctrl)
 {
 	struct serdev_device *serdev = ctrl->serdev;
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 955e1370f..f26daba30 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -40,6 +40,8 @@
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
 #include <linux/netfilter/nf_conntrack_common.h>
 #endif
+#include <linux/android_kabi.h>
+#include <linux/android_vendor.h>
 
 /* The interface for checksum offload between the stack and networking drivers
  * is as follows...
@@ -529,6 +531,8 @@ struct skb_shared_info {
 	 * remains valid until skb destructor */
 	void *		destructor_arg;
 
+	ANDROID_VENDOR_DATA_ARRAY(1, 3);
+
 	/* must be last field, see pskb_expand_head() */
 	skb_frag_t	frags[MAX_SKB_FRAGS];
 };
@@ -592,6 +596,8 @@ enum {
 	SKB_GSO_UDP = 1 << 16,
 
 	SKB_GSO_UDP_L4 = 1 << 17,
+
+	SKB_GSO_FRAGLIST = 1 << 18,
 };
 
 #if BITS_PER_LONG > 32
@@ -874,6 +880,9 @@ struct sk_buff {
 	__u32			headers_end[0];
 	/* public: */
 
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+
 	/* These elements must be at the end, see alloc_skb() for details.  */
 	sk_buff_data_t		tail;
 	sk_buff_data_t		end;
@@ -3525,6 +3534,8 @@ void skb_scrub_packet(struct sk_buff *skb, bool xnet);
 bool skb_gso_validate_network_len(const struct sk_buff *skb, unsigned int mtu);
 bool skb_gso_validate_mac_len(const struct sk_buff *skb, unsigned int len);
 struct sk_buff *skb_segment(struct sk_buff *skb, netdev_features_t features);
+struct sk_buff *skb_segment_list(struct sk_buff *skb, netdev_features_t features,
+				 unsigned int offset);
 struct sk_buff *skb_vlan_untag(struct sk_buff *skb);
 int skb_ensure_writable(struct sk_buff *skb, int write_len);
 int __skb_vlan_pop(struct sk_buff *skb, u16 *vlan_tci);
diff --git a/include/linux/soc/mediatek/mtk_sip_svc.h b/include/linux/soc/mediatek/mtk_sip_svc.h
new file mode 100644
index 000000000..082398e0c
--- /dev/null
+++ b/include/linux/soc/mediatek/mtk_sip_svc.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019 MediaTek Inc.
+ */
+#ifndef __MTK_SIP_SVC_H
+#define __MTK_SIP_SVC_H
+
+/* Error Code */
+#define SIP_SVC_E_SUCCESS               0
+#define SIP_SVC_E_NOT_SUPPORTED         -1
+#define SIP_SVC_E_INVALID_PARAMS        -2
+#define SIP_SVC_E_INVALID_RANGE         -3
+#define SIP_SVC_E_PERMISSION_DENIED     -4
+
+#ifdef CONFIG_ARM64
+#define MTK_SIP_SMC_CONVENTION          ARM_SMCCC_SMC_64
+#else
+#define MTK_SIP_SMC_CONVENTION          ARM_SMCCC_SMC_32
+#endif
+
+#define MTK_SIP_SMC_CMD(fn_id) \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, MTK_SIP_SMC_CONVENTION, \
+			   ARM_SMCCC_OWNER_SIP, fn_id)
+
+#endif
diff --git a/include/linux/soc/qcom/irq.h b/include/linux/soc/qcom/irq.h
new file mode 100644
index 000000000..fcb799c88
--- /dev/null
+++ b/include/linux/soc/qcom/irq.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#ifndef __QCOM_IRQ_H
+#define __QCOM_IRQ_H
+
+#include <linux/irqdomain.h>
+
+#define GPIO_NO_WAKE_IRQ	~0U
+
+/**
+ * QCOM specific IRQ domain flags that distinguishes the handling of wakeup
+ * capable interrupts by different interrupt controllers.
+ *
+ * IRQ_DOMAIN_FLAG_QCOM_PDC_WAKEUP: Line must be masked at TLMM and the
+ *                                  interrupt configuration is done at PDC
+ * IRQ_DOMAIN_FLAG_QCOM_MPM_WAKEUP: Interrupt configuration is handled at TLMM
+ */
+#define IRQ_DOMAIN_FLAG_QCOM_PDC_WAKEUP		(IRQ_DOMAIN_FLAG_NONCORE << 0)
+#define IRQ_DOMAIN_FLAG_QCOM_MPM_WAKEUP		(IRQ_DOMAIN_FLAG_NONCORE << 1)
+
+/**
+ * irq_domain_qcom_handle_wakeup: Return if the domain handles interrupt
+ *                                configuration
+ * @parent: irq domain
+ *
+ * This QCOM specific irq domain call returns if the interrupt controller
+ * requires the interrupt be masked at the child interrupt controller.
+ */
+static inline bool irq_domain_qcom_handle_wakeup(struct irq_domain *parent)
+{
+	return (parent->flags & IRQ_DOMAIN_FLAG_QCOM_PDC_WAKEUP);
+}
+
+#endif
diff --git a/include/linux/stat.h b/include/linux/stat.h
index 765573dc1..528c4baad 100644
--- a/include/linux/stat.h
+++ b/include/linux/stat.h
@@ -33,7 +33,8 @@ struct kstat {
 	 STATX_ATTR_IMMUTABLE |				\
 	 STATX_ATTR_APPEND |				\
 	 STATX_ATTR_NODUMP |				\
-	 STATX_ATTR_ENCRYPTED				\
+	 STATX_ATTR_ENCRYPTED |				\
+	 STATX_ATTR_VERITY				\
 	 )/* Attrs corresponding to FS_*_FL flags */
 	u64		ino;
 	dev_t		dev;
diff --git a/include/linux/string.h b/include/linux/string.h
index b22643552..32ef8b978 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -216,6 +216,8 @@ int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __printf(3, 4);
 extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
 				       const void *from, size_t available);
 
+int ptr_to_hashval(const void *ptr, unsigned long *hashval_out);
+
 /**
  * strstarts - does @str start with @prefix?
  * @str: string to examine
diff --git a/include/linux/sunxi-boot.h b/include/linux/sunxi-boot.h
new file mode 100644
index 000000000..25fe6824a
--- /dev/null
+++ b/include/linux/sunxi-boot.h
@@ -0,0 +1,251 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * allwinner socs boot information.
+ *
+ * copyright (c) 2019 allwinner.
+ *
+ * this file is licensed under the terms of the gnu general public
+ * license version 2.  this program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __SUNXI_BOOT_H__
+#define __SUNXI_BOOT_H__
+
+#include <linux/types.h>
+
+enum size_type {
+	BYTE,
+	SECTOR,
+	PAGE,
+	BLOCK
+};
+
+
+#define SBROM_TOC0_HEAD_SPACE  (0x80)
+#define NDFC_PAGE_TAB_MAGIC "BT0.NTAB"
+#define NDFC_PAGE_TAB_HEAD_SIZE (64)
+#define STAMP_VALUE 0x5F0A6C39
+#define NDFC_RR_TAB_MAGIC "BT0.RRTB"
+#define NDFC_DMY_TAB_MAGIC "BT0.DMTB" //dummy table
+
+
+typedef struct {
+	__u8        ChipCnt;                 /* the count of the total nand flash chips are currently connecting on the CE pin */
+	__u8        ConnectMode;             /* the rb connect  mode */
+	__u8        BankCntPerChip;          /* the count of the banks in one nand chip, multiple banks can support Inter-Leave */
+	__u8        DieCntPerChip;           /* the count of the dies in one nand chip, block management is based on Die */
+	__u8        PlaneCntPerDie;          /* the count of planes in one die, multiple planes can support multi-plane operation */
+	__u8        SectorCntPerPage;        /* the count of sectors in one single physic page, one sector is 0.5k */
+	__u16       ChipConnectInfo;         /* chip connect information, bit == 1 means there is a chip connecting on the CE pin */
+	__u32       PageCntPerPhyBlk;        /* the count of physic pages in one physic block */
+	__u32       BlkCntPerDie;            /* the count of the physic blocks in one die, include valid block and invalid block */
+	__u32       OperationOpt;            /* the mask of the operation types which current nand flash can support support */
+	__u32       FrequencePar;            /* the parameter of the hardware access clock, based on 'MHz' */
+	__u32       SpiMode;                 /* spi nand mode, 0:mode 0, 3:mode 3 */
+	__u8        NandChipId[8];           /* the nand chip id of current connecting nand chip */
+	__u32       pagewithbadflag;         /* bad block flag was written at the first byte of spare area of this page */
+	__u32       MultiPlaneBlockOffset;   /* the value of the block number offset between the two plane block */
+	__u32       MaxEraseTimes;           /* the max erase times of a physic block */
+	__u32       MaxEccBits;              /* the max ecc bits that nand support */
+	__u32       EccLimitBits;            /* the ecc limit flag for tne nand */
+	__u32       uboot_start_block;
+	__u32       uboot_next_block;
+	__u32       logic_start_block;
+	__u32       nand_specialinfo_page;
+	__u32       nand_specialinfo_offset;
+	__u32       physic_block_reserved;
+	__u32       Reserved[4];
+} boot_spinand_para_t;
+
+typedef struct {
+	unsigned int ChannelCnt;
+	/*count of total nand chips are currently connecting on the CE pin*/
+	unsigned int ChipCnt;
+	/*chip connect info, bit=1 means one chip connecting on the CE pin*/
+	unsigned int ChipConnectInfo;
+	unsigned int RbCnt;
+	/*connect info of all rb  chips are connected*/
+	unsigned int RbConnectInfo;
+	unsigned int RbConnectMode;	/*rb connect mode*/
+	/*count of banks in one nand chip, multi banks can support Inter-Leave*/
+	unsigned int BankCntPerChip;
+	/*count of dies in one nand chip, block management is based on Die*/
+	unsigned int DieCntPerChip;
+	/*count of planes in one die, >1 can support multi-plane operation*/
+	unsigned int PlaneCntPerDie;
+	/*count of sectors in one single physic page, one sector is 0.5k*/
+	unsigned int SectorCntPerPage;
+	/*count of physic pages in one physic block*/
+	unsigned int PageCntPerPhyBlk;
+	/*count of physic blocks in one die, include valid and invalid blocks*/
+	unsigned int BlkCntPerDie;
+	/*mask of operation types which current nand flash can support support*/
+	unsigned int OperationOpt;
+	/*parameter of hardware access clock, based on 'MHz'*/
+	unsigned int FrequencePar;
+	/*Ecc Mode for nand chip, 0: bch-16, 1:bch-28, 2:bch_32*/
+	unsigned int EccMode;
+	/*nand chip id of current connecting nand chip*/
+	unsigned char NandChipId[8];
+	/*ratio of valid physical blocks, based on 1024*/
+	unsigned int ValidBlkRatio;
+	unsigned int good_block_ratio; /*good block ratio get from hwscan*/
+	unsigned int ReadRetryType; /*read retry type*/
+	unsigned int DDRType;
+	unsigned int uboot_start_block;
+	unsigned int uboot_next_block;
+	unsigned int logic_start_block;
+	unsigned int nand_specialinfo_page;
+	unsigned int nand_specialinfo_offset;
+	unsigned int physic_block_reserved;
+	/*special nand cmd for some nand in batch cmd, only for write*/
+	unsigned int random_cmd2_send_flag;
+	/*random col addr num in batch cmd*/
+	unsigned int random_addr_num;
+	/*real physic page size*/
+	unsigned int nand_real_page_size;
+	unsigned int Reserved[23];
+} boot_nand_para_t;
+
+typedef struct _normal_gpio_cfg {
+	unsigned char port;
+	unsigned char port_num;
+	char mul_sel;
+	char pull;
+	char drv_level;
+	char data;
+	unsigned char reserved[2];
+} normal_gpio_cfg;
+
+/******************************************************************************/
+/*                              head of Boot0                                 */
+/******************************************************************************/
+typedef struct _boot0_private_head_t {
+	unsigned int prvt_head_size;
+	char prvt_head_vsn[4];        /* the version of boot0_private_head_t */
+	unsigned int dram_para[32];   /* Original values is arbitrary */
+	int uart_port;
+	normal_gpio_cfg uart_ctrl[2];
+	int enable_jtag;              /* 1 : enable,  0 : disable */
+	normal_gpio_cfg jtag_gpio[5];
+	normal_gpio_cfg storage_gpio[32];
+	char storage_data[512 - sizeof(normal_gpio_cfg) * 32];
+}
+boot0_private_head_t;
+
+typedef struct standard_Boot_file_head {
+	unsigned int jump_instruction;  /* one intruction jumping to real code */
+	unsigned char magic[8];         /* ="eGON.BT0" or "eGON.BT1",  not C-style string */
+	unsigned int check_sum;         /* generated by PC */
+	unsigned int length;            /* generated by PC */
+	unsigned int pub_head_size;     /* size of boot_file_head_t */
+	unsigned char pub_head_vsn[4];  /* version of boot_file_head_t */
+	unsigned char file_head_vsn[4]; /* version of boot0_file_head_t or boot1_file_head_t */
+	unsigned char Boot_vsn[4];      /* Boot version */
+	unsigned char eGON_vsn[4];      /* eGON version */
+	unsigned char platform[8];      /* platform information */
+} standard_boot_file_head_t;
+
+typedef struct _boot0_file_head_t {
+	standard_boot_file_head_t boot_head;
+	boot0_private_head_t prvt_head;
+} boot0_file_head_t;
+
+typedef struct _boot_core_para_t {
+	unsigned int user_set_clock;
+	unsigned int user_set_core_vol;
+	unsigned int vol_threshold;
+} boot_core_para_t;
+
+typedef struct {
+	u8 name[8];
+	u32 magic;
+	u32 check_sum;
+
+	u32 serial_num;
+	u32 status;
+
+	u32 items_nr;
+	u32 length;
+	u8 platform[4];
+	u32 reserved[2];
+	u32 end;
+
+} toc0_private_head_t;
+
+typedef struct sbrom_toc0_config {
+	unsigned char config_vsn[4];
+	unsigned int dram_para[32];
+	int uart_port;
+	normal_gpio_cfg uart_ctrl[2];
+	int enable_jtag;
+	normal_gpio_cfg jtag_gpio[5];
+	normal_gpio_cfg storage_gpio[50];
+	char storage_data[384];
+	unsigned int secure_dram_mbytes;
+	unsigned int drm_start_mbytes;
+	unsigned int drm_size_mbytes;
+	unsigned int res[8];
+} sbrom_toc0_config_t;
+
+/******************************************************************************/
+/*                                   head of Boot1                            */
+/******************************************************************************/
+typedef struct _boot1_private_head_t {
+	unsigned int dram_para[32];
+	int run_clock;		/* Mhz*/
+	int run_core_vol;	/* mV*/
+	int uart_port;
+	normal_gpio_cfg uart_gpio[2];
+	int twi_port;
+	normal_gpio_cfg twi_gpio[2];
+	int work_mode;
+	int storage_type;	/* 0nand   1sdcard    2: spinor*/
+	normal_gpio_cfg nand_gpio[32];
+	char nand_spare_data[256];
+	normal_gpio_cfg sdcard_gpio[32];
+	char sdcard_spare_data[256];
+	int reserved[6];
+} boot1_private_head_t;
+#if 0
+typedef struct _Boot_file_head {
+	unsigned int jump_instruction; /* one intruction jumping to real code */
+	unsigned char magic[8];        /* ="u-boot" */
+	unsigned int check_sum;        /* generated by PC */
+	unsigned int align_size;       /* align size in byte */
+	unsigned int length;           /* the size of all file */
+	unsigned int uboot_length;     /* the size of uboot */
+	unsigned char version[8];      /* uboot version */
+	unsigned char platform[8];     /* platform information */
+	int reserved[1];               /* stamp space, 16bytes align */
+} boot_file_head_t;
+
+typedef struct _boot1_file_head_t {
+	boot_file_head_t boot_head;
+	boot1_private_head_t prvt_head;
+} boot1_file_head_t;
+#endif
+
+typedef struct _Boot_file_head {
+	__u32  jump_instruction;   /* one intruction jumping to real code */
+	__u8   magic[8];  /* ="eGON.BT0" */
+	__u32  check_sum;          /* generated by PC */
+	__u32  length;             /* generated by PC */
+	__u32  pub_head_size;      /* the size of boot_file_head_t */
+	__u8   pub_head_vsn[4];    /* the version of boot_file_head_t */
+	__u32  ret_addr;           /* the return value */
+	__u32  run_addr;           /* run addr */
+	__u32  boot_cpu;           /* eGON version */
+	__u8   platform[8];        /* platform information */
+} boot_file_head_t;
+
+
+
+struct boot_ndfc_cfg {
+	u8 page_size_kb;
+	u8 ecc_mode;
+	u8 sequence_mode;
+	u8 res[5];
+};
+#endif /*SUNXI_BOOT_H*/
diff --git a/include/linux/sunxi-dump.h b/include/linux/sunxi-dump.h
new file mode 100644
index 000000000..b371adcff
--- /dev/null
+++ b/include/linux/sunxi-dump.h
@@ -0,0 +1,21 @@
+/*
+ * include/linux/ion_sunxi.h
+ *
+ * Copyright(c) 2019-2025 Allwinnertech Co., Ltd.
+ *      http://www.allwinnertech.com
+ *
+ *
+ * sunxi dump header file
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _INCLUDE_LINUX_SUNXI_DUMP_H
+#define _INCLUDE_LINUX_SUNXI_DUMP_H
+
+extern int sunxi_dump_group_dump(void);
+extern int sunxi_set_crashdump_mode(void);
+#endif
diff --git a/include/linux/sunxi-gpio.h b/include/linux/sunxi-gpio.h
new file mode 100644
index 000000000..1fe2abd85
--- /dev/null
+++ b/include/linux/sunxi-gpio.h
@@ -0,0 +1,188 @@
+/*
+ * include/linux/sunxi-gpio.h
+ *
+ * (C) Copyright 2015-2020
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wim Hwang <huangwei@allwinnertech.com>
+ *
+ * sunxi gpio utils
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SW_GPIO_H
+#define __SW_GPIO_H
+
+#define SUNXI_PINCTRL	"pio"
+#define SUNXI_R_PINCTRL	"r_pio"
+#include <linux/pinctrl/pinconf-generic.h>
+
+/* pin group base number name space,
+ * the max pin number : 26*32=832.
+ */
+#define SUNXI_BANK_SIZE 32
+#define SUNXI_PA_BASE	0
+#define SUNXI_PB_BASE	32
+#define SUNXI_PC_BASE	64
+#define SUNXI_PD_BASE	96
+#define SUNXI_PE_BASE	128
+#define SUNXI_PF_BASE	160
+#define SUNXI_PG_BASE	192
+#define SUNXI_PH_BASE	224
+#define SUNXI_PI_BASE	256
+#define SUNXI_PJ_BASE	288
+#define SUNXI_PK_BASE	320
+#define SUNXI_PL_BASE	352
+#define SUNXI_PM_BASE	384
+#define SUNXI_PN_BASE	416
+#define SUNXI_PO_BASE	448
+#define AXP_PIN_BASE	1024
+
+#define SUNXI_PIN_NAME_MAX_LEN	8
+
+/* sunxi gpio name space */
+#define GPIOA(n)	(SUNXI_PA_BASE + (n))
+#define GPIOB(n)	(SUNXI_PB_BASE + (n))
+#define GPIOC(n)	(SUNXI_PC_BASE + (n))
+#define GPIOD(n)	(SUNXI_PD_BASE + (n))
+#define GPIOE(n)	(SUNXI_PE_BASE + (n))
+#define GPIOF(n)	(SUNXI_PF_BASE + (n))
+#define GPIOG(n)	(SUNXI_PG_BASE + (n))
+#define GPIOH(n)	(SUNXI_PH_BASE + (n))
+#define GPIOI(n)	(SUNXI_PI_BASE + (n))
+#define GPIOJ(n)	(SUNXI_PJ_BASE + (n))
+#define GPIOK(n)	(SUNXI_PK_BASE + (n))
+#define GPIOL(n)	(SUNXI_PL_BASE + (n))
+#define GPIOM(n)	(SUNXI_PM_BASE + (n))
+#define GPION(n)	(SUNXI_PN_BASE + (n))
+#define GPIOO(n)	(SUNXI_PO_BASE + (n))
+#define GPIO_AXP(n)	(AXP_PIN_BASE  + (n))
+
+/* sunxi specific input/output/eint functions */
+#define SUNXI_PIN_INPUT_FUNC	(0)
+#define SUNXI_PIN_OUTPUT_FUNC	(1)
+#define SUNXI_PIN_EINT_FUNC	(6)
+#define SUNXI_PIN_IO_DISABLE	(7)
+
+/* axp group base number name space,
+ * axp pinctrl number space coherent to sunxi-pinctrl.
+ */
+#define AXP_PINCTRL	        "axp-pinctrl"
+#define AXP_CFG_GRP		(0xFFFF)
+#define AXP_PIN_INPUT_FUNC	(0)
+#define AXP_PIN_OUTPUT_FUNC	(1)
+#define IS_AXP_PIN(pin)		(pin >= AXP_PIN_BASE)
+
+/* sunxi specific pull up/down */
+enum sunxi_pull_up_down {
+	SUNXI_PULL_DISABLE = 0,
+	SUNXI_PULL_UP,
+	SUNXI_PULL_DOWN,
+};
+
+/* sunxi specific data types */
+enum sunxi_data_type {
+	SUNXI_DATA_LOW = 0,
+	SUNXI_DATA_HIGH = 0,
+};
+
+/* sunxi specific pull status */
+enum sunxi_pin_pull {
+	SUNXI_PIN_PULL_DISABLE	= 0x00,
+	SUNXI_PIN_PULL_UP	= 0x01,
+	SUNXI_PIN_PULL_DOWN	= 0x02,
+	SUNXI_PIN_PULL_RESERVED	= 0x03,
+};
+
+/* sunxi specific driver levels */
+enum sunxi_pin_drv_level {
+	SUNXI_DRV_LEVEL0 = 10,
+	SUNXI_DRV_LEVEL1 = 20,
+	SUNXI_DRV_LEVEL2 = 30,
+	SUNXI_DRV_LEVEL3 = 40,
+};
+
+/* sunxi specific data bit status */
+enum sunxi_pin_data_status {
+	SUNXI_PIN_DATA_LOW  = 0x00,
+	SUNXI_PIN_DATA_HIGH = 0x01,
+};
+
+/* sunxi pin interrupt trigger mode */
+enum sunxi_pin_int_trigger_mode {
+	SUNXI_PIN_EINT_POSITIVE_EDGE   =   0x0,
+	SUNXI_PIN_EINT_NEGATIVE_EDGE   =   0x1,
+	SUNXI_PIN_EINT_HIGN_LEVEL      =   0x2,
+	SUNXI_PIN_EINT_LOW_LEVEL       =   0x3,
+	SUNXI_PIN_EINT_DOUBLE_EDGE     =   0x4
+};
+
+/* the source clock of pin int */
+enum sunxi_pin_int_source_clk {
+	SUNXI_PIN_INT_SRC_CLK_32K = 0x0,
+	SUNXI_PIN_INT_SRC_CLK_24M = 0x1
+};
+
+/*
+ * pin configuration (pull up/down and drive strength) type and its value are
+ * packed together into a 32-bits. The lower 8-bits represent the configuration
+ * type and the upper 24-bits hold the value of the configuration type.
+ */
+#define SUNXI_PINCFG_PACK(type, value)	(((value) << 8) | (type & 0xFF))
+#define SUNXI_PINCFG_UNPACK_TYPE(cfg)	((cfg) & 0xFF)
+#define SUNXI_PINCFG_UNPACK_VALUE(cfg)	(((cfg) & 0xFFFFFF00) >> 8)
+
+static inline int sunxi_gpio_to_name(int gpio, char *name)
+{
+	int bank, index;
+
+	if (!name)
+		return -EINVAL;
+
+	if (IS_AXP_PIN(gpio)) {
+		/* axp gpio name like this : GPIO0/GPIO1/.. */
+		index = gpio - AXP_PIN_BASE;
+		sprintf(name, "GPIO%d", index);
+	} else {
+		/* sunxi gpio name like this : PA0/PA1/PB0 */
+		bank = gpio / SUNXI_BANK_SIZE;
+		index = gpio % SUNXI_BANK_SIZE;
+		sprintf(name, "P%c%d", ('A' + bank), index);
+	}
+
+	return 0;
+}
+
+/* pio end, invalid macro */
+#define GPIO_INDEX_INVALID	(0xFFFFFFF0)
+#define GPIO_CFG_INVALID	(0xEEEEEEEE)
+#define GPIO_PULL_INVALID	(0xDDDDDDDD)
+#define GPIO_DRVLVL_INVALID	(0xCCCCCCCC)
+#define IRQ_NUM_INVALID		(0xFFFFFFFF)
+#define AXP_PORT_VAL		(0x0000FFFF)
+
+/* pio default macro */
+#define GPIO_PULL_DEFAULT	((u32)-1)
+#define GPIO_DRVLVL_DEFAULT	((u32)-1)
+#define GPIO_DATA_DEFAULT	((u32)-1)
+
+/*
+ * struct gpio_config - gpio config info
+ * @gpio:      gpio global index, must be unique
+ * @mul_sel:   multi sel val: 0 - input, 1 - output.
+ * @pull:      pull val: 0 - pull up/down disable, 1 - pull up
+ * @drv_level: driver level val: 0 - level 0, 1 - level 1
+ * @data:      data val: 0 - low, 1 - high, only valid when mul_sel is input/output
+ */
+struct gpio_config {
+	u32	data;
+	u32	gpio;
+	u32	mul_sel;
+	u32	pull;
+	u32	drv_level;
+};
+
+#endif
diff --git a/include/linux/sunxi-panicpart.h b/include/linux/sunxi-panicpart.h
new file mode 100644
index 000000000..2f8d4add2
--- /dev/null
+++ b/include/linux/sunxi-panicpart.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __SUNXI_PANICPART_H
+#define __SUNXI_PANICPART_H
+
+#include <linux/types.h>
+
+enum sunxi_flash {
+	SUNXI_FLASH_ERROR = 0,
+	SUNXI_FLASH_MMC,
+	SUNXI_FLASH_NAND,
+	SUNXI_FLASH_NOR,
+};
+
+struct panic_part {
+	enum sunxi_flash type;
+	const char *bdev;
+	size_t start_sect;
+	size_t sects;
+
+	ssize_t (*panic_read)(struct panic_part *part, loff_t sec_off,
+			size_t sec_cnt, char *buf);
+	ssize_t (*panic_write)(struct panic_part *part, loff_t sec_off,
+			size_t sec_cnt, const char *buf);
+
+	void *private;
+};
+
+#if IS_ENABLED(CONFIG_SUNXI_PANICPART)
+extern int sunxi_panicpart_init(struct panic_part *part);
+extern int sunxi_parse_blkdev(char *bdev, int len);
+#else
+/*
+ *static int sunxi_panicpart_init(struct panic_part *part)
+ *{
+ *    return -1;
+ *}
+ *
+ *static int sunxi_parse_blkdev(char *bdev, int len)
+ *{
+ *    return -1;
+ *}
+ */
+#endif
+
+#endif
diff --git a/include/linux/sunxi-sid.h b/include/linux/sunxi-sid.h
new file mode 100644
index 000000000..2aa145f35
--- /dev/null
+++ b/include/linux/sunxi-sid.h
@@ -0,0 +1,107 @@
+/*
+ * linux/sunxi-sid.h
+ *
+ * Copyright(c) 2014-2016 Allwinnertech Co., Ltd.
+ *         http://www.allwinnertech.com
+ *
+ * Author: sunny <sunny@allwinnertech.com>
+ *
+ * allwinner sunxi soc chip version and chip id manager.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __SUNXI_MACH_SUNXI_CHIP_H
+#define __SUNXI_MACH_SUNXI_CHIP_H
+
+#include <linux/types.h>
+#include <linux/errno.h>
+
+/* The key info in Efuse */
+
+#define EFUSE_CHIPID_NAME            "chipid"
+#define EFUSE_BROM_CONF_NAME         "brom_conf"
+#define EFUSE_BROM_TRY_NAME          "brom_try"
+#define EFUSE_THM_SENSOR_NAME        "thermal_sensor"
+#define EFUSE_FT_ZONE_NAME           "ft_zone"
+#define EFUSE_TV_OUT_NAME            "tvout"
+#define EFUSE_TVE_NAME               "tve"
+#define EFUSE_OEM_NAME               "oem"
+#define EFUSE_ANTI_BLUSH_NAME        "anti_blushing"
+
+#define EFUSE_PSENSOR_NAME           "psensor"
+#define EFUSE_DDR_CFG_NAME           "ddr_cfg"
+#define EFUSE_LDOA_NAME              "ldoa"
+#define EFUSE_LDOB_NAME              "ldob"
+#define EFUSE_AUDIO_BIAS_NAME        "audio_bias"
+#define EFUSE_GAMMA_NAME             "gamma"
+#define EFUSE_WR_PROTECT_NAME        "write_protect"
+#define EFUSE_RD_PROTECT_NAME        "read_protect"
+#define EFUSE_IN_NAME                "in"
+#define EFUSE_ID_NAME                "id"
+#define EFUSE_ROTPK_NAME             "rotpk"
+#define EFUSE_SSK_NAME               "ssk"
+#define EFUSE_RSSK_NAME              "rssk"
+#define EFUSE_HDCP_HASH_NAME         "hdcp_hash"
+#define EFUSE_HDCP_PKF_NAME          "hdcp_pkf"
+#define EFUSE_HDCP_DUK_NAME          "hdcp_duk"
+#define EFUSE_EK_HASH_NAME           "ek_hash"
+#define EFUSE_SN_NAME                "sn"
+#define EFUSE_NV1_NAME               "nv1"
+#define EFUSE_NV2_NAME               "nv2"
+#define EFUSE_BACKUP_KEY_NAME        "backup_key"
+#define EFUSE_BACKUP_KEY2_NAME       "backup_key2"
+#define EFUSE_TCON_PARM_NAME         "tcon_parm"
+#define EFUSE_RSAKEY_HASH_NAME       "rsakey_hash"
+#define EFUSE_RENEW_NAME             "renewability"
+#define EFUSE_OPT_ID_NAME            "operator_id"
+#define EFUSE_LIFE_CYCLE_NAME        "life_cycle"
+#define EFUSE_JTAG_SECU_NAME         "jtag_security"
+#define EFUSE_JTAG_ATTR_NAME         "jtag_attr"
+#define EFUSE_CHIP_CONF_NAME         "chip_config"
+#define EFUSE_RESERVED_NAME          "reserved"
+#define EFUSE_RESERVED2_NAME         "reserved2"
+
+#define SUNXI_KEY_NAME_LEN	32
+
+#define SID_PRCTL			0x40
+#define SID_RDKEY			0x60
+#define SID_OP_LOCK			0xAC
+
+#define SRAM_CTRL_BASE		"allwinner,sram_ctrl"
+#define EFUSE_SID_BASE		"allwinner,sunxi-sid"
+
+#define sunxi_efuse_read(key_name, read_buf) \
+		sunxi_efuse_readn(key_name, read_buf, 1024)
+
+/* The interface functions */
+#if IS_ENABLED(CONFIG_SUNXI_SID)
+unsigned int sunxi_get_soc_ver(void);
+int sunxi_get_soc_chipid(unsigned char *chipid);
+int sunxi_get_soc_chipid_str(char *chipid);
+int sunxi_get_soc_ft_zone_str(char *serial);
+int sunxi_get_soc_rotpk_status_str(char *status);
+int sunxi_get_pmu_chipid(unsigned char *chipid);
+int sunxi_get_serial(unsigned char *serial);
+unsigned int sunxi_get_soc_bin(void);
+s32 sunxi_get_platform(s8 *buf, s32 size);
+s32 sunxi_efuse_readn(s8 *key_name, void *buf, u32 n);
+int sunxi_get_module_param_from_sid(u32 *dst, u32 offset, u32 len);
+#else
+unsigned int __attribute__((weak)) sunxi_get_soc_ver(void) {return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_soc_chipid(unsigned char *chipid) {return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_soc_chipid_str(char *chipid) {return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_soc_ft_zone_str(char *serial) {return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_soc_rotpk_status_str(char *status) {return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_pmu_chipid(unsigned char *chipid) {return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_serial(unsigned char *serial) {return -ENOSYS; }
+unsigned int __attribute__((weak)) sunxi_get_soc_bin(void) {return -ENOSYS; }
+s32 __attribute__((weak)) sunxi_get_platform(s8 *buf, s32 size) {return -ENOSYS; }
+s32 __attribute__((weak)) sunxi_efuse_readn(s8 *key_name, void *buf, u32 n) {return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_module_param_from_sid(u32 *dst, u32 offset, u32 len) {return -ENOSYS; }
+#endif
+int sunxi_soc_is_secure(void);
+#endif  /* __SUNXI_MACH_SUNXI_CHIP_H */
diff --git a/include/linux/sunxi-smc.h b/include/linux/sunxi-smc.h
new file mode 100644
index 000000000..f73efa0d1
--- /dev/null
+++ b/include/linux/sunxi-smc.h
@@ -0,0 +1,32 @@
+/*
+ * drivers/char/sunxi_sys_info/sunxi-smc.c
+ *
+ * Copyright(c) 2015-2016 Allwinnertech Co., Ltd.
+ *         http://www.allwinnertech.com
+ *
+ * Author: sunny <superm@allwinnertech.com>
+ *
+ * allwinner sunxi soc chip version and chip id manager.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __SUNXI_SMC_H
+#define __SUNXI_SMC_H
+
+#define SUNXI_OPTEE_SMC_OFFSET (0x200)
+
+extern int invoke_smc_fn(u32 function_id, u64 arg0, u64 arg1, u64 arg2);
+extern u32 sunxi_smc_readl(phys_addr_t addr);
+extern int sunxi_smc_writel(u32 value, phys_addr_t addr);
+extern int sunxi_smc_probe_secure(void);
+extern int sunxi_soc_is_secure(void);
+extern int sunxi_smc_copy_arisc_paras(phys_addr_t dest, phys_addr_t src, u32 len);
+extern int sunxi_smc_call_offset(void);
+extern int  optee_probe_drm_configure(unsigned long *drm_base,
+	size_t *drm_size, unsigned long  *tee_base);
+
+#endif  /* __SUNXI_SMC_H */
diff --git a/include/linux/sunxi_mbus.h b/include/linux/sunxi_mbus.h
new file mode 100644
index 000000000..ad6fae99d
--- /dev/null
+++ b/include/linux/sunxi_mbus.h
@@ -0,0 +1,148 @@
+/*
+ * SUNXI MBUS support
+ *
+ * Copyright (C) 2015 AllWinnertech Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_SUNXI_MBUS_H
+#define __LINUX_SUNXI_MBUS_H
+
+#include <linux/types.h>
+
+/* Port ids */
+/* See SDRAM Controller Spec: DRAMC access master list */
+enum mbus_port {
+#if IS_ENABLED(CONFIG_ARCH_SUN8IW20) || IS_ENABLED(CONFIG_ARCH_SUN20IW1)
+	MBUS_PORT_CPU		= 0,
+	MBUS_PORT_MAHB		= 2,
+	MBUS_PORT_DMA		= 3,
+	MBUS_PORT_VE		= 4,
+	MBUS_PORT_CE		= 5,
+	MBUS_PORT_TVD		= 10,
+	MBUS_PORT_CSI		= 11,
+	MBUS_PORT_G2D		= 13,
+	MBUS_PORT_DI		= 14,
+	MBUS_PORT_DE		= 16,
+	MBUS_PORT_IOMMU		= 25,
+	MBUS_PORT_DSP		= 37,
+	MBUS_PORT_RISCV		= 39,
+	MBUS_PORTS_MAX		= 40,
+#elif IS_ENABLED(CONFIG_ARCH_SUN50IW9)
+	MBUS_PORT_CPU           = 0,
+	MBUS_PORT_GPU           = 1,
+	MBUS_PORT_MAHB          = 2,
+	MBUS_PORT_DMA           = 3,
+	MBUS_PORT_VE0           = 4,
+	MBUS_PORT_CE            = 5,
+	MBUS_PORT_TSC0          = 6,
+	MBUS_PORT_NDFC0         = 8,
+	MBUS_PORT_CSI0          = 11,
+	MBUS_PORT_DI0           = 14,
+	MBUS_PORT_DE300         = 16,
+	MBUS_PORT_G2D_ROT       = 21,
+	MBUS_PORT_CSI1          = 22,
+	MBUS_PORT_ISP1          = 23,
+	MBUS_PORT_VE1           = 24,
+	MBUS_PORT_IOMMU         = 25,
+	MBUS_PORT_HDMI          = 39,
+	MBUS_PORTS_MAX          = 40,
+
+#else
+	/* ... */
+#endif
+};
+
+struct device_node;
+
+#ifdef CONFIG_SUNXI_MBUS
+extern int mbus_port_setbwlen(enum mbus_port port, bool en);
+extern int mbus_port_setpri(enum mbus_port port, bool pri);
+extern int mbus_port_setqos(enum mbus_port port, unsigned int qos);
+extern int mbus_port_setwt(enum mbus_port port, unsigned int wt);
+extern int mbus_port_setacs(enum mbus_port port, unsigned int acs);
+extern int mbus_port_setbwl0(enum mbus_port port, unsigned int bwl0);
+extern int mbus_port_setbwl1(enum mbus_port port, unsigned int bwl1);
+extern int mbus_port_setbwl2(enum mbus_port port, unsigned int bwl2);
+extern int mbus_port_setbwl(enum mbus_port port, unsigned int bwl0,
+			    unsigned int bwl1, unsigned int bwl2);
+extern int mbus_set_bwlwen(bool enable);
+extern int mbus_set_bwlwsiz(unsigned int size);
+extern int mbus_port_control_by_index(enum mbus_port port, bool enable);
+extern bool mbus_probed(void);
+extern int mbus_port_setbwcu(unsigned int unit);
+#else
+static inline int mbus_port_setbwlen(enum mbus_port port, bool en)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_setpri(enum mbus_port port, bool pri)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_setqos(enum mbus_port port, unsigned int qos)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_setwt(enum mbus_port port, unsigned int wt)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_setacs(enum mbus_port port, unsigned int acs)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_setbwl0(enum mbus_port port, unsigned int bwl0)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_setbwl1(enum mbus_port port, unsigned int bwl1)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_setbwl2(enum mbus_port port, unsigned int bwl2)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_setbwl(enum mbus_port port, unsigned int bwl0,
+				   unsigned int bwl1, unsigned int bwl2)
+{
+	return -ENODEV;
+}
+static inline int mbus_set_bwlwen(bool enable)
+{
+	return -ENODEV;
+}
+static inline int mbus_set_bwlwsiz(unsigned int size)
+{
+	return -ENODEV;
+}
+static inline int mbus_port_control_by_index(enum mbus_port port, bool enable)
+{
+	return -ENODEV;
+}
+static inline bool mbus_probed(void)
+{
+	return false;
+}
+static inline int mbus_port_setbwcu(unsigned int unit)
+{
+	return -ENODEV;
+}
+#endif
+
+#define mbus_disable_port_by_index(dev) \
+	mbus_port_control_by_index(dev, false)
+#define mbus_enable_port_by_index(dev) \
+	mbus_port_control_by_index(dev, true)
+
+#endif
diff --git a/include/linux/sunxi_nand_errno.h b/include/linux/sunxi_nand_errno.h
new file mode 100644
index 000000000..9cb058266
--- /dev/null
+++ b/include/linux/sunxi_nand_errno.h
@@ -0,0 +1,145 @@
+//SPDX-License-Identifier: GPL-2.0
+
+
+#ifndef __NAND_ERRNO_H__
+#define __NAND_ERRNO_H__
+
+
+//define the return value
+
+#define NAND_OP_TRUE (0)	/* define the successful return value */
+#define NAND_OP_FALSE (-1)	/*define the failed return value*/
+
+#define ECC_LIMIT (10)		/*reach the limit of the ability of ECC*/
+#define ERR_ECC (-2)		/*too much ecc error*/
+#define ERR_TIMEOUT (-3)	/*hardware timeout*/
+#define ERR_PARA (-4)
+
+#define ERR_INVALIDPHYADDR 5
+
+#define ERR_NO_10 (-10)
+#define ERR_NO_11 (-11)
+#define ERR_NO_12 (-12)		/*-ENOMEM*/
+#define ERR_NO_13 (-13)		/*reset chip fail*/
+#define ERR_NO_14 (-14)		/*read id fail*/
+#define ERR_NO_15 (-15)		/*id no support*/
+#define ERR_NO_16 (-16)		/*update nci fail*/
+#define ERR_NO_17 (-17)		/*init nctri fail*/
+#define ERR_NO_18 (-18)		/*chip init fail*/
+#define ERR_NO_19 (-19)
+#define ERR_NO_20 (-20)
+#define ERR_NO_21 (-21)
+#define ERR_NO_22 (-22)		/*invalid parameter*/
+#define ERR_NO_23 (-23)
+#define ERR_NO_24 (-24)
+#define ERR_NO_25 (-25)
+#define ERR_NO_26 (-26)
+#define ERR_NO_27 (-27)
+#define ERR_NO_28 (-28)
+#define ERR_NO_29 (-29)
+#define ERR_NO_30 (-30)
+#define ERR_NO_31 (-31)
+#define ERR_NO_32 (-32)
+#define ERR_NO_33 (-33)
+#define ERR_NO_34 (-34)
+#define ERR_NO_35 (-35)
+#define ERR_NO_36 (-36)
+#define ERR_NO_37 (-37)
+#define ERR_NO_38 (-38)
+#define ERR_NO_39 (-39)
+#define ERR_NO_40 (-40)
+#define ERR_NO_41 (-41)
+#define ERR_NO_42 (-42)
+#define ERR_NO_43 (-43)
+#define ERR_NO_44 (-44)
+#define ERR_NO_45 (-45)
+#define ERR_NO_46 (-46)
+#define ERR_NO_47 (-47)
+#define ERR_NO_48 (-48)
+#define ERR_NO_49 (-49)
+#define ERR_NO_50 (-50)
+#define ERR_NO_51 (-51)
+#define ERR_NO_52 (-52)
+#define ERR_NO_53 (-53)
+#define ERR_NO_54 (-54)
+#define ERR_NO_55 (-55)
+#define ERR_NO_56 (-56)
+#define ERR_NO_57 (-57)
+#define ERR_NO_58 (-58)
+#define ERR_NO_59 (-59)
+#define ERR_NO_60 (-60)
+#define ERR_NO_61 (-61)
+#define ERR_NO_62 (-62)
+#define ERR_NO_63 (-63)
+#define ERR_NO_64 (-64)
+#define ERR_NO_65 (-65)
+#define ERR_NO_66 (-66)
+#define ERR_NO_67 (-67)
+#define ERR_NO_68 (-68)
+#define ERR_NO_69 (-69)
+#define ERR_NO_70 (-70)
+#define ERR_NO_71 (-71)
+#define ERR_NO_72 (-72)
+#define ERR_NO_73 (-73)
+#define ERR_NO_74 (-74)
+#define ERR_NO_75 (-75)
+#define ERR_NO_76 (-76)
+#define ERR_NO_77 (-77)
+#define ERR_NO_78 (-78)
+#define ERR_NO_79 (-79)
+#define ERR_NO_80 (-80)
+#define ERR_NO_81 (-81)
+#define ERR_NO_82 (-82)
+#define ERR_NO_83 (-83)
+#define ERR_NO_84 (-84)
+#define ERR_NO_85 (-85)
+#define ERR_NO_86 (-86)
+#define ERR_NO_87 (-87)
+#define ERR_NO_88 (-88)
+#define ERR_NO_89 (-89)
+#define ERR_NO_90 (-90)
+#define ERR_NO_91 (-91)
+#define ERR_NO_92 (-92)
+#define ERR_NO_93 (-93)
+#define ERR_NO_94 (-94)
+#define ERR_NO_95 (-95)
+#define ERR_NO_96 (-96)
+#define ERR_NO_97 (-97)
+#define ERR_NO_98 (-98)
+#define ERR_NO_99 (-99)
+#define ERR_NO_100 (-100)
+#define ERR_NO_101 (-101)
+#define ERR_NO_102 (-102)
+#define ERR_NO_103 (-103)
+#define ERR_NO_104 (-104)
+#define ERR_NO_105 (-105)
+#define ERR_NO_106 (-106)
+#define ERR_NO_107 (-107)
+#define ERR_NO_108 (-108)
+#define ERR_NO_109 (-109)
+#define ERR_NO_110 (-110)
+#define ERR_NO_111 (-111)
+#define ERR_NO_112 (-112)
+#define ERR_NO_113 (-113)
+#define ERR_NO_114 (-114)
+#define ERR_NO_115 (-115)
+#define ERR_NO_116 (-116)
+#define ERR_NO_117 (-117)
+#define ERR_NO_118 (-118)
+#define ERR_NO_119 (-119)
+#define ERR_NO_120 (-120)
+#define ERR_NO_121 (-121)
+#define ERR_NO_122 (-122)
+#define ERR_NO_123 (-123)
+#define ERR_NO_124 (-124)
+#define ERR_NO_125 (-125)
+#define ERR_NO_126 (-126)
+#define ERR_NO_127 (-127)
+#define ERR_NO_128 (-128)
+#define ERR_NO_129 (-129)
+#define ERR_NO_130 (-130)
+#define ERR_NO_131 (-131)
+#define ERR_NO_132 (-132)
+#define ERR_NO_133 (-133)
+
+#endif /*NAND_ERRNO_H*/
diff --git a/include/linux/sunxi_nsi.h b/include/linux/sunxi_nsi.h
new file mode 100644
index 000000000..f59f21331
--- /dev/null
+++ b/include/linux/sunxi_nsi.h
@@ -0,0 +1,103 @@
+/*
+ * SUNXI MBUS support
+ *
+ * Copyright (C) 2015 AllWinnertech Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_SUNXI_MBUS_H
+#define __LINUX_SUNXI_MBUS_H
+
+#include <linux/types.h>
+
+/* MBUS PMU ids */
+enum nsi_pmu {
+	MBUS_PMU_CPU    = 0,
+	MBUS_PMU_GPU     = 1,
+
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+	MBUS_PMU_SD1     = 2,
+	MBUS_PMU_MSTG    = 3,
+	MBUS_PMU_GMAC0   = 4,
+	MBUS_PMU_GMAC1   = 5,
+	MBUS_PMU_USB0    = 6,
+	MBUS_PMU_USB1    = 7,
+	MBUS_PMU_NDFC    = 8,
+	MBUS_PMU_DMAC    = 9,
+	MBUS_PMU_CE      = 10,
+	MBUS_PMU_DE0     = 11,
+	MBUS_PMU_DE1     = 12,
+	MBUS_PMU_VE      = 13,
+	MBUS_PMU_CSI     = 14,
+	MBUS_PMU_ISP     = 15,
+	MBUS_PMU_G2D     = 16,
+	MBUS_PMU_EINK    = 17,
+	MBUS_PMU_IOMMU   = 18,
+	MBUS_PMU_SYS_CPU = 19,
+	MBUS_PMU_IAG_MAX,
+	MBUS_PMU_TAG = 23,
+#elif IS_ENABLED(CONFIG_ARCH_SUN50IW12)
+	MBUS_PMU_VE_R			= 2,
+	MBUS_PMU_VE				= 3,
+	MBUS_PMU_TVDISP_MBUS	= 4,
+	MBUS_PMU_TVDISP_AXI		= 5,
+	MBUS_PMU_VE_RW			= 6,
+	MBUS_PMU_TVFE			= 7,
+	MBUS_PMU_NDFC			= 8,
+	MBUS_PMU_DMAC			= 9,
+	MBUS_PMU_CE				= 10,
+	MBUS_PMU_IOMMU			= 11,
+	MBUS_PMU_TVCAP			= 12,
+	MBUS_PMU_GMAC0			= 13,
+	MBUS_PMU_MSTG			= 14,
+	MBUS_PMU_MIPS			= 15,
+	MBUS_PMU_USB0			= 16,
+	MBUS_PMU_USB1			= 17,
+	MBUS_PMU_USB2			= 18,
+	MBUS_PMU_MSTG1			= 19,
+	MBUS_PMU_MSTG2			= 20,
+	MBUS_PMU_NPD			= 21,
+	MBUS_PMU_IAG_MAX,
+	/* use RA1 to get total bandwidth, because no TA pmu for sun50iw12 */
+	MBUS_PMU_TAG = 24,
+#endif
+	MBUS_PMU_MAX,
+};
+
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+static const char *const pmu_name[] = {
+	"cpu", "gpu", "sd1", "mstg", "gmac0", "gmac1", "usb0", "usb1", "ndfc",
+	"dmac", "ce", "de0", "de1", "ve", "csi", "isp", "g2d", "eink", "iommu",
+	"sys_cpu", "total",
+};
+#elif IS_ENABLED(CONFIG_ARCH_SUN50IW12)
+static const char *const pmu_name[] = {
+	"cpu", "gpu", "ve_r", "ve", "tvd_mbus", "tvd_axi", "ve_rw", "tvfe", "ndfc", "dmac", "ce",
+	"iommu", "tvcap", "gmac0", "mstg", "mips", "usb0", "usb1", "usb2", "mstg1", "mstg2",
+	"npd", "total",
+};
+#endif
+
+#define get_name(n)      pmu_name[n]
+
+#if IS_ENABLED(CONFIG_SUNXI_NSI)
+extern int nsi_port_setpri(enum nsi_pmu port, unsigned int pri);
+extern int nsi_port_setqos(enum nsi_pmu port, unsigned int qos);
+extern bool nsi_probed(void);
+#endif
+
+#define nsi_disable_port_by_index(dev) \
+	nsi_port_control_by_index(dev, false)
+#define nsi_enable_port_by_index(dev) \
+	nsi_port_control_by_index(dev, true)
+
+#endif
diff --git a/include/linux/sunxi_timer_test.h b/include/linux/sunxi_timer_test.h
new file mode 100644
index 000000000..289c6612c
--- /dev/null
+++ b/include/linux/sunxi_timer_test.h
@@ -0,0 +1,31 @@
+/*
+ * include/linux/sunxi_timer_test.h
+ *
+ * Copyright(c) 2013-2015 Allwinnertech Co., Ltd.
+ *      http://www.allwinnertech.com
+ *
+ * Author: liugang <liugang@allwinnertech.com>
+ *
+ * sunxi timer test head file
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __SUNXI_TIMER_TEST_H
+#define __SUNXI_TIMER_TEST_H
+
+enum e_sunxi_timer_test_cmd {
+	TIMER_TEST_CMD_FUNC_NORMAL,
+	TIMER_TEST_CMD_FUNC_HRTIMER,
+};
+
+struct timer_test_para {
+	unsigned int timer_interv_us; /* timer interval in us */
+	unsigned int print_gap_s;     /* print gap in s */
+	unsigned int total_test_s;    /* total test time in s */
+};
+
+#endif
diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index cd97d2c88..58b666276 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -503,6 +503,7 @@ extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
 extern void pm_wakep_autosleep_enabled(bool set);
 extern void pm_print_active_wakeup_sources(void);
+extern void pm_get_active_wakeup_sources(char *pending_sources, size_t max);
 
 extern void lock_system_sleep(void);
 extern void unlock_system_sleep(void);
diff --git a/include/linux/sys_soc.h b/include/linux/sys_soc.h
index 48ceea867..d9b3cf0f4 100644
--- a/include/linux/sys_soc.h
+++ b/include/linux/sys_soc.h
@@ -15,6 +15,7 @@ struct soc_device_attribute {
 	const char *serial_number;
 	const char *soc_id;
 	const void *data;
+	const struct attribute_group *custom_attr_group;
 };
 
 /**
diff --git a/include/linux/task_io_accounting.h b/include/linux/task_io_accounting.h
index 6f6acce06..bb26108ca 100644
--- a/include/linux/task_io_accounting.h
+++ b/include/linux/task_io_accounting.h
@@ -19,6 +19,8 @@ struct task_io_accounting {
 	u64 syscr;
 	/* # of write syscalls */
 	u64 syscw;
+	/* # of fsync syscalls */
+	u64 syscfs;
 #endif /* CONFIG_TASK_XACCT */
 
 #ifdef CONFIG_TASK_IO_ACCOUNTING
diff --git a/include/linux/task_io_accounting_ops.h b/include/linux/task_io_accounting_ops.h
index bb5498bcd..733ab62ae 100644
--- a/include/linux/task_io_accounting_ops.h
+++ b/include/linux/task_io_accounting_ops.h
@@ -97,6 +97,7 @@ static inline void task_chr_io_accounting_add(struct task_io_accounting *dst,
 	dst->wchar += src->wchar;
 	dst->syscr += src->syscr;
 	dst->syscw += src->syscw;
+	dst->syscfs += src->syscfs;
 }
 #else
 static inline void task_chr_io_accounting_add(struct task_io_accounting *dst,
diff --git a/include/linux/time.h b/include/linux/time.h
index 5f3e49978..47ed31fe5 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -109,4 +109,7 @@ static inline bool itimerspec64_valid(const struct itimerspec64 *its)
  * Equivalent to !(time_before32(@t, @l) || time_after32(@t, @h)).
  */
 #define time_between32(t, l, h) ((u32)(h) - (u32)(l) >= (u32)(t) - (u32)(l))
+
+# include <vdso/time.h>
+
 #endif
diff --git a/include/linux/time32.h b/include/linux/time32.h
index 0a1f302a1..a6a471193 100644
--- a/include/linux/time32.h
+++ b/include/linux/time32.h
@@ -12,19 +12,9 @@
 #include <linux/time64.h>
 #include <linux/timex.h>
 
-#define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
-
-typedef s32		old_time32_t;
-
-struct old_timespec32 {
-	old_time32_t	tv_sec;
-	s32		tv_nsec;
-};
+#include <vdso/time32.h>
 
-struct old_timeval32 {
-	old_time32_t	tv_sec;
-	s32		tv_usec;
-};
+#define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
 
 struct old_itimerspec32 {
 	struct old_timespec32 it_interval;
diff --git a/include/linux/time64.h b/include/linux/time64.h
index 19125489a..c9dcb3e57 100644
--- a/include/linux/time64.h
+++ b/include/linux/time64.h
@@ -3,6 +3,7 @@
 #define _LINUX_TIME64_H
 
 #include <linux/math64.h>
+#include <vdso/time64.h>
 
 typedef __s64 time64_t;
 typedef __u64 timeu64_t;
@@ -19,15 +20,6 @@ struct itimerspec64 {
 	struct timespec64 it_value;
 };
 
-/* Parameters used to convert the timespec values: */
-#define MSEC_PER_SEC	1000L
-#define USEC_PER_MSEC	1000L
-#define NSEC_PER_USEC	1000L
-#define NSEC_PER_MSEC	1000000L
-#define USEC_PER_SEC	1000000L
-#define NSEC_PER_SEC	1000000000L
-#define FSEC_PER_SEC	1000000000000000LL
-
 /* Located here for timespec[64]_valid_strict */
 #define TIME64_MAX			((s64)~((u64)1 << 63))
 #define TIME64_MIN			(-TIME64_MAX - 1)
diff --git a/include/linux/timer.h b/include/linux/timer.h
index 1e6650ed0..4184069aa 100644
--- a/include/linux/timer.h
+++ b/include/linux/timer.h
@@ -7,6 +7,7 @@
 #include <linux/stddef.h>
 #include <linux/debugobjects.h>
 #include <linux/stringify.h>
+#include <linux/android_kabi.h>
 
 struct timer_list {
 	/*
@@ -21,6 +22,9 @@ struct timer_list {
 #ifdef CONFIG_LOCKDEP
 	struct lockdep_map	lockdep_map;
 #endif
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 #ifdef CONFIG_LOCKDEP
diff --git a/include/linux/unicode.h b/include/linux/unicode.h
index 990aa97d8..74484d44c 100644
--- a/include/linux/unicode.h
+++ b/include/linux/unicode.h
@@ -27,6 +27,9 @@ int utf8_normalize(const struct unicode_map *um, const struct qstr *str,
 int utf8_casefold(const struct unicode_map *um, const struct qstr *str,
 		  unsigned char *dest, size_t dlen);
 
+int utf8_casefold_hash(const struct unicode_map *um, const void *salt,
+		       struct qstr *str);
+
 struct unicode_map *utf8_load(const char *version);
 void utf8_unload(struct unicode_map *um);
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index e656e7b4b..a39eb4f60 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -22,6 +22,7 @@
 #include <linux/sched.h>	/* for current && schedule_timeout */
 #include <linux/mutex.h>	/* for struct mutex */
 #include <linux/pm_runtime.h>	/* for runtime PM */
+#include <linux/android_kabi.h>
 
 struct usb_device;
 struct usb_driver;
@@ -257,6 +258,11 @@ struct usb_interface {
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;
 	struct work_struct reset_ws;	/* for resets in atomic context */
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 
@@ -402,6 +408,11 @@ struct usb_host_bos {
 	struct usb_ssp_cap_descriptor	*ssp_cap;
 	struct usb_ss_container_id_descriptor	*ss_id;
 	struct usb_ptm_cap_descriptor	*ptm_cap;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
@@ -465,6 +476,11 @@ struct usb_bus {
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
 #endif
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct usb_dev_state;
@@ -708,6 +724,11 @@ struct usb_device {
 	unsigned lpm_disable_count;
 
 	u16 hub_delay;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 
@@ -1207,6 +1228,11 @@ struct usb_driver {
 	unsigned int supports_autosuspend:1;
 	unsigned int disable_hub_initiated_lpm:1;
 	unsigned int soft_unbind:1;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
 
@@ -1584,6 +1610,10 @@ struct urb {
 	usb_complete_t complete;	/* (in) completion routine */
 	struct usb_iso_packet_descriptor iso_frame_desc[0];
 					/* (in) ISO ONLY */
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 /* ----------------------------------------------------------------------- */
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
index 2040696d7..d66710052 100644
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -590,6 +590,7 @@ struct usb_function_instance {
 	struct config_group group;
 	struct list_head cfs_list;
 	struct usb_function_driver *fd;
+	struct usb_function *f;
 	int (*set_inst_name)(struct usb_function_instance *inst,
 			      const char *name);
 	void (*free_func_inst)(struct usb_function_instance *inst);
diff --git a/include/linux/usb/f_accessory.h b/include/linux/usb/f_accessory.h
new file mode 100644
index 000000000..ebe3c4d59
--- /dev/null
+++ b/include/linux/usb/f_accessory.h
@@ -0,0 +1,23 @@
+/*
+ * Gadget Function Driver for Android USB accessories
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __LINUX_USB_F_ACCESSORY_H
+#define __LINUX_USB_F_ACCESSORY_H
+
+#include <uapi/linux/usb/f_accessory.h>
+
+#endif /* __LINUX_USB_F_ACCESSORY_H */
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 67f5adc9b..7b9b3b2c1 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -25,6 +25,7 @@
 #include <linux/types.h>
 #include <linux/workqueue.h>
 #include <linux/usb/ch9.h>
+#include <linux/android_kabi.h>
 
 #define UDC_TRACE_STR_MAX	512
 
@@ -429,6 +430,11 @@ struct usb_gadget {
 	unsigned			connected:1;
 	unsigned			lpm_capable:1;
 	int				irq;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 #define work_to_gadget(w)	(container_of((w), struct usb_gadget, work))
 
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 712b2a603..d4c80696e 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -25,6 +25,7 @@
 #include <linux/rwsem.h>
 #include <linux/interrupt.h>
 #include <linux/idr.h>
+#include <linux/android_kabi.h>
 
 #define MAX_TOPO_LEVEL		6
 
@@ -225,6 +226,11 @@ struct usb_hcd {
 	 * (ohci 32, uhci 1024, ehci 256/512/1024).
 	 */
 
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
+
 	/* The HC driver's private data is stored at the end of
 	 * this structure.
 	 */
@@ -409,7 +415,12 @@ struct hc_driver {
 	int	(*find_raw_port_number)(struct usb_hcd *, int);
 	/* Call for power on/off the port if necessary */
 	int	(*port_power)(struct usb_hcd *hcd, int portnum, bool enable);
-
+	/* Android vendor reserved */
+	unsigned long android_vendor_data[2];
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)
@@ -560,6 +571,11 @@ struct usb_tt {
 	spinlock_t		lock;
 	struct list_head	clear_list;	/* of usb_tt_clear */
 	struct work_struct	clear_work;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct usb_tt_clear {
diff --git a/include/linux/usb/typec.h b/include/linux/usb/typec.h
index 7df4ecabc..894798084 100644
--- a/include/linux/usb/typec.h
+++ b/include/linux/usb/typec.h
@@ -168,6 +168,23 @@ struct typec_partner_desc {
 	struct usb_pd_identity	*identity;
 };
 
+/**
+ * struct typec_operations - USB Type-C Port Operations
+ * @try_role: Set data role preference for DRP port
+ * @dr_set: Set Data Role
+ * @pr_set: Set Power Role
+ * @vconn_set: Source VCONN
+ * @port_type_set: Set port type
+ */
+struct typec_operations {
+	int (*try_role)(struct typec_port *port, int role);
+	int (*dr_set)(struct typec_port *port, enum typec_data_role role);
+	int (*pr_set)(struct typec_port *port, enum typec_role role);
+	int (*vconn_set)(struct typec_port *port, enum typec_role role);
+	int (*port_type_set)(struct typec_port *port,
+			     enum typec_port_type type);
+};
+
 /*
  * struct typec_capability - USB Type-C Port Capabilities
  * @type: Supported power role of the port
@@ -179,11 +196,8 @@ struct typec_partner_desc {
  * @sw: Cable plug orientation switch
  * @mux: Multiplexer switch for Alternate/Accessory Modes
  * @fwnode: Optional fwnode of the port
- * @try_role: Set data role preference for DRP port
- * @dr_set: Set Data Role
- * @pr_set: Set Power Role
- * @vconn_set: Set VCONN Role
- * @port_type_set: Set port type
+ * @driver_data: Private pointer for driver specific info
+ * @ops: Port operations vector
  *
  * Static capabilities of a single USB Type-C port.
  */
@@ -198,18 +212,9 @@ struct typec_capability {
 	struct typec_switch	*sw;
 	struct typec_mux	*mux;
 	struct fwnode_handle	*fwnode;
+	void			*driver_data;
 
-	int		(*try_role)(const struct typec_capability *,
-				    int role);
-
-	int		(*dr_set)(const struct typec_capability *,
-				  enum typec_data_role);
-	int		(*pr_set)(const struct typec_capability *,
-				  enum typec_role);
-	int		(*vconn_set)(const struct typec_capability *,
-				     enum typec_role);
-	int		(*port_type_set)(const struct typec_capability *,
-					 enum typec_port_type);
+	const struct typec_operations	*ops;
 };
 
 /* Specific to try_role(). Indicates the user want's to clear the preference. */
@@ -241,6 +246,8 @@ int typec_set_orientation(struct typec_port *port,
 enum typec_orientation typec_get_orientation(struct typec_port *port);
 int typec_set_mode(struct typec_port *port, int mode);
 
+void *typec_get_drvdata(struct typec_port *port);
+
 int typec_find_port_power_role(const char *name);
 int typec_find_power_role(const char *name);
 int typec_find_port_data_role(const char *name);
diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index d8860f2d0..e39a261a3 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -23,6 +23,8 @@
 #ifndef	__LINUX_USB_USBNET_H
 #define	__LINUX_USB_USBNET_H
 
+#include <linux/android_kabi.h>
+
 /* interface from usbnet core to each USB networking link we handle */
 struct usbnet {
 	/* housekeeping */
@@ -83,6 +85,11 @@ struct usbnet {
 #		define EVENT_LINK_CHANGE	11
 #		define EVENT_SET_RX_MODE	12
 #		define EVENT_NO_IP_ALIGN	13
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)
@@ -172,6 +179,9 @@ struct driver_info {
 	int		out;		/* tx endpoint */
 
 	unsigned long	data;		/* Misc driver specific data */
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 /* Minidrivers are just drivers using the "usbnet" core as a powerful
diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index fb9f4f799..a8cb8b1a8 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -10,6 +10,7 @@
 #include <linux/rwsem.h>
 #include <linux/sysctl.h>
 #include <linux/err.h>
+#include <linux/android_kabi.h>
 
 #define UID_GID_MAP_MAX_BASE_EXTENTS 5
 #define UID_GID_MAP_MAX_EXTENTS 340
@@ -86,6 +87,9 @@ struct user_namespace {
 #endif
 	struct ucounts		*ucounts;
 	int ucount_max[UCOUNT_COUNTS];
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 } __randomize_layout;
 
 struct ucounts {
diff --git a/include/linux/vm_event_item.h b/include/linux/vm_event_item.h
index 47a3441cf..9d20f7567 100644
--- a/include/linux/vm_event_item.h
+++ b/include/linux/vm_event_item.h
@@ -70,7 +70,7 @@ enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
 		UNEVICTABLE_PGMUNLOCKED,
 		UNEVICTABLE_PGCLEARED,	/* on COW, page truncate */
 		UNEVICTABLE_PGSTRANDED,	/* unable to isolate on unlock */
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_GKI_OPT_FEATURES)
 		THP_FAULT_ALLOC,
 		THP_FAULT_FALLBACK,
 		THP_COLLAPSE_ALLOC,
diff --git a/include/linux/wakeup_reason.h b/include/linux/wakeup_reason.h
new file mode 100644
index 000000000..54f5caaa5
--- /dev/null
+++ b/include/linux/wakeup_reason.h
@@ -0,0 +1,37 @@
+/*
+ * include/linux/wakeup_reason.h
+ *
+ * Logs the reason which caused the kernel to resume
+ * from the suspend mode.
+ *
+ * Copyright (C) 2014 Google, Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _LINUX_WAKEUP_REASON_H
+#define _LINUX_WAKEUP_REASON_H
+
+#define MAX_SUSPEND_ABORT_LEN 256
+
+#ifdef CONFIG_SUSPEND
+void log_irq_wakeup_reason(int irq);
+void log_threaded_irq_wakeup_reason(int irq, int parent_irq);
+void log_suspend_abort_reason(const char *fmt, ...);
+void log_abnormal_wakeup_reason(const char *fmt, ...);
+void clear_wakeup_reasons(void);
+#else
+static inline void log_irq_wakeup_reason(int irq) { }
+static inline void log_threaded_irq_wakeup_reason(int irq, int parent_irq) { }
+static inline void log_suspend_abort_reason(const char *fmt, ...) { }
+static inline void log_abnormal_wakeup_reason(const char *fmt, ...) { }
+static inline void clear_wakeup_reasons(void) { }
+#endif
+
+#endif /* _LINUX_WAKEUP_REASON_H */
diff --git a/include/linux/workqueue.h b/include/linux/workqueue.h
index 4261d1c6e..71726c98c 100644
--- a/include/linux/workqueue.h
+++ b/include/linux/workqueue.h
@@ -14,6 +14,7 @@
 #include <linux/atomic.h>
 #include <linux/cpumask.h>
 #include <linux/rcupdate.h>
+#include <linux/android_kabi.h>
 
 struct workqueue_struct;
 
@@ -106,6 +107,8 @@ struct work_struct {
 #ifdef CONFIG_LOCKDEP
 	struct lockdep_map lockdep_map;
 #endif
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 #define WORK_DATA_INIT()	ATOMIC_LONG_INIT((unsigned long)WORK_STRUCT_NO_POOL)
@@ -119,6 +122,9 @@ struct delayed_work {
 	/* target workqueue and CPU ->timer uses to queue ->work */
 	struct workqueue_struct *wq;
 	int cpu;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
 };
 
 struct rcu_work {
diff --git a/include/linux/xattr.h b/include/linux/xattr.h
index 3a71ad716..0d970fdc6 100644
--- a/include/linux/xattr.h
+++ b/include/linux/xattr.h
@@ -30,10 +30,10 @@ struct xattr_handler {
 	const char *prefix;
 	int flags;      /* fs private flags */
 	bool (*list)(struct dentry *dentry);
-	int (*get)(const struct xattr_handler *, struct dentry *dentry,
+	int (*get)(const struct xattr_handler *handler, struct dentry *dentry,
 		   struct inode *inode, const char *name, void *buffer,
-		   size_t size);
-	int (*set)(const struct xattr_handler *, struct dentry *dentry,
+		   size_t size, int flags);
+	int (*set)(const struct xattr_handler *handler, struct dentry *dentry,
 		   struct inode *inode, const char *name, const void *buffer,
 		   size_t size, int flags);
 };
@@ -46,7 +46,8 @@ struct xattr {
 	size_t value_len;
 };
 
-ssize_t __vfs_getxattr(struct dentry *, struct inode *, const char *, void *, size_t);
+ssize_t __vfs_getxattr(struct dentry *dentry, struct inode *inode,
+		       const char *name, void *buffer, size_t size, int flags);
 ssize_t vfs_getxattr(struct dentry *, const char *, void *, size_t);
 ssize_t vfs_listxattr(struct dentry *d, char *list, size_t size);
 int __vfs_setxattr(struct dentry *, struct inode *, const char *, const void *, size_t, int);
-- 
2.17.1

