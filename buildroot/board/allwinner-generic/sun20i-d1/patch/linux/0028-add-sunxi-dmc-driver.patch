From 4aa2cd426abb1dfb5b73e4e0c0acd7c98e4be511 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 16:52:39 +0800
Subject: [PATCH 28/93] add sunxi dmc driver

---
 drivers/devfreq/Kconfig              |  15 ++
 drivers/devfreq/Makefile             |   1 +
 drivers/devfreq/event/Kconfig        |   7 +
 drivers/devfreq/event/Makefile       |   1 +
 drivers/devfreq/event/sunxi-nsipmu.c | 196 +++++++++++++++++++
 drivers/devfreq/sunxi-dmc.c          | 273 +++++++++++++++++++++++++++
 6 files changed, 493 insertions(+)
 create mode 100644 drivers/devfreq/event/sunxi-nsipmu.c
 create mode 100644 drivers/devfreq/sunxi-dmc.c

diff --git a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
index 1433f2ba9..0f9c198d2 100644
--- a/drivers/devfreq/Kconfig
+++ b/drivers/devfreq/Kconfig
@@ -129,6 +129,21 @@ config ARM_RK3399_DMC_DEVFREQ
           It sets the frequency for the memory controller and reads the usage counts
           from hardware.
 
+config ARM_SUNXI_DMC_DEVFREQ
+	tristate "ARM SUNXI DMC DEVFREQ Driver"
+	depends on ARCH_SUNXI || COMPILE_TEST
+	select DEVFREQ_EVENT_SUNXI_DFI
+	select DEVFREQ_GOV_SIMPLE_ONDEMAND
+	select PM_DEVFREQ_EVENT
+	select PM_OPP
+
+	help
+          This adds the DEVFREQ driver for the A100 DMC(Dynamic Memory Controller).
+          It sets the frequency for the memory controller and reads the usage counts
+          from hardware.
+
+	  If in doubt, say N.
+
 source "drivers/devfreq/event/Kconfig"
 
 endif # PM_DEVFREQ
diff --git a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
index 338ae8440..d4bc9b926 100644
--- a/drivers/devfreq/Makefile
+++ b/drivers/devfreq/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_ARM_EXYNOS_BUS_DEVFREQ)	+= exynos-bus.o
 obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
 obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
 obj-$(CONFIG_ARM_TEGRA20_DEVFREQ)	+= tegra20-devfreq.o
+obj-$(CONFIG_ARM_SUNXI_DMC_DEVFREQ)	+= sunxi-dmc.o
 
 # DEVFREQ Event Drivers
 obj-$(CONFIG_PM_DEVFREQ_EVENT)		+= event/
diff --git a/drivers/devfreq/event/Kconfig b/drivers/devfreq/event/Kconfig
index a53e0a6ff..89f73c348 100644
--- a/drivers/devfreq/event/Kconfig
+++ b/drivers/devfreq/event/Kconfig
@@ -39,4 +39,11 @@ config DEVFREQ_EVENT_ROCKCHIP_DFI
 	  This add the devfreq-event driver for Rockchip SoC. It provides DFI
 	  (DDR Monitor Module) driver to count ddr load.
 
+config DEVFREQ_EVENT_SUNXI_DFI
+	tristate "ALLWINNER DFI DEVFREQ event Driver"
+	depends on ARCH_SUNXI || COMPILE_TEST
+	help
+	  This add the devfreq-event driver for Allwinner SoC. It provides DFI
+	  (DDR Monitor Module) driver to count ddr load.
+
 endif # PM_DEVFREQ_EVENT
diff --git a/drivers/devfreq/event/Makefile b/drivers/devfreq/event/Makefile
index 3c847e5d5..48a68e2db 100644
--- a/drivers/devfreq/event/Makefile
+++ b/drivers/devfreq/event/Makefile
@@ -4,3 +4,4 @@
 obj-$(CONFIG_DEVFREQ_EVENT_EXYNOS_NOCP) += exynos-nocp.o
 obj-$(CONFIG_DEVFREQ_EVENT_EXYNOS_PPMU) += exynos-ppmu.o
 obj-$(CONFIG_DEVFREQ_EVENT_ROCKCHIP_DFI) += rockchip-dfi.o
+obj-$(CONFIG_DEVFREQ_EVENT_SUNXI_DFI) += sunxi-nsipmu.o
diff --git a/drivers/devfreq/event/sunxi-nsipmu.c b/drivers/devfreq/event/sunxi-nsipmu.c
new file mode 100644
index 000000000..dff243f50
--- /dev/null
+++ b/drivers/devfreq/event/sunxi-nsipmu.c
@@ -0,0 +1,196 @@
+/*
+ * Allwinner DFI support.
+ *
+ * Copyright (C) 2019 Allwinner Technology, Inc.
+ *	fanqinghua <fanqinghua@allwinnertech.com>
+ *
+ * Supplied ddr loading info for devfreq.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/devfreq-event.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/of.h>
+
+#define SUNXI_RA1PE	0x2CC0
+#define SUNXI_RA1PC	0x2CC4
+#define SUNXI_RA1PP	0x2CC8
+#define SUNXI_RA1DR	0x2CD4
+#define SUNXI_RA1DW	0x2CD8
+
+#define PERIOD		100	/* ms */
+#define SECOND		1000	/* ms(const) */
+
+#define DRIVER_NAME	"DFI Driver"
+/*
+ * The dfi controller can monitor DDR load. It has an upper and lower threshold
+ * for the operating points. Whenever the usage leaves these bounds an event is
+ * generated to indicate the DDR frequency should be changed.
+ */
+struct sunxi_nsipmu {
+	struct clk *dram_clk;
+	struct devfreq_event_dev *edev;
+	struct devfreq_event_desc *desc;
+	struct device *dev;
+	struct regmap *regmap;
+};
+
+static void sunxi_nsipmu_start_hardware_counter(struct devfreq_event_dev *edev)
+{
+	struct sunxi_nsipmu *info = devfreq_event_get_drvdata(edev);
+	unsigned int val;
+
+	/* Automatically updated every 100ms */
+	val = ((clk_get_rate(info->dram_clk)  >> 1) / SECOND) * PERIOD;
+	regmap_write(info->regmap, SUNXI_RA1PP, val);
+	regmap_write(info->regmap, SUNXI_RA1PE, BIT(0));
+}
+
+static void sunxi_nsipmu_stop_hardware_counter(struct devfreq_event_dev *edev)
+{
+	struct sunxi_nsipmu *info = devfreq_event_get_drvdata(edev);
+
+	regmap_write(info->regmap, SUNXI_RA1PE, 0);
+}
+
+static int sunxi_nsipmu_disable(struct devfreq_event_dev *edev)
+{
+	sunxi_nsipmu_stop_hardware_counter(edev);
+
+	return 0;
+}
+
+static int sunxi_nsipmu_enable(struct devfreq_event_dev *edev)
+{
+	sunxi_nsipmu_start_hardware_counter(edev);
+	return 0;
+}
+
+static int sunxi_nsipmu_set_event(struct devfreq_event_dev *edev)
+{
+	return 0;
+}
+
+static int sunxi_nsipmu_get_event(struct devfreq_event_dev *edev,
+				  struct devfreq_event_data *edata)
+{
+	struct sunxi_nsipmu *info = devfreq_event_get_drvdata(edev);
+	unsigned int read_data, write_data;
+
+	regmap_read(info->regmap, SUNXI_RA1DR, &read_data);
+	regmap_read(info->regmap, SUNXI_RA1DW, &write_data);
+
+	info->dram_clk = devm_clk_get(info->dev, "dram");
+	if (IS_ERR(info->dram_clk))
+		return PTR_ERR(info->dram_clk);
+	dev_info(info->dev, "dram_clk:%ld\n", clk_get_rate(info->dram_clk));
+	/*
+	 * read/write: In byte
+	 * Max Utilization
+	 *
+	 * load = (read + write) / (dram_clk * 2 * 4)
+	 */
+	edata->load_count = (unsigned long)(read_data + write_data);
+	edata->total_count = (clk_get_rate(info->dram_clk) * 8 * PERIOD) / SECOND;
+
+	dev_info(info->dev, "load:%ld access:%ld total:%ld\n",
+				edata->load_count * 100 / edata->total_count,
+				edata->load_count, edata->total_count);
+
+	return 0;
+}
+
+static const struct devfreq_event_ops sunxi_nsipmu_ops = {
+	.disable = sunxi_nsipmu_disable,
+	.enable = sunxi_nsipmu_enable,
+	.get_event = sunxi_nsipmu_get_event,
+	.set_event = sunxi_nsipmu_set_event,
+};
+
+static const struct of_device_id sunxi_nsipmu_id_match[] = {
+	{
+		.compatible = "allwinner,sunxi-dfi",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sunxi_nsipmu_id_match);
+
+static int sunxi_nsipmu_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sunxi_nsipmu *data;
+	struct devfreq_event_desc *desc;
+	struct device_node *np = pdev->dev.of_node;
+
+	data = devm_kzalloc(dev, sizeof(struct sunxi_nsipmu), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->dram_clk = devm_clk_get(dev, "dram");
+	if (IS_ERR(data->dram_clk)) {
+		dev_err(&pdev->dev, "devm_clk_get error!\n");
+		return PTR_ERR(data->dram_clk);
+	}
+
+	data->regmap = syscon_node_to_regmap(dev->of_node);
+	if (IS_ERR(data->regmap)) {
+		dev_err(&pdev->dev, "syscon_node_to_regmap error!\n");
+		return PTR_ERR(data->regmap);
+	}
+
+	data->dev = dev;
+
+	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+	if (!desc)
+		return -ENOMEM;
+
+	desc->ops = &sunxi_nsipmu_ops;
+	desc->driver_data = data;
+	desc->name = np->name;
+	data->desc = desc;
+
+	data->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);
+	if (IS_ERR(data->edev)) {
+		dev_err(&pdev->dev, "devm_devfreq_event_add_edev error!\n");
+		return PTR_ERR(data->edev);
+	}
+
+	platform_set_drvdata(pdev, data);
+
+	return 0;
+}
+
+static int sunxi_nsipmu_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver sunxi_nsipmu_driver = {
+	.probe	= sunxi_nsipmu_probe,
+	.remove  = sunxi_nsipmu_remove,
+	.driver = {
+		.name	= "sunxi-nsipmu",
+		.of_match_table = sunxi_nsipmu_id_match,
+	},
+};
+
+module_platform_driver(sunxi_nsipmu_driver);
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("sunxi dfi driver");
+MODULE_ALIAS("platform:" DRIVER_NAME);
+MODULE_AUTHOR("fanqinghua <fanqinghua@allwinnertech.com>");
+MODULE_AUTHOR("frank <frank@allwinnertech.com>");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/devfreq/sunxi-dmc.c b/drivers/devfreq/sunxi-dmc.c
new file mode 100644
index 000000000..c19923c81
--- /dev/null
+++ b/drivers/devfreq/sunxi-dmc.c
@@ -0,0 +1,273 @@
+/*
+ * Allwinner GPU power domain support.
+ *
+ * Copyright (C) 2019 Allwinner Technology, Inc.
+ *	fanqinghua <fanqinghua@allwinnertech.com>
+ *
+ * Implementation of gpu specific power domain control which is used in
+ * conjunction with runtime-pm. Support for both device-tree and non-device-tree
+ * based power domain support is included.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/devfreq.h>
+#include <linux/devfreq-event.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/suspend.h>
+
+#define DRIVER_NAME	"devfreq Driver"
+
+struct sunxi_dmcfreq {
+	struct device *dev;
+	struct devfreq *devfreq;
+	struct devfreq_simple_ondemand_data ondemand_data;
+	struct clk *dmc_clk;
+	struct devfreq_event_dev *edev;
+	struct mutex lock;
+
+	unsigned long rate, target_rate;
+	struct dev_pm_opp *curr_opp;
+};
+
+static int sunxi_dmc_target(struct device *dev,
+						unsigned long *freq, u32 flags)
+{
+	struct sunxi_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	unsigned long target_rate;
+	struct dev_pm_opp *opp;
+	int rc = 0;
+
+	rcu_read_lock();
+	opp = devfreq_recommended_opp(dev, freq, flags);
+	if (IS_ERR(opp)) {
+		rcu_read_unlock();
+		return PTR_ERR(opp);
+	}
+
+	target_rate = dev_pm_opp_get_freq(opp);
+	dmcfreq->rate = dev_pm_opp_get_freq(dmcfreq->curr_opp);
+	rcu_read_unlock();
+
+	if (dmcfreq->rate == target_rate)
+		return 0;
+
+	/* start frequency scaling */
+	mutex_lock(&dmcfreq->lock);
+
+	rc = clk_set_rate(dmcfreq->dmc_clk, target_rate);
+	if (rc)
+		goto out;
+
+	dmcfreq->rate = clk_get_rate(dmcfreq->dmc_clk);
+	if (dmcfreq->rate != target_rate)
+		dev_err(dev, "Get wrong ddr frequency, Request frequency %lu,\
+			Current frequency %lu\n", target_rate, dmcfreq->rate);
+
+	dmcfreq->curr_opp = opp;
+
+out:
+	mutex_unlock(&dmcfreq->lock);
+	return rc;
+}
+
+static int sunxi_get_dev_status(struct device *dev,
+				struct devfreq_dev_status *stat)
+{
+	struct sunxi_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	struct devfreq_event_data edata;
+	ret = devfreq_event_get_event(dmcfreq->edev, &edata);
+	if (ret < 0)
+		return ret;
+
+	stat->current_frequency = dmcfreq->rate;
+	stat->busy_time = edata.load_count;
+	stat->total_time = edata.total_count;
+
+	return ret;
+}
+
+static int sunxi_dmcfreq_get_cur_freq(struct device *dev, unsigned long *freq)
+{
+	struct sunxi_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+
+	*freq = dmcfreq->rate;
+
+	return 0;
+}
+
+static struct devfreq_dev_profile sunxi_dmcfreq_profile = {
+	.polling_ms     = 100,
+	.target         = sunxi_dmc_target,
+	.get_dev_status = sunxi_get_dev_status,
+	.get_cur_freq   = sunxi_dmcfreq_get_cur_freq,
+};
+
+static const struct of_device_id sunxi_dmcfreq_match[] = {
+	{ .compatible = "allwinner,sunxi-dmc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_dmcfreq_match);
+
+static int sunxi_dmcfreq_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct sunxi_dmcfreq *dmcfreq;
+	int rc = 0;
+
+	dmcfreq = devm_kzalloc(dev, sizeof(*dmcfreq), GFP_KERNEL);
+	if (!dmcfreq)
+		return -ENOMEM;
+
+	mutex_init(&dmcfreq->lock);
+
+	dmcfreq->dmc_clk = devm_clk_get(dev, "dram");
+	if (IS_ERR(dmcfreq->dmc_clk)) {
+		dev_err(&pdev->dev, "devm_clk_get error!\n");
+		return PTR_ERR(dmcfreq->dmc_clk);
+	}
+
+	dmcfreq->edev = devfreq_event_get_edev_by_phandle(dev, 0);
+	if (IS_ERR(dmcfreq->edev)) {
+		dev_err(&pdev->dev, "event get phandle error!\n");
+		return -EPROBE_DEFER;
+	}
+
+	rc = devfreq_event_enable_edev(dmcfreq->edev);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "devfreq_event_enable_edev error!\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * We add a devfreq driver to our parent since it has a device tree node
+	 * with operating points.
+	 */
+	rc = dev_pm_opp_of_add_table(dev);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "dev_pm_opp_of_add_table error!\n");
+		goto err_opp;
+	}
+
+	of_property_read_u32(np, "upthreshold",
+			     &dmcfreq->ondemand_data.upthreshold);
+	of_property_read_u32(np, "downdifferential",
+			     &dmcfreq->ondemand_data.downdifferential);
+
+	dmcfreq->rate = clk_get_rate(dmcfreq->dmc_clk);
+
+	rcu_read_lock();
+	dmcfreq->curr_opp = devfreq_recommended_opp(dev, &dmcfreq->rate,
+					DEVFREQ_FLAG_LEAST_UPPER_BOUND);
+	if (IS_ERR(dmcfreq->curr_opp)) {
+		dev_err(&pdev->dev, "devfreq_recommended_opp error!\n");
+		rcu_read_unlock();
+		rc = PTR_ERR(dmcfreq->curr_opp);
+		goto err;
+	}
+	rcu_read_unlock();
+
+	/* Add devfreq device to monitor */
+	dmcfreq->devfreq = devm_devfreq_add_device(dev,
+						   &sunxi_dmcfreq_profile,
+						   "simple_ondemand",
+						   &dmcfreq->ondemand_data);
+	if (IS_ERR(dmcfreq->devfreq)) {
+		dev_err(&pdev->dev, "devm_devfreq_add_device error!\n");
+		rc = PTR_ERR(dmcfreq->devfreq);
+		goto err;
+	}
+	devm_devfreq_register_opp_notifier(dev, dmcfreq->devfreq);
+
+	dmcfreq->dev = dev;
+	platform_set_drvdata(pdev, dmcfreq);
+
+	return 0;
+
+err:
+	dev_pm_opp_of_remove_table(dev);
+err_opp:
+	devfreq_event_disable_edev(dmcfreq->edev);
+	return rc;
+}
+
+static int sunxi_dmcfreq_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sunxi_dmcfreq *dmcfreq = platform_get_drvdata(pdev);
+
+	dev_pm_opp_of_remove_table(dev);
+	devfreq_event_disable_edev(dmcfreq->edev);
+	return 0;
+}
+
+static __maybe_unused int sunxi_dmcfreq_suspend(struct device *dev)
+{
+	struct sunxi_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = devfreq_event_disable_edev(dmcfreq->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to disable the devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = devfreq_suspend_device(dmcfreq->devfreq);
+	if (ret < 0) {
+		dev_err(dev, "failed to suspend the devfreq devices\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static __maybe_unused int sunxi_dmcfreq_resume(struct device *dev)
+{
+	struct sunxi_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = devfreq_event_enable_edev(dmcfreq->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable the devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = devfreq_resume_device(dmcfreq->devfreq);
+	if (ret < 0) {
+		dev_err(dev, "failed to resume the devfreq devices\n");
+		return ret;
+	}
+	return ret;
+}
+
+static SIMPLE_DEV_PM_OPS(sunxi_dmcfreq_pm, sunxi_dmcfreq_suspend,
+			 sunxi_dmcfreq_resume);
+
+static struct platform_driver sunxi_dmcfreq_driver = {
+	.probe  = sunxi_dmcfreq_probe,
+	.remove  = sunxi_dmcfreq_remove,
+	.driver = {
+		.name = "sunxi-dmcfreq",
+		.pm = &sunxi_dmcfreq_pm,
+		.of_match_table = sunxi_dmcfreq_match,
+	},
+};
+
+module_platform_driver(sunxi_dmcfreq_driver);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SUNXI dmcfreq driver");
+MODULE_ALIAS("platform:" DRIVER_NAME);
+MODULE_AUTHOR("fanqinghua <fanqinghua@allwinnertech.com>");
+MODULE_VERSION("1.0.0");
-- 
2.17.1

