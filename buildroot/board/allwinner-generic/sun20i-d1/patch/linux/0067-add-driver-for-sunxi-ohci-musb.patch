From 6be40a17d4c0b06948a2932fe2141c29c0ac760a Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 17:16:12 +0800
Subject: [PATCH 67/93] add driver for sunxi ohci musb

---
 drivers/usb/Kconfig                           |    4 +-
 drivers/usb/Makefile                          |    3 +
 drivers/usb/core/hub.c                        |    5 +
 drivers/usb/dwc3/core.c                       |   22 +-
 drivers/usb/dwc3/core.h                       |    6 +
 drivers/usb/dwc3/drd.c                        |   96 +-
 drivers/usb/gadget/Kconfig                    |   59 +-
 drivers/usb/gadget/configfs.c                 |  305 +-
 drivers/usb/gadget/function/Makefile          |    4 +
 drivers/usb/gadget/function/f_accessory.c     | 1366 ++++++
 drivers/usb/gadget/function/f_audio_source.c  | 1071 +++++
 drivers/usb/gadget/function/f_midi.c          |   66 +
 drivers/usb/gadget/function/f_uac1.c          |   26 +-
 drivers/usb/gadget/legacy/Kconfig             |   39 +
 drivers/usb/gadget/legacy/Makefile            |    1 +
 drivers/usb/gadget/legacy/raw_gadget.c        | 1280 ++++++
 drivers/usb/gadget/udc/Kconfig                |   15 +-
 drivers/usb/gadget/udc/core.c                 |    4 +
 drivers/usb/gadget/udc/dummy_hcd.c            |   26 +-
 drivers/usb/host/Kconfig                      |  163 +
 drivers/usb/host/Makefile                     |    5 +
 drivers/usb/host/ehci-hcd.c                   |   12 +
 drivers/usb/host/ehci-hub.c                   |    1 -
 drivers/usb/host/ehci-sunxi.c                 | 1179 +++++
 drivers/usb/host/ehci.h                       |    1 +
 drivers/usb/host/ohci-hcd.c                   |   10 +
 drivers/usb/host/ohci-sunxi.c                 |  839 ++++
 drivers/usb/host/ohci.h                       |    2 +
 drivers/usb/host/sunxi-hci.c                  | 2259 ++++++++++
 drivers/usb/host/sunxi-hci.h                  |  495 ++
 drivers/usb/host/xhci-pci-renesas.c           |  985 ++++
 drivers/usb/host/xhci-pci.c                   |   18 +-
 drivers/usb/host/xhci-pci.h                   |   18 +
 drivers/usb/host/xhci_sunxi.c                 |  798 ++++
 drivers/usb/musb/Kconfig                      |    9 +-
 drivers/usb/musb/Makefile                     |    1 +
 drivers/usb/musb/mediatek.c                   |  588 +++
 drivers/usb/musb/musb_core.c                  |   84 +-
 drivers/usb/musb/musb_core.h                  |   17 +-
 drivers/usb/musb/musb_dma.h                   |    9 +
 drivers/usb/musb/musb_host.c                  |   46 +-
 drivers/usb/musb/musb_io.h                    |   18 +-
 drivers/usb/musb/musbhsdma.c                  |   56 +-
 drivers/usb/musb/sunxi.c                      |    4 +-
 drivers/usb/musb/tusb6010.c                   |    2 +-
 drivers/usb/sunxi_usb/Kconfig                 |   52 +
 drivers/usb/sunxi_usb/Makefile                |   35 +
 drivers/usb/sunxi_usb/include/sunxi_hcd.h     |  103 +
 drivers/usb/sunxi_usb/include/sunxi_sys_reg.h |   22 +
 drivers/usb/sunxi_usb/include/sunxi_udc.h     |  299 ++
 .../usb/sunxi_usb/include/sunxi_usb_board.h   |  136 +
 drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h |  966 ++++
 .../usb/sunxi_usb/include/sunxi_usb_config.h  |   44 +
 .../usb/sunxi_usb/include/sunxi_usb_debug.h   |   93 +
 .../usb/sunxi_usb/include/sunxi_usb_typedef.h |   68 +
 .../usb/sunxi_usb/manager/usb_hcd_servers.c   |  147 +
 .../usb/sunxi_usb/manager/usb_hcd_servers.h   |   27 +
 drivers/usb/sunxi_usb/manager/usb_hw_scan.c   |  646 +++
 drivers/usb/sunxi_usb/manager/usb_hw_scan.h   |   61 +
 drivers/usb/sunxi_usb/manager/usb_manager.c   |  562 +++
 drivers/usb/sunxi_usb/manager/usb_manager.h   |   28 +
 .../usb/sunxi_usb/manager/usb_msg_center.c    |  340 ++
 .../usb/sunxi_usb/manager/usb_msg_center.h    |   67 +
 .../usb/sunxi_usb/manager/usbc0_platform.c    |  227 +
 drivers/usb/sunxi_usb/manager/usbc_platform.h |   23 +
 drivers/usb/sunxi_usb/misc/sunxi_usb_debug.c  |  238 +
 drivers/usb/sunxi_usb/udc/sunxi_udc.c         | 3961 +++++++++++++++++
 drivers/usb/sunxi_usb/udc/sunxi_udc_board.c   |  255 ++
 drivers/usb/sunxi_usb/udc/sunxi_udc_board.h   |   28 +
 drivers/usb/sunxi_usb/udc/sunxi_udc_config.h  |   56 +
 drivers/usb/sunxi_usb/udc/sunxi_udc_debug.c   |   60 +
 drivers/usb/sunxi_usb/udc/sunxi_udc_debug.h   |   22 +
 drivers/usb/sunxi_usb/udc/sunxi_udc_dma.c     |  622 +++
 drivers/usb/sunxi_usb/udc/sunxi_udc_dma.h     |   79 +
 drivers/usb/sunxi_usb/usbc/usbc.c             | 1450 ++++++
 drivers/usb/sunxi_usb/usbc/usbc_dev.c         | 1325 ++++++
 drivers/usb/sunxi_usb/usbc/usbc_i.h           |   57 +
 drivers/usb/sunxi_usb/usbc/usbc_phy.c         |  408 ++
 drivers/usb/typec/class.c                     |   42 +-
 drivers/usb/typec/tcpm/tcpm.c                 |   45 +-
 drivers/usb/typec/tps6598x.c                  |   49 +-
 drivers/usb/typec/ucsi/ucsi.c                 |   22 +-
 82 files changed, 24449 insertions(+), 233 deletions(-)
 create mode 100644 drivers/usb/gadget/function/f_accessory.c
 create mode 100644 drivers/usb/gadget/function/f_audio_source.c
 create mode 100644 drivers/usb/gadget/legacy/raw_gadget.c
 create mode 100644 drivers/usb/host/ehci-sunxi.c
 create mode 100644 drivers/usb/host/ohci-sunxi.c
 create mode 100644 drivers/usb/host/sunxi-hci.c
 create mode 100644 drivers/usb/host/sunxi-hci.h
 create mode 100644 drivers/usb/host/xhci-pci-renesas.c
 create mode 100644 drivers/usb/host/xhci-pci.h
 create mode 100644 drivers/usb/host/xhci_sunxi.c
 create mode 100644 drivers/usb/musb/mediatek.c
 create mode 100644 drivers/usb/sunxi_usb/Kconfig
 create mode 100644 drivers/usb/sunxi_usb/Makefile
 create mode 100644 drivers/usb/sunxi_usb/include/sunxi_hcd.h
 create mode 100644 drivers/usb/sunxi_usb/include/sunxi_sys_reg.h
 create mode 100644 drivers/usb/sunxi_usb/include/sunxi_udc.h
 create mode 100644 drivers/usb/sunxi_usb/include/sunxi_usb_board.h
 create mode 100644 drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h
 create mode 100644 drivers/usb/sunxi_usb/include/sunxi_usb_config.h
 create mode 100644 drivers/usb/sunxi_usb/include/sunxi_usb_debug.h
 create mode 100644 drivers/usb/sunxi_usb/include/sunxi_usb_typedef.h
 create mode 100644 drivers/usb/sunxi_usb/manager/usb_hcd_servers.c
 create mode 100644 drivers/usb/sunxi_usb/manager/usb_hcd_servers.h
 create mode 100644 drivers/usb/sunxi_usb/manager/usb_hw_scan.c
 create mode 100644 drivers/usb/sunxi_usb/manager/usb_hw_scan.h
 create mode 100644 drivers/usb/sunxi_usb/manager/usb_manager.c
 create mode 100644 drivers/usb/sunxi_usb/manager/usb_manager.h
 create mode 100644 drivers/usb/sunxi_usb/manager/usb_msg_center.c
 create mode 100644 drivers/usb/sunxi_usb/manager/usb_msg_center.h
 create mode 100644 drivers/usb/sunxi_usb/manager/usbc0_platform.c
 create mode 100644 drivers/usb/sunxi_usb/manager/usbc_platform.h
 create mode 100644 drivers/usb/sunxi_usb/misc/sunxi_usb_debug.c
 create mode 100644 drivers/usb/sunxi_usb/udc/sunxi_udc.c
 create mode 100644 drivers/usb/sunxi_usb/udc/sunxi_udc_board.c
 create mode 100644 drivers/usb/sunxi_usb/udc/sunxi_udc_board.h
 create mode 100644 drivers/usb/sunxi_usb/udc/sunxi_udc_config.h
 create mode 100644 drivers/usb/sunxi_usb/udc/sunxi_udc_debug.c
 create mode 100644 drivers/usb/sunxi_usb/udc/sunxi_udc_debug.h
 create mode 100644 drivers/usb/sunxi_usb/udc/sunxi_udc_dma.c
 create mode 100644 drivers/usb/sunxi_usb/udc/sunxi_udc_dma.h
 create mode 100644 drivers/usb/sunxi_usb/usbc/usbc.c
 create mode 100644 drivers/usb/sunxi_usb/usbc/usbc_dev.c
 create mode 100644 drivers/usb/sunxi_usb/usbc/usbc_i.h
 create mode 100644 drivers/usb/sunxi_usb/usbc/usbc_phy.c

diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 275568abc..7718f584a 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -42,7 +42,7 @@ config USB_ARCH_HAS_HCD
 	def_bool y
 
 config USB
-	tristate "Support for Host-side USB"
+	bool "Support for Host-side USB"
 	depends on USB_ARCH_HAS_HCD
 	select GENERIC_ALLOCATOR
 	select USB_COMMON
@@ -170,6 +170,8 @@ source "drivers/usb/phy/Kconfig"
 
 source "drivers/usb/gadget/Kconfig"
 
+source "drivers/usb/sunxi_usb/Kconfig"
+
 source "drivers/usb/typec/Kconfig"
 
 source "drivers/usb/roles/Kconfig"
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index 1c1c1d659..dfb071f5e 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_USB_CDNS3)		+= cdns3/
 obj-$(CONFIG_USB_MON)		+= mon/
 obj-$(CONFIG_USB_MTU3)		+= mtu3/
 
+obj-$(CONFIG_USB_SUNXI_HCI)	+= host/
 obj-$(CONFIG_USB_PCI)		+= host/
 obj-$(CONFIG_USB_EHCI_HCD)	+= host/
 obj-$(CONFIG_USB_ISP116X_HCD)	+= host/
@@ -63,6 +64,8 @@ obj-$(CONFIG_USB_GADGET)	+= gadget/
 
 obj-$(CONFIG_USBIP_CORE)	+= usbip/
 
+obj-$(CONFIG_USB_SUNXI_USB)     += sunxi_usb/
+
 obj-$(CONFIG_TYPEC)		+= typec/
 
 obj-$(CONFIG_USB_ROLE_SWITCH)	+= roles/
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4d3de3388..d459bea0c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -18,6 +18,7 @@
 #include <linux/sched/mm.h>
 #include <linux/list.h>
 #include <linux/slab.h>
+#include <linux/kcov.h>
 #include <linux/ioctl.h>
 #include <linux/usb.h>
 #include <linux/usbdevice_fs.h>
@@ -5398,6 +5399,8 @@ static void hub_event(struct work_struct *work)
 	hub_dev = hub->intfdev;
 	intf = to_usb_interface(hub_dev);
 
+	kcov_remote_start_usb((u64)hdev->bus->busnum);
+
 	dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",
 			hdev->state, hdev->maxchild,
 			/* NOTE: expects max 15 ports... */
@@ -5504,6 +5507,8 @@ static void hub_event(struct work_struct *work)
 	/* Balance the stuff in kick_hub_wq() and allow autosuspend */
 	usb_autopm_put_interface(intf);
 	kref_put(&hub->kref, hub_release);
+
+	kcov_remote_stop();
 }
 
 static const struct usb_device_id hub_id_table[] = {
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 526c275ad..0bdc4c29d 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -289,12 +289,6 @@ static int dwc3_core_soft_reset(struct dwc3 *dwc)
 	return 0;
 }
 
-static const struct clk_bulk_data dwc3_core_clks[] = {
-	{ .id = "ref" },
-	{ .id = "bus_early" },
-	{ .id = "suspend" },
-};
-
 /*
  * dwc3_frame_length_adjustment - Adjusts frame length if required
  * @dwc3: Pointer to our controller context structure
@@ -1409,11 +1403,6 @@ static int dwc3_probe(struct platform_device *pdev)
 	if (!dwc)
 		return -ENOMEM;
 
-	dwc->clks = devm_kmemdup(dev, dwc3_core_clks, sizeof(dwc3_core_clks),
-				 GFP_KERNEL);
-	if (!dwc->clks)
-		return -ENOMEM;
-
 	dwc->dev = dev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1444,22 +1433,23 @@ static int dwc3_probe(struct platform_device *pdev)
 
 	dwc3_get_properties(dwc);
 
-	dwc->reset = devm_reset_control_get_optional_shared(dev, NULL);
+	dwc->reset = devm_reset_control_array_get(dev, true, true);
 	if (IS_ERR(dwc->reset))
 		return PTR_ERR(dwc->reset);
 
 	if (dev->of_node) {
-		dwc->num_clks = ARRAY_SIZE(dwc3_core_clks);
-
-		ret = devm_clk_bulk_get(dev, dwc->num_clks, dwc->clks);
+		ret = devm_clk_bulk_get_all(dev, &dwc->clks);
 		if (ret == -EPROBE_DEFER)
 			return ret;
 		/*
 		 * Clocks are optional, but new DT platforms should support all
 		 * clocks as required by the DT-binding.
 		 */
-		if (ret)
+		if (ret < 0)
 			dwc->num_clks = 0;
+		else
+			dwc->num_clks = ret;
+
 	}
 
 	ret = reset_control_deassert(dwc->reset);
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index ce4acbf7f..4ef6cf8ad 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -25,6 +25,7 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/otg.h>
+#include <linux/usb/role.h>
 #include <linux/ulpi/interface.h>
 
 #include <linux/phy/phy.h>
@@ -958,6 +959,9 @@ struct dwc3_scratchpad_array {
  * @hsphy_mode: UTMI phy mode, one of following:
  *		- USBPHY_INTERFACE_MODE_UTMI
  *		- USBPHY_INTERFACE_MODE_UTMIW
+ * @role_sw: usb_role_switch handle
+ * @role_switch_default_mode: default operation mode of controller while
+ *			usb role is USB_ROLE_NONE.
  * @usb2_phy: pointer to USB2 PHY
  * @usb3_phy: pointer to USB3 PHY
  * @usb2_generic_phy: pointer to USB2 PHY
@@ -1093,6 +1097,8 @@ struct dwc3 {
 	struct extcon_dev	*edev;
 	struct notifier_block	edev_nb;
 	enum usb_phy_interface	hsphy_mode;
+	struct usb_role_switch	*role_sw;
+	enum usb_dr_mode	role_switch_default_mode;
 
 	u32			fladj;
 	u32			irq_gadget;
diff --git a/drivers/usb/dwc3/drd.c b/drivers/usb/dwc3/drd.c
index c946d6414..db68d48c2 100644
--- a/drivers/usb/dwc3/drd.c
+++ b/drivers/usb/dwc3/drd.c
@@ -476,6 +476,92 @@ static struct extcon_dev *dwc3_get_extcon(struct dwc3 *dwc)
 	return edev;
 }
 
+#if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)
+#define ROLE_SWITCH 1
+static int dwc3_usb_role_switch_set(struct device *dev, enum usb_role role)
+{
+	struct dwc3 *dwc = dev_get_drvdata(dev);
+	u32 mode;
+
+	switch (role) {
+	case USB_ROLE_HOST:
+		mode = DWC3_GCTL_PRTCAP_HOST;
+		break;
+	case USB_ROLE_DEVICE:
+		mode = DWC3_GCTL_PRTCAP_DEVICE;
+		break;
+	default:
+		if (dwc->role_switch_default_mode == USB_DR_MODE_HOST)
+			mode = DWC3_GCTL_PRTCAP_HOST;
+		else
+			mode = DWC3_GCTL_PRTCAP_DEVICE;
+		break;
+	}
+
+	dwc3_set_mode(dwc, mode);
+	return 0;
+}
+
+static enum usb_role dwc3_usb_role_switch_get(struct device *dev)
+{
+	struct dwc3 *dwc = dev_get_drvdata(dev);
+	unsigned long flags;
+	enum usb_role role;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	switch (dwc->current_dr_role) {
+	case DWC3_GCTL_PRTCAP_HOST:
+		role = USB_ROLE_HOST;
+		break;
+	case DWC3_GCTL_PRTCAP_DEVICE:
+		role = USB_ROLE_DEVICE;
+		break;
+	case DWC3_GCTL_PRTCAP_OTG:
+		role = dwc->current_otg_role;
+		break;
+	default:
+		if (dwc->role_switch_default_mode == USB_DR_MODE_HOST)
+			role = USB_ROLE_HOST;
+		else
+			role = USB_ROLE_DEVICE;
+		break;
+	}
+	spin_unlock_irqrestore(&dwc->lock, flags);
+	return role;
+}
+
+static int dwc3_setup_role_switch(struct dwc3 *dwc)
+{
+	struct usb_role_switch_desc dwc3_role_switch = {NULL};
+	const char *str;
+	u32 mode;
+	int ret;
+
+	ret = device_property_read_string(dwc->dev, "role-switch-default-mode",
+					  &str);
+	if (ret >= 0  && !strncmp(str, "host", strlen("host"))) {
+		dwc->role_switch_default_mode = USB_DR_MODE_HOST;
+		mode = DWC3_GCTL_PRTCAP_HOST;
+	} else {
+		dwc->role_switch_default_mode = USB_DR_MODE_PERIPHERAL;
+		mode = DWC3_GCTL_PRTCAP_DEVICE;
+	}
+
+	dwc3_role_switch.fwnode = dev_fwnode(dwc->dev);
+	dwc3_role_switch.set = dwc3_usb_role_switch_set;
+	dwc3_role_switch.get = dwc3_usb_role_switch_get;
+	dwc->role_sw = usb_role_switch_register(dwc->dev, &dwc3_role_switch);
+	if (IS_ERR(dwc->role_sw))
+		return PTR_ERR(dwc->role_sw);
+
+	dwc3_set_mode(dwc, mode);
+	return 0;
+}
+#else
+#define ROLE_SWITCH 0
+#define dwc3_setup_role_switch(x) 0
+#endif
+
 int dwc3_drd_init(struct dwc3 *dwc)
 {
 	int ret, irq;
@@ -484,7 +570,12 @@ int dwc3_drd_init(struct dwc3 *dwc)
 	if (IS_ERR(dwc->edev))
 		return PTR_ERR(dwc->edev);
 
-	if (dwc->edev) {
+	if (ROLE_SWITCH &&
+	    device_property_read_bool(dwc->dev, "usb-role-switch")) {
+		ret = dwc3_setup_role_switch(dwc);
+		if (ret < 0)
+			return ret;
+	} else if (dwc->edev) {
 		dwc->edev_nb.notifier_call = dwc3_drd_notifier;
 		ret = extcon_register_notifier(dwc->edev, EXTCON_USB_HOST,
 					       &dwc->edev_nb);
@@ -531,6 +622,9 @@ void dwc3_drd_exit(struct dwc3 *dwc)
 {
 	unsigned long flags;
 
+	if (dwc->role_sw)
+		usb_role_switch_unregister(dwc->role_sw);
+
 	if (dwc->edev)
 		extcon_unregister_notifier(dwc->edev, EXTCON_USB_HOST,
 					   &dwc->edev_nb);
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 02ff85027..608f2aac9 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -216,6 +216,12 @@ config USB_F_PRINTER
 config USB_F_TCM
 	tristate
 
+config USB_F_ACC
+	tristate
+
+config USB_F_AUDIO_SRC
+	tristate
+
 # this first set of drivers all depend on bulk-capable hardware.
 
 config USB_CONFIGFS
@@ -230,6 +236,14 @@ config USB_CONFIGFS
 	  appropriate symbolic links.
 	  For more information see Documentation/usb/gadget_configfs.rst.
 
+config USB_CONFIGFS_UEVENT
+	bool "Uevent notification of Gadget state"
+	depends on USB_CONFIGFS
+	help
+	  Enable uevent notifications to userspace when the gadget
+	  state changes. The gadget can be in any of the following
+	  three states: "CONNECTED/DISCONNECTED/CONFIGURED"
+
 config USB_CONFIGFS_SERIAL
 	bool "Generic serial bulk in/out"
 	depends on USB_CONFIGFS
@@ -369,6 +383,23 @@ config USB_CONFIGFS_F_FS
 	  implemented in kernel space (for instance Ethernet, serial or
 	  mass storage) and other are implemented in user space.
 
+config USB_CONFIGFS_F_ACC
+	bool "Accessory gadget"
+	depends on USB_CONFIGFS
+	depends on HID=y
+	select USB_F_ACC
+	help
+	  USB gadget Accessory support
+
+config USB_CONFIGFS_F_AUDIO_SRC
+	bool "Audio Source gadget"
+	depends on USB_CONFIGFS
+	depends on SND
+	select SND_PCM
+	select USB_F_AUDIO_SRC
+	help
+	  USB gadget Audio Source support
+
 config USB_CONFIGFS_F_UAC1
 	bool "Audio Class 1.0"
 	depends on USB_CONFIGFS
@@ -483,34 +514,6 @@ config USB_CONFIGFS_F_TCM
 	  Both protocols can work on USB2.0 and USB3.0.
 	  UAS utilizes the USB 3.0 feature called streams support.
 
-choice
-	tristate "USB Gadget precomposed configurations"
-	default USB_ETH
-	optional
-	help
-	  A Linux "Gadget Driver" talks to the USB Peripheral Controller
-	  driver through the abstract "gadget" API.  Some other operating
-	  systems call these "client" drivers, of which "class drivers"
-	  are a subset (implementing a USB device class specification).
-	  A gadget driver implements one or more USB functions using
-	  the peripheral hardware.
-
-	  Gadget drivers are hardware-neutral, or "platform independent",
-	  except that they sometimes must understand quirks or limitations
-	  of the particular controllers they work with.  For example, when
-	  a controller doesn't support alternate configurations or provide
-	  enough of the right types of endpoints, the gadget driver might
-	  not be able work with that controller, or might need to implement
-	  a less common variant of a device class protocol.
-
-	  The available choices each represent a single precomposed USB
-	  gadget configuration. In the device model, each option contains
-	  both the device instantiation as a child for a USB gadget
-	  controller, and the relevant drivers for each function declared
-	  by the device.
-
 source "drivers/usb/gadget/legacy/Kconfig"
 
-endchoice
-
 endif # USB_GADGET
diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
index a7709d126..63f1acaf4 100644
--- a/drivers/usb/gadget/configfs.c
+++ b/drivers/usb/gadget/configfs.c
@@ -10,6 +10,32 @@
 #include "u_f.h"
 #include "u_os_desc.h"
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+#include <linux/platform_device.h>
+#include <linux/kdev_t.h>
+#include <linux/usb/ch9.h>
+
+#ifdef CONFIG_USB_CONFIGFS_F_ACC
+extern int acc_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl);
+void acc_disconnect(void);
+#endif
+static struct class *android_class;
+static struct device *android_device;
+static int index;
+static int gadget_index;
+
+struct device *create_function_device(char *name)
+{
+	if (android_device && !IS_ERR(android_device))
+		return device_create(android_class, android_device,
+			MKDEV(0, index++), NULL, name);
+	else
+		return ERR_PTR(-EINVAL);
+}
+EXPORT_SYMBOL_GPL(create_function_device);
+#endif
+
 int check_user_usb_string(const char *name,
 		struct usb_gadget_strings *stringtab_dev)
 {
@@ -63,6 +89,12 @@ struct gadget_info {
 	char qw_sign[OS_STRING_QW_SIGN_LEN];
 	spinlock_t spinlock;
 	bool unbind;
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	bool connected;
+	bool sw_connected;
+	struct work_struct work;
+	struct device *dev;
+#endif
 };
 
 static inline struct gadget_info *to_gadget_info(struct config_item *item)
@@ -271,7 +303,7 @@ static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,
 
 	mutex_lock(&gi->lock);
 
-	if (!strlen(name)) {
+	if (!strlen(name) || strcmp(name, "none") == 0) {
 		ret = unregister_gadget(gi);
 		if (ret)
 			goto err;
@@ -296,6 +328,36 @@ static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,
 	return ret;
 }
 
+static ssize_t gadget_driver_match_existing_only_store(struct config_item *item,
+		const char *page, size_t len)
+{
+	struct gadget_info *gi = to_gadget_info(item);
+	struct usb_gadget_driver *gadget_driver = &(gi->composite.gadget_driver);
+	bool match_existing_only;
+	int ret;
+
+	ret = kstrtobool(page, &match_existing_only);
+	if (ret)
+		return ret;
+
+	if (match_existing_only)
+		gadget_driver->match_existing_only = 1;
+	else
+		gadget_driver->match_existing_only = 0;
+
+	return len;
+}
+
+static ssize_t gadget_driver_match_existing_only_show(struct config_item *item,
+		char *page)
+{
+	struct gadget_info *gi = to_gadget_info(item);
+	struct usb_gadget_driver *gadget_driver = &(gi->composite.gadget_driver);
+	bool match_existing_only = !!gadget_driver->match_existing_only;
+
+	return sprintf(page, "%s\n", match_existing_only ? "true" : "false");
+}
+
 CONFIGFS_ATTR(gadget_dev_desc_, bDeviceClass);
 CONFIGFS_ATTR(gadget_dev_desc_, bDeviceSubClass);
 CONFIGFS_ATTR(gadget_dev_desc_, bDeviceProtocol);
@@ -305,6 +367,7 @@ CONFIGFS_ATTR(gadget_dev_desc_, idProduct);
 CONFIGFS_ATTR(gadget_dev_desc_, bcdDevice);
 CONFIGFS_ATTR(gadget_dev_desc_, bcdUSB);
 CONFIGFS_ATTR(gadget_dev_desc_, UDC);
+CONFIGFS_ATTR(gadget_, driver_match_existing_only);
 
 static struct configfs_attribute *gadget_root_attrs[] = {
 	&gadget_dev_desc_attr_bDeviceClass,
@@ -316,6 +379,7 @@ static struct configfs_attribute *gadget_root_attrs[] = {
 	&gadget_dev_desc_attr_bcdDevice,
 	&gadget_dev_desc_attr_bcdUSB,
 	&gadget_dev_desc_attr_UDC,
+	&gadget_attr_driver_match_existing_only,
 	NULL,
 };
 
@@ -1378,6 +1442,57 @@ static int configfs_composite_bind(struct usb_gadget *gadget,
 	return ret;
 }
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+static void android_work(struct work_struct *data)
+{
+	struct gadget_info *gi = container_of(data, struct gadget_info, work);
+	struct usb_composite_dev *cdev = &gi->cdev;
+	char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };
+	char *connected[2]    = { "USB_STATE=CONNECTED", NULL };
+	char *configured[2]   = { "USB_STATE=CONFIGURED", NULL };
+	/* 0-connected 1-configured 2-disconnected*/
+	bool status[3] = { false, false, false };
+	unsigned long flags;
+	bool uevent_sent = false;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		status[1] = true;
+
+	if (gi->connected != gi->sw_connected) {
+		if (gi->connected)
+			status[0] = true;
+		else
+			status[2] = true;
+		gi->sw_connected = gi->connected;
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	if (status[0]) {
+		kobject_uevent_env(&gi->dev->kobj, KOBJ_CHANGE, connected);
+		pr_info("%s: sent uevent %s\n", __func__, connected[0]);
+		uevent_sent = true;
+	}
+
+	if (status[1]) {
+		kobject_uevent_env(&gi->dev->kobj, KOBJ_CHANGE, configured);
+		pr_info("%s: sent uevent %s\n", __func__, configured[0]);
+		uevent_sent = true;
+	}
+
+	if (status[2]) {
+		kobject_uevent_env(&gi->dev->kobj, KOBJ_CHANGE, disconnected);
+		pr_info("%s: sent uevent %s\n", __func__, disconnected[0]);
+		uevent_sent = true;
+	}
+
+	if (!uevent_sent) {
+		pr_info("%s: did not send uevent (%d %d %p)\n", __func__,
+			gi->connected, gi->sw_connected, cdev->config);
+	}
+}
+#endif
+
 static void configfs_composite_unbind(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev;
@@ -1403,6 +1518,80 @@ static void configfs_composite_unbind(struct usb_gadget *gadget)
 	spin_unlock_irqrestore(&gi->spinlock, flags);
 }
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+static int android_setup(struct usb_gadget *gadget,
+			const struct usb_ctrlrequest *c)
+{
+	struct usb_composite_dev *cdev = get_gadget_data(gadget);
+	unsigned long flags;
+	struct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);
+	int value = -EOPNOTSUPP;
+	struct usb_function_instance *fi;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (!gi->connected) {
+		gi->connected = 1;
+		schedule_work(&gi->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+	list_for_each_entry(fi, &gi->available_func, cfs_list) {
+		if (fi != NULL && fi->f != NULL && fi->f->setup != NULL) {
+			value = fi->f->setup(fi->f, c);
+			if (value >= 0)
+				break;
+		}
+	}
+
+#ifdef CONFIG_USB_CONFIGFS_F_ACC
+	if (value < 0)
+		value = acc_ctrlrequest(cdev, c);
+#endif
+
+	if (value < 0)
+		value = composite_setup(gadget, c);
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
+						cdev->config) {
+		schedule_work(&gi->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	return value;
+}
+
+static void android_disconnect(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev        *cdev = get_gadget_data(gadget);
+	struct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);
+
+	/* FIXME: There's a race between usb_gadget_udc_stop() which is likely
+	 * to set the gadget driver to NULL in the udc driver and this drivers
+	 * gadget disconnect fn which likely checks for the gadget driver to
+	 * be a null ptr. It happens that unbind (doing set_gadget_data(NULL))
+	 * is called before the gadget driver is set to NULL and the udc driver
+	 * calls disconnect fn which results in cdev being a null ptr.
+	 */
+	if (cdev == NULL) {
+		WARN(1, "%s: gadget driver already disconnected\n", __func__);
+		return;
+	}
+
+	/* accessory HID support can be active while the
+		accessory function is not actually enabled,
+		so we need to inform it when we are disconnected.
+	*/
+
+#ifdef CONFIG_USB_CONFIGFS_F_ACC
+	acc_disconnect();
+#endif
+	gi->connected = 0;
+	schedule_work(&gi->work);
+	composite_disconnect(gadget);
+}
+
+#else // CONFIG_USB_CONFIGFS_UEVENT
+
 static int configfs_composite_setup(struct usb_gadget *gadget,
 		const struct usb_ctrlrequest *ctrl)
 {
@@ -1450,6 +1639,8 @@ static void configfs_composite_disconnect(struct usb_gadget *gadget)
 	spin_unlock_irqrestore(&gi->spinlock, flags);
 }
 
+#endif // CONFIG_USB_CONFIGFS_UEVENT
+
 static void configfs_composite_suspend(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev *cdev;
@@ -1498,10 +1689,15 @@ static const struct usb_gadget_driver configfs_driver_template = {
 	.bind           = configfs_composite_bind,
 	.unbind         = configfs_composite_unbind,
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	.setup          = android_setup,
+	.reset          = android_disconnect,
+	.disconnect     = android_disconnect,
+#else
 	.setup          = configfs_composite_setup,
 	.reset          = configfs_composite_disconnect,
 	.disconnect     = configfs_composite_disconnect,
-
+#endif
 	.suspend	= configfs_composite_suspend,
 	.resume		= configfs_composite_resume,
 
@@ -1513,6 +1709,91 @@ static const struct usb_gadget_driver configfs_driver_template = {
 	.match_existing_only = 1,
 };
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
+			char *buf)
+{
+	struct gadget_info *dev = dev_get_drvdata(pdev);
+	struct usb_composite_dev *cdev;
+	char *state = "DISCONNECTED";
+	unsigned long flags;
+
+	if (!dev)
+		goto out;
+
+	cdev = &dev->cdev;
+
+	if (!cdev)
+		goto out;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		state = "CONFIGURED";
+	else if (dev->connected)
+		state = "CONNECTED";
+	spin_unlock_irqrestore(&cdev->lock, flags);
+out:
+	return sprintf(buf, "%s\n", state);
+}
+
+static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
+
+static struct device_attribute *android_usb_attributes[] = {
+	&dev_attr_state,
+	NULL
+};
+
+static int android_device_create(struct gadget_info *gi)
+{
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+
+	INIT_WORK(&gi->work, android_work);
+	gi->dev = device_create(android_class, NULL,
+			MKDEV(0, 0), NULL, "android%d", gadget_index++);
+	if (IS_ERR(gi->dev))
+		return PTR_ERR(gi->dev);
+
+	dev_set_drvdata(gi->dev, gi);
+	if (!android_device)
+		android_device = gi->dev;
+
+	attrs = android_usb_attributes;
+	while ((attr = *attrs++)) {
+		int err;
+
+		err = device_create_file(gi->dev, attr);
+		if (err) {
+			device_destroy(gi->dev->class,
+				       gi->dev->devt);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static void android_device_destroy(struct gadget_info *gi)
+{
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+
+	attrs = android_usb_attributes;
+	while ((attr = *attrs++))
+		device_remove_file(gi->dev, attr);
+	device_destroy(gi->dev->class, gi->dev->devt);
+}
+#else
+static inline int android_device_create(struct gadget_info *gi)
+{
+	return 0;
+}
+
+static inline void android_device_destroy(struct gadget_info *gi)
+{
+}
+#endif
+
 static struct config_group *gadgets_make(
 		struct config_group *group,
 		const char *name)
@@ -1565,7 +1846,11 @@ static struct config_group *gadgets_make(
 	if (!gi->composite.gadget_driver.function)
 		goto err;
 
+	if (android_device_create(gi) < 0)
+		goto err;
+
 	return &gi->group;
+
 err:
 	kfree(gi);
 	return ERR_PTR(-ENOMEM);
@@ -1573,7 +1858,11 @@ static struct config_group *gadgets_make(
 
 static void gadgets_drop(struct config_group *group, struct config_item *item)
 {
+	struct gadget_info *gi;
+
+	gi = container_of(to_config_group(item), struct gadget_info, group);
 	config_item_put(item);
+	android_device_destroy(gi);
 }
 
 static struct configfs_group_operations gadgets_ops = {
@@ -1613,6 +1902,13 @@ static int __init gadget_cfs_init(void)
 	config_group_init(&gadget_subsys.su_group);
 
 	ret = configfs_register_subsystem(&gadget_subsys);
+
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	android_class = class_create(THIS_MODULE, "android_usb");
+	if (IS_ERR(android_class))
+		return PTR_ERR(android_class);
+#endif
+
 	return ret;
 }
 module_init(gadget_cfs_init);
@@ -1620,5 +1916,10 @@ module_init(gadget_cfs_init);
 static void __exit gadget_cfs_exit(void)
 {
 	configfs_unregister_subsystem(&gadget_subsys);
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	if (!IS_ERR(android_class))
+		class_destroy(android_class);
+#endif
+
 }
 module_exit(gadget_cfs_exit);
diff --git a/drivers/usb/gadget/function/Makefile b/drivers/usb/gadget/function/Makefile
index 5d3a6cf02..dd33a1243 100644
--- a/drivers/usb/gadget/function/Makefile
+++ b/drivers/usb/gadget/function/Makefile
@@ -50,3 +50,7 @@ usb_f_printer-y			:= f_printer.o
 obj-$(CONFIG_USB_F_PRINTER)	+= usb_f_printer.o
 usb_f_tcm-y			:= f_tcm.o
 obj-$(CONFIG_USB_F_TCM)		+= usb_f_tcm.o
+usb_f_accessory-y		:= f_accessory.o
+obj-$(CONFIG_USB_F_ACC)		+= usb_f_accessory.o
+usb_f_audio_source-y		:= f_audio_source.o
+obj-$(CONFIG_USB_F_AUDIO_SRC)	+= usb_f_audio_source.o
diff --git a/drivers/usb/gadget/function/f_accessory.c b/drivers/usb/gadget/function/f_accessory.c
new file mode 100644
index 000000000..af8f8c264
--- /dev/null
+++ b/drivers/usb/gadget/function/f_accessory.c
@@ -0,0 +1,1366 @@
+/*
+ * Gadget Function Driver for Android USB accessories
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+
+#include <linux/types.h>
+#include <linux/file.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include <linux/hid.h>
+#include <linux/hiddev.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/f_accessory.h>
+
+#include <linux/configfs.h>
+#include <linux/usb/composite.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+
+#define MAX_INST_NAME_LEN        40
+#define BULK_BUFFER_SIZE    16384
+#define ACC_STRING_SIZE     256
+
+#define PROTOCOL_VERSION    2
+
+/* String IDs */
+#define INTERFACE_STRING_INDEX	0
+
+/* number of tx and rx requests to allocate */
+#define TX_REQ_MAX 4
+#define RX_REQ_MAX 2
+
+struct acc_hid_dev {
+	struct list_head	list;
+	struct hid_device *hid;
+	struct acc_dev *dev;
+	/* accessory defined ID */
+	int id;
+	/* HID report descriptor */
+	u8 *report_desc;
+	/* length of HID report descriptor */
+	int report_desc_len;
+	/* number of bytes of report_desc we have received so far */
+	int report_desc_offset;
+};
+
+struct acc_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+
+	struct usb_ep *ep_in;
+	struct usb_ep *ep_out;
+
+	/* online indicates state of function_set_alt & function_unbind
+	 * set to 1 when we connect
+	 */
+	int online:1;
+
+	/* disconnected indicates state of open & release
+	 * Set to 1 when we disconnect.
+	 * Not cleared until our file is closed.
+	 */
+	int disconnected:1;
+
+	/* strings sent by the host */
+	char manufacturer[ACC_STRING_SIZE];
+	char model[ACC_STRING_SIZE];
+	char description[ACC_STRING_SIZE];
+	char version[ACC_STRING_SIZE];
+	char uri[ACC_STRING_SIZE];
+	char serial[ACC_STRING_SIZE];
+
+	/* for acc_complete_set_string */
+	int string_index;
+
+	/* set to 1 if we have a pending start request */
+	int start_requested;
+
+	int audio_mode;
+
+	/* synchronize access to our device file */
+	atomic_t open_excl;
+
+	struct list_head tx_idle;
+
+	wait_queue_head_t read_wq;
+	wait_queue_head_t write_wq;
+	struct usb_request *rx_req[RX_REQ_MAX];
+	int rx_done;
+
+	/* delayed work for handling ACCESSORY_START */
+	struct delayed_work start_work;
+
+	/* worker for registering and unregistering hid devices */
+	struct work_struct hid_work;
+
+	/* list of active HID devices */
+	struct list_head	hid_list;
+
+	/* list of new HID devices to register */
+	struct list_head	new_hid_list;
+
+	/* list of dead HID devices to unregister */
+	struct list_head	dead_hid_list;
+};
+
+static struct usb_interface_descriptor acc_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bInterfaceNumber       = 0,
+	.bNumEndpoints          = 2,
+	.bInterfaceClass        = USB_CLASS_VENDOR_SPEC,
+	.bInterfaceSubClass     = USB_SUBCLASS_VENDOR_SPEC,
+	.bInterfaceProtocol     = 0,
+};
+
+static struct usb_endpoint_descriptor acc_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor acc_highspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor acc_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor acc_fullspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_descriptor_header *fs_acc_descs[] = {
+	(struct usb_descriptor_header *) &acc_interface_desc,
+	(struct usb_descriptor_header *) &acc_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &acc_fullspeed_out_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_acc_descs[] = {
+	(struct usb_descriptor_header *) &acc_interface_desc,
+	(struct usb_descriptor_header *) &acc_highspeed_in_desc,
+	(struct usb_descriptor_header *) &acc_highspeed_out_desc,
+	NULL,
+};
+
+static struct usb_string acc_string_defs[] = {
+	[INTERFACE_STRING_INDEX].s	= "Android Accessory Interface",
+	{  },	/* end of list */
+};
+
+static struct usb_gadget_strings acc_string_table = {
+	.language		= 0x0409,	/* en-US */
+	.strings		= acc_string_defs,
+};
+
+static struct usb_gadget_strings *acc_strings[] = {
+	&acc_string_table,
+	NULL,
+};
+
+/* temporary variable used between acc_open() and acc_gadget_bind() */
+static struct acc_dev *_acc_dev;
+
+struct acc_instance {
+	struct usb_function_instance func_inst;
+	const char *name;
+};
+
+static inline struct acc_dev *func_to_dev(struct usb_function *f)
+{
+	return container_of(f, struct acc_dev, function);
+}
+
+static struct usb_request *acc_request_new(struct usb_ep *ep, int buffer_size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+
+	if (!req)
+		return NULL;
+
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void acc_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+/* add a request to the tail of a list */
+static void req_put(struct acc_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct usb_request *req_get(struct acc_dev *dev, struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void acc_set_disconnected(struct acc_dev *dev)
+{
+	dev->disconnected = 1;
+}
+
+static void acc_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct acc_dev *dev = _acc_dev;
+
+	if (req->status == -ESHUTDOWN) {
+		pr_debug("acc_complete_in set disconnected");
+		acc_set_disconnected(dev);
+	}
+
+	req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static void acc_complete_out(struct usb_ep *ep, struct usb_request *req)
+{
+	struct acc_dev *dev = _acc_dev;
+
+	dev->rx_done = 1;
+	if (req->status == -ESHUTDOWN) {
+		pr_debug("acc_complete_out set disconnected");
+		acc_set_disconnected(dev);
+	}
+
+	wake_up(&dev->read_wq);
+}
+
+static void acc_complete_set_string(struct usb_ep *ep, struct usb_request *req)
+{
+	struct acc_dev	*dev = ep->driver_data;
+	char *string_dest = NULL;
+	int length = req->actual;
+
+	if (req->status != 0) {
+		pr_err("acc_complete_set_string, err %d\n", req->status);
+		return;
+	}
+
+	switch (dev->string_index) {
+	case ACCESSORY_STRING_MANUFACTURER:
+		string_dest = dev->manufacturer;
+		break;
+	case ACCESSORY_STRING_MODEL:
+		string_dest = dev->model;
+		break;
+	case ACCESSORY_STRING_DESCRIPTION:
+		string_dest = dev->description;
+		break;
+	case ACCESSORY_STRING_VERSION:
+		string_dest = dev->version;
+		break;
+	case ACCESSORY_STRING_URI:
+		string_dest = dev->uri;
+		break;
+	case ACCESSORY_STRING_SERIAL:
+		string_dest = dev->serial;
+		break;
+	}
+	if (string_dest) {
+		unsigned long flags;
+
+		if (length >= ACC_STRING_SIZE)
+			length = ACC_STRING_SIZE - 1;
+
+		spin_lock_irqsave(&dev->lock, flags);
+		memcpy(string_dest, req->buf, length);
+		/* ensure zero termination */
+		string_dest[length] = 0;
+		spin_unlock_irqrestore(&dev->lock, flags);
+	} else {
+		pr_err("unknown accessory string index %d\n",
+			dev->string_index);
+	}
+}
+
+static void acc_complete_set_hid_report_desc(struct usb_ep *ep,
+		struct usb_request *req)
+{
+	struct acc_hid_dev *hid = req->context;
+	struct acc_dev *dev = hid->dev;
+	int length = req->actual;
+
+	if (req->status != 0) {
+		pr_err("acc_complete_set_hid_report_desc, err %d\n",
+			req->status);
+		return;
+	}
+
+	memcpy(hid->report_desc + hid->report_desc_offset, req->buf, length);
+	hid->report_desc_offset += length;
+	if (hid->report_desc_offset == hid->report_desc_len) {
+		/* After we have received the entire report descriptor
+		 * we schedule work to initialize the HID device
+		 */
+		schedule_work(&dev->hid_work);
+	}
+}
+
+static void acc_complete_send_hid_event(struct usb_ep *ep,
+		struct usb_request *req)
+{
+	struct acc_hid_dev *hid = req->context;
+	int length = req->actual;
+
+	if (req->status != 0) {
+		pr_err("acc_complete_send_hid_event, err %d\n", req->status);
+		return;
+	}
+
+	hid_report_raw_event(hid->hid, HID_INPUT_REPORT, req->buf, length, 1);
+}
+
+static int acc_hid_parse(struct hid_device *hid)
+{
+	struct acc_hid_dev *hdev = hid->driver_data;
+
+	hid_parse_report(hid, hdev->report_desc, hdev->report_desc_len);
+	return 0;
+}
+
+static int acc_hid_start(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void acc_hid_stop(struct hid_device *hid)
+{
+}
+
+static int acc_hid_open(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void acc_hid_close(struct hid_device *hid)
+{
+}
+
+static int acc_hid_raw_request(struct hid_device *hid, unsigned char reportnum,
+	__u8 *buf, size_t len, unsigned char rtype, int reqtype)
+{
+	return 0;
+}
+
+static struct hid_ll_driver acc_hid_ll_driver = {
+	.parse = acc_hid_parse,
+	.start = acc_hid_start,
+	.stop = acc_hid_stop,
+	.open = acc_hid_open,
+	.close = acc_hid_close,
+	.raw_request = acc_hid_raw_request,
+};
+
+static struct acc_hid_dev *acc_hid_new(struct acc_dev *dev,
+		int id, int desc_len)
+{
+	struct acc_hid_dev *hdev;
+
+	hdev = kzalloc(sizeof(*hdev), GFP_ATOMIC);
+	if (!hdev)
+		return NULL;
+	hdev->report_desc = kzalloc(desc_len, GFP_ATOMIC);
+	if (!hdev->report_desc) {
+		kfree(hdev);
+		return NULL;
+	}
+	hdev->dev = dev;
+	hdev->id = id;
+	hdev->report_desc_len = desc_len;
+
+	return hdev;
+}
+
+static struct acc_hid_dev *acc_hid_get(struct list_head *list, int id)
+{
+	struct acc_hid_dev *hid;
+
+	list_for_each_entry(hid, list, list) {
+		if (hid->id == id)
+			return hid;
+	}
+	return NULL;
+}
+
+static int acc_register_hid(struct acc_dev *dev, int id, int desc_length)
+{
+	struct acc_hid_dev *hid;
+	unsigned long flags;
+
+	/* report descriptor length must be > 0 */
+	if (desc_length <= 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	/* replace HID if one already exists with this ID */
+	hid = acc_hid_get(&dev->hid_list, id);
+	if (!hid)
+		hid = acc_hid_get(&dev->new_hid_list, id);
+	if (hid)
+		list_move(&hid->list, &dev->dead_hid_list);
+
+	hid = acc_hid_new(dev, id, desc_length);
+	if (!hid) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -ENOMEM;
+	}
+
+	list_add(&hid->list, &dev->new_hid_list);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	/* schedule work to register the HID device */
+	schedule_work(&dev->hid_work);
+	return 0;
+}
+
+static int acc_unregister_hid(struct acc_dev *dev, int id)
+{
+	struct acc_hid_dev *hid;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	hid = acc_hid_get(&dev->hid_list, id);
+	if (!hid)
+		hid = acc_hid_get(&dev->new_hid_list, id);
+	if (!hid) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -EINVAL;
+	}
+
+	list_move(&hid->list, &dev->dead_hid_list);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	schedule_work(&dev->hid_work);
+	return 0;
+}
+
+static int create_bulk_endpoints(struct acc_dev *dev,
+				struct usb_endpoint_descriptor *in_desc,
+				struct usb_endpoint_descriptor *out_desc)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	DBG(cdev, "create_bulk_endpoints dev: %p\n", dev);
+
+	ep = usb_ep_autoconfig(cdev->gadget, in_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_in failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for ep_in got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for ep_out got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	/* now allocate requests for our endpoints */
+	for (i = 0; i < TX_REQ_MAX; i++) {
+		req = acc_request_new(dev->ep_in, BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = acc_complete_in;
+		req_put(dev, &dev->tx_idle, req);
+	}
+	for (i = 0; i < RX_REQ_MAX; i++) {
+		req = acc_request_new(dev->ep_out, BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = acc_complete_out;
+		dev->rx_req[i] = req;
+	}
+
+	return 0;
+
+fail:
+	pr_err("acc_bind() could not allocate requests\n");
+	while ((req = req_get(dev, &dev->tx_idle)))
+		acc_request_free(req, dev->ep_in);
+	for (i = 0; i < RX_REQ_MAX; i++)
+		acc_request_free(dev->rx_req[i], dev->ep_out);
+	return -1;
+}
+
+static ssize_t acc_read(struct file *fp, char __user *buf,
+	size_t count, loff_t *pos)
+{
+	struct acc_dev *dev = fp->private_data;
+	struct usb_request *req;
+	ssize_t r = count;
+	unsigned xfer;
+	int ret = 0;
+
+	pr_debug("acc_read(%zu)\n", count);
+
+	if (dev->disconnected) {
+		pr_debug("acc_read disconnected");
+		return -ENODEV;
+	}
+
+	if (count > BULK_BUFFER_SIZE)
+		count = BULK_BUFFER_SIZE;
+
+	/* we will block until we're online */
+	pr_debug("acc_read: waiting for online\n");
+	ret = wait_event_interruptible(dev->read_wq, dev->online);
+	if (ret < 0) {
+		r = ret;
+		goto done;
+	}
+
+	if (dev->rx_done) {
+		// last req cancelled. try to get it.
+		req = dev->rx_req[0];
+		goto copy_data;
+	}
+
+requeue_req:
+	/* queue a request */
+	req = dev->rx_req[0];
+	req->length = count;
+	dev->rx_done = 0;
+	ret = usb_ep_queue(dev->ep_out, req, GFP_KERNEL);
+	if (ret < 0) {
+		r = -EIO;
+		goto done;
+	} else {
+		pr_debug("rx %p queue\n", req);
+	}
+
+	/* wait for a request to complete */
+	ret = wait_event_interruptible(dev->read_wq, dev->rx_done);
+	if (ret < 0) {
+		r = ret;
+		ret = usb_ep_dequeue(dev->ep_out, req);
+		if (ret != 0) {
+			// cancel failed. There can be a data already received.
+			// it will be retrieved in the next read.
+			pr_debug("acc_read: cancelling failed %d", ret);
+		}
+		goto done;
+	}
+
+copy_data:
+	dev->rx_done = 0;
+	if (dev->online) {
+		/* If we got a 0-len packet, throw it back and try again. */
+		if (req->actual == 0)
+			goto requeue_req;
+
+		pr_debug("rx %p %u\n", req, req->actual);
+		xfer = (req->actual < count) ? req->actual : count;
+		r = xfer;
+		if (copy_to_user(buf, req->buf, xfer))
+			r = -EFAULT;
+	} else
+		r = -EIO;
+
+done:
+	pr_debug("acc_read returning %zd\n", r);
+	return r;
+}
+
+static ssize_t acc_write(struct file *fp, const char __user *buf,
+	size_t count, loff_t *pos)
+{
+	struct acc_dev *dev = fp->private_data;
+	struct usb_request *req = 0;
+	ssize_t r = count;
+	unsigned xfer;
+	int ret;
+
+	pr_debug("acc_write(%zu)\n", count);
+
+	if (!dev->online || dev->disconnected) {
+		pr_debug("acc_write disconnected or not online");
+		return -ENODEV;
+	}
+
+	while (count > 0) {
+		if (!dev->online) {
+			pr_debug("acc_write dev->error\n");
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+			((req = req_get(dev, &dev->tx_idle)) || !dev->online));
+		if (!req) {
+			r = ret;
+			break;
+		}
+
+		if (count > BULK_BUFFER_SIZE) {
+			xfer = BULK_BUFFER_SIZE;
+			/* ZLP, They will be more TX requests so not yet. */
+			req->zero = 0;
+		} else {
+			xfer = count;
+			/* If the data length is a multple of the
+			 * maxpacket size then send a zero length packet(ZLP).
+			*/
+			req->zero = ((xfer % dev->ep_in->maxpacket) == 0);
+		}
+		if (copy_from_user(req->buf, buf, xfer)) {
+			r = -EFAULT;
+			break;
+		}
+
+		req->length = xfer;
+		ret = usb_ep_queue(dev->ep_in, req, GFP_KERNEL);
+		if (ret < 0) {
+			pr_debug("acc_write: xfer error %d\n", ret);
+			r = -EIO;
+			break;
+		}
+
+		buf += xfer;
+		count -= xfer;
+
+		/* zero this so we don't try to free it on error exit */
+		req = 0;
+	}
+
+	if (req)
+		req_put(dev, &dev->tx_idle, req);
+
+	pr_debug("acc_write returning %zd\n", r);
+	return r;
+}
+
+static long acc_ioctl(struct file *fp, unsigned code, unsigned long value)
+{
+	struct acc_dev *dev = fp->private_data;
+	char *src = NULL;
+	int ret;
+
+	switch (code) {
+	case ACCESSORY_GET_STRING_MANUFACTURER:
+		src = dev->manufacturer;
+		break;
+	case ACCESSORY_GET_STRING_MODEL:
+		src = dev->model;
+		break;
+	case ACCESSORY_GET_STRING_DESCRIPTION:
+		src = dev->description;
+		break;
+	case ACCESSORY_GET_STRING_VERSION:
+		src = dev->version;
+		break;
+	case ACCESSORY_GET_STRING_URI:
+		src = dev->uri;
+		break;
+	case ACCESSORY_GET_STRING_SERIAL:
+		src = dev->serial;
+		break;
+	case ACCESSORY_IS_START_REQUESTED:
+		return dev->start_requested;
+	case ACCESSORY_GET_AUDIO_MODE:
+		return dev->audio_mode;
+	}
+	if (!src)
+		return -EINVAL;
+
+	ret = strlen(src) + 1;
+	if (copy_to_user((void __user *)value, src, ret))
+		ret = -EFAULT;
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long acc_compat_ioctl(struct file *fp, unsigned code,
+				unsigned long value)
+{
+	return acc_ioctl(fp, code, (unsigned long) compat_ptr(value));
+}
+#endif
+
+static int acc_open(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "acc_open\n");
+	if (atomic_xchg(&_acc_dev->open_excl, 1))
+		return -EBUSY;
+
+	_acc_dev->disconnected = 0;
+	fp->private_data = _acc_dev;
+	return 0;
+}
+
+static int acc_release(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "acc_release\n");
+
+	WARN_ON(!atomic_xchg(&_acc_dev->open_excl, 0));
+	/* indicate that we are disconnected
+	 * still could be online so don't touch online flag
+	 */
+	_acc_dev->disconnected = 1;
+	return 0;
+}
+
+/* file operations for /dev/usb_accessory */
+static const struct file_operations acc_fops = {
+	.owner = THIS_MODULE,
+	.read = acc_read,
+	.write = acc_write,
+	.unlocked_ioctl = acc_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = acc_compat_ioctl,
+#endif
+	.open = acc_open,
+	.release = acc_release,
+};
+
+static int acc_hid_probe(struct hid_device *hdev,
+		const struct hid_device_id *id)
+{
+	int ret;
+
+	ret = hid_parse(hdev);
+	if (ret)
+		return ret;
+	return hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+}
+
+static struct miscdevice acc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "usb_accessory",
+	.fops = &acc_fops,
+};
+
+static const struct hid_device_id acc_hid_table[] = {
+	{ HID_USB_DEVICE(HID_ANY_ID, HID_ANY_ID) },
+	{ }
+};
+
+static struct hid_driver acc_hid_driver = {
+	.name = "USB accessory",
+	.id_table = acc_hid_table,
+	.probe = acc_hid_probe,
+};
+
+static void acc_complete_setup_noop(struct usb_ep *ep, struct usb_request *req)
+{
+	/*
+	 * Default no-op function when nothing needs to be done for the
+	 * setup request
+	 */
+}
+
+int acc_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl)
+{
+	struct acc_dev	*dev = _acc_dev;
+	int	value = -EOPNOTSUPP;
+	struct acc_hid_dev *hid;
+	int offset;
+	u8 b_requestType = ctrl->bRequestType;
+	u8 b_request = ctrl->bRequest;
+	u16	w_index = le16_to_cpu(ctrl->wIndex);
+	u16	w_value = le16_to_cpu(ctrl->wValue);
+	u16	w_length = le16_to_cpu(ctrl->wLength);
+	unsigned long flags;
+
+/*
+	printk(KERN_INFO "acc_ctrlrequest "
+			"%02x.%02x v%04x i%04x l%u\n",
+			b_requestType, b_request,
+			w_value, w_index, w_length);
+*/
+
+	if (b_requestType == (USB_DIR_OUT | USB_TYPE_VENDOR)) {
+		if (b_request == ACCESSORY_START) {
+			dev->start_requested = 1;
+			schedule_delayed_work(
+				&dev->start_work, msecs_to_jiffies(10));
+			value = 0;
+			cdev->req->complete = acc_complete_setup_noop;
+		} else if (b_request == ACCESSORY_SEND_STRING) {
+			dev->string_index = w_index;
+			cdev->gadget->ep0->driver_data = dev;
+			cdev->req->complete = acc_complete_set_string;
+			value = w_length;
+		} else if (b_request == ACCESSORY_SET_AUDIO_MODE &&
+				w_index == 0 && w_length == 0) {
+			dev->audio_mode = w_value;
+			cdev->req->complete = acc_complete_setup_noop;
+			value = 0;
+		} else if (b_request == ACCESSORY_REGISTER_HID) {
+			cdev->req->complete = acc_complete_setup_noop;
+			value = acc_register_hid(dev, w_value, w_index);
+		} else if (b_request == ACCESSORY_UNREGISTER_HID) {
+			cdev->req->complete = acc_complete_setup_noop;
+			value = acc_unregister_hid(dev, w_value);
+		} else if (b_request == ACCESSORY_SET_HID_REPORT_DESC) {
+			spin_lock_irqsave(&dev->lock, flags);
+			hid = acc_hid_get(&dev->new_hid_list, w_value);
+			spin_unlock_irqrestore(&dev->lock, flags);
+			if (!hid) {
+				value = -EINVAL;
+				goto err;
+			}
+			offset = w_index;
+			if (offset != hid->report_desc_offset
+				|| offset + w_length > hid->report_desc_len) {
+				value = -EINVAL;
+				goto err;
+			}
+			cdev->req->context = hid;
+			cdev->req->complete = acc_complete_set_hid_report_desc;
+			value = w_length;
+		} else if (b_request == ACCESSORY_SEND_HID_EVENT) {
+			spin_lock_irqsave(&dev->lock, flags);
+			hid = acc_hid_get(&dev->hid_list, w_value);
+			spin_unlock_irqrestore(&dev->lock, flags);
+			if (!hid) {
+				value = -EINVAL;
+				goto err;
+			}
+			cdev->req->context = hid;
+			cdev->req->complete = acc_complete_send_hid_event;
+			value = w_length;
+		}
+	} else if (b_requestType == (USB_DIR_IN | USB_TYPE_VENDOR)) {
+		if (b_request == ACCESSORY_GET_PROTOCOL) {
+			*((u16 *)cdev->req->buf) = PROTOCOL_VERSION;
+			value = sizeof(u16);
+			cdev->req->complete = acc_complete_setup_noop;
+			/* clear any string left over from a previous session */
+			memset(dev->manufacturer, 0, sizeof(dev->manufacturer));
+			memset(dev->model, 0, sizeof(dev->model));
+			memset(dev->description, 0, sizeof(dev->description));
+			memset(dev->version, 0, sizeof(dev->version));
+			memset(dev->uri, 0, sizeof(dev->uri));
+			memset(dev->serial, 0, sizeof(dev->serial));
+			dev->start_requested = 0;
+			dev->audio_mode = 0;
+		}
+	}
+
+	if (value >= 0) {
+		cdev->req->zero = 0;
+		cdev->req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (value < 0)
+			ERROR(cdev, "%s setup response queue error\n",
+				__func__);
+	}
+
+err:
+	if (value == -EOPNOTSUPP)
+		VDBG(cdev,
+			"unknown class-specific control req "
+			"%02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+	return value;
+}
+EXPORT_SYMBOL_GPL(acc_ctrlrequest);
+
+static int
+__acc_function_bind(struct usb_configuration *c,
+			struct usb_function *f, bool configfs)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct acc_dev	*dev = func_to_dev(f);
+	int			id;
+	int			ret;
+
+	DBG(cdev, "acc_function_bind dev: %p\n", dev);
+
+	if (configfs) {
+		if (acc_string_defs[INTERFACE_STRING_INDEX].id == 0) {
+			ret = usb_string_id(c->cdev);
+			if (ret < 0)
+				return ret;
+			acc_string_defs[INTERFACE_STRING_INDEX].id = ret;
+			acc_interface_desc.iInterface = ret;
+		}
+		dev->cdev = c->cdev;
+	}
+	ret = hid_register_driver(&acc_hid_driver);
+	if (ret)
+		return ret;
+
+	dev->start_requested = 0;
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	acc_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = create_bulk_endpoints(dev, &acc_fullspeed_in_desc,
+			&acc_fullspeed_out_desc);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		acc_highspeed_in_desc.bEndpointAddress =
+			acc_fullspeed_in_desc.bEndpointAddress;
+		acc_highspeed_out_desc.bEndpointAddress =
+			acc_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name, dev->ep_out->name);
+	return 0;
+}
+
+static int
+acc_function_bind_configfs(struct usb_configuration *c,
+			struct usb_function *f) {
+	return __acc_function_bind(c, f, true);
+}
+
+static void
+kill_all_hid_devices(struct acc_dev *dev)
+{
+	struct acc_hid_dev *hid;
+	struct list_head *entry, *temp;
+	unsigned long flags;
+
+	/* do nothing if usb accessory device doesn't exist */
+	if (!dev)
+		return;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_for_each_safe(entry, temp, &dev->hid_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		list_del(&hid->list);
+		list_add(&hid->list, &dev->dead_hid_list);
+	}
+	list_for_each_safe(entry, temp, &dev->new_hid_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		list_del(&hid->list);
+		list_add(&hid->list, &dev->dead_hid_list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	schedule_work(&dev->hid_work);
+}
+
+static void
+acc_hid_unbind(struct acc_dev *dev)
+{
+	hid_unregister_driver(&acc_hid_driver);
+	kill_all_hid_devices(dev);
+}
+
+static void
+acc_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct acc_dev	*dev = func_to_dev(f);
+	struct usb_request *req;
+	int i;
+
+	dev->online = 0;		/* clear online flag */
+	wake_up(&dev->read_wq);		/* unblock reads on closure */
+	wake_up(&dev->write_wq);	/* likewise for writes */
+
+	while ((req = req_get(dev, &dev->tx_idle)))
+		acc_request_free(req, dev->ep_in);
+	for (i = 0; i < RX_REQ_MAX; i++)
+		acc_request_free(dev->rx_req[i], dev->ep_out);
+
+	acc_hid_unbind(dev);
+}
+
+static void acc_start_work(struct work_struct *data)
+{
+	char *envp[2] = { "ACCESSORY=START", NULL };
+
+	kobject_uevent_env(&acc_device.this_device->kobj, KOBJ_CHANGE, envp);
+}
+
+static int acc_hid_init(struct acc_hid_dev *hdev)
+{
+	struct hid_device *hid;
+	int ret;
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid))
+		return PTR_ERR(hid);
+
+	hid->ll_driver = &acc_hid_ll_driver;
+	hid->dev.parent = acc_device.this_device;
+
+	hid->bus = BUS_USB;
+	hid->vendor = HID_ANY_ID;
+	hid->product = HID_ANY_ID;
+	hid->driver_data = hdev;
+	ret = hid_add_device(hid);
+	if (ret) {
+		pr_err("can't add hid device: %d\n", ret);
+		hid_destroy_device(hid);
+		return ret;
+	}
+
+	hdev->hid = hid;
+	return 0;
+}
+
+static void acc_hid_delete(struct acc_hid_dev *hid)
+{
+	kfree(hid->report_desc);
+	kfree(hid);
+}
+
+static void acc_hid_work(struct work_struct *data)
+{
+	struct acc_dev *dev = _acc_dev;
+	struct list_head	*entry, *temp;
+	struct acc_hid_dev *hid;
+	struct list_head	new_list, dead_list;
+	unsigned long flags;
+
+	INIT_LIST_HEAD(&new_list);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* copy hids that are ready for initialization to new_list */
+	list_for_each_safe(entry, temp, &dev->new_hid_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		if (hid->report_desc_offset == hid->report_desc_len)
+			list_move(&hid->list, &new_list);
+	}
+
+	if (list_empty(&dev->dead_hid_list)) {
+		INIT_LIST_HEAD(&dead_list);
+	} else {
+		/* move all of dev->dead_hid_list to dead_list */
+		dead_list.prev = dev->dead_hid_list.prev;
+		dead_list.next = dev->dead_hid_list.next;
+		dead_list.next->prev = &dead_list;
+		dead_list.prev->next = &dead_list;
+		INIT_LIST_HEAD(&dev->dead_hid_list);
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	/* register new HID devices */
+	list_for_each_safe(entry, temp, &new_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		if (acc_hid_init(hid)) {
+			pr_err("can't add HID device %p\n", hid);
+			acc_hid_delete(hid);
+		} else {
+			spin_lock_irqsave(&dev->lock, flags);
+			list_move(&hid->list, &dev->hid_list);
+			spin_unlock_irqrestore(&dev->lock, flags);
+		}
+	}
+
+	/* remove dead HID devices */
+	list_for_each_safe(entry, temp, &dead_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		list_del(&hid->list);
+		if (hid->hid)
+			hid_destroy_device(hid->hid);
+		acc_hid_delete(hid);
+	}
+}
+
+static int acc_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct acc_dev	*dev = func_to_dev(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	DBG(cdev, "acc_function_set_alt intf: %d alt: %d\n", intf, alt);
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_in);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_in);
+	if (ret)
+		return ret;
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_out);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_out);
+	if (ret) {
+		usb_ep_disable(dev->ep_in);
+		return ret;
+	}
+
+	dev->online = 1;
+	dev->disconnected = 0; /* if online then not disconnected */
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+	return 0;
+}
+
+static void acc_function_disable(struct usb_function *f)
+{
+	struct acc_dev	*dev = func_to_dev(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	DBG(cdev, "acc_function_disable\n");
+	acc_set_disconnected(dev); /* this now only sets disconnected */
+	dev->online = 0; /* so now need to clear online flag here too */
+	usb_ep_disable(dev->ep_in);
+	usb_ep_disable(dev->ep_out);
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+
+	VDBG(cdev, "%s disabled\n", dev->function.name);
+}
+
+static int acc_setup(void)
+{
+	struct acc_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+	init_waitqueue_head(&dev->read_wq);
+	init_waitqueue_head(&dev->write_wq);
+	atomic_set(&dev->open_excl, 0);
+	INIT_LIST_HEAD(&dev->tx_idle);
+	INIT_LIST_HEAD(&dev->hid_list);
+	INIT_LIST_HEAD(&dev->new_hid_list);
+	INIT_LIST_HEAD(&dev->dead_hid_list);
+	INIT_DELAYED_WORK(&dev->start_work, acc_start_work);
+	INIT_WORK(&dev->hid_work, acc_hid_work);
+
+	/* _acc_dev must be set before calling usb_gadget_register_driver */
+	_acc_dev = dev;
+
+	ret = misc_register(&acc_device);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(dev);
+	pr_err("USB accessory gadget driver failed to initialize\n");
+	return ret;
+}
+
+void acc_disconnect(void)
+{
+	/* unregister all HID devices if USB is disconnected */
+	kill_all_hid_devices(_acc_dev);
+}
+EXPORT_SYMBOL_GPL(acc_disconnect);
+
+static void acc_cleanup(void)
+{
+	misc_deregister(&acc_device);
+	kfree(_acc_dev);
+	_acc_dev = NULL;
+}
+static struct acc_instance *to_acc_instance(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct acc_instance,
+		func_inst.group);
+}
+
+static void acc_attr_release(struct config_item *item)
+{
+	struct acc_instance *fi_acc = to_acc_instance(item);
+
+	usb_put_function_instance(&fi_acc->func_inst);
+}
+
+static struct configfs_item_operations acc_item_ops = {
+	.release        = acc_attr_release,
+};
+
+static struct config_item_type acc_func_type = {
+	.ct_item_ops    = &acc_item_ops,
+	.ct_owner       = THIS_MODULE,
+};
+
+static struct acc_instance *to_fi_acc(struct usb_function_instance *fi)
+{
+	return container_of(fi, struct acc_instance, func_inst);
+}
+
+static int acc_set_inst_name(struct usb_function_instance *fi, const char *name)
+{
+	struct acc_instance *fi_acc;
+	char *ptr;
+	int name_len;
+
+	name_len = strlen(name) + 1;
+	if (name_len > MAX_INST_NAME_LEN)
+		return -ENAMETOOLONG;
+
+	ptr = kstrndup(name, name_len, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	fi_acc = to_fi_acc(fi);
+	fi_acc->name = ptr;
+	return 0;
+}
+
+static void acc_free_inst(struct usb_function_instance *fi)
+{
+	struct acc_instance *fi_acc;
+
+	fi_acc = to_fi_acc(fi);
+	kfree(fi_acc->name);
+	acc_cleanup();
+}
+
+static struct usb_function_instance *acc_alloc_inst(void)
+{
+	struct acc_instance *fi_acc;
+	struct acc_dev *dev;
+	int err;
+
+	fi_acc = kzalloc(sizeof(*fi_acc), GFP_KERNEL);
+	if (!fi_acc)
+		return ERR_PTR(-ENOMEM);
+	fi_acc->func_inst.set_inst_name = acc_set_inst_name;
+	fi_acc->func_inst.free_func_inst = acc_free_inst;
+
+	err = acc_setup();
+	if (err) {
+		kfree(fi_acc);
+		pr_err("Error setting ACCESSORY\n");
+		return ERR_PTR(err);
+	}
+
+	config_group_init_type_name(&fi_acc->func_inst.group,
+					"", &acc_func_type);
+	dev = _acc_dev;
+	return  &fi_acc->func_inst;
+}
+
+static void acc_free(struct usb_function *f)
+{
+/*NO-OP: no function specific resource allocation in mtp_alloc*/
+}
+
+int acc_ctrlrequest_configfs(struct usb_function *f,
+			const struct usb_ctrlrequest *ctrl) {
+	if (f->config != NULL && f->config->cdev != NULL)
+		return acc_ctrlrequest(f->config->cdev, ctrl);
+	else
+		return -1;
+}
+
+static struct usb_function *acc_alloc(struct usb_function_instance *fi)
+{
+	struct acc_dev *dev = _acc_dev;
+
+	pr_info("acc_alloc\n");
+
+	dev->function.name = "accessory";
+	dev->function.strings = acc_strings,
+	dev->function.fs_descriptors = fs_acc_descs;
+	dev->function.hs_descriptors = hs_acc_descs;
+	dev->function.bind = acc_function_bind_configfs;
+	dev->function.unbind = acc_function_unbind;
+	dev->function.set_alt = acc_function_set_alt;
+	dev->function.disable = acc_function_disable;
+	dev->function.free_func = acc_free;
+	dev->function.setup = acc_ctrlrequest_configfs;
+
+	return &dev->function;
+}
+DECLARE_USB_FUNCTION_INIT(accessory, acc_alloc_inst, acc_alloc);
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/function/f_audio_source.c b/drivers/usb/gadget/function/f_audio_source.c
new file mode 100644
index 000000000..8124af33b
--- /dev/null
+++ b/drivers/usb/gadget/function/f_audio_source.c
@@ -0,0 +1,1071 @@
+/*
+ * Gadget Function Driver for USB audio source device
+ *
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/usb/audio.h>
+#include <linux/wait.h>
+#include <linux/pm_qos.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+
+#include <linux/usb.h>
+#include <linux/usb_usual.h>
+#include <linux/usb/ch9.h>
+#include <linux/configfs.h>
+#include <linux/usb/composite.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#define SAMPLE_RATE 44100
+#define FRAMES_PER_MSEC (SAMPLE_RATE / 1000)
+
+#define IN_EP_MAX_PACKET_SIZE 256
+
+/* Number of requests to allocate */
+#define IN_EP_REQ_COUNT 4
+
+#define AUDIO_AC_INTERFACE	0
+#define AUDIO_AS_INTERFACE	1
+#define AUDIO_NUM_INTERFACES	2
+#define MAX_INST_NAME_LEN     40
+
+/* B.3.1  Standard AC Interface Descriptor */
+static struct usb_interface_descriptor ac_interface_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bNumEndpoints =	0,
+	.bInterfaceClass =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOCONTROL,
+};
+
+DECLARE_UAC_AC_HEADER_DESCRIPTOR(2);
+
+#define UAC_DT_AC_HEADER_LENGTH	UAC_DT_AC_HEADER_SIZE(AUDIO_NUM_INTERFACES)
+/* 1 input terminal, 1 output terminal and 1 feature unit */
+#define UAC_DT_TOTAL_LENGTH (UAC_DT_AC_HEADER_LENGTH \
+	+ UAC_DT_INPUT_TERMINAL_SIZE + UAC_DT_OUTPUT_TERMINAL_SIZE \
+	+ UAC_DT_FEATURE_UNIT_SIZE(0))
+/* B.3.2  Class-Specific AC Interface Descriptor */
+static struct uac1_ac_header_descriptor_2 ac_header_desc = {
+	.bLength =		UAC_DT_AC_HEADER_LENGTH,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_HEADER,
+	.bcdADC =		__constant_cpu_to_le16(0x0100),
+	.wTotalLength =		__constant_cpu_to_le16(UAC_DT_TOTAL_LENGTH),
+	.bInCollection =	AUDIO_NUM_INTERFACES,
+	.baInterfaceNr = {
+		[0] =		AUDIO_AC_INTERFACE,
+		[1] =		AUDIO_AS_INTERFACE,
+	}
+};
+
+#define INPUT_TERMINAL_ID	1
+static struct uac_input_terminal_descriptor input_terminal_desc = {
+	.bLength =		UAC_DT_INPUT_TERMINAL_SIZE,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_INPUT_TERMINAL,
+	.bTerminalID =		INPUT_TERMINAL_ID,
+	.wTerminalType =	UAC_INPUT_TERMINAL_MICROPHONE,
+	.bAssocTerminal =	0,
+	.wChannelConfig =	0x3,
+};
+
+DECLARE_UAC_FEATURE_UNIT_DESCRIPTOR(0);
+
+#define FEATURE_UNIT_ID		2
+static struct uac_feature_unit_descriptor_0 feature_unit_desc = {
+	.bLength		= UAC_DT_FEATURE_UNIT_SIZE(0),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= UAC_FEATURE_UNIT,
+	.bUnitID		= FEATURE_UNIT_ID,
+	.bSourceID		= INPUT_TERMINAL_ID,
+	.bControlSize		= 2,
+};
+
+#define OUTPUT_TERMINAL_ID	3
+static struct uac1_output_terminal_descriptor output_terminal_desc = {
+	.bLength		= UAC_DT_OUTPUT_TERMINAL_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= UAC_OUTPUT_TERMINAL,
+	.bTerminalID		= OUTPUT_TERMINAL_ID,
+	.wTerminalType		= UAC_TERMINAL_STREAMING,
+	.bAssocTerminal		= FEATURE_UNIT_ID,
+	.bSourceID		= FEATURE_UNIT_ID,
+};
+
+/* B.4.1  Standard AS Interface Descriptor */
+static struct usb_interface_descriptor as_interface_alt_0_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bAlternateSetting =	0,
+	.bNumEndpoints =	0,
+	.bInterfaceClass =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOSTREAMING,
+};
+
+static struct usb_interface_descriptor as_interface_alt_1_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bAlternateSetting =	1,
+	.bNumEndpoints =	1,
+	.bInterfaceClass =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOSTREAMING,
+};
+
+/* B.4.2  Class-Specific AS Interface Descriptor */
+static struct uac1_as_header_descriptor as_header_desc = {
+	.bLength =		UAC_DT_AS_HEADER_SIZE,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_AS_GENERAL,
+	.bTerminalLink =	INPUT_TERMINAL_ID,
+	.bDelay =		1,
+	.wFormatTag =		UAC_FORMAT_TYPE_I_PCM,
+};
+
+DECLARE_UAC_FORMAT_TYPE_I_DISCRETE_DESC(1);
+
+static struct uac_format_type_i_discrete_descriptor_1 as_type_i_desc = {
+	.bLength =		UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(1),
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_FORMAT_TYPE,
+	.bFormatType =		UAC_FORMAT_TYPE_I,
+	.bSubframeSize =	2,
+	.bBitResolution =	16,
+	.bSamFreqType =		1,
+};
+
+/* Standard ISO IN Endpoint Descriptor for highspeed */
+static struct usb_endpoint_descriptor hs_as_in_ep_desc  = {
+	.bLength =		USB_DT_ENDPOINT_AUDIO_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_SYNC_SYNC
+				| USB_ENDPOINT_XFER_ISOC,
+	.wMaxPacketSize =	__constant_cpu_to_le16(IN_EP_MAX_PACKET_SIZE),
+	.bInterval =		4, /* poll 1 per millisecond */
+};
+
+/* Standard ISO IN Endpoint Descriptor for highspeed */
+static struct usb_endpoint_descriptor fs_as_in_ep_desc  = {
+	.bLength =		USB_DT_ENDPOINT_AUDIO_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_SYNC_SYNC
+				| USB_ENDPOINT_XFER_ISOC,
+	.wMaxPacketSize =	__constant_cpu_to_le16(IN_EP_MAX_PACKET_SIZE),
+	.bInterval =		1, /* poll 1 per millisecond */
+};
+
+/* Class-specific AS ISO OUT Endpoint Descriptor */
+static struct uac_iso_endpoint_descriptor as_iso_in_desc = {
+	.bLength =		UAC_ISO_ENDPOINT_DESC_SIZE,
+	.bDescriptorType =	USB_DT_CS_ENDPOINT,
+	.bDescriptorSubtype =	UAC_EP_GENERAL,
+	.bmAttributes =		1,
+	.bLockDelayUnits =	1,
+	.wLockDelay =		__constant_cpu_to_le16(1),
+};
+
+static struct usb_descriptor_header *hs_audio_desc[] = {
+	(struct usb_descriptor_header *)&ac_interface_desc,
+	(struct usb_descriptor_header *)&ac_header_desc,
+
+	(struct usb_descriptor_header *)&input_terminal_desc,
+	(struct usb_descriptor_header *)&output_terminal_desc,
+	(struct usb_descriptor_header *)&feature_unit_desc,
+
+	(struct usb_descriptor_header *)&as_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&as_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&as_header_desc,
+
+	(struct usb_descriptor_header *)&as_type_i_desc,
+
+	(struct usb_descriptor_header *)&hs_as_in_ep_desc,
+	(struct usb_descriptor_header *)&as_iso_in_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *fs_audio_desc[] = {
+	(struct usb_descriptor_header *)&ac_interface_desc,
+	(struct usb_descriptor_header *)&ac_header_desc,
+
+	(struct usb_descriptor_header *)&input_terminal_desc,
+	(struct usb_descriptor_header *)&output_terminal_desc,
+	(struct usb_descriptor_header *)&feature_unit_desc,
+
+	(struct usb_descriptor_header *)&as_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&as_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&as_header_desc,
+
+	(struct usb_descriptor_header *)&as_type_i_desc,
+
+	(struct usb_descriptor_header *)&fs_as_in_ep_desc,
+	(struct usb_descriptor_header *)&as_iso_in_desc,
+	NULL,
+};
+
+static struct snd_pcm_hardware audio_hw_info = {
+	.info =			SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_BATCH |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.rate_min		= SAMPLE_RATE,
+	.rate_max		= SAMPLE_RATE,
+
+	.buffer_bytes_max =	1024 * 1024,
+	.period_bytes_min =	64,
+	.period_bytes_max =	512 * 1024,
+	.periods_min =		2,
+	.periods_max =		1024,
+};
+
+/*-------------------------------------------------------------------------*/
+
+struct audio_source_config {
+	int	card;
+	int	device;
+};
+
+struct audio_dev {
+	struct usb_function		func;
+	struct snd_card			*card;
+	struct snd_pcm			*pcm;
+	struct snd_pcm_substream *substream;
+
+	struct list_head		idle_reqs;
+	struct usb_ep			*in_ep;
+
+	spinlock_t			lock;
+
+	/* beginning, end and current position in our buffer */
+	void				*buffer_start;
+	void				*buffer_end;
+	void				*buffer_pos;
+
+	/* byte size of a "period" */
+	unsigned int			period;
+	/* bytes sent since last call to snd_pcm_period_elapsed */
+	unsigned int			period_offset;
+	/* time we started playing */
+	ktime_t				start_time;
+	/* number of frames sent since start_time */
+	s64				frames_sent;
+	struct audio_source_config	*config;
+	/* for creating and issuing QoS requests */
+	struct pm_qos_request pm_qos;
+};
+
+static inline struct audio_dev *func_to_audio(struct usb_function *f)
+{
+	return container_of(f, struct audio_dev, func);
+}
+
+/*-------------------------------------------------------------------------*/
+
+struct audio_source_instance {
+	struct usb_function_instance func_inst;
+	const char *name;
+	struct audio_source_config *config;
+	struct device *audio_device;
+};
+
+static void audio_source_attr_release(struct config_item *item);
+
+static struct configfs_item_operations audio_source_item_ops = {
+	.release        = audio_source_attr_release,
+};
+
+static struct config_item_type audio_source_func_type = {
+	.ct_item_ops    = &audio_source_item_ops,
+	.ct_owner       = THIS_MODULE,
+};
+
+static ssize_t audio_source_pcm_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static DEVICE_ATTR(pcm, S_IRUGO, audio_source_pcm_show, NULL);
+
+static struct device_attribute *audio_source_function_attributes[] = {
+	&dev_attr_pcm,
+	NULL
+};
+
+/*--------------------------------------------------------------------------*/
+
+static struct usb_request *audio_request_new(struct usb_ep *ep, int buffer_size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+
+	if (!req)
+		return NULL;
+
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+	req->length = buffer_size;
+	return req;
+}
+
+static void audio_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+static void audio_req_put(struct audio_dev *audio, struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&audio->lock, flags);
+	list_add_tail(&req->list, &audio->idle_reqs);
+	spin_unlock_irqrestore(&audio->lock, flags);
+}
+
+static struct usb_request *audio_req_get(struct audio_dev *audio)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&audio->lock, flags);
+	if (list_empty(&audio->idle_reqs)) {
+		req = 0;
+	} else {
+		req = list_first_entry(&audio->idle_reqs, struct usb_request,
+				list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&audio->lock, flags);
+	return req;
+}
+
+/* send the appropriate number of packets to match our bitrate */
+static void audio_send(struct audio_dev *audio)
+{
+	struct snd_pcm_runtime *runtime;
+	struct usb_request *req;
+	int length, length1, length2, ret;
+	s64 msecs;
+	s64 frames;
+	ktime_t now;
+
+	/* audio->substream will be null if we have been closed */
+	if (!audio->substream)
+		return;
+	/* audio->buffer_pos will be null if we have been stopped */
+	if (!audio->buffer_pos)
+		return;
+
+	runtime = audio->substream->runtime;
+
+	/* compute number of frames to send */
+	now = ktime_get();
+	msecs = div_s64((ktime_to_ns(now) - ktime_to_ns(audio->start_time)),
+			1000000);
+	frames = div_s64((msecs * SAMPLE_RATE), 1000);
+
+	/* Readjust our frames_sent if we fall too far behind.
+	 * If we get too far behind it is better to drop some frames than
+	 * to keep sending data too fast in an attempt to catch up.
+	 */
+	if (frames - audio->frames_sent > 10 * FRAMES_PER_MSEC)
+		audio->frames_sent = frames - FRAMES_PER_MSEC;
+
+	frames -= audio->frames_sent;
+
+	/* We need to send something to keep the pipeline going */
+	if (frames <= 0)
+		frames = FRAMES_PER_MSEC;
+
+	while (frames > 0) {
+		req = audio_req_get(audio);
+		if (!req)
+			break;
+
+		length = frames_to_bytes(runtime, frames);
+		if (length > IN_EP_MAX_PACKET_SIZE)
+			length = IN_EP_MAX_PACKET_SIZE;
+
+		if (audio->buffer_pos + length > audio->buffer_end)
+			length1 = audio->buffer_end - audio->buffer_pos;
+		else
+			length1 = length;
+		memcpy(req->buf, audio->buffer_pos, length1);
+		if (length1 < length) {
+			/* Wrap around and copy remaining length
+			 * at beginning of buffer.
+			 */
+			length2 = length - length1;
+			memcpy(req->buf + length1, audio->buffer_start,
+					length2);
+			audio->buffer_pos = audio->buffer_start + length2;
+		} else {
+			audio->buffer_pos += length1;
+			if (audio->buffer_pos >= audio->buffer_end)
+				audio->buffer_pos = audio->buffer_start;
+		}
+
+		req->length = length;
+		ret = usb_ep_queue(audio->in_ep, req, GFP_ATOMIC);
+		if (ret < 0) {
+			pr_err("usb_ep_queue failed ret: %d\n", ret);
+			audio_req_put(audio, req);
+			break;
+		}
+
+		frames -= bytes_to_frames(runtime, length);
+		audio->frames_sent += bytes_to_frames(runtime, length);
+	}
+}
+
+static void audio_control_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	/* nothing to do here */
+}
+
+static void audio_data_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct audio_dev *audio = req->context;
+
+	pr_debug("audio_data_complete req->status %d req->actual %d\n",
+		req->status, req->actual);
+
+	audio_req_put(audio, req);
+
+	if (!audio->buffer_start || req->status)
+		return;
+
+	audio->period_offset += req->actual;
+	if (audio->period_offset >= audio->period) {
+		snd_pcm_period_elapsed(audio->substream);
+		audio->period_offset = 0;
+	}
+	audio_send(audio);
+}
+
+static int audio_set_endpoint_req(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	int value = -EOPNOTSUPP;
+	u16 ep = le16_to_cpu(ctrl->wIndex);
+	u16 len = le16_to_cpu(ctrl->wLength);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+
+	pr_debug("bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",
+			ctrl->bRequest, w_value, len, ep);
+
+	switch (ctrl->bRequest) {
+	case UAC_SET_CUR:
+	case UAC_SET_MIN:
+	case UAC_SET_MAX:
+	case UAC_SET_RES:
+		value = len;
+		break;
+	default:
+		break;
+	}
+
+	return value;
+}
+
+static int audio_get_endpoint_req(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int value = -EOPNOTSUPP;
+	u8 ep = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);
+	u16 len = le16_to_cpu(ctrl->wLength);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+	u8 *buf = cdev->req->buf;
+
+	pr_debug("bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",
+			ctrl->bRequest, w_value, len, ep);
+
+	if (w_value == UAC_EP_CS_ATTR_SAMPLE_RATE << 8) {
+		switch (ctrl->bRequest) {
+		case UAC_GET_CUR:
+		case UAC_GET_MIN:
+		case UAC_GET_MAX:
+		case UAC_GET_RES:
+			/* return our sample rate */
+			buf[0] = (u8)SAMPLE_RATE;
+			buf[1] = (u8)(SAMPLE_RATE >> 8);
+			buf[2] = (u8)(SAMPLE_RATE >> 16);
+			value = 3;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return value;
+}
+
+static int
+audio_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_request *req = cdev->req;
+	int value = -EOPNOTSUPP;
+	u16 w_index = le16_to_cpu(ctrl->wIndex);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+	u16 w_length = le16_to_cpu(ctrl->wLength);
+
+	/* composite driver infrastructure handles everything; interface
+	 * activation uses set_alt().
+	 */
+	switch (ctrl->bRequestType) {
+	case USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:
+		value = audio_set_endpoint_req(f, ctrl);
+		break;
+
+	case USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:
+		value = audio_get_endpoint_req(f, ctrl);
+		break;
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		pr_debug("audio req%02x.%02x v%04x i%04x l%d\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+		req->zero = 0;
+		req->length = value;
+		req->complete = audio_control_complete;
+		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+		if (value < 0)
+			pr_err("audio response on err %d\n", value);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static int audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
+{
+	struct audio_dev *audio = func_to_audio(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	pr_debug("audio_set_alt intf %d, alt %d\n", intf, alt);
+
+	ret = config_ep_by_speed(cdev->gadget, f, audio->in_ep);
+	if (ret)
+		return ret;
+
+	usb_ep_enable(audio->in_ep);
+	return 0;
+}
+
+static void audio_disable(struct usb_function *f)
+{
+	struct audio_dev	*audio = func_to_audio(f);
+
+	pr_debug("audio_disable\n");
+	usb_ep_disable(audio->in_ep);
+}
+
+static void audio_free_func(struct usb_function *f)
+{
+	/* no-op */
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void audio_build_desc(struct audio_dev *audio)
+{
+	u8 *sam_freq;
+	int rate;
+
+	/* Set channel numbers */
+	input_terminal_desc.bNrChannels = 2;
+	as_type_i_desc.bNrChannels = 2;
+
+	/* Set sample rates */
+	rate = SAMPLE_RATE;
+	sam_freq = as_type_i_desc.tSamFreq[0];
+	memcpy(sam_freq, &rate, 3);
+}
+
+
+static int snd_card_setup(struct usb_configuration *c,
+	struct audio_source_config *config);
+static struct audio_source_instance *to_fi_audio_source(
+	const struct usb_function_instance *fi);
+
+
+/* audio function driver setup/binding */
+static int
+audio_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct audio_dev *audio = func_to_audio(f);
+	int status;
+	struct usb_ep *ep;
+	struct usb_request *req;
+	int i;
+	int err;
+
+	if (IS_ENABLED(CONFIG_USB_CONFIGFS)) {
+		struct audio_source_instance *fi_audio =
+				to_fi_audio_source(f->fi);
+		struct audio_source_config *config =
+				fi_audio->config;
+
+		err = snd_card_setup(c, config);
+		if (err)
+			return err;
+	}
+
+	audio_build_desc(audio);
+
+	/* allocate instance-specific interface IDs, and patch descriptors */
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	ac_interface_desc.bInterfaceNumber = status;
+
+	/* AUDIO_AC_INTERFACE */
+	ac_header_desc.baInterfaceNr[0] = status;
+
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	as_interface_alt_0_desc.bInterfaceNumber = status;
+	as_interface_alt_1_desc.bInterfaceNumber = status;
+
+	/* AUDIO_AS_INTERFACE */
+	ac_header_desc.baInterfaceNr[1] = status;
+
+	status = -ENODEV;
+
+	/* allocate our endpoint */
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_as_in_ep_desc);
+	if (!ep)
+		goto fail;
+	audio->in_ep = ep;
+	ep->driver_data = audio; /* claim */
+
+	if (gadget_is_dualspeed(c->cdev->gadget))
+		hs_as_in_ep_desc.bEndpointAddress =
+			fs_as_in_ep_desc.bEndpointAddress;
+
+	f->fs_descriptors = fs_audio_desc;
+	f->hs_descriptors = hs_audio_desc;
+
+	for (i = 0, status = 0; i < IN_EP_REQ_COUNT && status == 0; i++) {
+		req = audio_request_new(ep, IN_EP_MAX_PACKET_SIZE);
+		if (req) {
+			req->context = audio;
+			req->complete = audio_data_complete;
+			audio_req_put(audio, req);
+		} else
+			status = -ENOMEM;
+	}
+
+fail:
+	return status;
+}
+
+static void
+audio_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct audio_dev *audio = func_to_audio(f);
+	struct usb_request *req;
+
+	while ((req = audio_req_get(audio)))
+		audio_request_free(req, audio->in_ep);
+
+	snd_card_free_when_closed(audio->card);
+	audio->card = NULL;
+	audio->pcm = NULL;
+	audio->substream = NULL;
+	audio->in_ep = NULL;
+
+	if (IS_ENABLED(CONFIG_USB_CONFIGFS)) {
+		struct audio_source_instance *fi_audio =
+				to_fi_audio_source(f->fi);
+		struct audio_source_config *config =
+				fi_audio->config;
+
+		config->card = -1;
+		config->device = -1;
+	}
+}
+
+static void audio_pcm_playback_start(struct audio_dev *audio)
+{
+	audio->start_time = ktime_get();
+	audio->frames_sent = 0;
+	audio_send(audio);
+}
+
+static void audio_pcm_playback_stop(struct audio_dev *audio)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&audio->lock, flags);
+	audio->buffer_start = 0;
+	audio->buffer_end = 0;
+	audio->buffer_pos = 0;
+	spin_unlock_irqrestore(&audio->lock, flags);
+}
+
+static int audio_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct audio_dev *audio = substream->private_data;
+
+	runtime->private_data = audio;
+	runtime->hw = audio_hw_info;
+	snd_pcm_limit_hw_rates(runtime);
+	runtime->hw.channels_max = 2;
+
+	audio->substream = substream;
+
+	/* Add the QoS request and set the latency to 0 */
+	pm_qos_add_request(&audio->pm_qos, PM_QOS_CPU_DMA_LATENCY, 0);
+
+	return 0;
+}
+
+static int audio_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct audio_dev *audio = substream->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&audio->lock, flags);
+
+	/* Remove the QoS request */
+	pm_qos_remove_request(&audio->pm_qos);
+
+	audio->substream = NULL;
+	spin_unlock_irqrestore(&audio->lock, flags);
+
+	return 0;
+}
+
+static int audio_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	unsigned int channels = params_channels(params);
+	unsigned int rate = params_rate(params);
+
+	if (rate != SAMPLE_RATE)
+		return -EINVAL;
+	if (channels != 2)
+		return -EINVAL;
+
+	return snd_pcm_lib_alloc_vmalloc_buffer(substream,
+		params_buffer_bytes(params));
+}
+
+static int audio_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int audio_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct audio_dev *audio = runtime->private_data;
+
+	audio->period = snd_pcm_lib_period_bytes(substream);
+	audio->period_offset = 0;
+	audio->buffer_start = runtime->dma_area;
+	audio->buffer_end = audio->buffer_start
+		+ snd_pcm_lib_buffer_bytes(substream);
+	audio->buffer_pos = audio->buffer_start;
+
+	return 0;
+}
+
+static snd_pcm_uframes_t audio_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct audio_dev *audio = runtime->private_data;
+	ssize_t bytes = audio->buffer_pos - audio->buffer_start;
+
+	/* return offset of next frame to fill in our buffer */
+	return bytes_to_frames(runtime, bytes);
+}
+
+static int audio_pcm_playback_trigger(struct snd_pcm_substream *substream,
+					int cmd)
+{
+	struct audio_dev *audio = substream->runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		audio_pcm_playback_start(audio);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		audio_pcm_playback_stop(audio);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static struct audio_dev _audio_dev = {
+	.func = {
+		.name = "audio_source",
+		.bind = audio_bind,
+		.unbind = audio_unbind,
+		.set_alt = audio_set_alt,
+		.setup = audio_setup,
+		.disable = audio_disable,
+		.free_func = audio_free_func,
+	},
+	.lock = __SPIN_LOCK_UNLOCKED(_audio_dev.lock),
+	.idle_reqs = LIST_HEAD_INIT(_audio_dev.idle_reqs),
+};
+
+static struct snd_pcm_ops audio_playback_ops = {
+	.open		= audio_pcm_open,
+	.close		= audio_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= audio_pcm_hw_params,
+	.hw_free	= audio_pcm_hw_free,
+	.prepare	= audio_pcm_prepare,
+	.trigger	= audio_pcm_playback_trigger,
+	.pointer	= audio_pcm_pointer,
+};
+
+int audio_source_bind_config(struct usb_configuration *c,
+		struct audio_source_config *config)
+{
+	struct audio_dev *audio;
+	int err;
+
+	config->card = -1;
+	config->device = -1;
+
+	audio = &_audio_dev;
+
+	err = snd_card_setup(c, config);
+	if (err)
+		return err;
+
+	err = usb_add_function(c, &audio->func);
+	if (err)
+		goto add_fail;
+
+	return 0;
+
+add_fail:
+	snd_card_free(audio->card);
+	return err;
+}
+
+static int snd_card_setup(struct usb_configuration *c,
+		struct audio_source_config *config)
+{
+	struct audio_dev *audio;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	int err;
+
+	audio = &_audio_dev;
+
+	err = snd_card_new(&c->cdev->gadget->dev,
+			SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			THIS_MODULE, 0, &card);
+	if (err)
+		return err;
+
+	err = snd_pcm_new(card, "USB audio source", 0, 1, 0, &pcm);
+	if (err)
+		goto pcm_fail;
+
+	pcm->private_data = audio;
+	pcm->info_flags = 0;
+	audio->pcm = pcm;
+
+	strlcpy(pcm->name, "USB gadget audio", sizeof(pcm->name));
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &audio_playback_ops);
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+				NULL, 0, 64 * 1024);
+
+	strlcpy(card->driver, "audio_source", sizeof(card->driver));
+	strlcpy(card->shortname, card->driver, sizeof(card->shortname));
+	strlcpy(card->longname, "USB accessory audio source",
+		sizeof(card->longname));
+
+	err = snd_card_register(card);
+	if (err)
+		goto register_fail;
+
+	config->card = pcm->card->number;
+	config->device = pcm->device;
+	audio->card = card;
+	return 0;
+
+register_fail:
+pcm_fail:
+	snd_card_free(audio->card);
+	return err;
+}
+
+static struct audio_source_instance *to_audio_source_instance(
+					struct config_item *item)
+{
+	return container_of(to_config_group(item), struct audio_source_instance,
+		func_inst.group);
+}
+
+static struct audio_source_instance *to_fi_audio_source(
+					const struct usb_function_instance *fi)
+{
+	return container_of(fi, struct audio_source_instance, func_inst);
+}
+
+static void audio_source_attr_release(struct config_item *item)
+{
+	struct audio_source_instance *fi_audio = to_audio_source_instance(item);
+
+	usb_put_function_instance(&fi_audio->func_inst);
+}
+
+static int audio_source_set_inst_name(struct usb_function_instance *fi,
+					const char *name)
+{
+	struct audio_source_instance *fi_audio;
+	char *ptr;
+	int name_len;
+
+	name_len = strlen(name) + 1;
+	if (name_len > MAX_INST_NAME_LEN)
+		return -ENAMETOOLONG;
+
+	ptr = kstrndup(name, name_len, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	fi_audio = to_fi_audio_source(fi);
+	fi_audio->name = ptr;
+
+	return 0;
+}
+
+static void audio_source_free_inst(struct usb_function_instance *fi)
+{
+	struct audio_source_instance *fi_audio;
+
+	fi_audio = to_fi_audio_source(fi);
+	device_destroy(fi_audio->audio_device->class,
+			fi_audio->audio_device->devt);
+	kfree(fi_audio->name);
+	kfree(fi_audio->config);
+}
+
+static ssize_t audio_source_pcm_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct audio_source_instance *fi_audio = dev_get_drvdata(dev);
+	struct audio_source_config *config = fi_audio->config;
+
+	/* print PCM card and device numbers */
+	return sprintf(buf, "%d %d\n", config->card, config->device);
+}
+
+struct device *create_function_device(char *name);
+
+static struct usb_function_instance *audio_source_alloc_inst(void)
+{
+	struct audio_source_instance *fi_audio;
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+	struct device *dev;
+	void *err_ptr;
+	int err = 0;
+
+	fi_audio = kzalloc(sizeof(*fi_audio), GFP_KERNEL);
+	if (!fi_audio)
+		return ERR_PTR(-ENOMEM);
+
+	fi_audio->func_inst.set_inst_name = audio_source_set_inst_name;
+	fi_audio->func_inst.free_func_inst = audio_source_free_inst;
+
+	fi_audio->config = kzalloc(sizeof(struct audio_source_config),
+							GFP_KERNEL);
+	if (!fi_audio->config) {
+		err_ptr = ERR_PTR(-ENOMEM);
+		goto fail_audio;
+	}
+
+	config_group_init_type_name(&fi_audio->func_inst.group, "",
+						&audio_source_func_type);
+	dev = create_function_device("f_audio_source");
+
+	if (IS_ERR(dev)) {
+		err_ptr = dev;
+		goto fail_audio_config;
+	}
+
+	fi_audio->config->card = -1;
+	fi_audio->config->device = -1;
+	fi_audio->audio_device = dev;
+
+	attrs = audio_source_function_attributes;
+	if (attrs) {
+		while ((attr = *attrs++) && !err)
+			err = device_create_file(dev, attr);
+		if (err) {
+			err_ptr = ERR_PTR(-EINVAL);
+			goto fail_device;
+		}
+	}
+
+	dev_set_drvdata(dev, fi_audio);
+	_audio_dev.config = fi_audio->config;
+
+	return  &fi_audio->func_inst;
+
+fail_device:
+	device_destroy(dev->class, dev->devt);
+fail_audio_config:
+	kfree(fi_audio->config);
+fail_audio:
+	kfree(fi_audio);
+	return err_ptr;
+
+}
+
+static struct usb_function *audio_source_alloc(struct usb_function_instance *fi)
+{
+	return &_audio_dev.func;
+}
+
+DECLARE_USB_FUNCTION_INIT(audio_source, audio_source_alloc_inst,
+			audio_source_alloc);
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/function/f_midi.c b/drivers/usb/gadget/function/f_midi.c
index 46af0aa07..4713a1c7f 100644
--- a/drivers/usb/gadget/function/f_midi.c
+++ b/drivers/usb/gadget/function/f_midi.c
@@ -1216,6 +1216,65 @@ static void f_midi_free_inst(struct usb_function_instance *f)
 	}
 }
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+extern struct device *create_function_device(char *name);
+static ssize_t alsa_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct usb_function_instance *fi_midi = dev_get_drvdata(dev);
+	struct f_midi *midi;
+
+	if (!fi_midi->f)
+		dev_warn(dev, "f_midi: function not set\n");
+
+	if (fi_midi && fi_midi->f) {
+		midi = func_to_midi(fi_midi->f);
+		if (midi->rmidi && midi->rmidi->card)
+			return sprintf(buf, "%d %d\n",
+			midi->rmidi->card->number, midi->rmidi->device);
+	}
+
+	/* print PCM card and device numbers */
+	return sprintf(buf, "%d %d\n", -1, -1);
+}
+
+static DEVICE_ATTR(alsa, S_IRUGO, alsa_show, NULL);
+
+static struct device_attribute *alsa_function_attributes[] = {
+	&dev_attr_alsa,
+	NULL
+};
+
+static int create_alsa_device(struct usb_function_instance *fi)
+{
+	struct device *dev;
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+	int err = 0;
+
+	dev = create_function_device("f_midi");
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	attrs = alsa_function_attributes;
+	if (attrs) {
+		while ((attr = *attrs++) && !err)
+			err = device_create_file(dev, attr);
+		if (err) {
+			device_destroy(dev->class, dev->devt);
+			return -EINVAL;
+		}
+	}
+	dev_set_drvdata(dev, fi);
+	return 0;
+}
+#else
+static int create_alsa_device(struct usb_function_instance *fi)
+{
+	return 0;
+}
+#endif
+
 static struct usb_function_instance *f_midi_alloc_inst(void)
 {
 	struct f_midi_opts *opts;
@@ -1234,6 +1293,11 @@ static struct usb_function_instance *f_midi_alloc_inst(void)
 	opts->out_ports = 1;
 	opts->refcnt = 1;
 
+	if (create_alsa_device(&opts->func_inst)) {
+		kfree(opts);
+		return ERR_PTR(-ENODEV);
+	}
+
 	config_group_init_type_name(&opts->func_inst.group, "",
 				    &midi_func_type);
 
@@ -1254,6 +1318,7 @@ static void f_midi_free(struct usb_function *f)
 		kfifo_free(&midi->in_req_fifo);
 		kfree(midi);
 		free = true;
+		opts->func_inst.f = NULL;
 	}
 	mutex_unlock(&opts->lock);
 
@@ -1341,6 +1406,7 @@ static struct usb_function *f_midi_alloc(struct usb_function_instance *fi)
 	midi->func.disable	= f_midi_disable;
 	midi->func.free_func	= f_midi_free;
 
+	fi->f = &midi->func;
 	return &midi->func;
 
 setup_fail:
diff --git a/drivers/usb/gadget/function/f_uac1.c b/drivers/usb/gadget/function/f_uac1.c
index 00d346965..1baea8422 100644
--- a/drivers/usb/gadget/function/f_uac1.c
+++ b/drivers/usb/gadget/function/f_uac1.c
@@ -586,17 +586,21 @@ static int f_audio_bind(struct usb_configuration *c, struct usb_function *f)
 	status = -ENODEV;
 
 	/* allocate instance-specific endpoints */
-	ep = usb_ep_autoconfig(cdev->gadget, &as_out_ep_desc);
-	if (!ep)
-		goto fail;
-	audio->out_ep = ep;
-	audio->out_ep->desc = &as_out_ep_desc;
+	if (audio_opts->c_chmask != 0) {
+		ep = usb_ep_autoconfig(cdev->gadget, &as_out_ep_desc);
+		if (!ep)
+			goto fail;
+		audio->out_ep = ep;
+		audio->out_ep->desc = &as_out_ep_desc;
+	}
 
-	ep = usb_ep_autoconfig(cdev->gadget, &as_in_ep_desc);
-	if (!ep)
-		goto fail;
-	audio->in_ep = ep;
-	audio->in_ep->desc = &as_in_ep_desc;
+	if (audio_opts->p_chmask != 0) {
+		ep = usb_ep_autoconfig(cdev->gadget, &as_in_ep_desc);
+		if (!ep)
+			goto fail;
+		audio->in_ep = ep;
+		audio->in_ep->desc = &as_in_ep_desc;
+	}
 
 	/* copy descriptors, and track endpoint copies */
 	status = usb_assign_descriptors(f, f_audio_desc, f_audio_desc, NULL,
@@ -654,7 +658,7 @@ static ssize_t f_uac1_opts_##name##_show(				\
 	int result;							\
 									\
 	mutex_lock(&opts->lock);					\
-	result = sprintf(page, "%u\n", opts->name);			\
+	result = sprintf(page, "%d\n", opts->name);			\
 	mutex_unlock(&opts->lock);					\
 									\
 	return result;							\
diff --git a/drivers/usb/gadget/legacy/Kconfig b/drivers/usb/gadget/legacy/Kconfig
index 69ff7f8c8..abf7a0594 100644
--- a/drivers/usb/gadget/legacy/Kconfig
+++ b/drivers/usb/gadget/legacy/Kconfig
@@ -14,6 +14,32 @@
 # both kinds of controller can also support "USB On-the-Go" (CONFIG_USB_OTG).
 #
 
+choice
+	tristate "USB Gadget precomposed configurations"
+	default USB_ETH
+	optional
+	help
+	  A Linux "Gadget Driver" talks to the USB Peripheral Controller
+	  driver through the abstract "gadget" API.  Some other operating
+	  systems call these "client" drivers, of which "class drivers"
+	  are a subset (implementing a USB device class specification).
+	  A gadget driver implements one or more USB functions using
+	  the peripheral hardware.
+
+	  Gadget drivers are hardware-neutral, or "platform independent",
+	  except that they sometimes must understand quirks or limitations
+	  of the particular controllers they work with.  For example, when
+	  a controller doesn't support alternate configurations or provide
+	  enough of the right types of endpoints, the gadget driver might
+	  not be able work with that controller, or might need to implement
+	  a less common variant of a device class protocol.
+
+	  The available choices each represent a single precomposed USB
+	  gadget configuration. In the device model, each option contains
+	  both the device instantiation as a child for a USB gadget
+	  controller, and the relevant drivers for each function declared
+	  by the device.
+
 config USB_ZERO
 	tristate "Gadget Zero (DEVELOPMENT)"
 	select USB_LIBCOMPOSITE
@@ -489,3 +515,16 @@ config USB_G_WEBCAM
 
 	  Say "y" to link the driver statically, or "m" to build a
 	  dynamically linked module called "g_webcam".
+
+config USB_RAW_GADGET
+	tristate "USB Raw Gadget"
+	help
+	  USB Raw Gadget is a kernel module that provides a userspace interface
+	  for the USB Gadget subsystem. Essentially it allows to emulate USB
+	  devices from userspace. See Documentation/usb/raw-gadget.rst for
+	  details.
+
+	  Say "y" to link the driver statically, or "m" to build a
+	  dynamically linked module called "raw_gadget".
+
+endchoice
diff --git a/drivers/usb/gadget/legacy/Makefile b/drivers/usb/gadget/legacy/Makefile
index abd0c3e66..4d864bf82 100644
--- a/drivers/usb/gadget/legacy/Makefile
+++ b/drivers/usb/gadget/legacy/Makefile
@@ -43,3 +43,4 @@ obj-$(CONFIG_USB_G_WEBCAM)	+= g_webcam.o
 obj-$(CONFIG_USB_G_NCM)		+= g_ncm.o
 obj-$(CONFIG_USB_G_ACM_MS)	+= g_acm_ms.o
 obj-$(CONFIG_USB_GADGET_TARGET)	+= tcm_usb_gadget.o
+obj-$(CONFIG_USB_RAW_GADGET)	+= raw_gadget.o
diff --git a/drivers/usb/gadget/legacy/raw_gadget.c b/drivers/usb/gadget/legacy/raw_gadget.c
new file mode 100644
index 000000000..e01e366d8
--- /dev/null
+++ b/drivers/usb/gadget/legacy/raw_gadget.c
@@ -0,0 +1,1280 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * USB Raw Gadget driver.
+ * See Documentation/usb/raw-gadget.rst for more details.
+ *
+ * Andrey Konovalov <andreyknvl@gmail.com>
+ */
+
+#include <linux/compiler.h>
+#include <linux/ctype.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/kref.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/ch11.h>
+#include <linux/usb/gadget.h>
+
+#include <uapi/linux/usb/raw_gadget.h>
+
+#define	DRIVER_DESC "USB Raw Gadget"
+#define DRIVER_NAME "raw-gadget"
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Andrey Konovalov");
+MODULE_LICENSE("GPL");
+
+/*----------------------------------------------------------------------*/
+
+#define RAW_EVENT_QUEUE_SIZE	16
+
+struct raw_event_queue {
+	/* See the comment in raw_event_queue_fetch() for locking details. */
+	spinlock_t		lock;
+	struct semaphore	sema;
+	struct usb_raw_event	*events[RAW_EVENT_QUEUE_SIZE];
+	int			size;
+};
+
+static void raw_event_queue_init(struct raw_event_queue *queue)
+{
+	spin_lock_init(&queue->lock);
+	sema_init(&queue->sema, 0);
+	queue->size = 0;
+}
+
+static int raw_event_queue_add(struct raw_event_queue *queue,
+	enum usb_raw_event_type type, size_t length, const void *data)
+{
+	unsigned long flags;
+	struct usb_raw_event *event;
+
+	spin_lock_irqsave(&queue->lock, flags);
+	if (WARN_ON(queue->size >= RAW_EVENT_QUEUE_SIZE)) {
+		spin_unlock_irqrestore(&queue->lock, flags);
+		return -ENOMEM;
+	}
+	event = kmalloc(sizeof(*event) + length, GFP_ATOMIC);
+	if (!event) {
+		spin_unlock_irqrestore(&queue->lock, flags);
+		return -ENOMEM;
+	}
+	event->type = type;
+	event->length = length;
+	if (event->length)
+		memcpy(&event->data[0], data, length);
+	queue->events[queue->size] = event;
+	queue->size++;
+	up(&queue->sema);
+	spin_unlock_irqrestore(&queue->lock, flags);
+	return 0;
+}
+
+static struct usb_raw_event *raw_event_queue_fetch(
+				struct raw_event_queue *queue)
+{
+	int ret;
+	unsigned long flags;
+	struct usb_raw_event *event;
+
+	/*
+	 * This function can be called concurrently. We first check that
+	 * there's at least one event queued by decrementing the semaphore,
+	 * and then take the lock to protect queue struct fields.
+	 */
+	ret = down_interruptible(&queue->sema);
+	if (ret)
+		return ERR_PTR(ret);
+	spin_lock_irqsave(&queue->lock, flags);
+	/*
+	 * queue->size must have the same value as queue->sema counter (before
+	 * the down_interruptible() call above), so this check is a fail-safe.
+	 */
+	if (WARN_ON(!queue->size)) {
+		spin_unlock_irqrestore(&queue->lock, flags);
+		return ERR_PTR(-ENODEV);
+	}
+	event = queue->events[0];
+	queue->size--;
+	memmove(&queue->events[0], &queue->events[1],
+			queue->size * sizeof(queue->events[0]));
+	spin_unlock_irqrestore(&queue->lock, flags);
+	return event;
+}
+
+static void raw_event_queue_destroy(struct raw_event_queue *queue)
+{
+	int i;
+
+	for (i = 0; i < queue->size; i++)
+		kfree(queue->events[i]);
+	queue->size = 0;
+}
+
+/*----------------------------------------------------------------------*/
+
+struct raw_dev;
+
+enum ep_state {
+	STATE_EP_DISABLED,
+	STATE_EP_ENABLED,
+};
+
+struct raw_ep {
+	struct raw_dev		*dev;
+	enum ep_state		state;
+	struct usb_ep		*ep;
+	u8			addr;
+	struct usb_request	*req;
+	bool			urb_queued;
+	bool			disabling;
+	ssize_t			status;
+};
+
+enum dev_state {
+	STATE_DEV_INVALID = 0,
+	STATE_DEV_OPENED,
+	STATE_DEV_INITIALIZED,
+	STATE_DEV_RUNNING,
+	STATE_DEV_CLOSED,
+	STATE_DEV_FAILED
+};
+
+struct raw_dev {
+	struct kref			count;
+	spinlock_t			lock;
+
+	const char			*udc_name;
+	struct usb_gadget_driver	driver;
+
+	/* Reference to misc device: */
+	struct device			*dev;
+
+	/* Protected by lock: */
+	enum dev_state			state;
+	bool				gadget_registered;
+	struct usb_gadget		*gadget;
+	struct usb_request		*req;
+	bool				ep0_in_pending;
+	bool				ep0_out_pending;
+	bool				ep0_urb_queued;
+	ssize_t				ep0_status;
+	struct raw_ep			eps[USB_RAW_EPS_NUM_MAX];
+	int				eps_num;
+
+	struct completion		ep0_done;
+	struct raw_event_queue		queue;
+};
+
+static struct raw_dev *dev_new(void)
+{
+	struct raw_dev *dev;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+	/* Matches kref_put() in raw_release(). */
+	kref_init(&dev->count);
+	spin_lock_init(&dev->lock);
+	init_completion(&dev->ep0_done);
+	raw_event_queue_init(&dev->queue);
+	return dev;
+}
+
+static void dev_free(struct kref *kref)
+{
+	struct raw_dev *dev = container_of(kref, struct raw_dev, count);
+	int i;
+
+	kfree(dev->udc_name);
+	kfree(dev->driver.udc_name);
+	if (dev->req) {
+		if (dev->ep0_urb_queued)
+			usb_ep_dequeue(dev->gadget->ep0, dev->req);
+		usb_ep_free_request(dev->gadget->ep0, dev->req);
+	}
+	raw_event_queue_destroy(&dev->queue);
+	for (i = 0; i < dev->eps_num; i++) {
+		if (dev->eps[i].state == STATE_EP_DISABLED)
+			continue;
+		usb_ep_disable(dev->eps[i].ep);
+		usb_ep_free_request(dev->eps[i].ep, dev->eps[i].req);
+		kfree(dev->eps[i].ep->desc);
+		dev->eps[i].state = STATE_EP_DISABLED;
+	}
+	kfree(dev);
+}
+
+/*----------------------------------------------------------------------*/
+
+static int raw_queue_event(struct raw_dev *dev,
+	enum usb_raw_event_type type, size_t length, const void *data)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	ret = raw_event_queue_add(&dev->queue, type, length, data);
+	if (ret < 0) {
+		spin_lock_irqsave(&dev->lock, flags);
+		dev->state = STATE_DEV_FAILED;
+		spin_unlock_irqrestore(&dev->lock, flags);
+	}
+	return ret;
+}
+
+static void gadget_ep0_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct raw_dev *dev = req->context;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (req->status)
+		dev->ep0_status = req->status;
+	else
+		dev->ep0_status = req->actual;
+	if (dev->ep0_in_pending)
+		dev->ep0_in_pending = false;
+	else
+		dev->ep0_out_pending = false;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	complete(&dev->ep0_done);
+}
+
+static u8 get_ep_addr(const char *name)
+{
+	/* If the endpoint has fixed function (named as e.g. "ep12out-bulk"),
+	 * parse the endpoint address from its name. We deliberately use
+	 * deprecated simple_strtoul() function here, as the number isn't
+	 * followed by '\0' nor '\n'.
+	 */
+	if (isdigit(name[2]))
+		return simple_strtoul(&name[2], NULL, 10);
+	/* Otherwise the endpoint is configurable (named as e.g. "ep-a"). */
+	return USB_RAW_EP_ADDR_ANY;
+}
+
+static int gadget_bind(struct usb_gadget *gadget,
+			struct usb_gadget_driver *driver)
+{
+	int ret = 0, i = 0;
+	struct raw_dev *dev = container_of(driver, struct raw_dev, driver);
+	struct usb_request *req;
+	struct usb_ep *ep;
+	unsigned long flags;
+
+	if (strcmp(gadget->name, dev->udc_name) != 0)
+		return -ENODEV;
+
+	set_gadget_data(gadget, dev);
+	req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);
+	if (!req) {
+		dev_err(&gadget->dev, "usb_ep_alloc_request failed\n");
+		set_gadget_data(gadget, NULL);
+		return -ENOMEM;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->req = req;
+	dev->req->context = dev;
+	dev->req->complete = gadget_ep0_complete;
+	dev->gadget = gadget;
+	gadget_for_each_ep(ep, dev->gadget) {
+		dev->eps[i].ep = ep;
+		dev->eps[i].addr = get_ep_addr(ep->name);
+		dev->eps[i].state = STATE_EP_DISABLED;
+		i++;
+	}
+	dev->eps_num = i;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	/* Matches kref_put() in gadget_unbind(). */
+	kref_get(&dev->count);
+
+	ret = raw_queue_event(dev, USB_RAW_EVENT_CONNECT, 0, NULL);
+	if (ret < 0)
+		dev_err(&gadget->dev, "failed to queue event\n");
+
+	return ret;
+}
+
+static void gadget_unbind(struct usb_gadget *gadget)
+{
+	struct raw_dev *dev = get_gadget_data(gadget);
+
+	set_gadget_data(gadget, NULL);
+	/* Matches kref_get() in gadget_bind(). */
+	kref_put(&dev->count, dev_free);
+}
+
+static int gadget_setup(struct usb_gadget *gadget,
+			const struct usb_ctrlrequest *ctrl)
+{
+	int ret = 0;
+	struct raw_dev *dev = get_gadget_data(gadget);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_err(&gadget->dev, "ignoring, device is not running\n");
+		ret = -ENODEV;
+		goto out_unlock;
+	}
+	if (dev->ep0_in_pending || dev->ep0_out_pending) {
+		dev_dbg(&gadget->dev, "stalling, request already pending\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if ((ctrl->bRequestType & USB_DIR_IN) && ctrl->wLength)
+		dev->ep0_in_pending = true;
+	else
+		dev->ep0_out_pending = true;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	ret = raw_queue_event(dev, USB_RAW_EVENT_CONTROL, sizeof(*ctrl), ctrl);
+	if (ret < 0)
+		dev_err(&gadget->dev, "failed to queue event\n");
+	goto out;
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+out:
+	return ret;
+}
+
+/* These are currently unused but present in case UDC driver requires them. */
+static void gadget_disconnect(struct usb_gadget *gadget) { }
+static void gadget_suspend(struct usb_gadget *gadget) { }
+static void gadget_resume(struct usb_gadget *gadget) { }
+static void gadget_reset(struct usb_gadget *gadget) { }
+
+/*----------------------------------------------------------------------*/
+
+static struct miscdevice raw_misc_device;
+
+static int raw_open(struct inode *inode, struct file *fd)
+{
+	struct raw_dev *dev;
+
+	/* Nonblocking I/O is not supported yet. */
+	if (fd->f_flags & O_NONBLOCK)
+		return -EINVAL;
+
+	dev = dev_new();
+	if (!dev)
+		return -ENOMEM;
+	fd->private_data = dev;
+	dev->state = STATE_DEV_OPENED;
+	dev->dev = raw_misc_device.this_device;
+	return 0;
+}
+
+static int raw_release(struct inode *inode, struct file *fd)
+{
+	int ret = 0;
+	struct raw_dev *dev = fd->private_data;
+	unsigned long flags;
+	bool unregister = false;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->state = STATE_DEV_CLOSED;
+	if (!dev->gadget) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		goto out_put;
+	}
+	if (dev->gadget_registered)
+		unregister = true;
+	dev->gadget_registered = false;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	if (unregister) {
+		ret = usb_gadget_unregister_driver(&dev->driver);
+		if (ret != 0)
+			dev_err(dev->dev,
+				"usb_gadget_unregister_driver() failed with %d\n",
+				ret);
+		/* Matches kref_get() in raw_ioctl_run(). */
+		kref_put(&dev->count, dev_free);
+	}
+
+out_put:
+	/* Matches dev_new() in raw_open(). */
+	kref_put(&dev->count, dev_free);
+	return ret;
+}
+
+/*----------------------------------------------------------------------*/
+
+static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	struct usb_raw_init arg;
+	char *udc_driver_name;
+	char *udc_device_name;
+	unsigned long flags;
+
+	if (copy_from_user(&arg, (void __user *)value, sizeof(arg)))
+		return -EFAULT;
+
+	switch (arg.speed) {
+	case USB_SPEED_UNKNOWN:
+		arg.speed = USB_SPEED_HIGH;
+		break;
+	case USB_SPEED_LOW:
+	case USB_SPEED_FULL:
+	case USB_SPEED_HIGH:
+	case USB_SPEED_SUPER:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	udc_driver_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);
+	if (!udc_driver_name)
+		return -ENOMEM;
+	ret = strscpy(udc_driver_name, &arg.driver_name[0],
+				UDC_NAME_LENGTH_MAX);
+	if (ret < 0) {
+		kfree(udc_driver_name);
+		return ret;
+	}
+	ret = 0;
+
+	udc_device_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);
+	if (!udc_device_name) {
+		kfree(udc_driver_name);
+		return -ENOMEM;
+	}
+	ret = strscpy(udc_device_name, &arg.device_name[0],
+				UDC_NAME_LENGTH_MAX);
+	if (ret < 0) {
+		kfree(udc_driver_name);
+		kfree(udc_device_name);
+		return ret;
+	}
+	ret = 0;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_OPENED) {
+		dev_dbg(dev->dev, "fail, device is not opened\n");
+		kfree(udc_driver_name);
+		kfree(udc_device_name);
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	dev->udc_name = udc_driver_name;
+
+	dev->driver.function = DRIVER_DESC;
+	dev->driver.max_speed = arg.speed;
+	dev->driver.setup = gadget_setup;
+	dev->driver.disconnect = gadget_disconnect;
+	dev->driver.bind = gadget_bind;
+	dev->driver.unbind = gadget_unbind;
+	dev->driver.suspend = gadget_suspend;
+	dev->driver.resume = gadget_resume;
+	dev->driver.reset = gadget_reset;
+	dev->driver.driver.name = DRIVER_NAME;
+	dev->driver.udc_name = udc_device_name;
+	dev->driver.match_existing_only = 1;
+
+	dev->state = STATE_DEV_INITIALIZED;
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static int raw_ioctl_run(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	if (value)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_INITIALIZED) {
+		dev_dbg(dev->dev, "fail, device is not initialized\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	ret = usb_gadget_probe_driver(&dev->driver);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (ret) {
+		dev_err(dev->dev,
+			"fail, usb_gadget_probe_driver returned %d\n", ret);
+		dev->state = STATE_DEV_FAILED;
+		goto out_unlock;
+	}
+	dev->gadget_registered = true;
+	dev->state = STATE_DEV_RUNNING;
+	/* Matches kref_put() in raw_release(). */
+	kref_get(&dev->count);
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static int raw_ioctl_event_fetch(struct raw_dev *dev, unsigned long value)
+{
+	struct usb_raw_event arg;
+	unsigned long flags;
+	struct usb_raw_event *event;
+	uint32_t length;
+
+	if (copy_from_user(&arg, (void __user *)value, sizeof(arg)))
+		return -EFAULT;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -EINVAL;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -EBUSY;
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	event = raw_event_queue_fetch(&dev->queue);
+	if (PTR_ERR(event) == -EINTR) {
+		dev_dbg(&dev->gadget->dev, "event fetching interrupted\n");
+		return -EINTR;
+	}
+	if (IS_ERR(event)) {
+		dev_err(&dev->gadget->dev, "failed to fetch event\n");
+		spin_lock_irqsave(&dev->lock, flags);
+		dev->state = STATE_DEV_FAILED;
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -ENODEV;
+	}
+	length = min(arg.length, event->length);
+	if (copy_to_user((void __user *)value, event, sizeof(*event) + length))
+		return -EFAULT;
+
+	return 0;
+}
+
+static void *raw_alloc_io_data(struct usb_raw_ep_io *io, void __user *ptr,
+				bool get_from_user)
+{
+	void *data;
+
+	if (copy_from_user(io, ptr, sizeof(*io)))
+		return ERR_PTR(-EFAULT);
+	if (io->ep >= USB_RAW_EPS_NUM_MAX)
+		return ERR_PTR(-EINVAL);
+	if (!usb_raw_io_flags_valid(io->flags))
+		return ERR_PTR(-EINVAL);
+	if (io->length > PAGE_SIZE)
+		return ERR_PTR(-EINVAL);
+	if (get_from_user)
+		data = memdup_user(ptr + sizeof(*io), io->length);
+	else {
+		data = kmalloc(io->length, GFP_KERNEL);
+		if (!data)
+			data = ERR_PTR(-ENOMEM);
+	}
+	return data;
+}
+
+static int raw_process_ep0_io(struct raw_dev *dev, struct usb_raw_ep_io *io,
+				void *data, bool in)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (dev->ep0_urb_queued) {
+		dev_dbg(&dev->gadget->dev, "fail, urb already queued\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if ((in && !dev->ep0_in_pending) ||
+			(!in && !dev->ep0_out_pending)) {
+		dev_dbg(&dev->gadget->dev, "fail, wrong direction\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (WARN_ON(in && dev->ep0_out_pending)) {
+		ret = -ENODEV;
+		dev->state = STATE_DEV_FAILED;
+		goto out_done;
+	}
+	if (WARN_ON(!in && dev->ep0_in_pending)) {
+		ret = -ENODEV;
+		dev->state = STATE_DEV_FAILED;
+		goto out_done;
+	}
+
+	dev->req->buf = data;
+	dev->req->length = io->length;
+	dev->req->zero = usb_raw_io_flags_zero(io->flags);
+	dev->ep0_urb_queued = true;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	ret = usb_ep_queue(dev->gadget->ep0, dev->req, GFP_KERNEL);
+	if (ret) {
+		dev_err(&dev->gadget->dev,
+				"fail, usb_ep_queue returned %d\n", ret);
+		spin_lock_irqsave(&dev->lock, flags);
+		dev->state = STATE_DEV_FAILED;
+		goto out_done;
+	}
+
+	ret = wait_for_completion_interruptible(&dev->ep0_done);
+	if (ret) {
+		dev_dbg(&dev->gadget->dev, "wait interrupted\n");
+		usb_ep_dequeue(dev->gadget->ep0, dev->req);
+		wait_for_completion(&dev->ep0_done);
+		spin_lock_irqsave(&dev->lock, flags);
+		goto out_done;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+	ret = dev->ep0_status;
+
+out_done:
+	dev->ep0_urb_queued = false;
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static int raw_ioctl_ep0_write(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	void *data;
+	struct usb_raw_ep_io io;
+
+	data = raw_alloc_io_data(&io, (void __user *)value, true);
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+	ret = raw_process_ep0_io(dev, &io, data, true);
+	kfree(data);
+	return ret;
+}
+
+static int raw_ioctl_ep0_read(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	void *data;
+	struct usb_raw_ep_io io;
+	unsigned int length;
+
+	data = raw_alloc_io_data(&io, (void __user *)value, false);
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+	ret = raw_process_ep0_io(dev, &io, data, false);
+	if (ret < 0)
+		goto free;
+
+	length = min(io.length, (unsigned int)ret);
+	if (copy_to_user((void __user *)(value + sizeof(io)), data, length))
+		ret = -EFAULT;
+	else
+		ret = length;
+free:
+	kfree(data);
+	return ret;
+}
+
+static int raw_ioctl_ep0_stall(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	if (value)
+		return -EINVAL;
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (dev->ep0_urb_queued) {
+		dev_dbg(&dev->gadget->dev, "fail, urb already queued\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (!dev->ep0_in_pending && !dev->ep0_out_pending) {
+		dev_dbg(&dev->gadget->dev, "fail, no request pending\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+
+	ret = usb_ep_set_halt(dev->gadget->ep0);
+	if (ret < 0)
+		dev_err(&dev->gadget->dev,
+				"fail, usb_ep_set_halt returned %d\n", ret);
+
+	if (dev->ep0_in_pending)
+		dev->ep0_in_pending = false;
+	else
+		dev->ep0_out_pending = false;
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static int raw_ioctl_ep_enable(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0, i;
+	unsigned long flags;
+	struct usb_endpoint_descriptor *desc;
+	struct raw_ep *ep;
+
+	desc = memdup_user((void __user *)value, sizeof(*desc));
+	if (IS_ERR(desc))
+		return PTR_ERR(desc);
+
+	/*
+	 * Endpoints with a maxpacket length of 0 can cause crashes in UDC
+	 * drivers.
+	 */
+	if (usb_endpoint_maxp(desc) == 0) {
+		dev_dbg(dev->dev, "fail, bad endpoint maxpacket\n");
+		kfree(desc);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		goto out_free;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		goto out_free;
+	}
+
+	for (i = 0; i < dev->eps_num; i++) {
+		ep = &dev->eps[i];
+		if (ep->state != STATE_EP_DISABLED)
+			continue;
+		if (ep->addr != usb_endpoint_num(desc) &&
+				ep->addr != USB_RAW_EP_ADDR_ANY)
+			continue;
+		if (!usb_gadget_ep_match_desc(dev->gadget, ep->ep, desc, NULL))
+			continue;
+		ep->ep->desc = desc;
+		ret = usb_ep_enable(ep->ep);
+		if (ret < 0) {
+			dev_err(&dev->gadget->dev,
+				"fail, usb_ep_enable returned %d\n", ret);
+			goto out_free;
+		}
+		ep->req = usb_ep_alloc_request(ep->ep, GFP_ATOMIC);
+		if (!ep->req) {
+			dev_err(&dev->gadget->dev,
+				"fail, usb_ep_alloc_request failed\n");
+			usb_ep_disable(ep->ep);
+			ret = -ENOMEM;
+			goto out_free;
+		}
+		ep->state = STATE_EP_ENABLED;
+		ep->ep->driver_data = ep;
+		ret = i;
+		goto out_unlock;
+	}
+
+	dev_dbg(&dev->gadget->dev, "fail, no gadget endpoints available\n");
+	ret = -EBUSY;
+
+out_free:
+	kfree(desc);
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static int raw_ioctl_ep_disable(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0, i = value;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (i < 0 || i >= dev->eps_num) {
+		dev_dbg(dev->dev, "fail, invalid endpoint\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (dev->eps[i].state == STATE_EP_DISABLED) {
+		dev_dbg(&dev->gadget->dev, "fail, endpoint is not enabled\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (dev->eps[i].disabling) {
+		dev_dbg(&dev->gadget->dev,
+				"fail, disable already in progress\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (dev->eps[i].urb_queued) {
+		dev_dbg(&dev->gadget->dev,
+				"fail, waiting for urb completion\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	dev->eps[i].disabling = true;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	usb_ep_disable(dev->eps[i].ep);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	usb_ep_free_request(dev->eps[i].ep, dev->eps[i].req);
+	kfree(dev->eps[i].ep->desc);
+	dev->eps[i].state = STATE_EP_DISABLED;
+	dev->eps[i].disabling = false;
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static int raw_ioctl_ep_set_clear_halt_wedge(struct raw_dev *dev,
+		unsigned long value, bool set, bool halt)
+{
+	int ret = 0, i = value;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (i < 0 || i >= dev->eps_num) {
+		dev_dbg(dev->dev, "fail, invalid endpoint\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (dev->eps[i].state == STATE_EP_DISABLED) {
+		dev_dbg(&dev->gadget->dev, "fail, endpoint is not enabled\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (dev->eps[i].disabling) {
+		dev_dbg(&dev->gadget->dev,
+				"fail, disable is in progress\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (dev->eps[i].urb_queued) {
+		dev_dbg(&dev->gadget->dev,
+				"fail, waiting for urb completion\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (usb_endpoint_xfer_isoc(dev->eps[i].ep->desc)) {
+		dev_dbg(&dev->gadget->dev,
+				"fail, can't halt/wedge ISO endpoint\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	if (set && halt) {
+		ret = usb_ep_set_halt(dev->eps[i].ep);
+		if (ret < 0)
+			dev_err(&dev->gadget->dev,
+				"fail, usb_ep_set_halt returned %d\n", ret);
+	} else if (!set && halt) {
+		ret = usb_ep_clear_halt(dev->eps[i].ep);
+		if (ret < 0)
+			dev_err(&dev->gadget->dev,
+				"fail, usb_ep_clear_halt returned %d\n", ret);
+	} else if (set && !halt) {
+		ret = usb_ep_set_wedge(dev->eps[i].ep);
+		if (ret < 0)
+			dev_err(&dev->gadget->dev,
+				"fail, usb_ep_set_wedge returned %d\n", ret);
+	}
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static void gadget_ep_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct raw_ep *r_ep = (struct raw_ep *)ep->driver_data;
+	struct raw_dev *dev = r_ep->dev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (req->status)
+		r_ep->status = req->status;
+	else
+		r_ep->status = req->actual;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	complete((struct completion *)req->context);
+}
+
+static int raw_process_ep_io(struct raw_dev *dev, struct usb_raw_ep_io *io,
+				void *data, bool in)
+{
+	int ret = 0;
+	unsigned long flags;
+	struct raw_ep *ep;
+	DECLARE_COMPLETION_ONSTACK(done);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (io->ep >= dev->eps_num) {
+		dev_dbg(&dev->gadget->dev, "fail, invalid endpoint\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	ep = &dev->eps[io->ep];
+	if (ep->state != STATE_EP_ENABLED) {
+		dev_dbg(&dev->gadget->dev, "fail, endpoint is not enabled\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (ep->disabling) {
+		dev_dbg(&dev->gadget->dev,
+				"fail, endpoint is already being disabled\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if (ep->urb_queued) {
+		dev_dbg(&dev->gadget->dev, "fail, urb already queued\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	if ((in && !ep->ep->caps.dir_in) || (!in && ep->ep->caps.dir_in)) {
+		dev_dbg(&dev->gadget->dev, "fail, wrong direction\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	ep->dev = dev;
+	ep->req->context = &done;
+	ep->req->complete = gadget_ep_complete;
+	ep->req->buf = data;
+	ep->req->length = io->length;
+	ep->req->zero = usb_raw_io_flags_zero(io->flags);
+	ep->urb_queued = true;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	ret = usb_ep_queue(ep->ep, ep->req, GFP_KERNEL);
+	if (ret) {
+		dev_err(&dev->gadget->dev,
+				"fail, usb_ep_queue returned %d\n", ret);
+		spin_lock_irqsave(&dev->lock, flags);
+		dev->state = STATE_DEV_FAILED;
+		goto out_done;
+	}
+
+	ret = wait_for_completion_interruptible(&done);
+	if (ret) {
+		dev_dbg(&dev->gadget->dev, "wait interrupted\n");
+		usb_ep_dequeue(ep->ep, ep->req);
+		wait_for_completion(&done);
+		spin_lock_irqsave(&dev->lock, flags);
+		goto out_done;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+	ret = ep->status;
+
+out_done:
+	ep->urb_queued = false;
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static int raw_ioctl_ep_write(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	char *data;
+	struct usb_raw_ep_io io;
+
+	data = raw_alloc_io_data(&io, (void __user *)value, true);
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+	ret = raw_process_ep_io(dev, &io, data, true);
+	kfree(data);
+	return ret;
+}
+
+static int raw_ioctl_ep_read(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	char *data;
+	struct usb_raw_ep_io io;
+	unsigned int length;
+
+	data = raw_alloc_io_data(&io, (void __user *)value, false);
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+	ret = raw_process_ep_io(dev, &io, data, false);
+	if (ret < 0)
+		goto free;
+
+	length = min(io.length, (unsigned int)ret);
+	if (copy_to_user((void __user *)(value + sizeof(io)), data, length))
+		ret = -EFAULT;
+	else
+		ret = length;
+free:
+	kfree(data);
+	return ret;
+}
+
+static int raw_ioctl_configure(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	if (value)
+		return -EINVAL;
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	usb_gadget_set_state(dev->gadget, USB_STATE_CONFIGURED);
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static int raw_ioctl_vbus_draw(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+	usb_gadget_vbus_draw(dev->gadget, 2 * value);
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+static void fill_ep_caps(struct usb_ep_caps *caps,
+				struct usb_raw_ep_caps *raw_caps)
+{
+	raw_caps->type_control = caps->type_control;
+	raw_caps->type_iso = caps->type_iso;
+	raw_caps->type_bulk = caps->type_bulk;
+	raw_caps->type_int = caps->type_int;
+	raw_caps->dir_in = caps->dir_in;
+	raw_caps->dir_out = caps->dir_out;
+}
+
+static void fill_ep_limits(struct usb_ep *ep, struct usb_raw_ep_limits *limits)
+{
+	limits->maxpacket_limit = ep->maxpacket_limit;
+	limits->max_streams = ep->max_streams;
+}
+
+static int raw_ioctl_eps_info(struct raw_dev *dev, unsigned long value)
+{
+	int ret = 0, i;
+	unsigned long flags;
+	struct usb_raw_eps_info *info;
+	struct raw_ep *ep;
+
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->state != STATE_DEV_RUNNING) {
+		dev_dbg(dev->dev, "fail, device is not running\n");
+		ret = -EINVAL;
+		spin_unlock_irqrestore(&dev->lock, flags);
+		goto out_free;
+	}
+	if (!dev->gadget) {
+		dev_dbg(dev->dev, "fail, gadget is not bound\n");
+		ret = -EBUSY;
+		spin_unlock_irqrestore(&dev->lock, flags);
+		goto out_free;
+	}
+
+	memset(info, 0, sizeof(*info));
+	for (i = 0; i < dev->eps_num; i++) {
+		ep = &dev->eps[i];
+		strscpy(&info->eps[i].name[0], ep->ep->name,
+				USB_RAW_EP_NAME_MAX);
+		info->eps[i].addr = ep->addr;
+		fill_ep_caps(&ep->ep->caps, &info->eps[i].caps);
+		fill_ep_limits(ep->ep, &info->eps[i].limits);
+	}
+	ret = dev->eps_num;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	if (copy_to_user((void __user *)value, info, sizeof(*info)))
+		ret = -EFAULT;
+
+out_free:
+	kfree(info);
+out:
+	return ret;
+}
+
+static long raw_ioctl(struct file *fd, unsigned int cmd, unsigned long value)
+{
+	struct raw_dev *dev = fd->private_data;
+	int ret = 0;
+
+	if (!dev)
+		return -EBUSY;
+
+	switch (cmd) {
+	case USB_RAW_IOCTL_INIT:
+		ret = raw_ioctl_init(dev, value);
+		break;
+	case USB_RAW_IOCTL_RUN:
+		ret = raw_ioctl_run(dev, value);
+		break;
+	case USB_RAW_IOCTL_EVENT_FETCH:
+		ret = raw_ioctl_event_fetch(dev, value);
+		break;
+	case USB_RAW_IOCTL_EP0_WRITE:
+		ret = raw_ioctl_ep0_write(dev, value);
+		break;
+	case USB_RAW_IOCTL_EP0_READ:
+		ret = raw_ioctl_ep0_read(dev, value);
+		break;
+	case USB_RAW_IOCTL_EP_ENABLE:
+		ret = raw_ioctl_ep_enable(dev, value);
+		break;
+	case USB_RAW_IOCTL_EP_DISABLE:
+		ret = raw_ioctl_ep_disable(dev, value);
+		break;
+	case USB_RAW_IOCTL_EP_WRITE:
+		ret = raw_ioctl_ep_write(dev, value);
+		break;
+	case USB_RAW_IOCTL_EP_READ:
+		ret = raw_ioctl_ep_read(dev, value);
+		break;
+	case USB_RAW_IOCTL_CONFIGURE:
+		ret = raw_ioctl_configure(dev, value);
+		break;
+	case USB_RAW_IOCTL_VBUS_DRAW:
+		ret = raw_ioctl_vbus_draw(dev, value);
+		break;
+	case USB_RAW_IOCTL_EPS_INFO:
+		ret = raw_ioctl_eps_info(dev, value);
+		break;
+	case USB_RAW_IOCTL_EP0_STALL:
+		ret = raw_ioctl_ep0_stall(dev, value);
+		break;
+	case USB_RAW_IOCTL_EP_SET_HALT:
+		ret = raw_ioctl_ep_set_clear_halt_wedge(
+					dev, value, true, true);
+		break;
+	case USB_RAW_IOCTL_EP_CLEAR_HALT:
+		ret = raw_ioctl_ep_set_clear_halt_wedge(
+					dev, value, false, true);
+		break;
+	case USB_RAW_IOCTL_EP_SET_WEDGE:
+		ret = raw_ioctl_ep_set_clear_halt_wedge(
+					dev, value, true, false);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/*----------------------------------------------------------------------*/
+
+static const struct file_operations raw_fops = {
+	.open =			raw_open,
+	.unlocked_ioctl =	raw_ioctl,
+	.compat_ioctl =		raw_ioctl,
+	.release =		raw_release,
+	.llseek =		no_llseek,
+};
+
+static struct miscdevice raw_misc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DRIVER_NAME,
+	.fops = &raw_fops,
+};
+
+module_misc_device(raw_misc_device);
diff --git a/drivers/usb/gadget/udc/Kconfig b/drivers/usb/gadget/udc/Kconfig
index d354036ff..4c8bc52cb 100644
--- a/drivers/usb/gadget/udc/Kconfig
+++ b/drivers/usb/gadget/udc/Kconfig
@@ -402,6 +402,19 @@ config USB_GOKU
 	   dynamically linked module called "goku_udc" and to force all
 	   gadget drivers to also be dynamically linked.
 
+config USB_SUNXI_UDC0
+	tristate "SoftWinner SUNXI USB Peripheral Controller"
+	depends on USB_GADGET
+	select USB_GADGET_DUALSPEED
+	select USB_GADGET_SELECTED
+	help
+	  AllWinner SUNXI USB Device Controller.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
 config USB_EG20T
 	tristate "Intel QUARK X1000/EG20T PCH/LAPIS Semiconductor IOH(ML7213/ML7831) UDC"
 	depends on USB_PCI
@@ -449,7 +462,7 @@ source "drivers/usb/gadget/udc/aspeed-vhub/Kconfig"
 
 config USB_DUMMY_HCD
 	tristate "Dummy HCD (DEVELOPMENT)"
-	depends on USB=y || (USB=m && USB_GADGET=m)
+	depends on USB=y
 	help
 	  This host controller driver emulates USB, looping all data transfer
 	  requests back to a USB "gadget driver" in the same host.  The host
diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 0e7820158..6fa7e5d95 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -986,7 +986,11 @@ int usb_gadget_ep_match_desc(struct usb_gadget *gadget,
 		/* Bulk endpoints handle interrupt transfers,
 		 * except the toggle-quirky iso-synch kind
 		 */
+#if IS_ENABLED(CONFIG_USB_SUNXI_UDC0)
+		if (!ep->caps.type_int)
+#else
 		if (!ep->caps.type_int && !ep->caps.type_bulk)
+#endif
 			return 0;
 		/* INT:  limit 64 bytes full speed, 1024 high/super speed */
 		if (!gadget_is_dualspeed(gadget) && max > 64)
diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index 4c9d1e49d..9f177b223 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -187,31 +187,31 @@ static const struct {
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),
 
 	/* and now some generic EPs so we have enough in multi config */
-	EP_INFO("ep3out",
+	EP_INFO("ep-aout",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
-	EP_INFO("ep4in",
+	EP_INFO("ep-bin",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
-	EP_INFO("ep5out",
+	EP_INFO("ep-cout",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
-	EP_INFO("ep6out",
+	EP_INFO("ep-dout",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
-	EP_INFO("ep7in",
+	EP_INFO("ep-ein",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
-	EP_INFO("ep8out",
+	EP_INFO("ep-fout",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
-	EP_INFO("ep9in",
+	EP_INFO("ep-gin",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
-	EP_INFO("ep10out",
+	EP_INFO("ep-hout",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
-	EP_INFO("ep11out",
+	EP_INFO("ep-iout",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
-	EP_INFO("ep12in",
+	EP_INFO("ep-jin",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
-	EP_INFO("ep13out",
+	EP_INFO("ep-kout",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
-	EP_INFO("ep14in",
+	EP_INFO("ep-lin",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
-	EP_INFO("ep15out",
+	EP_INFO("ep-mout",
 		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 
 #undef EP_INFO
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 79b2e79dd..a275e4f13 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -42,6 +42,15 @@ config USB_XHCI_PCI
        depends on USB_PCI
        default y
 
+config USB_XHCI_PCI_RENESAS
+	tristate "Renesas USB XHCI Driver"
+	depends on USB_XHCI_PCI
+	---help---
+	  Say 'Y' to enable the support for renesas USB XHCI Driver if
+	  you have such a device. These devices need additional firmware,
+	  make sure that is available.
+	  If unsure, say 'N'.
+
 config USB_XHCI_PLATFORM
 	tristate "Generic xHCI driver for a platform device"
 	select USB_XHCI_RCAR if ARCH_RENESAS
@@ -253,6 +262,12 @@ config USB_EHCI_TEGRA
          This driver enables support for the internal USB Host Controllers
          found in NVIDIA Tegra SoCs. The controllers are EHCI compliant.
 
+config USB_EHCI_HCD_SUNXI
+       tristate "SUNXI EHCI HCD support"
+       help
+         This driver enables support for the internal USB Host Controllers
+         found in SUNXI SoCs. The controllers are EHCI compliant.
+
 config USB_EHCI_HCD_PPC_OF
 	bool "EHCI support for PPC USB controller on OF platform bus"
 	depends on PPC
@@ -482,6 +497,12 @@ config USB_OHCI_HCD_DAVINCI
 	  controller. This driver cannot currently be a loadable
 	  module because it lacks a proper PHY abstraction.
 
+config USB_OHCI_HCD_SUNXI
+       tristate "SUNXI OHCI HCD support"
+       help
+         This driver enables support for the internal USB Host Controllers
+         found in SUNXI SoCs. The controllers are OHCI compliant.
+
 config USB_OHCI_HCD_PPC_OF_BE
 	bool "OHCI support for OF platform bus (big endian)"
 	depends on PPC
@@ -762,3 +783,145 @@ config USB_HCD_TEST_MODE
 	  This option is of interest only to developers who need to validate
 	  their USB hardware designs.  It is not needed for normal use.  If
 	  unsure, say N.
+
+#-----------------------------------------------------
+#
+# SUNXI USB Host Controller Drivers
+#
+#-----------------------------------------------------
+config USB_SUNXI_HCD
+    tristate "SoftWinner SUNXI USB Host Controller support"
+	depends on USB
+	help
+	  SoftWinner SUNXI USB2.0 Host Controller support.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_HCD0
+    tristate "SoftWinner SUNXI USB Host Controller0"
+        depends on USB_SUNXI_HCD && ARCH_SUN8IW6
+        help
+          SoftWinner SUNXI USB2.0 Host Controller0.
+	  Enable this option if your board has this chip, and you want
+	  to use it as a host controller.
+
+	  If unsure, say N.
+
+config USB_SUNXI_HCI
+    tristate "SoftWinner SUNXI USB HCI"
+	depends on USB_SUNXI_HCD
+	help
+	  SoftWinner SUNXI USB HCI.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_EHCI0
+    tristate "SoftWinner SUNXI USB EHCI0"
+	depends on USB_SUNXI_HCI
+	help
+	  SoftWinner SUNXI USB EHCI0.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_EHCI1
+    tristate "SoftWinner SUNXI USB EHCI1"
+	depends on USB_SUNXI_HCI && !ARCH_SUN50IW6 && !ARCH_SUN8IW5 \
+			&& !ARCH_SUN8IW18
+	help
+	  SoftWinner SUNXI USB EHCI1.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_EHCI2
+    tristate "SoftWinner SUNXI USB EHCI2"
+	depends on USB_SUNXI_HCI && (ARCH_SUN8IW11 || ARCH_SUN50IW2 \
+			|| ARCH_SUN8IW7 || ARCH_SUN8IW17 || ARCH_SUN50IW9)
+	help
+	  SoftWinner SUNXI USB EHCI2.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_EHCI3
+    tristate "SoftWinner SUNXI USB EHCI3"
+	depends on USB_SUNXI_HCI && (ARCH_SUN50IW2 || ARCH_SUN8IW7 \
+			|| ARCH_SUN50IW6 || ARCH_SUN8IW17 || ARCH_SUN50IW9)
+	help
+	  SoftWinner SUNXI USB EHCI3.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_OHCI0
+    tristate "SoftWinner SUNXI USB OHCI0"
+	depends on USB_SUNXI_HCI
+	help
+	  SoftWinner SUNXI USB OHCI0.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_OHCI1
+    tristate "SoftWinner SUNXI USB OHCI1"
+	depends on USB_SUNXI_HCI && !ARCH_SUN8IW6 && !ARCH_SUN50IW6 \
+			&& !ARCH_SUN8IW5 && !ARCH_SUN8IW18
+	help
+	  SoftWinner SUNXI USB OHCI1.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_OHCI2
+    tristate "SoftWinner SUNXI USB OHCI2"
+	depends on USB_SUNXI_HCI && (ARCH_SUN8IW11 || ARCH_SUN50IW2 \
+			|| ARCH_SUN8IW7 || ARCH_SUN8IW17 || ARCH_SUN50IW9)
+	help
+	  SoftWinner SUNXI USB OHCI2.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_OHCI3
+    tristate "SoftWinner SUNXI USB OHCI3"
+	depends on USB_SUNXI_HCI && (ARCH_SUN50IW2 || ARCH_SUN8IW7 \
+			|| ARCH_SUN50IW6 || ARCH_SUN8IW17 || ARCH_SUN50IW9)
+	help
+	  SoftWinner SUNXI USB OHCI3.
+
+	  This option is of interest only to developers who need to
+	  develop on AllWinner SoC.
+
+	  If unsure, say N.
+
+config USB_SUNXI_XHCI
+	tristate "SoftWinner SUNXI USB XHCI"
+	depends on USB_SUNXI_HCI && ARCH_SUN50IW6
+	select USB_XHCI_PLATFORM if USB_SUPPORT && USB_XHCI_HCD
+	help
+	  The Renesas USBSS is a XHCI controller.
+	  Enable this option if your board has this chip, and you want
+	  to use it as a host controller.
+
+	  If unsure, say N.
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index b19136125..3c2008559 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -49,6 +49,7 @@ obj-$(CONFIG_USB_EHCI_HCD_STI)	+= ehci-st.o
 obj-$(CONFIG_USB_EHCI_EXYNOS)	+= ehci-exynos.o
 obj-$(CONFIG_USB_EHCI_HCD_AT91) += ehci-atmel.o
 obj-$(CONFIG_USB_EHCI_TEGRA)	+= ehci-tegra.o
+obj-$(CONFIG_USB_EHCI_HCD_SUNXI)	+= ehci-sunxi.o
 
 obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
 obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
@@ -66,10 +67,12 @@ obj-$(CONFIG_USB_OHCI_HCD_S3C2410)	+= ohci-s3c2410.o
 obj-$(CONFIG_USB_OHCI_HCD_LPC32XX)	+= ohci-nxp.o
 obj-$(CONFIG_USB_OHCI_HCD_PXA27X)	+= ohci-pxa27x.o
 obj-$(CONFIG_USB_OHCI_HCD_DAVINCI)	+= ohci-da8xx.o
+obj-$(CONFIG_USB_OHCI_HCD_SUNXI)	+= ohci-sunxi.o
 
 obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
 obj-$(CONFIG_USB_FHCI_HCD)	+= fhci.o
 obj-$(CONFIG_USB_XHCI_HCD)	+= xhci-hcd.o
+obj-$(CONFIG_USB_XHCI_PCI_RENESAS)	+= xhci-pci-renesas.o
 obj-$(CONFIG_USB_XHCI_PCI)	+= xhci-pci.o
 obj-$(CONFIG_USB_XHCI_PLATFORM) += xhci-plat-hcd.o
 obj-$(CONFIG_USB_XHCI_HISTB)	+= xhci-histb.o
@@ -88,3 +91,5 @@ obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
 obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
 obj-$(CONFIG_USB_MAX3421_HCD)	+= max3421-hcd.o
+obj-$(CONFIG_USB_SUNXI_HCI)	+= sunxi-hci.o
+obj-$(CONFIG_USB_SUNXI_XHCI)	+= xhci_sunxi.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index cf2b7ae93..d09cc4094 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -22,6 +22,7 @@
 #include <linux/interrupt.h>
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
+#include <linux/usb/otg.h>
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>
 #include <linux/debugfs.h>
@@ -765,6 +766,16 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
 		u32		ppcd = ~0;
 
+{
+		int pstatus0 = 0;
+		pstatus0 = ehci_readl(ehci, &ehci->regs->port_status[0]);
+
+		if ((pstatus0 & PORT_CONNECT) && (pstatus0 & PORT_CSC)) {
+			ehci_info(ehci, "ehci_irq: highspeed device connect\n");
+		} else if (!(pstatus0 & PORT_CONNECT) && (pstatus0 & PORT_CSC)) {
+			ehci_info(ehci, "ehci_irq: highspeed device disconnect\n");
+		}
+}
 		/* kick root hub later */
 		pcd_status = status;
 
@@ -1332,6 +1343,7 @@ static int __init ehci_hcd_init(void)
 	if (retval < 0)
 		goto clean4;
 #endif
+
 	return retval;
 
 #ifdef XILINX_OF_PLATFORM_DRIVER
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index ce0eaf7d7..087402aec 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -14,7 +14,6 @@
  */
 
 /*-------------------------------------------------------------------------*/
-#include <linux/usb/otg.h>
 
 #define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
 
diff --git a/drivers/usb/host/ehci-sunxi.c b/drivers/usb/host/ehci-sunxi.c
new file mode 100644
index 000000000..3674b5455
--- /dev/null
+++ b/drivers/usb/host/ehci-sunxi.c
@@ -0,0 +1,1179 @@
+/**
+ * drivers/usb/host/ehci-sunxi.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yangnaitian, 2011-5-24, create this file
+ * javen, 2011-6-26, add suspend and resume
+ * javen, 2011-7-18, move clock and power operations out from driver
+ *
+ * SoftWinner EHCI Driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/clk.h>
+#include <linux/notifier.h>
+#include <linux/suspend.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/phy/phy.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/regulator/consumer.h>
+#include "ehci.h"
+#include "sunxi-hci.h"
+
+#define DRIVER_DESC "EHCI SUNXI driver"
+
+#define  SUNXI_EHCI_NAME	"sunxi-ehci"
+static const char ehci_name[] = SUNXI_EHCI_NAME;
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI0)
+#define  SUNXI_EHCI0_OF_MATCH	"allwinner,sunxi-ehci0"
+#else
+#define  SUNXI_EHCI0_OF_MATCH   "null"
+#endif
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI1)
+#define  SUNXI_EHCI1_OF_MATCH	"allwinner,sunxi-ehci1"
+#else
+#define  SUNXI_EHCI1_OF_MATCH   "null"
+#endif
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI2)
+#define  SUNXI_EHCI2_OF_MATCH	"allwinner,sunxi-ehci2"
+#else
+#define  SUNXI_EHCI2_OF_MATCH   "null"
+#endif
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI3)
+#define  SUNXI_EHCI3_OF_MATCH	"allwinner,sunxi-ehci3"
+#else
+#define  SUNXI_EHCI3_OF_MATCH   "null"
+#endif
+
+static struct sunxi_hci_hcd *g_sunxi_ehci[4];
+static u32 ehci_first_probe[4] = {1, 1, 1, 1};
+static u32 ehci_enable[4] = {1, 1, 1, 1};
+static atomic_t ehci_in_standby;
+
+#if IS_ENABLED(CONFIG_PM)
+static void sunxi_ehci_resume_work(struct work_struct *work);
+#endif
+
+int sunxi_usb_disable_ehci(__u32 usbc_no);
+int sunxi_usb_enable_ehci(__u32 usbc_no);
+
+static void  ehci_set_interrupt_enable(const struct ehci_hcd *ehci,
+		void __iomem *regs, u32 enable)
+{
+	ehci_writel(ehci, enable & 0x3f, (regs + EHCI_OPR_USBINTR));
+}
+
+static void ehci_disable_periodic_schedule(const struct ehci_hcd *ehci,
+		void __iomem *regs)
+{
+	u32 reg_val = 0;
+
+	reg_val =  ehci_readl(ehci, (regs + EHCI_OPR_USBCMD));
+	reg_val	&= ~(0x1<<4);
+	ehci_writel(ehci, reg_val, (regs + EHCI_OPR_USBCMD));
+}
+
+static void ehci_disable_async_schedule(const struct ehci_hcd *ehci,
+		void __iomem *regs)
+{
+	unsigned int reg_val = 0;
+
+	reg_val =  ehci_readl(ehci, (regs + EHCI_OPR_USBCMD));
+	reg_val &= ~(0x1<<5);
+	ehci_writel(ehci, reg_val, (regs + EHCI_OPR_USBCMD));
+}
+
+static void ehci_set_config_flag(const struct ehci_hcd *ehci,
+		void __iomem *regs)
+{
+	ehci_writel(ehci, 0x1, (regs + EHCI_OPR_CFGFLAG));
+}
+
+static void ehci_test_stop(const struct ehci_hcd *ehci,
+		void __iomem *regs)
+{
+	unsigned int reg_val = 0;
+
+	reg_val =  ehci_readl(ehci, (regs + EHCI_OPR_USBCMD));
+	reg_val &= (~0x1);
+	ehci_writel(ehci, reg_val, (regs + EHCI_OPR_USBCMD));
+}
+
+static void ehci_test_reset(const struct ehci_hcd *ehci,
+		void __iomem *regs)
+{
+	u32 reg_val = 0;
+
+	reg_val =  ehci_readl(ehci, (regs + EHCI_OPR_USBCMD));
+	reg_val	|= (0x1<<1);
+	ehci_writel(ehci, reg_val, (regs + EHCI_OPR_USBCMD));
+}
+
+static unsigned int ehci_test_reset_complete(const struct ehci_hcd *ehci,
+		void __iomem *regs)
+{
+
+	unsigned int reg_val = 0;
+
+	reg_val = ehci_readl(ehci, (regs + EHCI_OPR_USBCMD));
+	reg_val &= (0x1<<1);
+
+	return !reg_val;
+}
+
+static void ehci_start(const struct ehci_hcd *ehci, void __iomem *regs)
+{
+	unsigned int reg_val = 0;
+
+	reg_val =  ehci_readl(ehci, (regs + EHCI_OPR_USBCMD));
+	reg_val	|= 0x1;
+	ehci_writel(ehci, reg_val, (regs + EHCI_OPR_USBCMD));
+}
+
+static unsigned int ehci_is_halt(const struct ehci_hcd *ehci,
+		void __iomem *regs)
+{
+	unsigned int reg_val = 0;
+
+	reg_val = ehci_readl(ehci, (regs + EHCI_OPR_USBSTS))  >> 12;
+	reg_val &= 0x1;
+	return reg_val;
+}
+
+static void ehci_port_control(const struct ehci_hcd *ehci,
+		void __iomem *regs, u32 port_no, u32 control)
+{
+	ehci_writel(ehci, control, (regs + EHCI_OPR_USBCMD + (port_no<<2)));
+}
+
+static void  ehci_put_port_suspend(const struct ehci_hcd *ehci,
+		void __iomem *regs)
+{
+	unsigned int reg_val = 0;
+
+	reg_val =  ehci_readl(ehci, (regs + EHCI_OPR_PORTSC));
+	reg_val	|= (0x01<<7);
+	ehci_writel(ehci, reg_val, (regs + EHCI_OPR_PORTSC));
+}
+
+static void ehci_test_mode(const struct ehci_hcd *ehci,
+		void __iomem *regs, u32 test_mode)
+{
+	unsigned int reg_val = 0;
+
+	reg_val =  ehci_readl(ehci, (regs + EHCI_OPR_PORTSC));
+	reg_val &= ~(0x0f<<16);
+	reg_val |= test_mode;
+	ehci_writel(ehci, reg_val, (regs + EHCI_OPR_PORTSC));
+}
+
+static void __ehci_ed_test(const struct ehci_hcd *ehci,
+		void __iomem *regs, __u32 test_mode)
+{
+	ehci_set_interrupt_enable(ehci, regs, 0x00);
+	ehci_disable_periodic_schedule(ehci, regs);
+	ehci_disable_async_schedule(ehci, regs);
+
+	ehci_set_config_flag(ehci, regs);
+
+	ehci_test_stop(ehci, regs);
+	ehci_test_reset(ehci, regs);
+
+	/* Wait until EHCI reset complete. */
+	while (!ehci_test_reset_complete(ehci, regs))
+		;
+
+	if (!ehci_is_halt(ehci, regs))
+		DMSG_ERR("%s_%d\n", __func__, __LINE__);
+
+	ehci_start(ehci, regs);
+	/* Wait until EHCI to be not halt. */
+	while (ehci_is_halt(ehci, regs))
+		;
+
+	/* Ehci start, config to test. */
+	ehci_set_config_flag(ehci, regs);
+	ehci_port_control(ehci, regs, 0, EHCI_PORTSC_POWER);
+
+	ehci_disable_periodic_schedule(ehci, regs);
+	ehci_disable_async_schedule(ehci, regs);
+
+	/* Put port suspend. */
+	ehci_put_port_suspend(ehci, regs);
+
+	ehci_test_stop(ehci, regs);
+
+	while ((!ehci_is_halt(ehci, regs)))
+		;
+
+	/* Test pack. */
+	DMSG_INFO("Start Host Test,mode:0x%x!\n", test_mode);
+	ehci_test_mode(ehci, regs, test_mode);
+	DMSG_INFO("End Host Test,mode:0x%x!\n", test_mode);
+}
+
+static ssize_t show_ed_test(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "USB2.0 host test mode:\n"
+				"echo:\ntest_j_state\ntest_k_state\ntest_se0_nak\n"
+				"test_pack\ntest_force_enable\ntest_mask\n\n");
+}
+
+static ssize_t ehci_ed_test(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	__u32 test_mode = 0;
+	struct usb_hcd *hcd = NULL;
+	struct ehci_hcd *ehci = NULL;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL) {
+		DMSG_PANIC("ERR: hcd is null\n");
+		return 0;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	if (ehci == NULL) {
+		DMSG_PANIC("ERR: ehci is null\n");
+		return 0;
+	}
+
+	mutex_lock(&dev->mutex);
+
+	DMSG_INFO("ehci_ed_test:%s\n", buf);
+
+	if (!strncmp(buf, "test_not_operating", 18)) {
+		test_mode = EHCI_PORTSC_PTC_DIS;
+		DMSG_INFO("test_mode:0x%x\n", test_mode);
+	} else if (!strncmp(buf, "test_j_state", 12)) {
+		test_mode = EHCI_PORTSC_PTC_J;
+		DMSG_INFO("test_mode:0x%x\n", test_mode);
+	} else if (!strncmp(buf, "test_k_state", 12)) {
+		test_mode = EHCI_PORTSC_PTC_K;
+		DMSG_INFO("test_mode:0x%x\n", test_mode);
+	} else if (!strncmp(buf, "test_se0_nak", 12)) {
+		test_mode = EHCI_PORTSC_PTC_SE0NAK;
+		DMSG_INFO("test_mode:0x%x\n", test_mode);
+	} else if (!strncmp(buf, "test_pack", 9)) {
+		test_mode = EHCI_PORTSC_PTC_PACKET;
+		DMSG_INFO("test_mode:0x%x\n", test_mode);
+	} else if (!strncmp(buf, "test_force_enable", 17)) {
+		test_mode = EHCI_PORTSC_PTC_FORCE;
+		DMSG_INFO("test_mode:0x%x\n", test_mode);
+	} else if (!strncmp(buf, "test_mask", 9)) {
+		test_mode = EHCI_PORTSC_PTC_MASK;
+		DMSG_INFO("test_mode:0x%x\n", test_mode);
+	} else {
+		DMSG_PANIC("ERR: test_mode Argment is invalid\n");
+		mutex_unlock(&dev->mutex);
+		return count;
+	}
+
+	DMSG_INFO("regs: 0x%p\n", hcd->regs);
+	__ehci_ed_test(ehci, hcd->regs, test_mode);
+
+	mutex_unlock(&dev->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(ed_test, 0644, show_ed_test, ehci_ed_test);
+
+static ssize_t show_phy_threshold(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+
+	sunxi_ehci = dev->platform_data;
+
+	return sprintf(buf, "threshold:0x%x\n",
+			usb_phyx_tp_read(sunxi_ehci, 0x2a, 2));
+}
+
+static ssize_t ehci_phy_threshold(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	int val = 0;
+	int err;
+
+	err = kstrtoint(buf, 16, &val);
+	if (err != 0)
+		return -EINVAL;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+	sunxi_ehci = dev->platform_data;
+
+	if ((val >= 0) && (val <= 0x3)) {
+		usb_phyx_tp_write(sunxi_ehci, 0x2a, val, 2);
+	} else {
+		DMSG_PANIC("adjust disconnect threshold 0x%x is fail, value:0x0~0x3\n", val);
+		return count;
+	}
+
+	DMSG_INFO("adjust succeed: threshold val:0x%x, no:%x\n",
+			usb_phyx_tp_read(sunxi_ehci, 0x2a, 2),
+			sunxi_ehci->usbc_no);
+
+	return count;
+}
+
+static DEVICE_ATTR(phy_threshold, 0644, show_phy_threshold, ehci_phy_threshold);
+
+static ssize_t show_phy_range(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+
+	sunxi_ehci = dev->platform_data;
+#if defined(CONFIG_ARCH_SUN8IW17) | defined(CONFIG_ARCH_SUN8IW11)
+	DMSG_INFO("PHY's rate and range:0x0~0x1f\n");
+	return sprintf(buf, "rate:0x%x\n",
+		usb_phyx_tp_read(sunxi_ehci, 0x20, 5));
+#else
+	DMSG_INFO("PHY's rate and range:0x0~0x3ff\n");
+	return sprintf(buf, "rate:0x%x\n",
+		usb_phyx_read(sunxi_ehci));
+#endif
+}
+
+static ssize_t ehci_phy_range(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	int val = 0;
+	int err;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	err = kstrtoint(buf, 16, &val);
+	if (err != 0)
+		return -EINVAL;
+
+	sunxi_ehci = dev->platform_data;
+
+
+#if defined(CONFIG_ARCH_SUN8IW17) || defined(CONFIG_ARCH_SUN8IW11)
+	DMSG_INFO("adjust PHY's rate and range:0x0~0x1f\n");
+	if ((val >= 0) && (val <= 0x1f)) {
+		usb_phyx_tp_write(sunxi_ehci, 0x20, val, 5);
+	} else {
+		DMSG_PANIC("adjust PHY's rate and range 0x%x is fail, value:0x0~0x1f\n", val);
+		return count;
+	}
+
+	DMSG_INFO("adjust succeed:,rate val:0x%x, no:%d\n",
+			usb_phyx_tp_read(sunxi_ehci, 0x20, 5),
+			sunxi_ehci->usbc_no);
+#else
+	DMSG_INFO("adjust PHY's rate and range:0x0~0x3ff\n");
+	if ((val >= 0x0) && (val <= 0x3ff)) {
+		usb_phyx_write(sunxi_ehci, val);
+	} else {
+		DMSG_PANIC("adjust PHY's paraments 0x%x is fail! value:0x0~0x3ff\n", val);
+		return count;
+	}
+
+	DMSG_INFO("adjust succeed:,PHY's paraments :0x%x, no:%d\n",
+		usb_phyx_read(sunxi_ehci), sunxi_ehci->usbc_no);
+#endif
+
+	return count;
+}
+
+static DEVICE_ATTR(phy_range, 0644, show_phy_range, ehci_phy_range);
+
+static ssize_t ehci_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	sunxi_ehci = dev->platform_data;
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: sw_ehci is null\n");
+		return 0;
+	}
+
+	return sprintf(buf, "ehci:%d, probe:%u\n",
+			sunxi_ehci->usbc_no, sunxi_ehci->probe);
+}
+
+static ssize_t ehci_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	int value = 0;
+	int err;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	sunxi_ehci = dev->platform_data;
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: sw_ehci is null\n");
+		return 0;
+	}
+
+	ehci_first_probe[sunxi_ehci->usbc_no] = 0;
+
+	err = kstrtoint(buf, 10, &value);
+	if (err != 0)
+		return -EINVAL;
+	if (value == 1) {
+		ehci_enable[sunxi_ehci->usbc_no] = 0;
+		sunxi_ehci->hsic_enable_flag = 1;
+		sunxi_usb_enable_ehci(sunxi_ehci->usbc_no);
+
+		if (sunxi_ehci->usbc_no == HCI0_USBC_NO)
+			sunxi_set_host_vbus(sunxi_ehci, 1);
+
+		if (sunxi_ehci->hsic_ctrl_flag)
+			sunxi_set_host_hisc_rdy(sunxi_ehci, 1);
+	} else if (value == 0) {
+		if (sunxi_ehci->hsic_ctrl_flag)
+			sunxi_set_host_hisc_rdy(sunxi_ehci, 0);
+
+		ehci_enable[sunxi_ehci->usbc_no] = 1;
+		sunxi_usb_disable_ehci(sunxi_ehci->usbc_no);
+		sunxi_ehci->hsic_enable_flag = 0;
+		ehci_enable[sunxi_ehci->usbc_no] = 0;
+	} else {
+		DMSG_INFO("unknown value (%d)\n", value);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(ehci_enable, 0664, ehci_enable_show, ehci_enable_store);
+
+static void sunxi_hcd_board_set_vbus(
+		struct sunxi_hci_hcd *sunxi_ehci, int is_on)
+{
+	sunxi_ehci->set_power(sunxi_ehci, is_on);
+}
+
+static void sunxi_hcd_board_set_passby(struct sunxi_hci_hcd *sunxi_ehci,
+						int is_on)
+{
+	sunxi_ehci->usb_passby(sunxi_ehci, is_on);
+}
+
+static int open_ehci_clock(struct sunxi_hci_hcd *sunxi_ehci)
+{
+	return sunxi_ehci->open_clock(sunxi_ehci, 0);
+}
+
+static int close_ehci_clock(struct sunxi_hci_hcd *sunxi_ehci)
+{
+	return sunxi_ehci->close_clock(sunxi_ehci, 0);
+}
+
+static void sunxi_start_ehci(struct sunxi_hci_hcd *sunxi_ehci)
+{
+	open_ehci_clock(sunxi_ehci);
+	sunxi_hcd_board_set_passby(sunxi_ehci, 1);
+	sunxi_hcd_board_set_vbus(sunxi_ehci, 1);
+}
+
+static void sunxi_stop_ehci(struct sunxi_hci_hcd *sunxi_ehci)
+{
+	sunxi_hcd_board_set_vbus(sunxi_ehci, 0);
+	sunxi_hcd_board_set_passby(sunxi_ehci, 0);
+	close_ehci_clock(sunxi_ehci);
+}
+
+static int sunxi_ehci_pm_notify(struct notifier_block *nb,
+				unsigned long mode, void *_unused)
+{
+	switch (mode) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_RESTORE_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		atomic_set(&ehci_in_standby, 1);
+		break;
+	case PM_POST_HIBERNATION:
+	case PM_POST_RESTORE:
+	case PM_POST_SUSPEND:
+		atomic_set(&ehci_in_standby, 0);
+		sunxi_hci_standby_completion(SUNXI_USB_EHCI);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static struct notifier_block sunxi_ehci_pm_nb = {
+	.notifier_call = sunxi_ehci_pm_notify,
+};
+
+static struct hc_driver sunxi_ehci_hc_driver;
+
+int sunxi_insmod_ehci(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd	= NULL;
+	struct ehci_hcd *ehci	= NULL;
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	struct device *dev = NULL;
+	int ret = 0;
+
+	sunxi_ehci = pdev->dev.platform_data;
+	if (!sunxi_ehci) {
+		DMSG_PANIC("ERR: sunxi_ehci is null\n");
+		ret = -ENOMEM;
+		goto ERR1;
+	}
+
+	sunxi_ehci->pdev = pdev;
+	g_sunxi_ehci[sunxi_ehci->usbc_no] = sunxi_ehci;
+
+	DMSG_INFO("[%s%d]: probe, pdev->name: %s, sunxi_ehci: 0x%px, 0x:%px, irq_no:%x\n",
+		ehci_name, sunxi_ehci->usbc_no, pdev->name,
+		sunxi_ehci, sunxi_ehci->usb_vbase, sunxi_ehci->irq_no);
+
+	/* get io resource */
+	sunxi_ehci->ehci_base		= sunxi_ehci->usb_vbase;
+	sunxi_ehci->ehci_reg_length	= SUNXI_USB_EHCI_LEN;
+
+	/* not init ehci, when driver probe */
+	if (sunxi_ehci->usbc_no == HCI0_USBC_NO) {
+		if (sunxi_ehci->port_type != USB_PORT_TYPE_HOST) {
+			if (ehci_first_probe[sunxi_ehci->usbc_no]) {
+				ehci_first_probe[sunxi_ehci->usbc_no] = 0;
+				DMSG_INFO("[%s%d]: Not init ehci0\n",
+					  ehci_name, sunxi_ehci->usbc_no);
+				return 0;
+			}
+		}
+	}
+
+	/* creat a usb_hcd for the ehci controller */
+	hcd = usb_create_hcd(&sunxi_ehci_hc_driver, &pdev->dev, ehci_name);
+	if (!hcd) {
+		DMSG_PANIC("ERR: usb_create_hcd failed\n");
+		ret = -ENOMEM;
+		goto ERR2;
+	}
+
+	hcd->rsrc_start = sunxi_ehci->usb_base_res->start;
+	hcd->rsrc_len	= SUNXI_USB_EHCI_LEN;
+	hcd->regs	= sunxi_ehci->ehci_base;
+	sunxi_ehci->hcd = hcd;
+
+	dev = &pdev->dev;
+	sunxi_ehci->supply = regulator_get(dev, "drvvbus");
+
+	if (IS_ERR(sunxi_ehci->supply)) {
+		DMSG_PANIC("%s()%d WARN: get supply failed\n", __func__, __LINE__);
+		sunxi_ehci->supply = NULL;
+	}
+
+	sunxi_ehci->hci_regulator = regulator_get(dev, "hci");
+	if (IS_ERR(sunxi_ehci->hci_regulator)) {
+		DMSG_PANIC("%s()%d WARN: get hci regulator failed\n", __func__, __LINE__);
+		sunxi_ehci->hci_regulator = NULL;
+	}
+	/* echi start to work */
+	sunxi_start_ehci(sunxi_ehci);
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs +
+			HC_LENGTH(ehci, readl(&ehci->caps->hc_capbase));
+
+	/* cache this readonly data, minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	ret = usb_add_hcd(hcd, sunxi_ehci->irq_no, IRQF_SHARED);
+	if (ret != 0) {
+		DMSG_PANIC("ERR: usb_add_hcd failed\n");
+		ret = -ENOMEM;
+		goto ERR3;
+	}
+
+	device_wakeup_enable(hcd->self.controller);
+	platform_set_drvdata(pdev, hcd);
+
+	device_create_file(&pdev->dev, &dev_attr_ed_test);
+	device_create_file(&pdev->dev, &dev_attr_phy_threshold);
+	device_create_file(&pdev->dev, &dev_attr_phy_range);
+
+#ifndef USB_SYNC_SUSPEND
+	device_enable_async_suspend(&pdev->dev);
+#endif
+
+#if IS_ENABLED(CONFIG_PM)
+	if (!sunxi_ehci->wakeup_suspend)
+		INIT_WORK(&sunxi_ehci->resume_work, sunxi_ehci_resume_work);
+#endif
+
+	sunxi_ehci->probe = 1;
+
+	return 0;
+
+ERR3:
+	sunxi_stop_ehci(sunxi_ehci);
+	usb_put_hcd(hcd);
+
+ERR2:
+	sunxi_ehci->hcd = NULL;
+	g_sunxi_ehci[sunxi_ehci->usbc_no] = NULL;
+
+ERR1:
+
+	return ret;
+}
+
+int sunxi_rmmod_ehci(struct platform_device *pdev)
+{
+
+	struct usb_hcd *hcd = NULL;
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	unsigned long time_left;
+
+	if (pdev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return -1;
+	}
+
+	hcd = platform_get_drvdata(pdev);
+	if (hcd == NULL) {
+		DMSG_PANIC("ERR: hcd is null\n");
+		return -1;
+	}
+
+	sunxi_ehci = pdev->dev.platform_data;
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ehci is null\n");
+		return -1;
+	}
+
+	if (atomic_read(&ehci_in_standby)) {
+		reinit_completion(&sunxi_ehci->standby_complete);
+		DMSG_INFO("INFO: sunxi_ehci disable, waiting until standby finish\n");
+		time_left = wait_for_completion_timeout(&sunxi_ehci->standby_complete,
+						msecs_to_jiffies(STANDBY_TIMEOUT));
+		if (time_left)
+			DMSG_INFO("INFO: sunxi_ehci disable time_left = %lu\n", time_left);
+		else
+			DMSG_PANIC("ERR: sunxi_ehci waiting standby failed, go on disable\n");
+
+	}
+
+	sunxi_ehci->probe = 0;
+
+#ifndef USB_SYNC_SUSPEND
+	device_disable_async_suspend(&pdev->dev);
+#endif
+
+	DMSG_INFO("[%s%d]: remove, pdev->name: %s, sunxi_ehci: 0x%px\n",
+		ehci_name, sunxi_ehci->usbc_no, pdev->name, sunxi_ehci);
+
+	device_remove_file(&pdev->dev, &dev_attr_ed_test);
+	device_remove_file(&pdev->dev, &dev_attr_phy_threshold);
+	device_remove_file(&pdev->dev, &dev_attr_phy_range);
+
+	device_wakeup_disable(hcd->self.controller);
+
+	usb_remove_hcd(hcd);
+
+#if IS_ENABLED(CONFIG_PM)
+	if (!sunxi_ehci->wakeup_suspend)
+		if (!IS_ERR_OR_NULL(&sunxi_ehci->resume_work))
+			cancel_work_sync(&sunxi_ehci->resume_work);
+#endif
+
+	sunxi_stop_ehci(sunxi_ehci);
+
+	usb_put_hcd(hcd);
+
+	if (sunxi_ehci->supply)
+		regulator_put(sunxi_ehci->supply);
+
+	sunxi_ehci->hcd = NULL;
+
+	return 0;
+}
+
+static int sunxi_ehci_hcd_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+#if defined(CONFIG_ARCH_SUN50IW10)
+	int val = 0;
+#endif
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	if (pdev == NULL) {
+		DMSG_PANIC("ERR: %s, Argment is invalid\n", __func__);
+		return -1;
+	}
+
+	/* if usb is disabled, can not probe */
+	if (usb_disabled()) {
+		DMSG_PANIC("ERR: usb hcd is disabled\n");
+		return -ENODEV;
+	}
+
+	ret = init_sunxi_hci(pdev, SUNXI_USB_EHCI);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "init_sunxi_hci is fail\n");
+		return -1;
+	}
+
+	sunxi_insmod_ehci(pdev);
+
+	sunxi_ehci = pdev->dev.platform_data;
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: %s, sunxi_ehci is null\n", __func__);
+		return -1;
+	}
+
+	if (sunxi_ehci->usbc_no == HCI0_USBC_NO) {
+		ret = register_pm_notifier(&sunxi_ehci_pm_nb);
+		if (ret) {
+			DMSG_PANIC("ERR: %s, can not register suspend notifier\n", __func__);
+			return -1;
+		}
+	}
+
+	init_completion(&sunxi_ehci->standby_complete);
+
+/* keep common circuit configuration when usb0 enable only*/
+#if defined(CONFIG_ARCH_SUN50IW10)
+	if (sunxi_ehci->usbc_no == HCI0_USBC_NO) {
+		val = readl(sunxi_ehci->usb_ccmu_config + 0x0A8C);
+		val |= (SUNXI_CCMU_USBEHCI1_GATING_OFFSET
+			| SUNXI_CCMU_USBEHCI1_RST_OFFSET);
+		writel(val, sunxi_ehci->usb_ccmu_config + 0x0A8C);
+
+		val = readl(sunxi_ehci->usb_ccmu_config + 0x0A74);
+		val |= (SUNXI_CCMU_SCLK_GATING_USBPHY1_OFFSET
+			| SUNXI_CCMU_USBPHY1_RST_OFFSET
+			| SUNXI_CCMU_SCLK_GATING_OHCI1_OFFSET);
+		writel(val, sunxi_ehci->usb_ccmu_config + 0x0A74);
+
+		/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+		val = USBC_Readl(sunxi_ehci->usb_common_phy_config
+				 + SUNXI_HCI_PHY_CTRL);
+		val &= ~(0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+		USBC_Writel(val, sunxi_ehci->usb_common_phy_config
+			    + SUNXI_HCI_PHY_CTRL);
+	}
+#endif
+
+	if (ehci_enable[sunxi_ehci->usbc_no]) {
+		device_create_file(&pdev->dev, &dev_attr_ehci_enable);
+		ehci_enable[sunxi_ehci->usbc_no] = 0;
+	}
+
+	return 0;
+}
+
+static int sunxi_ehci_hcd_remove(struct platform_device *pdev)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	int ret = 0;
+#if defined(CONFIG_ARCH_SUN50IW10)
+	int val = 0;
+#endif
+
+	if (pdev == NULL) {
+		DMSG_PANIC("ERR: %s, Argment is invalid\n", __func__);
+		return -1;
+	}
+
+	sunxi_ehci = pdev->dev.platform_data;
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: %s, sunxi_ehci is null\n", __func__);
+		return -1;
+	}
+
+	if (ehci_enable[sunxi_ehci->usbc_no] == 0) {
+		device_remove_file(&pdev->dev, &dev_attr_ehci_enable);
+		ehci_enable[sunxi_ehci->usbc_no] = 1;
+	}
+
+/* reset common circuit configuration*/
+#if defined(CONFIG_ARCH_SUN50IW10)
+	if (sunxi_ehci->usbc_no == HCI0_USBC_NO) {
+		val = readl(sunxi_ehci->usb_ccmu_config + 0x0A8C);
+		val &= ~(SUNXI_CCMU_USBEHCI1_GATING_OFFSET
+			 | SUNXI_CCMU_USBEHCI1_RST_OFFSET);
+		writel(val, sunxi_ehci->usb_ccmu_config + 0x0A8C);
+
+		val = readl(sunxi_ehci->usb_ccmu_config + 0x0A74);
+		val &= ~(SUNXI_CCMU_SCLK_GATING_USBPHY1_OFFSET
+			| SUNXI_CCMU_USBPHY1_RST_OFFSET
+			| SUNXI_CCMU_SCLK_GATING_OHCI1_OFFSET);
+		writel(val, sunxi_ehci->usb_ccmu_config + 0x0A74);
+
+		/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+		val = USBC_Readl(sunxi_ehci->usb_common_phy_config
+				 + SUNXI_HCI_PHY_CTRL);
+		val |= (0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+		USBC_Writel(val, sunxi_ehci->usb_common_phy_config
+			    + SUNXI_HCI_PHY_CTRL);
+	}
+#endif
+
+	if (sunxi_ehci->usbc_no == HCI0_USBC_NO)
+		unregister_pm_notifier(&sunxi_ehci_pm_nb);
+
+	if (sunxi_ehci->probe == 1) {
+		ret = sunxi_rmmod_ehci(pdev);
+		if (ret == 0)
+			exit_sunxi_hci(sunxi_ehci);
+
+		return ret;
+	} else
+		return 0;
+
+}
+
+static void sunxi_ehci_hcd_shutdown(struct platform_device *pdev)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+
+	if (pdev == NULL) {
+		DMSG_PANIC("ERR: %s, Argment is invalid\n", __func__);
+		return;
+	}
+
+	sunxi_ehci = pdev->dev.platform_data;
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: %s, is null\n", __func__);
+		return;
+	}
+
+	if (sunxi_ehci->probe == 0) {
+		DMSG_INFO("%s, %s is disable, need not shutdown\n",
+			 __func__, sunxi_ehci->hci_name);
+		return;
+	}
+
+	DMSG_INFO("[%s]: ehci shutdown start\n", sunxi_ehci->hci_name);
+	usb_hcd_platform_shutdown(pdev);
+
+	/**
+	 * disable usb otg INTUSBE, to solve usb0 device mode
+	 * catch audio udev on reboot system is fail.
+	 */
+	if (sunxi_ehci->usbc_no == 0) {
+		if (sunxi_ehci->otg_vbase) {
+			writel(0, (sunxi_ehci->otg_vbase
+						+ SUNXI_USBC_REG_INTUSBE));
+		}
+	}
+	sunxi_hcd_board_set_vbus(sunxi_ehci, 0);
+	DMSG_INFO("[%s]: ehci shutdown end\n", sunxi_ehci->hci_name);
+}
+
+#if IS_ENABLED(CONFIG_PM)
+
+static int sunxi_ehci_hcd_suspend(struct device *dev)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct ehci_hcd *ehci = NULL;
+	int val = 0;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: %s, Argment is invalid\n", __func__);
+		return 0;
+	}
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL) {
+		DMSG_PANIC("ERR: hcd is null\n");
+		return 0;
+	}
+
+	sunxi_ehci = dev->platform_data;
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ehci is null\n");
+		return 0;
+	}
+
+	if (sunxi_ehci->no_suspend) {
+		DMSG_INFO("[%s]:ehci is being enable, stop system suspend\n",
+			sunxi_ehci->hci_name);
+		return -1;
+	}
+
+	if (sunxi_ehci->probe == 0) {
+		DMSG_INFO("[%s]: is disable, can not suspend\n",
+			sunxi_ehci->hci_name);
+		return 0;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	if (ehci == NULL) {
+		DMSG_PANIC("ERR: ehci is null\n");
+		return 0;
+	}
+
+	if (sunxi_ehci->wakeup_suspend == USB_STANDBY) {
+		DMSG_INFO("[%s] usb suspend\n", sunxi_ehci->hci_name);
+		disable_irq(sunxi_ehci->irq_no);
+		/*phy reg, offset:0x18 bit0 bit1 bit2, set 1*/
+		val = ehci_readl(ehci, &ehci->regs->intr_enable);
+		val |= (0x7 << 0);
+		ehci_writel(ehci, val, &ehci->regs->intr_enable);
+
+#if IS_ENABLED(SUNXI_USB_STANDBY_LOW_POW_MODE)
+		/*phy reg, offset:0x10 bit4 bit5, set 0*/
+		val = ehci_readl(ehci, &ehci->regs->command);
+		val &= ~(0x30);
+		ehci_writel(ehci, val, &ehci->regs->command);
+		/*enable standby irq*/
+#endif
+		enter_usb_standby(sunxi_ehci);
+
+	} else {
+		DMSG_INFO("[%s]super suspend\n", sunxi_ehci->hci_name);
+
+		ehci_suspend(hcd, device_may_wakeup(dev));
+		cancel_work_sync(&sunxi_ehci->resume_work);
+		sunxi_stop_ehci(sunxi_ehci);
+	}
+
+	return 0;
+}
+
+static void sunxi_ehci_resume_work(struct work_struct *work)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+
+	sunxi_ehci = container_of(work, struct sunxi_hci_hcd, resume_work);
+
+	sunxi_hcd_board_set_vbus(sunxi_ehci, 1);
+}
+
+static int sunxi_ehci_hcd_resume(struct device *dev)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct ehci_hcd *ehci = NULL;
+	int __maybe_unused val = 0;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL) {
+		DMSG_PANIC("ERR: hcd is null\n");
+		return 0;
+	}
+
+	sunxi_ehci = dev->platform_data;
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ehci is null\n");
+		return 0;
+	}
+
+	if (sunxi_ehci->probe == 0) {
+		DMSG_INFO("[%s]: is disable, can not resume\n",
+			sunxi_ehci->hci_name);
+		return 0;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	if (ehci == NULL) {
+		DMSG_PANIC("ERR: ehci is null\n");
+		return 0;
+	}
+
+	if (sunxi_ehci->wakeup_suspend == USB_STANDBY) {
+		DMSG_INFO("[%s]usb resume\n", sunxi_ehci->hci_name);
+
+		exit_usb_standby(sunxi_ehci);
+#if IS_ENABLED(SUNXI_USB_STANDBY_LOW_POW_MODE)
+		val = ehci_readl(ehci, &ehci->regs->command);
+		val |= 0x30;
+		ehci_writel(ehci, val, &ehci->regs->command);
+
+#endif
+		enable_irq(sunxi_ehci->irq_no);
+	} else {
+		DMSG_INFO("[%s]super resume\n", sunxi_ehci->hci_name);
+
+		open_ehci_clock(sunxi_ehci);
+		sunxi_hcd_board_set_passby(sunxi_ehci, 1);
+		ehci_resume(hcd, false);
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+		if (sunxi_ehci->usbc_no == HCI0_USBC_NO) {
+			/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+			val = USBC_Readl(sunxi_ehci->usb_common_phy_config
+					 + SUNXI_HCI_PHY_CTRL);
+			val &= ~(0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+			USBC_Writel(val, sunxi_ehci->usb_common_phy_config
+				    + SUNXI_HCI_PHY_CTRL);
+		}
+#endif
+
+		schedule_work(&sunxi_ehci->resume_work);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops  aw_ehci_pmops = {
+	.suspend	= sunxi_ehci_hcd_suspend,
+	.resume		= sunxi_ehci_hcd_resume,
+};
+
+#define SUNXI_EHCI_PMOPS	(&aw_ehci_pmops)
+
+#else
+
+#define SUNXI_EHCI_PMOPS	NULL
+
+#endif
+
+
+static const struct of_device_id sunxi_ehci_match[] = {
+	{.compatible = SUNXI_EHCI0_OF_MATCH, },
+	{.compatible = SUNXI_EHCI1_OF_MATCH, },
+	{.compatible = SUNXI_EHCI2_OF_MATCH, },
+	{.compatible = SUNXI_EHCI3_OF_MATCH, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_ehci_match);
+
+static struct platform_driver sunxi_ehci_hcd_driver = {
+	.probe  = sunxi_ehci_hcd_probe,
+	.remove	= sunxi_ehci_hcd_remove,
+	.shutdown = sunxi_ehci_hcd_shutdown,
+	.driver = {
+			.name	= ehci_name,
+			.pm	= SUNXI_EHCI_PMOPS,
+			.of_match_table = sunxi_ehci_match,
+		}
+};
+
+int sunxi_usb_disable_ehci(__u32 usbc_no)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+
+	sunxi_ehci = g_sunxi_ehci[usbc_no];
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ehci is null\n");
+		return -1;
+	}
+
+	if (sunxi_ehci->probe == 0) {
+		DMSG_PANIC("ERR: sunxi_ehci is disable, can not disable again\n");
+		return -1;
+	}
+
+	sunxi_ehci->probe = 0;
+
+	DMSG_INFO("[%s]: sunxi_usb_disable_ehci\n", sunxi_ehci->hci_name);
+
+	sunxi_rmmod_ehci(sunxi_ehci->pdev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_usb_disable_ehci);
+
+int sunxi_usb_enable_ehci(__u32 usbc_no)
+{
+	struct sunxi_hci_hcd *sunxi_ehci = NULL;
+#if defined(CONFIG_ARCH_SUN50IW10)
+	int val;
+#endif
+
+	sunxi_ehci = g_sunxi_ehci[usbc_no];
+	if (sunxi_ehci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ehci is null\n");
+		return -1;
+	}
+
+	if (sunxi_ehci->probe == 1) {
+		DMSG_PANIC("ERR: sunxi_ehci is already enable, can not enable again\n");
+		return -1;
+	}
+
+	sunxi_ehci->no_suspend = 1;
+
+	DMSG_INFO("[%s]: sunxi_usb_enable_ehci\n", sunxi_ehci->hci_name);
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+		if (sunxi_ehci->usbc_no == HCI0_USBC_NO) {
+			/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+			val = USBC_Readl(sunxi_ehci->usb_common_phy_config
+					 + SUNXI_HCI_PHY_CTRL);
+			val &= ~(0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+			USBC_Writel(val, sunxi_ehci->usb_common_phy_config
+				    + SUNXI_HCI_PHY_CTRL);
+		}
+#endif
+
+	sunxi_insmod_ehci(sunxi_ehci->pdev);
+
+	sunxi_ehci->no_suspend = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_usb_enable_ehci);
+
+static int __init sunxi_ehci_hcd_init(void)
+{
+	if (usb_disabled()) {
+		DMSG_ERR(KERN_ERR "%s nousb\n", ehci_name);
+		return -ENODEV;
+	}
+
+	DMSG_INFO(KERN_INFO "%s: " DRIVER_DESC "\n", ehci_name);
+	ehci_init_driver(&sunxi_ehci_hc_driver, NULL);
+	return platform_driver_register(&sunxi_ehci_hcd_driver);
+}
+module_init(sunxi_ehci_hcd_init);
+
+static void __exit sunxi_ehci_hcd_cleanup(void)
+{
+	platform_driver_unregister(&sunxi_ehci_hcd_driver);
+}
+module_exit(sunxi_ehci_hcd_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" SUNXI_EHCI_NAME);
+MODULE_AUTHOR("javen");
+MODULE_VERSION("1.0.9");
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index ac5e96790..442a18040 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -6,6 +6,7 @@
 #ifndef __LINUX_EHCI_HCD_H
 #define __LINUX_EHCI_HCD_H
 
+#include <linux/io.h>
 /* definitions used for the EHCI driver */
 
 /*
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 4de91653a..0a2994e9b 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -883,6 +883,16 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	 */
 	ints = ohci_readl(ohci, &regs->intrstatus);
 
+{
+	if (ints & OHCI_INTR_RHSC) {
+		int portstatus0 = ohci_readl(ohci, &ohci->regs->roothub.portstatus[0]);
+		if ((portstatus0 & RH_PS_CCS) && (portstatus0 & RH_PS_CSC)) {
+			ohci_info(ohci, "ohci_irq: fullspeed or lowspeed device connect\n");
+		} else if (!(portstatus0 & RH_PS_CCS) && (portstatus0 & RH_PS_CSC)) {
+			ohci_info(ohci, "ohci_irq: fullspeed or lowspeed device disconnect\n");
+		}
+	}
+}
 	/* Check for an all 1's result which is a typical consequence
 	 * of dead, unclocked, or unplugged (CardBus...) devices
 	 */
diff --git a/drivers/usb/host/ohci-sunxi.c b/drivers/usb/host/ohci-sunxi.c
new file mode 100644
index 000000000..7b517fa63
--- /dev/null
+++ b/drivers/usb/host/ohci-sunxi.c
@@ -0,0 +1,839 @@
+/*
+ * drivers/usb/host/ohci-sunxi.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yangnaitian, 2011-5-24, create this file
+ * javen, 2011-6-26, add suspend and resume
+ * javen, 2011-7-18, move clock and power operations out from driver
+ *
+ * OHCI Driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/signal.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/clk.h>
+#include <linux/notifier.h>
+#include <linux/suspend.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/phy/phy.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include "ohci.h"
+#include "sunxi-hci.h"
+
+#define DRIVER_DESC "OHCI SUNXI driver"
+
+#define   SUNXI_OHCI_NAME	"sunxi-ohci"
+static const char ohci_name[] = SUNXI_OHCI_NAME;
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI0)
+#define  SUNXI_OHCI0_OF_MATCH	"allwinner,sunxi-ohci0"
+#else
+#define  SUNXI_OHCI0_OF_MATCH	"null"
+#endif
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI1)
+#define  SUNXI_OHCI1_OF_MATCH	"allwinner,sunxi-ohci1"
+#else
+#define  SUNXI_OHCI1_OF_MATCH	"null"
+#endif
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI2)
+#define  SUNXI_OHCI2_OF_MATCH	"allwinner,sunxi-ohci2"
+#else
+#define  SUNXI_OHCI2_OF_MATCH	"null"
+#endif
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI3)
+#define  SUNXI_OHCI3_OF_MATCH	"allwinner,sunxi-ohci3"
+#else
+#define  SUNXI_OHCI3_OF_MATCH	"null"
+#endif
+
+static struct sunxi_hci_hcd *g_sunxi_ohci[4];
+static u32 ohci_first_probe[4] = {1, 1, 1, 1};
+static u32 ohci_enable[4] = {1, 1, 1, 1};
+static atomic_t ohci_in_standby;
+
+#if IS_ENABLED(CONFIG_PM)
+static void sunxi_ohci_resume_work(struct work_struct *work);
+#endif
+
+int sunxi_usb_disable_ohci(__u32 usbc_no);
+int sunxi_usb_enable_ohci(__u32 usbc_no);
+
+static ssize_t ohci_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	sunxi_ohci = dev->platform_data;
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: sw_ohci is null\n");
+		return 0;
+	}
+
+	return sprintf(buf, "ohci:%d,probe:%u\n",
+			sunxi_ohci->usbc_no, sunxi_ohci->probe);
+}
+
+static ssize_t ohci_enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+	int value = 0;
+	int err;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	sunxi_ohci = dev->platform_data;
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: sw_ohci is null\n");
+		return 0;
+	}
+
+	ohci_first_probe[sunxi_ohci->usbc_no] = 0;
+
+	err = kstrtoint(buf, 10, &value);
+	if (err != 0)
+		return -EINVAL;
+	if (value == 1) {
+		ohci_enable[sunxi_ohci->usbc_no] = 0;
+		sunxi_usb_enable_ohci(sunxi_ohci->usbc_no);
+
+		if (sunxi_ohci->usbc_no == HCI0_USBC_NO)
+			sunxi_set_host_vbus(sunxi_ohci, 1);
+
+	} else if (value == 0) {
+		ohci_enable[sunxi_ohci->usbc_no] = 1;
+		sunxi_usb_disable_ohci(sunxi_ohci->usbc_no);
+		ohci_enable[sunxi_ohci->usbc_no] = 0;
+	} else {
+		DMSG_INFO("unknown value (%d)\n", value);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(ohci_enable, 0644, ohci_enable_show, ohci_enable_store);
+
+static int open_ohci_clock(struct sunxi_hci_hcd *sunxi_ohci)
+{
+	return sunxi_ohci->open_clock(sunxi_ohci, 1);
+}
+
+static int close_ohci_clock(struct sunxi_hci_hcd *sunxi_ohci)
+{
+	return sunxi_ohci->close_clock(sunxi_ohci, 1);
+}
+
+static void sunxi_ohci_set_vbus(struct sunxi_hci_hcd *sunxi_ohci, int is_on)
+{
+	sunxi_ohci->set_power(sunxi_ohci, is_on);
+}
+
+static void sunxi_ohci_set_passby(struct sunxi_hci_hcd *sunxi_ohci, int is_on)
+{
+	sunxi_ohci->usb_passby(sunxi_ohci, is_on);
+}
+
+static void sunxi_start_ohci(struct sunxi_hci_hcd *sunxi_ohci)
+{
+	open_ohci_clock(sunxi_ohci);
+	sunxi_ohci_set_passby(sunxi_ohci, 1);
+	sunxi_ohci_set_vbus(sunxi_ohci, 1);
+}
+
+static void sunxi_stop_ohci(struct sunxi_hci_hcd *sunxi_ohci)
+{
+	sunxi_ohci_set_vbus(sunxi_ohci, 0);
+	sunxi_ohci_set_passby(sunxi_ohci, 0);
+	close_ohci_clock(sunxi_ohci);
+}
+
+static int sunxi_ohci_pm_notify(struct notifier_block *nb,
+				unsigned long mode, void *_unused)
+{
+	switch (mode) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_RESTORE_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		atomic_set(&ohci_in_standby, 1);
+		break;
+	case PM_POST_HIBERNATION:
+	case PM_POST_RESTORE:
+	case PM_POST_SUSPEND:
+		atomic_set(&ohci_in_standby, 0);
+		sunxi_hci_standby_completion(SUNXI_USB_OHCI);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static struct notifier_block sunxi_ohci_pm_nb = {
+	.notifier_call = sunxi_ohci_pm_notify,
+};
+
+static struct hc_driver sunxi_ohci_hc_driver;
+
+static int sunxi_insmod_ohci(struct platform_device *pdev)
+{
+	int ret;
+	struct usb_hcd *hcd = NULL;
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+	struct device *dev = NULL;
+
+	if (pdev == NULL) {
+		DMSG_PANIC("ERR: Argment is invaild\n");
+		return -1;
+	}
+
+	/* if usb is disabled, can not probe */
+	if (usb_disabled()) {
+		DMSG_PANIC("ERR: usb hcd is disabled\n");
+		return -ENODEV;
+	}
+
+	sunxi_ohci = pdev->dev.platform_data;
+	if (!sunxi_ohci) {
+		DMSG_PANIC("ERR: sunxi_ohci is null\n");
+		ret = -ENOMEM;
+		goto ERR1;
+	}
+
+	sunxi_ohci->pdev = pdev;
+	g_sunxi_ohci[sunxi_ohci->usbc_no] = sunxi_ohci;
+
+	DMSG_INFO("[%s%d]: probe, pdev->name: %s, sunxi_ohci: 0x%px\n",
+		ohci_name, sunxi_ohci->usbc_no, pdev->name, sunxi_ohci);
+
+	sunxi_ohci->ohci_base = sunxi_ohci->usb_vbase +
+					SUNXI_USB_OHCI_BASE_OFFSET;
+
+	sunxi_ohci->ohci_reg_length = SUNXI_USB_OHCI_LEN;
+
+	/* not init ohci, when driver probe */
+	if (sunxi_ohci->usbc_no == HCI0_USBC_NO) {
+		if (sunxi_ohci->port_type != USB_PORT_TYPE_HOST) {
+			if (ohci_first_probe[sunxi_ohci->usbc_no]) {
+				ohci_first_probe[sunxi_ohci->usbc_no] = 0;
+				DMSG_INFO("[%s%d]: Not init ohci0\n",
+					  ohci_name, sunxi_ohci->usbc_no);
+				return 0;
+			}
+		}
+	}
+
+	/* creat a usb_hcd for the ohci controller */
+	hcd = usb_create_hcd(&sunxi_ohci_hc_driver, &pdev->dev, ohci_name);
+	if (!hcd) {
+		DMSG_PANIC("ERR: usb_ohci_create_hcd failed\n");
+		ret = -ENOMEM;
+		goto ERR2;
+	}
+
+	hcd->rsrc_start = sunxi_ohci->usb_base_res->start;
+	hcd->rsrc_len	= SUNXI_USB_OHCI_LEN;
+	hcd->regs	= sunxi_ohci->ohci_base;
+	sunxi_ohci->hcd	= hcd;
+
+	dev = &pdev->dev;
+	sunxi_ohci->supply = regulator_get(dev, "drvvbus");
+
+	if (IS_ERR(sunxi_ohci->supply)) {
+		DMSG_PANIC("%s()%d WARN: get supply failed\n", __func__, __LINE__);
+		sunxi_ohci->supply = NULL;
+	}
+
+	sunxi_ohci->hci_regulator = regulator_get(dev, "hci");
+	if (IS_ERR(sunxi_ohci->hci_regulator)) {
+		DMSG_PANIC("%s()%d WARN: get hci regulator failed\n", __func__, __LINE__);
+		sunxi_ohci->hci_regulator = NULL;
+	}
+	/* ochi start to work */
+	sunxi_start_ohci(sunxi_ohci);
+
+	ret = usb_add_hcd(hcd, sunxi_ohci->irq_no, IRQF_SHARED);
+	if (ret != 0) {
+		DMSG_PANIC("ERR: usb_add_hcd failed\n");
+		ret = -ENOMEM;
+		goto ERR3;
+	}
+
+	device_wakeup_enable(hcd->self.controller);
+	platform_set_drvdata(pdev, hcd);
+
+#ifndef USB_SYNC_SUSPEND
+	device_enable_async_suspend(&pdev->dev);
+#endif
+
+#if IS_ENABLED(CONFIG_PM)
+	if (!sunxi_ohci->wakeup_suspend)
+		INIT_WORK(&sunxi_ohci->resume_work, sunxi_ohci_resume_work);
+#endif
+
+	sunxi_ohci->probe = 1;
+
+	return 0;
+
+ERR3:
+	sunxi_stop_ohci(sunxi_ohci);
+	usb_put_hcd(hcd);
+
+ERR2:
+	sunxi_ohci->hcd = NULL;
+
+ERR1:
+	return ret;
+}
+
+static int sunxi_rmmod_ohci(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+	unsigned long time_left;
+
+	if (pdev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return -1;
+	}
+
+	hcd = platform_get_drvdata(pdev);
+	if (hcd == NULL) {
+		DMSG_PANIC("ERR: hcd is null\n");
+		return -1;
+	}
+
+	sunxi_ohci = pdev->dev.platform_data;
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ohci is null\n");
+		return -1;
+	}
+
+	if (atomic_read(&ohci_in_standby)) {
+		reinit_completion(&sunxi_ohci->standby_complete);
+		DMSG_INFO("INFO: sunxi_ohci disable, waiting until standby finish\n");
+		time_left = wait_for_completion_timeout(&sunxi_ohci->standby_complete,
+						msecs_to_jiffies(STANDBY_TIMEOUT));
+		if (time_left)
+			DMSG_INFO("INFO: sunxi_ohci disable time_left = %lu\n", time_left);
+		else
+			DMSG_PANIC("ERR: sunxi_ohci waiting standby failed, go on disable\n");
+
+	}
+
+	sunxi_ohci->probe = 0;
+
+#ifndef USB_SYNC_SUSPEND
+	device_disable_async_suspend(&pdev->dev);
+#endif
+
+	device_wakeup_disable(hcd->self.controller);
+
+	DMSG_INFO("[%s%d]: remove, pdev->name: %s, sunxi_ohci: 0x%px\n",
+		ohci_name, sunxi_ohci->usbc_no, pdev->name, sunxi_ohci);
+	usb_remove_hcd(hcd);
+
+#if IS_ENABLED(CONFIG_PM)
+	if (!sunxi_ohci->wakeup_suspend)
+		if (!IS_ERR_OR_NULL(&sunxi_ohci->resume_work))
+			cancel_work_sync(&sunxi_ohci->resume_work);
+#endif
+
+	sunxi_stop_ohci(sunxi_ohci);
+
+	usb_put_hcd(hcd);
+
+	if (sunxi_ohci->supply)
+		regulator_put(sunxi_ohci->supply);
+
+	sunxi_ohci->hcd = NULL;
+
+	return 0;
+}
+
+static int sunxi_ohci_hcd_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+#if defined(CONFIG_ARCH_SUN50IW10)
+	int val = 0;
+#endif
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+
+	if (pdev == NULL) {
+		DMSG_PANIC("ERR: %s, Argment is invalid\n", __func__);
+		return -1;
+	}
+
+	/* if usb is disabled, can not probe */
+	if (usb_disabled()) {
+		DMSG_PANIC("ERR: usb hcd is disabled\n");
+		return -ENODEV;
+	}
+
+	ret = init_sunxi_hci(pdev, SUNXI_USB_OHCI);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "init_sunxi_hci is fail\n");
+		return -1;
+	}
+
+	sunxi_insmod_ohci(pdev);
+
+	sunxi_ohci = pdev->dev.platform_data;
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: %s, sunxi_ohci is null\n", __func__);
+		return -1;
+	}
+
+	if (sunxi_ohci->usbc_no == HCI0_USBC_NO) {
+		ret = register_pm_notifier(&sunxi_ohci_pm_nb);
+		if (ret) {
+			DMSG_PANIC("ERR: %s, can not register suspend notifier\n", __func__);
+			return -1;
+		}
+	}
+
+	init_completion(&sunxi_ohci->standby_complete);
+
+/* keep common circuit configuration when usb0 enable only*/
+#if defined(CONFIG_ARCH_SUN50IW10)
+	if (sunxi_ohci->usbc_no == HCI0_USBC_NO) {
+		val = readl(sunxi_ohci->usb_ccmu_config + 0x0A8C);
+		val |= (SUNXI_CCMU_USBEHCI1_GATING_OFFSET
+			| SUNXI_CCMU_USBEHCI1_RST_OFFSET);
+		writel(val, sunxi_ohci->usb_ccmu_config + 0x0A8C);
+
+		val = readl(sunxi_ohci->usb_ccmu_config + 0x0A74);
+		val |= (SUNXI_CCMU_SCLK_GATING_USBPHY1_OFFSET
+			| SUNXI_CCMU_USBPHY1_RST_OFFSET
+			| SUNXI_CCMU_SCLK_GATING_OHCI1_OFFSET);
+		writel(val, sunxi_ohci->usb_ccmu_config + 0x0A74);
+
+		/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+		val = USBC_Readl(sunxi_ohci->usb_common_phy_config
+				 + SUNXI_HCI_PHY_CTRL);
+		val &= ~(0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+		USBC_Writel(val, sunxi_ohci->usb_common_phy_config
+			    + SUNXI_HCI_PHY_CTRL);
+	}
+#endif
+
+	if (ohci_enable[sunxi_ohci->usbc_no]) {
+		device_create_file(&pdev->dev, &dev_attr_ohci_enable);
+		ohci_enable[sunxi_ohci->usbc_no] = 0;
+	}
+
+	return 0;
+}
+
+static int sunxi_ohci_hcd_remove(struct platform_device *pdev)
+{
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+	int ret = 0;
+#if defined(CONFIG_ARCH_SUN50IW10)
+	int val = 0;
+#endif
+
+	if (pdev == NULL) {
+		DMSG_PANIC("ERR: %s, Argment is invalid\n", __func__);
+		return -1;
+	}
+
+	sunxi_ohci = pdev->dev.platform_data;
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: %s, sunxi_ohci is null\n", __func__);
+		return -1;
+	}
+
+	if (ohci_enable[sunxi_ohci->usbc_no] == 0)
+		device_remove_file(&pdev->dev, &dev_attr_ohci_enable);
+
+/* reset common circuit configuration*/
+#if defined(CONFIG_ARCH_SUN50IW10)
+	if (sunxi_ohci->usbc_no == HCI0_USBC_NO) {
+		val = readl(sunxi_ohci->usb_ccmu_config + 0x0A8C);
+		val &= ~(SUNXI_CCMU_USBEHCI1_GATING_OFFSET
+			 | SUNXI_CCMU_USBEHCI1_RST_OFFSET);
+		writel(val, sunxi_ohci->usb_ccmu_config + 0x0A8C);
+
+		val = readl(sunxi_ohci->usb_ccmu_config + 0x0A74);
+		val &= ~(SUNXI_CCMU_SCLK_GATING_USBPHY1_OFFSET
+			| SUNXI_CCMU_USBPHY1_RST_OFFSET
+			| SUNXI_CCMU_SCLK_GATING_OHCI1_OFFSET);
+		writel(val, sunxi_ohci->usb_ccmu_config + 0x0A74);
+
+		/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+		val = USBC_Readl(sunxi_ohci->usb_common_phy_config
+				 + SUNXI_HCI_PHY_CTRL);
+		val |= (0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+		USBC_Writel(val, sunxi_ohci->usb_common_phy_config
+			    + SUNXI_HCI_PHY_CTRL);
+	}
+#endif
+
+	if (sunxi_ohci->usbc_no == HCI0_USBC_NO)
+		unregister_pm_notifier(&sunxi_ohci_pm_nb);
+
+	if (sunxi_ohci->probe == 1) {
+		ret = sunxi_rmmod_ohci(pdev);
+		if (ret == 0)
+			exit_sunxi_hci(sunxi_ohci);
+
+
+		return ret;
+	} else
+		return 0;
+}
+
+static void sunxi_ohci_hcd_shutdown(struct platform_device *pdev)
+{
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+
+	sunxi_ohci = pdev->dev.platform_data;
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: %s sunxi_ohci is null\n", __func__);
+		return;
+	}
+
+	if (sunxi_ohci->probe == 0) {
+		DMSG_INFO("%s, %s is disable, need not shutdown\n",
+			__func__, sunxi_ohci->hci_name);
+		return;
+	}
+
+	DMSG_INFO("[%s]: ohci shutdown start\n", sunxi_ohci->hci_name);
+
+	usb_hcd_platform_shutdown(pdev);
+
+	/**
+	 * disable usb otg INTUSBE, to solve usb0 device mode
+	 * catch audio udev on reboot system is fail.
+	 */
+	if (sunxi_ohci->usbc_no == 0) {
+		if (sunxi_ohci->otg_vbase) {
+			writel(0, (sunxi_ohci->otg_vbase
+						+ SUNXI_USBC_REG_INTUSBE));
+		}
+	}
+	sunxi_ohci_set_vbus(sunxi_ohci, 0);
+	DMSG_INFO("[%s]: ohci shutdown end\n", sunxi_ohci->hci_name);
+}
+
+#if IS_ENABLED(CONFIG_PM)
+
+static int sunxi_ohci_hcd_suspend(struct device *dev)
+{
+	struct sunxi_hci_hcd *sunxi_ohci  = NULL;
+	struct usb_hcd *hcd	= NULL;
+	struct ohci_hcd	*ohci	= NULL;
+	int val = 0;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL) {
+		DMSG_PANIC("ERR: hcd is null\n");
+		return 0;
+	}
+
+	sunxi_ohci = dev->platform_data;
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ohci is null\n");
+		return 0;
+	}
+
+	if (sunxi_ohci->no_suspend) {
+		DMSG_INFO("[%s]:ohci is being enable, stop system suspend\n",
+			sunxi_ohci->hci_name);
+		return -1;
+	}
+
+	if (sunxi_ohci->probe == 0) {
+		DMSG_INFO("[%s]: is disable, can not suspend\n",
+			sunxi_ohci->hci_name);
+		return 0;
+	}
+
+	ohci = hcd_to_ohci(hcd);
+	if (ohci == NULL) {
+		DMSG_PANIC("ERR: ohci is null\n");
+		return 0;
+	}
+
+	if (sunxi_ohci->wakeup_suspend == USB_STANDBY) {
+		DMSG_INFO("[%s] usb suspend\n", sunxi_ohci->hci_name);
+		disable_irq(sunxi_ohci->irq_no);
+		val = ohci_readl(ohci, &ohci->regs->control);
+		val |= OHCI_CTRL_RWE;
+		ohci_writel(ohci, val,  &ohci->regs->control);
+
+		val = ohci_readl(ohci, &ohci->regs->intrenable);
+		val |= OHCI_INTR_RD;
+		val |= OHCI_INTR_MIE;
+		ohci_writel(ohci, val, &ohci->regs->intrenable);
+
+#if IS_ENABLED(SUNXI_USB_STANDBY_LOW_POW_MODE)
+		val = ohci_readl(ohci, &ohci->regs->control);
+		val |= OHCI_USB_SUSPEND;
+		ohci_writel(ohci, val, &ohci->regs->control);
+#endif
+		enter_usb_standby(sunxi_ohci);
+
+		if (sunxi_ohci->clk_usbohci12m && sunxi_ohci->clk_losc)
+			clk_set_parent(sunxi_ohci->clk_usbohci12m,
+					sunxi_ohci->clk_losc);
+	} else {
+		DMSG_INFO("[%s]super suspend\n", sunxi_ohci->hci_name);
+
+		/**
+		 * Root hub was already suspended. Disable irq emission and
+		 * mark HW unaccessible, bail out if RH has been resumed. Use
+		 * the spinlock to properly synchronize with possible pending
+		 * RH suspend or resume activity.
+		 *
+		 * This is still racy as hcd->state is manipulated outside of
+		 * any locks =P But that will be a different fix.
+		 */
+		ohci_suspend(hcd, device_may_wakeup(dev));
+
+		cancel_work_sync(&sunxi_ohci->resume_work);
+		sunxi_stop_ohci(sunxi_ohci);
+
+	}
+
+	return 0;
+}
+
+static void sunxi_ohci_resume_work(struct work_struct *work)
+{
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+
+	sunxi_ohci = container_of(work, struct sunxi_hci_hcd, resume_work);
+
+	sunxi_ohci_set_vbus(sunxi_ohci, 1);
+}
+
+static int sunxi_ohci_hcd_resume(struct device *dev)
+{
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct ohci_hcd	*ohci	= NULL;
+	int __maybe_unused val = 0;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL) {
+		DMSG_PANIC("ERR: hcd is null\n");
+		return 0;
+	}
+
+	sunxi_ohci = dev->platform_data;
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ohci is null\n");
+		return 0;
+	}
+
+	if (sunxi_ohci->probe == 0) {
+		DMSG_INFO("[%s]: is disable, can not resume\n",
+			sunxi_ohci->hci_name);
+		return 0;
+	}
+
+	ohci = hcd_to_ohci(hcd);
+	if (ohci == NULL) {
+		DMSG_PANIC("ERR: ohci is null\n");
+		return 0;
+	}
+
+	if (sunxi_ohci->wakeup_suspend == USB_STANDBY) {
+		DMSG_INFO("[%s]usb resume\n", sunxi_ohci->hci_name);
+
+		if (sunxi_ohci->clk_usbohci12m && sunxi_ohci->clk_hoscx2)
+			clk_set_parent(sunxi_ohci->clk_usbohci12m,
+					sunxi_ohci->clk_hoscx2);
+
+		exit_usb_standby(sunxi_ohci);
+#if IS_ENABLED(SUNXI_USB_STANDBY_LOW_POW_MODE)
+		val = ohci_readl(ohci, &ohci->regs->control);
+		val &= ~(OHCI_USB_SUSPEND);
+		val |= OHCI_USB_RESUME;
+		ohci_writel(ohci, val, &ohci->regs->control);
+#endif
+		enable_irq(sunxi_ohci->irq_no);
+	} else {
+		DMSG_INFO("[%s]super resume\n", sunxi_ohci->hci_name);
+		open_ohci_clock(sunxi_ohci);
+		sunxi_ohci_set_passby(sunxi_ohci, 1);
+		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		ohci_resume(hcd, false);
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+		if (sunxi_ohci->usbc_no == HCI0_USBC_NO) {
+			/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+			val = USBC_Readl(sunxi_ohci->usb_common_phy_config
+					 + SUNXI_HCI_PHY_CTRL);
+			val &= ~(0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+			USBC_Writel(val, sunxi_ohci->usb_common_phy_config
+				    + SUNXI_HCI_PHY_CTRL);
+		}
+#endif
+
+		schedule_work(&sunxi_ohci->resume_work);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops sunxi_ohci_pmops = {
+	.suspend	= sunxi_ohci_hcd_suspend,
+	.resume		= sunxi_ohci_hcd_resume,
+};
+
+#define SUNXI_OHCI_PMOPS (&sunxi_ohci_pmops)
+
+#else
+
+#define SUNXI_OHCI_PMOPS NULL
+
+#endif
+
+static const struct of_device_id sunxi_ohci_match[] = {
+	{.compatible = SUNXI_OHCI0_OF_MATCH, },
+	{.compatible = SUNXI_OHCI1_OF_MATCH, },
+	{.compatible = SUNXI_OHCI2_OF_MATCH, },
+	{.compatible = SUNXI_OHCI3_OF_MATCH, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_ohci_match);
+
+
+static struct platform_driver sunxi_ohci_hcd_driver = {
+	.probe		= sunxi_ohci_hcd_probe,
+	.remove		= sunxi_ohci_hcd_remove,
+	.shutdown	= sunxi_ohci_hcd_shutdown,
+	.driver		= {
+		.name	= ohci_name,
+		.owner	= THIS_MODULE,
+		.pm	= SUNXI_OHCI_PMOPS,
+		.of_match_table = sunxi_ohci_match,
+	},
+};
+
+int sunxi_usb_disable_ohci(__u32 usbc_no)
+{
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+
+	sunxi_ohci = g_sunxi_ohci[usbc_no];
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ohci is null\n");
+		return -1;
+	}
+
+	if (sunxi_ohci->probe == 0) {
+		DMSG_PANIC("ERR: sunxi_ohci is disable, can not disable again\n");
+		return -1;
+	}
+
+	sunxi_ohci->probe = 0;
+
+	DMSG_INFO("[%s]: sunxi_usb_disable_ohci\n", sunxi_ohci->hci_name);
+
+	sunxi_rmmod_ohci(sunxi_ohci->pdev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_usb_disable_ohci);
+
+int sunxi_usb_enable_ohci(__u32 usbc_no)
+{
+	struct sunxi_hci_hcd *sunxi_ohci = NULL;
+#if defined(CONFIG_ARCH_SUN50IW10)
+	int val;
+#endif
+
+	sunxi_ohci = g_sunxi_ohci[usbc_no];
+	if (sunxi_ohci == NULL) {
+		DMSG_PANIC("ERR: sunxi_ohci is null\n");
+		return -1;
+	}
+
+	if (sunxi_ohci->probe == 1) {
+		DMSG_PANIC("ERR: sunxi_ohci is already enable, can not enable again\n");
+		return -1;
+	}
+
+	sunxi_ohci->no_suspend = 1;
+
+	DMSG_INFO("[%s]: sunxi_usb_enable_ohci\n", sunxi_ohci->hci_name);
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+		if (sunxi_ohci->usbc_no == HCI0_USBC_NO) {
+			/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+			val = USBC_Readl(sunxi_ohci->usb_common_phy_config
+					 + SUNXI_HCI_PHY_CTRL);
+			val &= ~(0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+			USBC_Writel(val, sunxi_ohci->usb_common_phy_config
+				    + SUNXI_HCI_PHY_CTRL);
+		}
+#endif
+
+	sunxi_insmod_ohci(sunxi_ohci->pdev);
+
+	sunxi_ohci->no_suspend = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_usb_enable_ohci);
+
+static int __init sunxi_ohci_hcd_init(void)
+{
+	if (usb_disabled()) {
+		DMSG_ERR(KERN_ERR "%s nousb\n", ohci_name);
+		return -ENODEV;
+	}
+
+	DMSG_INFO(KERN_INFO "%s: " DRIVER_DESC "\n", ohci_name);
+	ohci_init_driver(&sunxi_ohci_hc_driver, NULL);
+	return platform_driver_register(&sunxi_ohci_hcd_driver);
+}
+module_init(sunxi_ohci_hcd_init);
+
+static void __exit sunxi_ohci_hcd_cleanup(void)
+{
+	platform_driver_unregister(&sunxi_ohci_hcd_driver);
+}
+module_exit(sunxi_ohci_hcd_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" SUNXI_OHCI_NAME);
+MODULE_AUTHOR("javen");
+MODULE_VERSION("1.0.9");
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index b015b0077..53c5cc292 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -16,6 +16,8 @@
 typedef __u32 __bitwise __hc32;
 typedef __u16 __bitwise __hc16;
 
+#include <linux/io.h>
+
 /*
  * OHCI Endpoint Descriptor (ED) ... holds TD queue
  * See OHCI spec, section 4.2
diff --git a/drivers/usb/host/sunxi-hci.c b/drivers/usb/host/sunxi-hci.c
new file mode 100644
index 000000000..67cc14f96
--- /dev/null
+++ b/drivers/usb/host/sunxi-hci.c
@@ -0,0 +1,2259 @@
+/**
+ * drivers/usb/host/sunxi-hci.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yangnaitian, 2011-5-24, create this file
+ * javen, 2011-7-18, add clock and power switch
+ *
+ * sunxi HCI Driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/gpio.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/unaligned.h>
+#include <linux/regulator/consumer.h>
+#include  <linux/of.h>
+#include  <linux/of_address.h>
+#include  <linux/of_device.h>
+#include <linux/sunxi-sid.h>
+
+#include  "sunxi-hci.h"
+
+#define DRIVER_DESC "SUNXI HCI driver"
+#define  SUNXI_HCI_NAME	"sunxi-hci"
+static const char hci_name[] = SUNXI_HCI_NAME;
+
+static u64 sunxi_hci_dmamask = ~0ULL; // DMA_BIT_MASK(64); /* Avoid Clang waring: shift count >= width of type */
+static DEFINE_MUTEX(usb_passby_lock);
+static DEFINE_MUTEX(usb_vbus_lock);
+static DEFINE_MUTEX(usb_clock_lock);
+static DEFINE_MUTEX(usb_standby_lock);
+
+#ifndef CONFIG_OF
+static char *usbc_name[4] = {"usbc0", "usbc1", "usbc2", "usbc3"};
+#endif
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_USB_MANAGER)
+int usb_otg_id_status(void);
+#endif
+
+static struct sunxi_hci_hcd sunxi_ohci0;
+static struct sunxi_hci_hcd sunxi_ohci1;
+static struct sunxi_hci_hcd sunxi_ohci2;
+static struct sunxi_hci_hcd sunxi_ohci3;
+static struct sunxi_hci_hcd sunxi_ehci0;
+static struct sunxi_hci_hcd sunxi_ehci1;
+static struct sunxi_hci_hcd sunxi_ehci2;
+static struct sunxi_hci_hcd sunxi_ehci3;
+static struct sunxi_hci_hcd sunxi_xhci;
+
+#define  USBPHYC_REG_o_PHYCTL		    0x0404
+
+atomic_t usb1_enable_passly_cnt = ATOMIC_INIT(0);
+atomic_t usb2_enable_passly_cnt = ATOMIC_INIT(0);
+atomic_t usb3_enable_passly_cnt = ATOMIC_INIT(0);
+atomic_t usb4_enable_passly_cnt = ATOMIC_INIT(0);
+
+atomic_t usb_standby_cnt = ATOMIC_INIT(0);
+static s32 request_usb_regulator_io(struct sunxi_hci_hcd *sunxi_hci)
+{
+	if (sunxi_hci->hsic_flag) {
+		if (sunxi_hci->hsic_regulator_io != NULL) {
+			sunxi_hci->hsic_regulator_io_hdle =
+					regulator_get(NULL, sunxi_hci->hsic_regulator_io);
+			if (IS_ERR(sunxi_hci->hsic_regulator_io_hdle)) {
+				DMSG_PANIC("ERR: some error happen, %s, hsic_regulator_io_hdle fail to get regulator!", sunxi_hci->hci_name);
+				sunxi_hci->hsic_regulator_io_hdle = NULL;
+				return 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static s32 release_usb_regulator_io(struct sunxi_hci_hcd *sunxi_hci)
+{
+	if (sunxi_hci->hsic_flag) {
+		if (sunxi_hci->hsic_regulator_io != NULL)
+			regulator_put(sunxi_hci->hsic_regulator_io_hdle);
+	}
+
+	return 0;
+}
+
+void __iomem *usb_phy_csr_add(struct sunxi_hci_hcd *sunxi_hci)
+{
+	return (sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CTRL);
+}
+
+void __iomem *usb_phy_csr_read(struct sunxi_hci_hcd *sunxi_hci)
+{
+	switch (sunxi_hci->usbc_no) {
+	case 0:
+		return sunxi_hci->otg_vbase + SUNXI_OTG_PHY_STATUS;
+
+	case 1:
+		return sunxi_hci->usb_vbase + SUNXI_HCI_UTMI_PHY_STATUS;
+
+	case 2:
+		return sunxi_hci->usb_vbase + SUNXI_HCI_UTMI_PHY_STATUS;
+
+	case 3:
+		return sunxi_hci->usb_vbase + SUNXI_HCI_UTMI_PHY_STATUS;
+
+	default:
+		DMSG_PANIC("usb_phy_csr_read is failed in %d index\n",
+			sunxi_hci->usbc_no);
+		break;
+	}
+
+	return NULL;
+}
+
+void __iomem *usb_phy_csr_write(struct sunxi_hci_hcd *sunxi_hci)
+{
+	switch (sunxi_hci->usbc_no) {
+	case 0:
+		return sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CTRL;
+
+	case 1:
+		return sunxi_hci->usb_vbase + SUNXI_HCI_PHY_CTRL;
+
+	case 2:
+		return sunxi_hci->usb_vbase + SUNXI_HCI_PHY_CTRL;
+
+	case 3:
+		return sunxi_hci->usb_vbase + SUNXI_HCI_PHY_CTRL;
+
+	default:
+		DMSG_PANIC("usb_phy_csr_write is failed in %d index\n",
+			sunxi_hci->usbc_no);
+		break;
+	}
+
+	return NULL;
+}
+
+int usb_phyx_tp_write(struct sunxi_hci_hcd *sunxi_hci,
+		int addr, int data, int len)
+{
+	int temp = 0;
+	int j = 0;
+	int reg_value = 0;
+	int reg_temp = 0;
+	int dtmp = 0;
+
+	if (sunxi_hci->otg_vbase == NULL) {
+		DMSG_PANIC("%s,otg_vbase is null\n", __func__);
+		return -1;
+	}
+
+	if (usb_phy_csr_add(sunxi_hci) == NULL) {
+		DMSG_PANIC("%s,phy_csr_add is null\n", __func__);
+		return -1;
+	}
+
+	if (usb_phy_csr_write(sunxi_hci) == NULL) {
+
+		DMSG_PANIC("%s,phy_csr_write is null\n", __func__);
+		return -1;
+	}
+
+	reg_value = USBC_Readl(sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CFG);
+	reg_temp = reg_value;
+	reg_value |= 0x01;
+	USBC_Writel(reg_value, (sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CFG));
+
+	dtmp = data;
+	for (j = 0; j < len; j++) {
+		USBC_Writeb(addr + j, usb_phy_csr_add(sunxi_hci) + 1);
+
+		temp = USBC_Readb(usb_phy_csr_write(sunxi_hci));
+		temp &= ~(0x1 << 0);
+		USBC_Writeb(temp, usb_phy_csr_write(sunxi_hci));
+
+		temp = USBC_Readb(usb_phy_csr_add(sunxi_hci));
+		temp &= ~(0x1 << 7);
+		temp |= (dtmp & 0x1) << 7;
+		USBC_Writeb(temp, usb_phy_csr_add(sunxi_hci));
+
+		temp = USBC_Readb(usb_phy_csr_write(sunxi_hci));
+		temp |= (0x1 << 0);
+		USBC_Writeb(temp, usb_phy_csr_write(sunxi_hci));
+
+		temp = USBC_Readb(usb_phy_csr_write(sunxi_hci));
+		temp &= ~(0x1 << 0);
+		USBC_Writeb(temp, usb_phy_csr_write(sunxi_hci));
+
+		dtmp >>= 1;
+	}
+
+	USBC_Writel(reg_temp, (sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CFG));
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_phyx_tp_write);
+
+int usb_phyx_write(struct sunxi_hci_hcd *sunxi_hci, int data)
+{
+	int reg_value = 0;
+	int temp = 0;
+	int dtmp = 0;
+	int ptmp = 0;
+
+	temp = data;
+	dtmp = data;
+	ptmp = data;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_HCI_PHY_TUNE);
+
+	/*TXVREFTUNE + TXRISETUNE + TXPREEMPAMPTUNE + TXRESTUNE*/
+	reg_value &= ~((0xf << 8) | (0x3 << 4) | (0xf << 0));
+	temp &= ~((0xf << 4) | (0x3 << 8));
+	reg_value |= temp << 8;
+	dtmp &= ~((0xf << 6) | (0xf << 0));
+	reg_value |= dtmp;
+	data &= ~((0x3 << 4) | (0xf << 0));
+	reg_value |= data >> 6;
+
+	USBC_Writel(reg_value, (sunxi_hci->usb_vbase + SUNXI_HCI_PHY_TUNE));
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_phyx_write);
+
+int usb_phyx_read(struct sunxi_hci_hcd *sunxi_hci)
+{
+	int reg_value = 0;
+	int temp = 0;
+	int ptmp = 0;
+	int ret = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_HCI_PHY_TUNE);
+	reg_value &= 0xf3f;
+	ptmp = reg_value;
+
+	temp = reg_value >> 8;
+	ptmp &= ~((0xf << 8) | (0xf << 4));
+	ptmp <<= 6;
+	reg_value &= ~((0xf << 8) | (0xf << 0));
+
+	ret = reg_value | ptmp | temp;
+
+	DMSG_INFO("bit[3:0]VREF = 0x%x; bit[5:4]RISE = 0x%x; bit[7:6]PREEMPAMP = 0x%x; bit[9:8]RES = 0x%x\n",
+		temp, reg_value >> 4, (ptmp >> 6) & 0x3,
+		((ptmp >> 6)  & 0xc) >> 2);
+
+	return ret;
+}
+EXPORT_SYMBOL(usb_phyx_read);
+
+int usb_phyx_tp_read(struct sunxi_hci_hcd *sunxi_hci, int addr, int len)
+{
+	int temp = 0;
+	int i = 0;
+	int j = 0;
+	int ret = 0;
+	int reg_value = 0;
+	int reg_temp = 0;
+
+	if (sunxi_hci->otg_vbase == NULL) {
+		DMSG_PANIC("%s,otg_vbase is null\n", __func__);
+		return -1;
+	}
+
+	if (usb_phy_csr_add(sunxi_hci) == NULL) {
+		DMSG_PANIC("%s,phy_csr_add is null\n", __func__);
+		return -1;
+	}
+
+	if (usb_phy_csr_read(sunxi_hci) == NULL) {
+		DMSG_PANIC("%s,phy_csr_read is null\n", __func__);
+		return -1;
+	}
+
+	reg_value = USBC_Readl(sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CFG);
+	reg_temp = reg_value;
+	reg_value |= 0x01;
+	USBC_Writel(reg_value, (sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CFG));
+
+	for (j = len; j > 0; j--) {
+		USBC_Writeb((addr + j - 1), usb_phy_csr_add(sunxi_hci) + 1);
+
+		for (i = 0; i < 0x4; i++)
+			;
+
+		temp = USBC_Readb(usb_phy_csr_read(sunxi_hci));
+		ret <<= 1;
+		ret |= (temp & 0x1);
+	}
+
+	USBC_Writel(reg_temp, (sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CFG));
+
+	return ret;
+}
+EXPORT_SYMBOL(usb_phyx_tp_read);
+
+#if defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+/*for new phy*/
+static int usb_new_phyx_tp_write(struct sunxi_hci_hcd *sunxi_hci,
+		int addr, int data, int len)
+{
+	int temp = 0;
+	int j = 0;
+	int dtmp = 0;
+	void __iomem *base;
+
+	if (sunxi_hci->otg_vbase == NULL) {
+		DMSG_PANIC("%s,otg_vbase is null\n", __func__);
+		return -1;
+	}
+
+	if (usb_phy_csr_add(sunxi_hci) == NULL) {
+		DMSG_PANIC("%s,phy_csr_add is null\n", __func__);
+		return -1;
+	}
+
+	if (usb_phy_csr_write(sunxi_hci) == NULL) {
+
+		DMSG_PANIC("%s,phy_csr_write is null\n", __func__);
+		return -1;
+	}
+	/*device: 0x410(phy_ctl)*/
+	base = sunxi_hci->usb_vbase;
+	dtmp = data;
+	for (j = 0; j < len; j++) {
+		temp = USBC_Readb(base + SUNXI_HCI_PHY_CTRL);
+		temp |= (0x1 << 1);
+		USBC_Writeb(temp, base + SUNXI_HCI_PHY_CTRL);
+
+		USBC_Writeb(addr + j, base + SUNXI_HCI_PHY_CTRL + 1);
+
+		temp = USBC_Readb(base + SUNXI_HCI_PHY_CTRL);
+		temp &= ~(0x1 << 0);
+		USBC_Writeb(temp, base + SUNXI_HCI_PHY_CTRL);
+
+		temp = USBC_Readb(base + SUNXI_HCI_PHY_CTRL);
+		temp &= ~(0x1 << 7);
+		temp |= (dtmp & 0x1) << 7;
+		USBC_Writeb(temp, base + SUNXI_HCI_PHY_CTRL);
+
+		temp |= (0x1 << 0);
+		USBC_Writeb(temp, base + SUNXI_HCI_PHY_CTRL);
+
+		temp &= ~(0x1 << 0);
+		USBC_Writeb(temp, base + SUNXI_HCI_PHY_CTRL);
+
+		temp = USBC_Readb(base + SUNXI_HCI_PHY_CTRL);
+		temp &= ~(0x1 << 1);
+		USBC_Writeb(temp, base + SUNXI_HCI_PHY_CTRL);
+
+		dtmp >>= 1;
+	}
+
+	return 0;
+}
+
+static int usb_new_phyx_tp_read(struct sunxi_hci_hcd *sunxi_hci, int addr, int len)
+{
+	int temp = 0;
+	int i = 0;
+	int j = 0;
+	int ret = 0;
+	void __iomem *base;
+
+	if (sunxi_hci->otg_vbase == NULL) {
+		DMSG_PANIC("%s,otg_vbase is null\n", __func__);
+		return -1;
+	}
+
+	if (usb_phy_csr_add(sunxi_hci) == NULL) {
+		DMSG_PANIC("%s,phy_csr_add is null\n", __func__);
+		return -1;
+	}
+
+	if (usb_phy_csr_read(sunxi_hci) == NULL) {
+		DMSG_PANIC("%s,phy_csr_read is null\n", __func__);
+		return -1;
+	}
+
+	base = sunxi_hci->usb_vbase;
+
+	temp = USBC_Readb(base + SUNXI_HCI_PHY_CTRL);
+	temp |= (0x1 << 1);
+	USBC_Writeb(temp, base + SUNXI_HCI_PHY_CTRL);
+
+	for (j = len; j > 0; j--) {
+		USBC_Writeb((addr + j - 1), base + SUNXI_HCI_PHY_CTRL + 1);
+
+		for (i = 0; i < 0x4; i++)
+			;
+
+		temp = USBC_Readb(base + SUNXI_HCI_UTMI_PHY_STATUS);
+		ret <<= 1;
+		ret |= (temp & 0x1);
+	}
+
+	temp = USBC_Readb(base + SUNXI_HCI_PHY_CTRL);
+	temp &= ~(0x1 << 1);
+	USBC_Writeb(temp, base + SUNXI_HCI_PHY_CTRL);
+
+	return ret;
+}
+
+static void usb_new_phy_init(struct sunxi_hci_hcd *sunxi_hci)
+{
+	int value = 0;
+	u32 efuse_val  = 0;
+
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x03, 0x06,
+			usb_new_phyx_tp_read(sunxi_hci, 0x03, 0x06));
+
+	//pll_prediv
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x16, 0x03,
+			usb_new_phyx_tp_read(sunxi_hci, 0x16, 0x03));
+
+	//usbc_new_phyx_tp_write(regs, 0x1c, 0x07, 0x03);
+	//pll_n
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x0b, 0x08,
+			usb_new_phyx_tp_read(sunxi_hci, 0x0b, 0x08));
+
+	//usbc_new_phyx_tp_write(regs, 0x30, 0x0f, 0x0d);
+	//pll_sts
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x09, 0x03,
+			usb_new_phyx_tp_read(sunxi_hci, 0x09, 0x03));
+
+	sunxi_get_module_param_from_sid(&efuse_val, EFUSE_OFFSET, 4);
+	pr_debug("efuse_val:0x%x\n", efuse_val);
+
+	usb_new_phyx_tp_write(sunxi_hci, 0x1c, 0x0, 0x03);
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x1c, 0x03,
+			usb_new_phyx_tp_read(sunxi_hci, 0x1c, 0x03));
+
+	if (efuse_val & SUNXI_HCI_PHY_EFUSE_ADJUST) {
+		if (efuse_val & SUNXI_HCI_PHY_EFUSE_MODE) {
+			/* iref mode */
+			usb_new_phyx_tp_write(sunxi_hci, 0x60, 0x1, 0x01);
+
+			switch (sunxi_hci->usbc_no) {
+			case 0:
+				value = (efuse_val & SUNXI_HCI_PHY_EFUSE_USB0TX) >> 22;
+				usb_new_phyx_tp_write(sunxi_hci, 0x61, value, 0x03);
+				break;
+
+			case 1:
+				value = (efuse_val & SUNXI_HCI_PHY_EFUSE_USB0TX) >> 25;
+				usb_new_phyx_tp_write(sunxi_hci, 0x61, value, 0x03);
+				break;
+
+			default:
+				pr_err("usb %d not exist!\n", sunxi_hci->usbc_no);
+				break;
+			}
+
+			value = (efuse_val & SUNXI_HCI_PHY_EFUSE_RES) >> 18;
+			usb_new_phyx_tp_write(sunxi_hci, 0x44, value, 0x04);
+
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x61, 0x03,
+				usb_new_phyx_tp_read(sunxi_hci, 0x61, 0x03));
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x44, 0x04,
+				usb_new_phyx_tp_read(sunxi_hci, 0x44, 0x04));
+		} else {
+			/* vref mode */
+			usb_new_phyx_tp_write(sunxi_hci, 0x60, 0x0, 0x01);
+
+			value = (efuse_val & SUNXI_HCI_PHY_EFUSE_RES) >> 18;
+			usb_new_phyx_tp_write(sunxi_hci, 0x44, value, 0x04);
+
+			value = (efuse_val & SUNXI_HCI_PHY_EFUSE_COM) >> 22;
+			usb_new_phyx_tp_write(sunxi_hci, 0x36, value, 0x03);
+
+
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x60, 0x01,
+				usb_new_phyx_tp_read(sunxi_hci, 0x60, 0x01));
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x44, 0x04,
+				usb_new_phyx_tp_read(sunxi_hci, 0x44, 0x04));
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x36, 0x03,
+				usb_new_phyx_tp_read(sunxi_hci, 0x36, 0x03));
+		}
+	}
+
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x03, 0x06,
+			usb_new_phyx_tp_read(sunxi_hci, 0x03, 0x06));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x16, 0x03,
+			usb_new_phyx_tp_read(sunxi_hci, 0x16, 0x03));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x0b, 0x08,
+			usb_new_phyx_tp_read(sunxi_hci, 0x0b, 0x08));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x09, 0x03,
+			usb_new_phyx_tp_read(sunxi_hci, 0x09, 0x03));
+}
+
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW7) || defined(CONFIG_ARCH_SUN8IW12) \
+	|| defined(CONFIG_ARCH_SUN8IW15) || defined(CONFIG_ARCH_SUN50IW3) \
+	|| defined(CONFIG_ARCH_SUN50IW6) || defined(CONFIG_ARCH_SUN50IW9) \
+	|| defined(CONFIG_ARCH_SUN8IW18)
+static void usb_hci_utmi_phy_tune(struct sunxi_hci_hcd *sunxi_hci, int mask,
+				  int offset, int val)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_HCI_PHY_TUNE);
+	reg_value &= ~mask;
+	val = val << offset;
+	val &= mask;
+	reg_value |= val;
+	USBC_Writel(reg_value, (sunxi_hci->usb_vbase + SUNXI_HCI_PHY_TUNE));
+}
+#endif
+
+static void USBC_SelectPhyToHci(struct sunxi_hci_hcd *sunxi_hci)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CFG);
+	reg_value &= ~(0x01);
+	USBC_Writel(reg_value, (sunxi_hci->otg_vbase + SUNXI_OTG_PHY_CFG));
+}
+
+static void USBC_Clean_SIDDP(struct sunxi_hci_hcd *sunxi_hci)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_HCI_PHY_CTRL);
+	reg_value &= ~(0x01 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+	USBC_Writel(reg_value, (sunxi_hci->usb_vbase + SUNXI_HCI_PHY_CTRL));
+}
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+/*for common circuit*/
+void sunxi_hci_common_set_rc_clk(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int reg_value = 0;
+	reg_value = USBC_Readl(sunxi_hci->usb_common_phy_config
+			+ SUNXI_USB_PMU_IRQ_ENABLE);
+	if (is_on)
+		reg_value |= 0x01 << SUNXI_HCI_RC16M_CLK_ENBALE;
+	else
+		reg_value &= ~(0x01 << SUNXI_HCI_RC16M_CLK_ENBALE);
+	USBC_Writel(reg_value, (sunxi_hci->usb_common_phy_config
+				+ SUNXI_USB_PMU_IRQ_ENABLE));
+}
+void sunxi_hci_common_switch_clk(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int reg_value = 0;
+	reg_value = USBC_Readl(sunxi_hci->usb_common_phy_config
+			+ SUNXI_USB_PMU_IRQ_ENABLE);
+	if (is_on)
+		reg_value |= 0x01 << 31;
+	else
+		reg_value &= ~(0x01 << 31);
+	USBC_Writel(reg_value, (sunxi_hci->usb_common_phy_config
+				+ SUNXI_USB_PMU_IRQ_ENABLE));
+}
+void sunxi_hci_common_set_rcgating(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int reg_value = 0;
+	reg_value = USBC_Readl(sunxi_hci->usb_common_phy_config
+			+ SUNXI_USB_PMU_IRQ_ENABLE);
+	if (is_on)
+		reg_value |= 0x01 << 3;
+	else
+		reg_value &= ~(0x01 << 3);
+	USBC_Writel(reg_value, (sunxi_hci->usb_common_phy_config
+				+ SUNXI_USB_PMU_IRQ_ENABLE));
+}
+void sunxi_hci_switch_clk(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int val = 0;
+	val = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE);
+	if (is_on)
+		val |= 0x01 << 31;
+	else
+		val &= ~(0x01 << 31);
+	USBC_Writel(val, (sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE));
+}
+void sunxi_hci_set_rcgating(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int val = 0;
+	val = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE);
+	if (is_on)
+		val |= 0x01 << 3;
+	else
+		val &= ~(0x01 << 3);
+	USBC_Writel(val, (sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE));
+}
+#endif
+/*
+ * Low-power mode USB standby helper functions.
+ */
+#if IS_ENABLED(SUNXI_USB_STANDBY_LOW_POW_MODE)
+void sunxi_hci_set_siddq(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_HCI_PHY_CTRL);
+
+	if (is_on)
+		reg_value |= 0x01 << SUNXI_HCI_PHY_CTRL_SIDDQ;
+	else
+		reg_value &= ~(0x01 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+
+	USBC_Writel(reg_value, (sunxi_hci->usb_vbase + SUNXI_HCI_PHY_CTRL));
+}
+
+void sunxi_hci_set_wakeup_ctrl(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_HCI_CTRL_3);
+
+	if (is_on)
+		reg_value |= 0x01 << SUNXI_HCI_CTRL_3_REMOTE_WAKEUP;
+	else
+		reg_value &= ~(0x01 << SUNXI_HCI_CTRL_3_REMOTE_WAKEUP);
+
+	USBC_Writel(reg_value, (sunxi_hci->usb_vbase + SUNXI_HCI_CTRL_3));
+}
+
+void sunxi_hci_set_rc_clk(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE);
+
+	if (is_on)
+		reg_value |= 0x01 << SUNXI_HCI_RC16M_CLK_ENBALE;
+	else
+		reg_value &= ~(0x01 << SUNXI_HCI_RC16M_CLK_ENBALE);
+
+	USBC_Writel(reg_value, (sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE));
+}
+
+#if defined(CONFIG_ARCH_SUN50IW9)
+void sunxi_hci_set_standby_irq(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_USB_EHCI_TIME_INT);
+
+	if (is_on)
+		reg_value |= 0x01 << SUNXI_USB_EHCI_STANDBY_IRQ;
+	else
+		reg_value &= ~(0x01 << SUNXI_USB_EHCI_STANDBY_IRQ);
+
+	USBC_Writel(reg_value, (sunxi_hci->usb_vbase + SUNXI_USB_EHCI_TIME_INT));
+}
+#endif
+
+void sunxi_hci_clean_standby_irq(struct sunxi_hci_hcd *sunxi_hci)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_USB_EHCI_TIME_INT);
+	reg_value |= 0x01 << SUNXI_USB_EHCI_STANDBY_IRQ_STATUS;
+	USBC_Writel(reg_value, (sunxi_hci->usb_vbase + SUNXI_USB_EHCI_TIME_INT));
+}
+#endif
+
+static int open_clock(struct sunxi_hci_hcd *sunxi_hci, u32 ohci)
+{
+	int ret;
+
+	mutex_lock(&usb_clock_lock);
+
+	/*
+	 * otg and hci share the same phy in fpga,
+	 * so need switch phy to hci here.
+	 * Notice: not need any more on new platforms.
+	 */
+
+	if (sunxi_hci->hci_regulator) {
+		ret = regulator_enable(sunxi_hci->hci_regulator);
+		if (ret)
+			DMSG_PANIC("ERR:%s hci regulator enable failed\n",
+					sunxi_hci->hci_name);
+	}
+	/* otg and hci0 Controller Shared phy in SUN50I */
+	if (sunxi_hci->usbc_no == HCI0_USBC_NO)
+		USBC_SelectPhyToHci(sunxi_hci);
+
+	/* To fix hardware design issue. */
+#if defined(CONFIG_ARCH_SUN8IW12) || defined(CONFIG_ARCH_SUN50IW3) \
+	|| defined(CONFIG_ARCH_SUN50IW6)
+	usb_hci_utmi_phy_tune(sunxi_hci, SUNXI_TX_RES_TUNE, SUNXI_TX_RES_TUNE_OFFSET, 0x3);
+	usb_hci_utmi_phy_tune(sunxi_hci, SUNXI_TX_VREF_TUNE, SUNXI_TX_VREF_TUNE_OFFSET, 0xc);
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW18)
+	usb_hci_utmi_phy_tune(sunxi_hci, SUNXI_TX_PREEMPAMP_TUNE, SUNXI_TX_PREEMPAMP_TUNE_OFFSET, 0x10);
+	usb_hci_utmi_phy_tune(sunxi_hci, SUNXI_TX_VREF_TUNE, SUNXI_TX_VREF_TUNE_OFFSET, 0xc);
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW7) || defined(CONFIG_ARCH_SUN8IW15)
+	usb_hci_utmi_phy_tune(sunxi_hci, SUNXI_TX_VREF_TUNE, SUNXI_TX_VREF_TUNE_OFFSET, 0x4);
+#endif
+
+#if defined(CONFIG_ARCH_SUN50IW9)
+	usb_hci_utmi_phy_tune(sunxi_hci, SUNXI_TX_PREEMPAMP_TUNE, SUNXI_TX_PREEMPAMP_TUNE_OFFSET, 0x2);
+#endif
+
+	if (!sunxi_hci->clk_is_open) {
+		sunxi_hci->clk_is_open = 1;
+
+		if (sunxi_hci->reset_phy) {
+			ret = reset_control_deassert(sunxi_hci->reset_phy);
+			if (ret) {
+				dev_err(&sunxi_hci->pdev->dev, "reset phy err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (sunxi_hci->reset_hci) {
+			ret = reset_control_deassert(sunxi_hci->reset_hci);
+			if (ret) {
+				dev_err(&sunxi_hci->pdev->dev, "reset hci err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (sunxi_hci->clk_bus_hci) {
+			ret = clk_prepare_enable(sunxi_hci->clk_bus_hci);
+			if (ret) {
+				dev_err(&sunxi_hci->pdev->dev, "enable clk_bus_hci err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (sunxi_hci->clk_ohci) {
+			if (strstr(sunxi_hci->hci_name, "ohci")) {
+				ret = clk_prepare_enable(sunxi_hci->clk_ohci);
+				if (ret) {
+					dev_err(&sunxi_hci->pdev->dev,
+						"enable clk_ohci err, return %d\n", ret);
+					return ret;
+				}
+			}
+		}
+
+
+		udelay(10);
+
+		if (sunxi_hci->hsic_flag) {
+			printk("%s()%d yhs\n", __func__, __LINE__);
+			if (sunxi_hci->hsic_ctrl_flag) {
+				if (sunxi_hci->hsic_enable_flag) {
+					if (clk_prepare_enable(sunxi_hci->pll_hsic))
+						DMSG_PANIC("ERR:try to prepare_enable %s pll_hsic failed!\n",
+							sunxi_hci->hci_name);
+
+					if (clk_prepare_enable(sunxi_hci->clk_usbhsic12m))
+						DMSG_PANIC("ERR:try to prepare_enable %s clk_usbhsic12m failed!\n",
+							sunxi_hci->hci_name);
+
+					if (clk_prepare_enable(sunxi_hci->hsic_usbphy))
+						DMSG_PANIC("ERR:try to prepare_enable %s_hsic_usbphy failed!\n",
+							sunxi_hci->hci_name);
+				}
+			} else {
+				if (clk_prepare_enable(sunxi_hci->pll_hsic))
+					DMSG_PANIC("ERR:try to prepare_enable %s pll_hsic failed!\n",
+						sunxi_hci->hci_name);
+
+				if (clk_prepare_enable(sunxi_hci->clk_usbhsic12m))
+					DMSG_PANIC("ERR:try to prepare_enable %s clk_usbhsic12m failed!\n",
+						sunxi_hci->hci_name);
+
+				if (clk_prepare_enable(sunxi_hci->hsic_usbphy))
+					DMSG_PANIC("ERR:try to prepare_enable %s_hsic_usbphy failed!\n",
+						sunxi_hci->hci_name);
+			}
+		} else {
+			if (sunxi_hci->clk_phy) {
+				ret = clk_prepare_enable(sunxi_hci->clk_phy);
+				if (ret) {
+					dev_err(&sunxi_hci->pdev->dev, "enable clk_phy err, return %d\n", ret);
+					return ret;
+				}
+			}
+		}
+
+		udelay(10);
+
+	} else {
+		DMSG_PANIC("[%s]: wrn: open clock failed, (%d, 0x%p)\n",
+			sunxi_hci->hci_name,
+			sunxi_hci->clk_is_open,
+			sunxi_hci->mod_usb);
+	}
+
+	USBC_Clean_SIDDP(sunxi_hci);
+#if !defined(CONFIG_ARCH_SUN8IW12) && !defined(CONFIG_ARCH_SUN50IW3) \
+	&& !defined(CONFIG_ARCH_SUN8IW6) && !defined(CONFIG_ARCH_SUN50IW6) \
+	&& !defined(CONFIG_ARCH_SUN8IW15) && !defined(CONFIG_ARCH_SUN50IW8) \
+	&& !defined(CONFIG_ARCH_SUN8IW18) && !defined(CONFIG_ARCH_SUN8IW16) \
+	&& !defined(CONFIG_ARCH_SUN50IW9) && !defined(CONFIG_ARCH_SUN50IW10) \
+	&& !defined(CONFIG_ARCH_SUN8IW19) && !defined(CONFIG_ARCH_SUN50IW11) \
+	&& !defined(CONFIG_ARCH_SUN8IW20) && !defined(CONFIG_ARCH_SUN20IW1) \
+	&& !defined(CONFIG_ARCH_SUN50IW12)
+	usb_phyx_tp_write(sunxi_hci, 0x2a, 3, 2);
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+	usb_new_phy_init(sunxi_hci);
+#endif
+
+	mutex_unlock(&usb_clock_lock);
+
+	return 0;
+}
+
+static int close_clock(struct sunxi_hci_hcd *sunxi_hci, u32 ohci)
+{
+	if (sunxi_hci->clk_is_open) {
+		sunxi_hci->clk_is_open = 0;
+
+		if (sunxi_hci->hsic_flag) {
+			if (sunxi_hci->hsic_ctrl_flag) {
+				if (sunxi_hci->hsic_enable_flag) {
+					clk_disable_unprepare(sunxi_hci->clk_usbhsic12m);
+					clk_disable_unprepare(sunxi_hci->hsic_usbphy);
+					clk_disable_unprepare(sunxi_hci->pll_hsic);
+				}
+			} else {
+				clk_disable_unprepare(sunxi_hci->clk_usbhsic12m);
+				clk_disable_unprepare(sunxi_hci->hsic_usbphy);
+				clk_disable_unprepare(sunxi_hci->pll_hsic);
+			}
+		} else {
+			if (sunxi_hci->clk_phy)
+				clk_disable_unprepare(sunxi_hci->clk_phy);
+		}
+
+		if (strstr(sunxi_hci->hci_name, "ohci"))
+			if (sunxi_hci->clk_ohci)
+				clk_disable_unprepare(sunxi_hci->clk_ohci);
+
+		if (sunxi_hci->clk_bus_hci)
+			clk_disable_unprepare(sunxi_hci->clk_bus_hci);
+
+		if (sunxi_hci->reset_hci)
+			reset_control_assert(sunxi_hci->reset_hci);
+
+		if (sunxi_hci->reset_phy)
+			reset_control_deassert(sunxi_hci->reset_phy);
+
+		udelay(10);
+	} else {
+		DMSG_PANIC("[%s]: wrn: open clock failed, (%d, 0x%p)\n",
+			sunxi_hci->hci_name,
+			sunxi_hci->clk_is_open,
+			sunxi_hci->mod_usb);
+	}
+	return 0;
+}
+
+static int usb_get_hsic_phy_ctrl(int value, int enable)
+{
+	if (enable) {
+		value |= (0x07<<8);
+		value |= (0x01<<1);
+		value |= (0x01<<0);
+		value |= (0x01<<16);
+		value |= (0x01<<20);
+	} else {
+		value &= ~(0x07<<8);
+		value &= ~(0x01<<1);
+		value &= ~(0x01<<0);
+		value &= ~(0x01<<16);
+		value &= ~(0x01<<20);
+	}
+
+	return value;
+}
+
+static void __usb_passby(struct sunxi_hci_hcd *sunxi_hci, u32 enable,
+			     atomic_t *usb_enable_passly_cnt)
+{
+	unsigned long reg_value = 0;
+
+	reg_value = USBC_Readl(sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE);
+	if (enable && (atomic_read(usb_enable_passly_cnt) == 0)) {
+		if (sunxi_hci->hsic_flag) {
+			reg_value = usb_get_hsic_phy_ctrl(reg_value, enable);
+		} else {
+			/* AHB Master interface INCR8 enable */
+			reg_value |= (1 << 10);
+			/* AHB Master interface burst type INCR4 enable */
+			reg_value |= (1 << 9);
+			/* AHB Master interface INCRX align enable */
+			reg_value |= (1 << 8);
+			if (sunxi_hci->usbc_no == HCI0_USBC_NO)
+#ifdef SUNXI_USB_FPGA
+				/* enable ULPI, disable UTMI */
+				reg_value |= (0 << 0);
+#else
+				/* enable UTMI, disable ULPI */
+				reg_value |= (1 << 0);
+#endif
+			else
+				/* ULPI bypass enable */
+				reg_value |= (1 << 0);
+		}
+	} else if (!enable && (atomic_read(usb_enable_passly_cnt) == 1)) {
+		if (sunxi_hci->hsic_flag) {
+			reg_value = usb_get_hsic_phy_ctrl(reg_value, enable);
+		} else {
+			/* AHB Master interface INCR8 disable */
+			reg_value &= ~(1 << 10);
+			/* AHB Master interface burst type INCR4 disable */
+			reg_value &= ~(1 << 9);
+			/* AHB Master interface INCRX align disable */
+			reg_value &= ~(1 << 8);
+			/* ULPI bypass disable */
+			reg_value &= ~(1 << 0);
+		}
+	}
+	USBC_Writel(reg_value,
+		(sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE));
+
+	if (enable)
+		atomic_add(1, usb_enable_passly_cnt);
+	else
+		atomic_sub(1, usb_enable_passly_cnt);
+}
+
+static void usb_passby(struct sunxi_hci_hcd *sunxi_hci, u32 enable)
+{
+	spinlock_t lock;
+	unsigned long flags = 0;
+
+	mutex_lock(&usb_passby_lock);
+
+	spin_lock_init(&lock);
+	spin_lock_irqsave(&lock, flags);
+	/* enable passby */
+	if (sunxi_hci->usbc_no == HCI0_USBC_NO) {
+		__usb_passby(sunxi_hci, enable, &usb1_enable_passly_cnt);
+	} else if (sunxi_hci->usbc_no == HCI1_USBC_NO) {
+		__usb_passby(sunxi_hci, enable, &usb2_enable_passly_cnt);
+	} else if (sunxi_hci->usbc_no == HCI2_USBC_NO) {
+		__usb_passby(sunxi_hci, enable, &usb3_enable_passly_cnt);
+	} else if (sunxi_hci->usbc_no == HCI3_USBC_NO) {
+		__usb_passby(sunxi_hci, enable, &usb4_enable_passly_cnt);
+	} else {
+		DMSG_PANIC("EER: unknown usbc_no(%d)\n", sunxi_hci->usbc_no);
+		spin_unlock_irqrestore(&lock, flags);
+
+		mutex_unlock(&usb_passby_lock);
+		return;
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	mutex_unlock(&usb_passby_lock);
+}
+
+static int alloc_pin(struct sunxi_hci_hcd *sunxi_hci)
+{
+	u32 ret = 1;
+
+	if (sunxi_hci->hsic_flag) {
+		/* Marvell 4G HSIC ctrl */
+		if (sunxi_hci->usb_host_hsic_rdy_valid) {
+			ret = gpio_request(sunxi_hci->usb_host_hsic_rdy.gpio, NULL);
+			if (ret != 0) {
+				DMSG_PANIC("ERR: gpio_request failed\n");
+				sunxi_hci->usb_host_hsic_rdy_valid = 0;
+			} else {
+				gpio_direction_output(sunxi_hci->usb_host_hsic_rdy.gpio, 0);
+			}
+		}
+
+		/* SMSC usb3503 HSIC HUB ctrl */
+		if (sunxi_hci->usb_hsic_usb3503_flag) {
+			if (sunxi_hci->usb_hsic_hub_connect_valid) {
+				ret = gpio_request(sunxi_hci->usb_hsic_hub_connect.gpio, NULL);
+				if (ret != 0) {
+					DMSG_PANIC("ERR: gpio_request failed\n");
+					sunxi_hci->usb_hsic_hub_connect_valid = 0;
+				} else {
+					gpio_direction_output(sunxi_hci->usb_hsic_hub_connect.gpio, 1);
+				}
+			}
+
+			if (sunxi_hci->usb_hsic_int_n_valid) {
+				ret = gpio_request(sunxi_hci->usb_hsic_int_n.gpio, NULL);
+				if (ret != 0) {
+					DMSG_PANIC("ERR: gpio_request failed\n");
+					sunxi_hci->usb_hsic_int_n_valid = 0;
+				} else {
+					gpio_direction_output(sunxi_hci->usb_hsic_int_n.gpio, 1);
+				}
+			}
+
+			msleep(20);
+
+			if (sunxi_hci->usb_hsic_reset_n_valid) {
+				ret = gpio_request(sunxi_hci->usb_hsic_reset_n.gpio, NULL);
+				if (ret != 0) {
+					DMSG_PANIC("ERR: gpio_request failed\n");
+					sunxi_hci->usb_hsic_reset_n_valid = 0;
+				} else {
+					gpio_direction_output(sunxi_hci->usb_hsic_reset_n.gpio, 1);
+				}
+			}
+
+			/**
+			 * usb3503 device goto hub connect status
+			 * is need 100ms after reset
+			 */
+			msleep(100);
+		}
+	}
+
+	return 0;
+}
+
+static void free_pin(struct sunxi_hci_hcd *sunxi_hci)
+{
+	if (sunxi_hci->hsic_flag) {
+		/* Marvell 4G HSIC ctrl */
+		if (sunxi_hci->usb_host_hsic_rdy_valid) {
+			gpio_free(sunxi_hci->usb_host_hsic_rdy.gpio);
+			sunxi_hci->usb_host_hsic_rdy_valid = 0;
+		}
+
+		/* SMSC usb3503 HSIC HUB ctrl */
+		if (sunxi_hci->usb_hsic_usb3503_flag) {
+			if (sunxi_hci->usb_hsic_hub_connect_valid) {
+				gpio_free(sunxi_hci->usb_hsic_hub_connect.gpio);
+				sunxi_hci->usb_hsic_hub_connect_valid = 0;
+			}
+
+			if (sunxi_hci->usb_hsic_int_n_valid) {
+				gpio_free(sunxi_hci->usb_hsic_int_n.gpio);
+				sunxi_hci->usb_hsic_int_n_valid = 0;
+			}
+
+			if (sunxi_hci->usb_hsic_reset_n_valid) {
+				gpio_free(sunxi_hci->usb_hsic_reset_n.gpio);
+				sunxi_hci->usb_hsic_reset_n_valid = 0;
+			}
+		}
+	}
+}
+
+void sunxi_set_host_hisc_rdy(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	if (sunxi_hci->usb_host_hsic_rdy_valid) {
+		/* set config, output */
+		gpio_direction_output(sunxi_hci->usb_host_hsic_rdy.gpio, is_on);
+	}
+}
+EXPORT_SYMBOL(sunxi_set_host_hisc_rdy);
+
+void sunxi_set_host_vbus(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int ret;
+
+	if (sunxi_hci->supply) {
+		if (is_on) {
+			ret = regulator_enable(sunxi_hci->supply);
+			if (ret)
+				DMSG_PANIC("ERR: %s regulator enable failed\n",
+					sunxi_hci->hci_name);
+		} else {
+			ret = regulator_disable(sunxi_hci->supply);
+			if (ret)
+				DMSG_PANIC("ERR: %s regulator force disable failed\n",
+					sunxi_hci->hci_name);
+		}
+	}
+}
+EXPORT_SYMBOL(sunxi_set_host_vbus);
+
+static void __sunxi_set_vbus(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	int ret;
+
+	/* set power flag */
+	sunxi_hci->power_flag = is_on;
+
+	if (sunxi_hci->hsic_flag) {
+		if ((sunxi_hci->hsic_regulator_io != NULL) &&
+				(sunxi_hci->hsic_regulator_io_hdle != NULL)) {
+			if (is_on) {
+				if (regulator_enable(sunxi_hci->hsic_regulator_io_hdle) < 0)
+					DMSG_INFO("%s: hsic_regulator_enable fail\n",
+						sunxi_hci->hci_name);
+			} else {
+				if (regulator_disable(sunxi_hci->hsic_regulator_io_hdle) < 0)
+					DMSG_INFO("%s: hsic_regulator_disable fail\n",
+						sunxi_hci->hci_name);
+			}
+		}
+	}
+
+/**
+ * No care of usb0 vbus when otg connect pc
+ * setup system without battery and to return.
+ */
+#ifdef CONFIG_USB_SUNXI_USB_MANAGER
+#if !defined(CONFIG_ARCH_SUN8IW6)
+	if (sunxi_hci->usbc_no == HCI0_USBC_NO) {
+		if (is_on) {
+			if (usb_otg_id_status() == 1)
+				return;
+		}
+	}
+#endif
+#endif
+
+	if (sunxi_hci->supply) {
+		if (is_on) {
+			ret = regulator_enable(sunxi_hci->supply);
+			if (ret)
+				DMSG_PANIC("ERR: %s regulator enable failed\n",
+					sunxi_hci->hci_name);
+		} else {
+			ret = regulator_disable(sunxi_hci->supply);
+			if (ret)
+				DMSG_PANIC("ERR: %s regulator force disable failed\n",
+					sunxi_hci->hci_name);
+		}
+	}
+
+	if (sunxi_hci->hci_regulator) {
+		if (!is_on) {
+			ret = regulator_disable(sunxi_hci->hci_regulator);
+			if (ret)
+				DMSG_PANIC("ERR: %s hci regulator force disable failed\n",
+					sunxi_hci->hci_name);
+		}
+	}
+}
+
+static void sunxi_set_vbus(struct sunxi_hci_hcd *sunxi_hci, int is_on)
+{
+	mutex_lock(&usb_vbus_lock);
+
+	if (sunxi_hci->usbc_no == HCI0_USBC_NO) {
+		if (is_on)
+			__sunxi_set_vbus(sunxi_hci, is_on);  /* power on */
+		else if (!is_on)
+			__sunxi_set_vbus(sunxi_hci, is_on);  /* power off */
+	} else if (sunxi_hci->usbc_no == HCI1_USBC_NO) {
+		if (is_on)
+			__sunxi_set_vbus(sunxi_hci, is_on);  /* power on */
+		else if (!is_on)
+			__sunxi_set_vbus(sunxi_hci, is_on);  /* power off */
+	} else if (sunxi_hci->usbc_no == HCI2_USBC_NO) {
+		if (is_on)
+			__sunxi_set_vbus(sunxi_hci, is_on);  /* power on */
+		else if (!is_on)
+			__sunxi_set_vbus(sunxi_hci, is_on);  /* power off */
+	} else if (sunxi_hci->usbc_no == HCI3_USBC_NO) {
+		if (is_on)
+			__sunxi_set_vbus(sunxi_hci, is_on);  /* power on */
+		else if (!is_on)
+			__sunxi_set_vbus(sunxi_hci, is_on);  /* power off */
+	} else {
+		DMSG_INFO("[%s]: sunxi_set_vbus no: %d\n",
+			sunxi_hci->hci_name, sunxi_hci->usbc_no);
+	}
+
+	mutex_unlock(&usb_vbus_lock);
+}
+
+static int sunxi_get_hci_base(struct platform_device *pdev,
+		struct sunxi_hci_hcd *sunxi_hci)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int ret = 0;
+
+	sunxi_hci->usb_vbase  = of_iomap(np, 0);
+	if (sunxi_hci->usb_vbase == NULL) {
+		dev_err(&pdev->dev, "%s, can't get vbase resource\n",
+			sunxi_hci->hci_name);
+		return -EINVAL;
+	}
+
+	if (strstr(sunxi_hci->hci_name, "ohci"))
+		sunxi_hci->usb_vbase  -= SUNXI_USB_OHCI_BASE_OFFSET;
+
+	sunxi_hci->otg_vbase  = of_iomap(np, 2);
+	if (sunxi_hci->otg_vbase == NULL) {
+		dev_err(&pdev->dev, "%s, can't get otg_vbase resource\n",
+			sunxi_hci->hci_name);
+		return -EINVAL;
+	}
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+	sunxi_hci->prcm = of_iomap(np, 3);
+	if (sunxi_hci->prcm == NULL) {
+		dev_err(&pdev->dev, "%s, can't get prcm resource\n",
+			sunxi_hci->hci_name);
+		return -EINVAL;
+	}
+
+	if (sunxi_hci->usbc_no == HCI0_USBC_NO) {
+		sunxi_hci->usb_ccmu_config = of_iomap(np, 4);
+		if (sunxi_hci->usb_ccmu_config == NULL) {
+			dev_err(&pdev->dev, "%s, can't get ccmu resource\n",
+				sunxi_hci->hci_name);
+			return -EINVAL;
+		}
+
+		sunxi_hci->usb_common_phy_config = of_iomap(np, 5);
+		if (sunxi_hci->usb_common_phy_config == NULL) {
+			dev_err(&pdev->dev, "%s, can't get common phy resource\n",
+				sunxi_hci->hci_name);
+			return -EINVAL;
+		}
+	}
+#endif
+
+	sunxi_hci->usb_base_res = kzalloc(sizeof(struct resource), GFP_KERNEL);
+	if (sunxi_hci->usb_base_res == NULL) {
+		dev_err(&pdev->dev, "%s, can't alloc mem\n",
+			sunxi_hci->hci_name);
+		return -ENOMEM;
+	}
+
+	ret = of_address_to_resource(np, 0, sunxi_hci->usb_base_res);
+	if (ret)
+		dev_err(&pdev->dev, "could not get regs\n");
+
+	return 0;
+}
+
+static int sunxi_get_hci_clock(struct platform_device *pdev,
+		struct sunxi_hci_hcd *sunxi_hci)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	if (strstr(sunxi_hci->hci_name, "ehci")) {
+		if (sunxi_hci->usbc_no == HCI0_USBC_NO) {
+			sunxi_hci->reset_phy = devm_reset_control_get_shared(&pdev->dev, "phy");
+			if (IS_ERR(sunxi_hci->reset_phy))
+				dev_warn(&pdev->dev, "Could not get phy rst share\n");
+		} else {
+			sunxi_hci->reset_phy = devm_reset_control_get_optional_shared(&pdev->dev, "phy");
+			if (IS_ERR(sunxi_hci->reset_phy))
+				dev_warn(&pdev->dev, "Could not get phy rst\n");
+		}
+	}
+
+	if (strstr(sunxi_hci->hci_name, "ohci")) {
+		sunxi_hci->clk_ohci = devm_clk_get(&pdev->dev, "ohci");
+		if (IS_ERR(sunxi_hci->clk_ohci)) {
+			dev_err(&pdev->dev, "Could not get ohci clock\n");
+			return PTR_ERR(sunxi_hci->clk_ohci);
+		}
+
+		sunxi_hci->reset_phy = devm_reset_control_get_shared(&pdev->dev, "phy");
+		if (IS_ERR(sunxi_hci->reset_phy))
+			dev_warn(&pdev->dev, "Could not get phy rst share\n");
+	}
+
+	sunxi_hci->clk_bus_hci = devm_clk_get(&pdev->dev, "bus_hci");
+	if (IS_ERR(sunxi_hci->clk_bus_hci)) {
+		dev_err(&pdev->dev, "Could not get bus_hci clock\n");
+		return PTR_ERR(sunxi_hci->clk_bus_hci);
+	}
+
+#if !defined(CONFIG_ARCH_SUN8IW20) && !defined(CONFIG_ARCH_SUN20IW1) && !defined(CONFIG_ARCH_SUN50IW12)
+	sunxi_hci->clk_phy = devm_clk_get(&pdev->dev, "phy");
+	if (IS_ERR(sunxi_hci->clk_phy)) {
+		dev_err(&pdev->dev, "Could not get phy clock\n");
+		return PTR_ERR(sunxi_hci->clk_phy);
+	}
+#endif
+	sunxi_hci->reset_hci = devm_reset_control_get(&pdev->dev, "hci");
+	if (IS_ERR(sunxi_hci->reset_hci))
+		dev_warn(&pdev->dev, "Could not get hci rst\n");
+
+
+	if (sunxi_hci->hsic_flag) {
+		printk("%s()%d yhs\n", __func__, __LINE__);
+		sunxi_hci->hsic_usbphy = of_clk_get(np, 2);
+		if (IS_ERR(sunxi_hci->hsic_usbphy)) {
+			sunxi_hci->hsic_usbphy = NULL;
+			DMSG_PANIC("ERR: %s get usb hsic_usbphy failed.\n",
+				sunxi_hci->hci_name);
+		}
+
+		sunxi_hci->clk_usbhsic12m = of_clk_get(np, 3);
+		if (IS_ERR(sunxi_hci->clk_usbhsic12m)) {
+			sunxi_hci->clk_usbhsic12m = NULL;
+			DMSG_PANIC("ERR: %s get usb clk_usbhsic12m failed.\n",
+				sunxi_hci->hci_name);
+		}
+
+		sunxi_hci->pll_hsic = of_clk_get(np, 4);
+		if (IS_ERR(sunxi_hci->pll_hsic)) {
+			sunxi_hci->pll_hsic = NULL;
+			DMSG_PANIC("ERR: %s get usb pll_hsic failed.\n",
+				sunxi_hci->hci_name);
+		}
+	}
+
+	return 0;
+}
+
+static int get_usb_cfg(struct platform_device *pdev,
+		struct sunxi_hci_hcd *sunxi_hci)
+{
+	struct device_node *usbc_np = NULL;
+	char np_name[10];
+	int ret = -1;
+
+	sprintf(np_name, "usbc%d", sunxi_get_hci_num(pdev));
+	usbc_np = of_find_node_by_type(NULL, np_name);
+
+	/* usbc enable */
+	ret = of_property_read_string(usbc_np,
+			"status", &sunxi_hci->used_status);
+	if (ret) {
+		DMSG_PRINT("get %s used is fail, %d\n",
+			sunxi_hci->hci_name, -ret);
+		sunxi_hci->used = 0;
+	} else if (!strcmp(sunxi_hci->used_status, "okay")) {
+		sunxi_hci->used = 1;
+	} else {
+		 sunxi_hci->used = 0;
+	}
+
+	/* usbc port type */
+	if (sunxi_hci->usbc_no == HCI0_USBC_NO) {
+		ret = of_property_read_u32(usbc_np,
+						KEY_USB_PORT_TYPE,
+						&sunxi_hci->port_type);
+		if (ret)
+			DMSG_INFO("get usb_port_type is fail, %d\n", -ret);
+	}
+
+	sunxi_hci->hsic_flag = 0;
+
+	if (sunxi_hci->usbc_no == HCI1_USBC_NO) {
+		ret = of_property_read_u32(usbc_np,
+				KEY_USB_HSIC_USBED, &sunxi_hci->hsic_flag);
+		if (ret)
+			sunxi_hci->hsic_flag = 0;
+
+		if (sunxi_hci->hsic_flag) {
+			if (!strncmp(sunxi_hci->hci_name,
+					"ohci", strlen("ohci"))) {
+				DMSG_PRINT("HSIC is no susport in %s, and to return\n",
+					sunxi_hci->hci_name);
+				sunxi_hci->used = 0;
+				return 0;
+			}
+
+			/* hsic regulator_io */
+			ret = of_property_read_string(usbc_np,
+					KEY_USB_HSIC_REGULATOR_IO,
+					&sunxi_hci->hsic_regulator_io);
+			if (ret) {
+				DMSG_PRINT("get %s, hsic_regulator_io is fail, %d\n",
+					sunxi_hci->hci_name, -ret);
+				sunxi_hci->hsic_regulator_io = NULL;
+			} else {
+				if (!strcmp(sunxi_hci->hsic_regulator_io, "nocare")) {
+					DMSG_PRINT("get %s, hsic_regulator_io is no nocare\n",
+						sunxi_hci->hci_name);
+					sunxi_hci->hsic_regulator_io = NULL;
+				}
+			}
+
+			/* Marvell 4G HSIC ctrl */
+			ret = of_property_read_u32(usbc_np,
+					KEY_USB_HSIC_CTRL,
+					&sunxi_hci->hsic_ctrl_flag);
+			if (ret) {
+				DMSG_PRINT("get %s usb_hsic_ctrl is fail, %d\n",
+					sunxi_hci->hci_name, -ret);
+				sunxi_hci->hsic_ctrl_flag = 0;
+			}
+			if (sunxi_hci->hsic_ctrl_flag) {
+				sunxi_hci->usb_host_hsic_rdy.gpio =
+						of_get_named_gpio(usbc_np,
+							KEY_USB_HSIC_RDY_GPIO, 0);
+				if (gpio_is_valid(sunxi_hci->usb_host_hsic_rdy.gpio)) {
+					sunxi_hci->usb_host_hsic_rdy_valid = 1;
+				} else {
+					sunxi_hci->usb_host_hsic_rdy_valid = 0;
+					DMSG_PRINT("get %s drv_vbus_gpio is fail\n",
+						sunxi_hci->hci_name);
+				}
+			} else {
+				sunxi_hci->usb_host_hsic_rdy_valid = 0;
+			}
+
+			/* SMSC usb3503 HSIC HUB ctrl */
+			ret = of_property_read_u32(usbc_np,
+					"usb_hsic_usb3503_flag",
+					&sunxi_hci->usb_hsic_usb3503_flag);
+			if (ret) {
+				DMSG_PRINT("get %s usb_hsic_usb3503_flag is fail, %d\n",
+					sunxi_hci->hci_name, -ret);
+				sunxi_hci->usb_hsic_usb3503_flag = 0;
+			}
+
+
+			if (sunxi_hci->usb_hsic_usb3503_flag) {
+				sunxi_hci->usb_hsic_hub_connect.gpio =
+						of_get_named_gpio(usbc_np,
+							"usb_hsic_hub_connect_gpio", 0);
+				if (gpio_is_valid(sunxi_hci->usb_hsic_hub_connect.gpio)) {
+					sunxi_hci->usb_hsic_hub_connect_valid = 1;
+				} else {
+					sunxi_hci->usb_hsic_hub_connect_valid = 0;
+					DMSG_PRINT("get %s usb_hsic_hub_connect is fail\n",
+						sunxi_hci->hci_name);
+				}
+
+
+				sunxi_hci->usb_hsic_int_n.gpio =
+						of_get_named_gpio(usbc_np,
+							"usb_hsic_int_n_gpio", 0);
+				if (gpio_is_valid(sunxi_hci->usb_hsic_int_n.gpio)) {
+					sunxi_hci->usb_hsic_int_n_valid = 1;
+				} else {
+					sunxi_hci->usb_hsic_int_n_valid = 0;
+					DMSG_PRINT("get %s usb_hsic_int_n is fail\n",
+						sunxi_hci->hci_name);
+				}
+
+
+				sunxi_hci->usb_hsic_reset_n.gpio =
+						of_get_named_gpio(usbc_np,
+							"usb_hsic_reset_n_gpio", 0);
+				if (gpio_is_valid(sunxi_hci->usb_hsic_reset_n.gpio)) {
+					sunxi_hci->usb_hsic_reset_n_valid = 1;
+				} else {
+					sunxi_hci->usb_hsic_reset_n_valid = 0;
+					DMSG_PRINT("get %s usb_hsic_reset_n is fail\n",
+						sunxi_hci->hci_name);
+				}
+
+			} else {
+				sunxi_hci->usb_hsic_hub_connect_valid = 0;
+				sunxi_hci->usb_hsic_int_n_valid = 0;
+				sunxi_hci->usb_hsic_reset_n_valid = 0;
+			}
+
+		} else {
+			sunxi_hci->hsic_ctrl_flag = 0;
+			sunxi_hci->usb_host_hsic_rdy_valid = 0;
+			sunxi_hci->usb_hsic_hub_connect_valid = 0;
+			sunxi_hci->usb_hsic_int_n_valid = 0;
+			sunxi_hci->usb_hsic_reset_n_valid = 0;
+		}
+	}
+
+	/* usbc wakeup_suspend */
+	ret = of_property_read_u32(usbc_np,
+			KEY_USB_WAKEUP_SUSPEND,
+			&sunxi_hci->wakeup_suspend);
+	if (ret) {
+		DMSG_PRINT("get %s wakeup_suspend is fail, %d\n",
+			sunxi_hci->hci_name, -ret);
+	}
+
+	/* wakeup-source */
+	if (of_property_read_bool(usbc_np, KEY_WAKEUP_SOURCE)) {
+		sunxi_hci->wakeup_source_flag = 1;
+	} else {
+		DMSG_PRINT("get %s wakeup-source is fail.\n",
+				sunxi_hci->hci_name);
+		sunxi_hci->wakeup_source_flag = 0;
+	}
+
+	return 0;
+}
+
+int sunxi_get_hci_num(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int ret = 0;
+	int hci_num = 0;
+
+	ret = of_property_read_u32(np, HCI_USBC_NO, &hci_num);
+	if (ret)
+		DMSG_PANIC("get hci_ctrl_num is fail, %d\n", -ret);
+
+	return hci_num;
+}
+
+static int sunxi_get_hci_name(struct platform_device *pdev,
+		struct sunxi_hci_hcd *sunxi_hci)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	sprintf(sunxi_hci->hci_name, "%s", np->name);
+
+	return 0;
+}
+
+static int sunxi_get_hci_irq_no(struct platform_device *pdev,
+		struct sunxi_hci_hcd *sunxi_hci)
+{
+	sunxi_hci->irq_no = platform_get_irq(pdev, 0);
+
+	return 0;
+}
+
+static int hci_wakeup_source_init(struct platform_device *pdev,
+		struct sunxi_hci_hcd *sunxi_hci)
+{
+	if (sunxi_hci->wakeup_source_flag) {
+		device_init_wakeup(&pdev->dev, true);
+		dev_pm_set_wake_irq(&pdev->dev, sunxi_hci->irq_no);
+	} else {
+		DMSG_INFO("sunxi %s don't init wakeup source\n", sunxi_hci->hci_name);
+	}
+
+	return 0;
+}
+void enter_usb_standby(struct sunxi_hci_hcd *sunxi_hci)
+{
+	mutex_lock(&usb_standby_lock);
+	if (!atomic_read(&usb_standby_cnt)) {
+		atomic_add(1, &usb_standby_cnt);
+	} else {
+		/*phy after ehci and ohci suspend.*/
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+		if (sunxi_hci->usbc_no == HCI0_USBC_NO) {
+			/*usb1 0x800 bit[2], enable rc16M*/
+			sunxi_hci_common_set_rc_clk(sunxi_hci, 1);
+			/*usb1 0x800 bit[31], switch 16M*/
+			sunxi_hci_common_switch_clk(sunxi_hci, 1);
+			/*usb1 0x800 bit[3], open 16M gating*/
+			sunxi_hci_common_set_rcgating(sunxi_hci, 1);
+		}
+#endif
+#if IS_ENABLED(SUNXI_USB_STANDBY_LOW_POW_MODE)
+#if IS_ENABLED(SUNXI_USB_STANDBY_NEW_MODE)
+		/*phy reg, offset:0x800 bit2, set 1, enable RC16M CLK*/
+		sunxi_hci_set_rc_clk(sunxi_hci, 1);
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW9)
+		/*enable standby irq*/
+		sunxi_hci_set_standby_irq(sunxi_hci, 1);
+#endif
+		/*phy reg, offset:0x808 bit3, set 1, remote enable*/
+		sunxi_hci_set_wakeup_ctrl(sunxi_hci, 1);
+		/*phy reg, offset:0x810 bit3 set 1, clean siddq*/
+		sunxi_hci_set_siddq(sunxi_hci, 1);
+#endif
+#endif
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+		/*phy reg, offset:0x0 bit31, set 1*/
+		sunxi_hci_switch_clk(sunxi_hci, 1);
+		/*phy reg, offset:0x0 bit3, set 1*/
+		sunxi_hci_set_rcgating(sunxi_hci, 1);
+#endif
+		atomic_sub(1, &usb_standby_cnt);
+
+	}
+	mutex_unlock(&usb_standby_lock);
+}
+EXPORT_SYMBOL(enter_usb_standby);
+
+void exit_usb_standby(struct sunxi_hci_hcd *sunxi_hci)
+{
+	mutex_lock(&usb_standby_lock);
+	if (atomic_read(&usb_standby_cnt)) {
+		atomic_sub(1, &usb_standby_cnt);
+	} else {
+		/*phy before ehci and ohci*/
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+		if (sunxi_hci->usbc_no == HCI0_USBC_NO) {
+			/*usb1 0x800 bit[3]*/
+			sunxi_hci_common_set_rcgating(sunxi_hci, 0);
+			/*usb1 0x800 bit[31]*/
+			sunxi_hci_common_switch_clk(sunxi_hci, 0);
+			/*usb1 0x800 bit[2]*/
+			sunxi_hci_common_set_rc_clk(sunxi_hci, 0);
+		}
+		/*phy reg, offset:0x0 bit3, set 0*/
+		sunxi_hci_set_rcgating(sunxi_hci, 0);
+		/*phy reg, offset:0x0 bit31, set 0*/
+		sunxi_hci_switch_clk(sunxi_hci, 0);
+#endif
+#if IS_ENABLED(SUNXI_USB_STANDBY_LOW_POW_MODE)
+		/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+		sunxi_hci_set_siddq(sunxi_hci, 0);
+		/*phy reg, offset:0x08 bit3, set 0, remote disable*/
+		sunxi_hci_set_wakeup_ctrl(sunxi_hci, 0);
+#if IS_ENABLED(SUNXI_USB_STANDBY_NEW_MODE)
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW9)
+		/*clear standby irq status*/
+		sunxi_hci_clean_standby_irq(sunxi_hci);
+		/*disable standby irq */
+		sunxi_hci_set_standby_irq(sunxi_hci, 0);
+#endif
+#endif
+		/*phy reg, offset:0x0 bit2, set 0, disable rc clk*/
+		sunxi_hci_set_rc_clk(sunxi_hci, 0);
+#endif
+		atomic_add(1, &usb_standby_cnt);
+	}
+	mutex_unlock(&usb_standby_lock);
+}
+EXPORT_SYMBOL(exit_usb_standby);
+
+static int sunxi_get_hci_resource(struct platform_device *pdev,
+		struct sunxi_hci_hcd *sunxi_hci, int usbc_no)
+{
+	if (sunxi_hci == NULL) {
+		dev_err(&pdev->dev, "sunxi_hci is NULL\n");
+		return -1;
+	}
+
+	memset(sunxi_hci, 0, sizeof(struct sunxi_hci_hcd));
+
+	sunxi_hci->usbc_no = usbc_no;
+	sunxi_get_hci_name(pdev, sunxi_hci);
+	get_usb_cfg(pdev, sunxi_hci);
+
+	if (sunxi_hci->used == 0) {
+		DMSG_INFO("sunxi %s is no enable\n", sunxi_hci->hci_name);
+		return -1;
+	}
+
+	sunxi_get_hci_base(pdev, sunxi_hci);
+	sunxi_get_hci_clock(pdev, sunxi_hci);
+	sunxi_get_hci_irq_no(pdev, sunxi_hci);
+	hci_wakeup_source_init(pdev, sunxi_hci);
+
+	request_usb_regulator_io(sunxi_hci);
+	sunxi_hci->open_clock	= open_clock;
+	sunxi_hci->close_clock	= close_clock;
+	sunxi_hci->set_power	= sunxi_set_vbus;
+	sunxi_hci->usb_passby	= usb_passby;
+
+	alloc_pin(sunxi_hci);
+
+	pdev->dev.platform_data = sunxi_hci;
+	return 0;
+}
+
+static int sunxi_hci_dump_reg_all(int usbc_type)
+{
+	struct sunxi_hci_hcd *sunxi_hci, *sunxi_ehci, *sunxi_ohci;
+	struct resource res, res1;
+	int i;
+
+	switch (usbc_type) {
+	case SUNXI_USB_EHCI:
+		for (i = 0; i < 4; i++) {
+			switch (i) {
+			case HCI0_USBC_NO:
+				sunxi_hci = &sunxi_ehci0;
+				break;
+			case HCI1_USBC_NO:
+				sunxi_hci = &sunxi_ehci1;
+				break;
+			case HCI2_USBC_NO:
+				sunxi_hci = &sunxi_ehci2;
+				break;
+			case HCI3_USBC_NO:
+				sunxi_hci = &sunxi_ehci3;
+				break;
+			}
+
+			if (sunxi_hci->used) {
+				of_address_to_resource(sunxi_hci->pdev->dev.of_node, 0, &res);
+				DMSG_INFO("usbc%d, ehci, base[0x%08x]:\n",
+					  i, (unsigned int)res.start);
+				print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+					       sunxi_hci->ehci_base, 0x58, false);
+				DMSG_INFO("\n");
+			}
+		}
+
+		return 0;
+
+	case SUNXI_USB_OHCI:
+		for (i = 0; i < 4; i++) {
+			switch (i) {
+			case HCI0_USBC_NO:
+				sunxi_hci = &sunxi_ohci0;
+				break;
+			case HCI1_USBC_NO:
+				sunxi_hci = &sunxi_ohci1;
+				break;
+			case HCI2_USBC_NO:
+				sunxi_hci = &sunxi_ohci2;
+				break;
+			case HCI3_USBC_NO:
+				sunxi_hci = &sunxi_ohci3;
+				break;
+			}
+
+			if (sunxi_hci->used) {
+				of_address_to_resource(sunxi_hci->pdev->dev.of_node, 0, &res);
+				DMSG_INFO("usbc%d, ohci, base[0x%08x]:\n",
+					  i, (unsigned int)(res.start));
+				print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+					       sunxi_hci->ohci_base, 0x58, false);
+				DMSG_INFO("\n");
+			}
+		}
+
+		return 0;
+
+	case SUNXI_USB_PHY:
+		for (i = 0; i < 4; i++) {
+			switch (i) {
+			case HCI0_USBC_NO:
+				sunxi_hci = &sunxi_ehci0;
+				break;
+			case HCI1_USBC_NO:
+				sunxi_hci = &sunxi_ehci1;
+				break;
+			case HCI2_USBC_NO:
+				sunxi_hci = &sunxi_ehci2;
+				break;
+			case HCI3_USBC_NO:
+				sunxi_hci = &sunxi_ehci3;
+				break;
+			}
+
+			if (sunxi_hci->used) {
+				of_address_to_resource(sunxi_hci->pdev->dev.of_node, 0, &res);
+				DMSG_INFO("usbc%d, phy, base[0x%08x]:\n",
+					  i, (unsigned int)(res.start + SUNXI_USB_PMU_IRQ_ENABLE));
+				print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+					       sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE, 0x34, false);
+				DMSG_INFO("\n");
+			}
+		}
+
+		return 0;
+
+	case SUNXI_USB_ALL:
+		for (i = 0; i < 4; i++) {
+			switch (i) {
+			case HCI0_USBC_NO:
+				sunxi_ehci = &sunxi_ehci0;
+				sunxi_ohci = &sunxi_ohci0;
+				break;
+			case HCI1_USBC_NO:
+				sunxi_ehci = &sunxi_ehci1;
+				sunxi_ohci = &sunxi_ohci1;
+				break;
+			case HCI2_USBC_NO:
+				sunxi_ehci = &sunxi_ehci2;
+				sunxi_ohci = &sunxi_ohci2;
+				break;
+			case HCI3_USBC_NO:
+				sunxi_ehci = &sunxi_ehci3;
+				sunxi_ohci = &sunxi_ohci3;
+				break;
+			}
+
+			if (sunxi_ehci->used) {
+				of_address_to_resource(sunxi_ehci->pdev->dev.of_node, 0, &res);
+				of_address_to_resource(sunxi_ohci->pdev->dev.of_node, 0, &res1);
+				DMSG_INFO("usbc%d, ehci, base[0x%08x]:\n",
+					  i, (unsigned int)res.start);
+				print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+					       sunxi_ehci->ehci_base, 0x58, false);
+				DMSG_INFO("usbc%d, ohci, base[0x%08x]:\n",
+					  i, (unsigned int)(res1.start));
+				print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+					       sunxi_ohci->ohci_base, 0x58, false);
+				DMSG_INFO("usbc%d, phy, base[0x%08x]:\n",
+					  i, (unsigned int)(res.start + SUNXI_USB_PMU_IRQ_ENABLE));
+				print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+					       sunxi_ehci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE, 0x34, false);
+				DMSG_INFO("\n");
+			}
+		}
+
+		return 0;
+
+	default:
+		DMSG_PANIC("%s()%d invalid argument\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+}
+
+static int sunxi_hci_dump_reg(int usbc_no, int usbc_type)
+{
+	struct sunxi_hci_hcd *sunxi_hci, *sunxi_ehci, *sunxi_ohci;
+	struct resource res, res1;
+
+	switch (usbc_type) {
+	case SUNXI_USB_EHCI:
+		switch (usbc_no) {
+		case HCI0_USBC_NO:
+			sunxi_hci = &sunxi_ehci0;
+			break;
+		case HCI1_USBC_NO:
+			sunxi_hci = &sunxi_ehci1;
+			break;
+		case HCI2_USBC_NO:
+			sunxi_hci = &sunxi_ehci2;
+			break;
+		case HCI3_USBC_NO:
+			sunxi_hci = &sunxi_ehci3;
+			break;
+		default:
+			DMSG_PANIC("%s()%d invalid argument\n", __func__, __LINE__);
+			return -EINVAL;
+		}
+
+		if (sunxi_hci->used) {
+			of_address_to_resource(sunxi_hci->pdev->dev.of_node, 0, &res);
+			DMSG_INFO("usbc%d, ehci, base[0x%08x]:\n",
+				  usbc_no, (unsigned int)res.start);
+			print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+				       sunxi_hci->ehci_base, 0x58, false);
+			DMSG_INFO("\n");
+		} else
+			DMSG_PANIC("%s()%d usbc%d is disable\n", __func__, __LINE__, usbc_no);
+
+		return 0;
+
+	case SUNXI_USB_OHCI:
+		switch (usbc_no) {
+		case HCI0_USBC_NO:
+			sunxi_hci = &sunxi_ohci0;
+			break;
+		case HCI1_USBC_NO:
+			sunxi_hci = &sunxi_ohci1;
+			break;
+		case HCI2_USBC_NO:
+			sunxi_hci = &sunxi_ohci2;
+			break;
+		case HCI3_USBC_NO:
+			sunxi_hci = &sunxi_ohci3;
+			break;
+		default:
+			DMSG_PANIC("%s()%d invalid argument\n", __func__, __LINE__);
+			return -EINVAL;
+		}
+
+		if (sunxi_hci->used) {
+			of_address_to_resource(sunxi_hci->pdev->dev.of_node, 0, &res);
+			DMSG_INFO("usbc%d, ohci, base[0x%08x]:\n",
+				  usbc_no, (unsigned int)(res.start));
+			print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+				       sunxi_hci->ohci_base, 0x58, false);
+			DMSG_INFO("\n");
+		} else
+			DMSG_PANIC("%s()%d usbc%d is disable\n", __func__, __LINE__, usbc_no);
+
+		return 0;
+
+	case SUNXI_USB_PHY:
+		switch (usbc_no) {
+		case HCI0_USBC_NO:
+			sunxi_hci = &sunxi_ehci0;
+			break;
+		case HCI1_USBC_NO:
+			sunxi_hci = &sunxi_ehci1;
+			break;
+		case HCI2_USBC_NO:
+			sunxi_hci = &sunxi_ehci2;
+			break;
+		case HCI3_USBC_NO:
+			sunxi_hci = &sunxi_ehci3;
+			break;
+		default:
+			DMSG_PANIC("%s()%d invalid argument\n", __func__, __LINE__);
+			return -EINVAL;
+		}
+
+		if (sunxi_hci->used) {
+			of_address_to_resource(sunxi_hci->pdev->dev.of_node, 0, &res);
+			DMSG_INFO("usbc%d, phy, base[0x%08x]:\n",
+				  usbc_no, (unsigned int)(res.start + SUNXI_USB_PMU_IRQ_ENABLE));
+			print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+				       sunxi_hci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE, 0x34, false);
+			DMSG_INFO("\n");
+		} else
+			DMSG_PANIC("%s()%d usbc%d is disable\n", __func__, __LINE__, usbc_no);
+
+		return 0;
+
+	case SUNXI_USB_ALL:
+		switch (usbc_no) {
+		case HCI0_USBC_NO:
+			sunxi_ehci = &sunxi_ehci0;
+			sunxi_ohci = &sunxi_ohci0;
+			break;
+		case HCI1_USBC_NO:
+			sunxi_ehci = &sunxi_ehci1;
+			sunxi_ohci = &sunxi_ohci1;
+			break;
+		case HCI2_USBC_NO:
+			sunxi_ehci = &sunxi_ehci2;
+			sunxi_ohci = &sunxi_ohci2;
+			break;
+		case HCI3_USBC_NO:
+			sunxi_ehci = &sunxi_ehci3;
+			sunxi_ohci = &sunxi_ohci3;
+			break;
+		default:
+			DMSG_PANIC("%s()%d invalid argument\n", __func__, __LINE__);
+			return -EINVAL;
+		}
+
+		if (sunxi_ehci->used) {
+			of_address_to_resource(sunxi_ehci->pdev->dev.of_node, 0, &res);
+			of_address_to_resource(sunxi_ohci->pdev->dev.of_node, 0, &res1);
+			DMSG_INFO("usbc%d, ehci, base[0x%08x]:\n",
+				  usbc_no, (unsigned int)res.start);
+			print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+				       sunxi_ehci->ehci_base, 0x58, false);
+			DMSG_INFO("usbc%d, ohci, base[0x%08x]:\n",
+				  usbc_no, (unsigned int)(res1.start));
+			print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+				       sunxi_ohci->ohci_base, 0x58, false);
+			DMSG_INFO("usbc%d, phy, base[0x%08x]:\n",
+				  usbc_no, (unsigned int)(res.start + SUNXI_USB_PMU_IRQ_ENABLE));
+			print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+				       sunxi_ehci->usb_vbase + SUNXI_USB_PMU_IRQ_ENABLE, 0x34, false);
+			DMSG_INFO("\n");
+		} else
+			DMSG_PANIC("%s()%d usbc%d is disable\n", __func__, __LINE__, usbc_no);
+
+		return 0;
+
+	default:
+		DMSG_PANIC("%s()%d invalid argument\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+}
+
+int sunxi_hci_standby_completion(int usbc_type)
+{
+	if (sunxi_ehci0.used) {
+		if (usbc_type == SUNXI_USB_EHCI) {
+			complete(&sunxi_ehci0.standby_complete);
+		} else if (usbc_type == SUNXI_USB_OHCI) {
+			complete(&sunxi_ohci0.standby_complete);
+		} else {
+			pr_err("%s()%d err usb type\n", __func__, __LINE__);
+			return -1;
+		}
+	}
+
+	if (sunxi_ehci1.used) {
+		if (usbc_type == SUNXI_USB_EHCI) {
+			complete(&sunxi_ehci1.standby_complete);
+		} else if (usbc_type == SUNXI_USB_OHCI) {
+			complete(&sunxi_ohci1.standby_complete);
+		} else {
+			pr_err("%s()%d err usb type\n", __func__, __LINE__);
+			return -1;
+		}
+	}
+
+	if (sunxi_ehci2.used) {
+		if (usbc_type == SUNXI_USB_EHCI) {
+			complete(&sunxi_ehci2.standby_complete);
+		} else if (usbc_type == SUNXI_USB_OHCI) {
+			complete(&sunxi_ohci2.standby_complete);
+		} else {
+			pr_err("%s()%d err usb type\n", __func__, __LINE__);
+			return -1;
+		}
+	}
+
+	if (sunxi_ehci3.used) {
+		if (usbc_type == SUNXI_USB_EHCI) {
+			complete(&sunxi_ehci3.standby_complete);
+		} else if (usbc_type == SUNXI_USB_OHCI) {
+			complete(&sunxi_ohci3.standby_complete);
+		} else {
+			pr_err("%s()%d err usb type\n", __func__, __LINE__);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_hci_standby_completion);
+
+int exit_sunxi_hci(struct sunxi_hci_hcd *sunxi_hci)
+{
+	release_usb_regulator_io(sunxi_hci);
+	free_pin(sunxi_hci);
+	if (sunxi_hci->usb_base_res)
+		kfree(sunxi_hci->usb_base_res);
+	return 0;
+}
+EXPORT_SYMBOL(exit_sunxi_hci);
+
+int init_sunxi_hci(struct platform_device *pdev, int usbc_type)
+{
+	struct sunxi_hci_hcd *sunxi_hci = NULL;
+	int usbc_no = 0;
+	int hci_num = -1;
+	int ret = -1;
+
+#if IS_ENABLED(CONFIG_OF)
+	pdev->dev.dma_mask = &sunxi_hci_dmamask;
+	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(64);
+#endif
+
+	hci_num = sunxi_get_hci_num(pdev);
+
+	if (usbc_type == SUNXI_USB_XHCI) {
+		usbc_no = hci_num;
+		sunxi_hci = &sunxi_xhci;
+	} else {
+		switch (hci_num) {
+		case HCI0_USBC_NO:
+			usbc_no = HCI0_USBC_NO;
+			if (usbc_type == SUNXI_USB_EHCI) {
+				sunxi_hci = &sunxi_ehci0;
+			} else if (usbc_type == SUNXI_USB_OHCI) {
+				sunxi_hci = &sunxi_ohci0;
+			} else {
+				dev_err(&pdev->dev, "get hci num fail: %d\n", hci_num);
+				return -1;
+			}
+			break;
+
+		case HCI1_USBC_NO:
+			usbc_no = HCI1_USBC_NO;
+			if (usbc_type == SUNXI_USB_EHCI) {
+				sunxi_hci = &sunxi_ehci1;
+			} else if (usbc_type == SUNXI_USB_OHCI) {
+				sunxi_hci = &sunxi_ohci1;
+			} else {
+				dev_err(&pdev->dev, "get hci num fail: %d\n", hci_num);
+				return -1;
+			}
+			break;
+
+		case HCI2_USBC_NO:
+			usbc_no = HCI2_USBC_NO;
+			if (usbc_type == SUNXI_USB_EHCI) {
+				sunxi_hci = &sunxi_ehci2;
+			} else if (usbc_type == SUNXI_USB_OHCI) {
+				sunxi_hci = &sunxi_ohci2;
+			} else {
+				dev_err(&pdev->dev, "get hci num fail: %d\n", hci_num);
+				return -1;
+			}
+			break;
+
+		case HCI3_USBC_NO:
+			usbc_no = HCI3_USBC_NO;
+			if (usbc_type == SUNXI_USB_EHCI) {
+				sunxi_hci = &sunxi_ehci3;
+			} else if (usbc_type == SUNXI_USB_OHCI) {
+				sunxi_hci = &sunxi_ohci3;
+			} else {
+				dev_err(&pdev->dev, "get hci num fail: %d\n", hci_num);
+				return -1;
+			}
+			break;
+
+		default:
+			dev_err(&pdev->dev, "get hci num fail: %d\n", hci_num);
+			return -1;
+		}
+	}
+
+	ret = sunxi_get_hci_resource(pdev, sunxi_hci, usbc_no);
+	if (ret != 0)
+		return ret;
+
+	return ret;
+}
+EXPORT_SYMBOL(init_sunxi_hci);
+
+static int __parse_hci_str(const char *buf, size_t size)
+{
+	int ret = 0;
+	unsigned long val;
+
+	if (!buf) {
+		pr_err("%s()%d invalid argument\n", __func__, __LINE__);
+		return -1;
+	}
+
+	ret = kstrtoul(buf, 10, &val);
+	if (ret) {
+		pr_err("%s()%d failed to transfer\n", __func__, __LINE__);
+		return -1;
+	}
+
+	return val;
+}
+
+static ssize_t
+ehci_reg_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	sunxi_hci_dump_reg_all(SUNXI_USB_EHCI);
+
+	return 0;
+}
+
+static ssize_t
+ehci_reg_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	int usbc_no;
+
+	usbc_no = __parse_hci_str(buf, count);
+	if (usbc_no < 0)
+		return -EINVAL;
+
+	sunxi_hci_dump_reg(usbc_no, SUNXI_USB_EHCI);
+
+	return count;
+}
+static CLASS_ATTR_RW(ehci_reg);
+
+static ssize_t
+ohci_reg_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	sunxi_hci_dump_reg_all(SUNXI_USB_OHCI);
+
+	return 0;
+}
+
+static ssize_t
+ohci_reg_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	int usbc_no;
+
+	usbc_no = __parse_hci_str(buf, count);
+	if (usbc_no < 0)
+		return -EINVAL;
+
+	sunxi_hci_dump_reg(usbc_no, SUNXI_USB_OHCI);
+
+	return count;
+}
+static CLASS_ATTR_RW(ohci_reg);
+
+static ssize_t
+phy_reg_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	sunxi_hci_dump_reg_all(SUNXI_USB_PHY);
+
+	return 0;
+}
+
+static ssize_t
+phy_reg_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	int usbc_no;
+
+	usbc_no = __parse_hci_str(buf, count);
+	if (usbc_no < 0)
+		return -EINVAL;
+
+	sunxi_hci_dump_reg(usbc_no, SUNXI_USB_PHY);
+
+	return count;
+}
+static CLASS_ATTR_RW(phy_reg);
+
+static ssize_t
+all_reg_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	sunxi_hci_dump_reg_all(SUNXI_USB_ALL);
+
+	return 0;
+}
+
+static ssize_t
+all_reg_store(struct class *class, struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	int usbc_no;
+
+
+	usbc_no = __parse_hci_str(buf, count);
+	if (usbc_no < 0)
+		return -EINVAL;
+
+	sunxi_hci_dump_reg(usbc_no, SUNXI_USB_ALL);
+
+	return count;
+}
+static CLASS_ATTR_RW(all_reg);
+
+static struct attribute *hci_class_attrs[] = {
+	&class_attr_ehci_reg.attr,
+	&class_attr_ohci_reg.attr,
+	&class_attr_phy_reg.attr,
+	&class_attr_all_reg.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(hci_class);
+
+static struct class hci_class = {
+	.name		= "hci_reg",
+	.owner		= THIS_MODULE,
+	.class_groups	= hci_class_groups,
+};
+
+static int __init init_sunxi_hci_class(void)
+{
+	int ret = 0;
+
+	ret = class_register(&hci_class);
+	if (ret) {
+		DMSG_PANIC("%s()%d register class fialed\n", __func__, __LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void __exit exit_sunxi_hci_class(void)
+{
+	class_unregister(&hci_class);
+}
+
+late_initcall(init_sunxi_hci_class);
+module_exit(exit_sunxi_hci_class);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" SUNXI_HCI_NAME);
+MODULE_AUTHOR("javen");
+MODULE_VERSION("1.0.10");
diff --git a/drivers/usb/host/sunxi-hci.h b/drivers/usb/host/sunxi-hci.h
new file mode 100644
index 000000000..e3d7a8ef8
--- /dev/null
+++ b/drivers/usb/host/sunxi-hci.h
@@ -0,0 +1,495 @@
+/**
+ * drivers/usb/host/sunxi-hci.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yangnaitian, 2011-5-24, create this file
+ *
+ * Include file for SUNXI HCI Host Controller Driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_HCI_SUNXI_H__
+#define __SUNXI_HCI_SUNXI_H__
+
+#include <linux/delay.h>
+#include <linux/types.h>
+
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/of_gpio.h>
+#include <linux/sunxi-gpio.h>
+
+#include <linux/pm_wakeirq.h>
+#include <linux/regulator/consumer.h>
+
+extern int usb_disabled(void);
+
+#define  DMSG_ERR(format, args...)		pr_err("hci: "format, ##args)
+#define  DMSG_PRINT(format, args...)		pr_warning(format, ##args)
+
+#define HCI_USBC_NO     "hci_ctrl_no"
+
+#if defined(CONFIG_ARCH_SUN8IW6)
+#define HCI0_USBC_NO    1
+#define HCI1_USBC_NO    2
+#define HCI2_USBC_NO    3
+#define HCI3_USBC_NO    4
+#else
+#define HCI0_USBC_NO    0
+#define HCI1_USBC_NO    1
+#define HCI2_USBC_NO    2
+#define HCI3_USBC_NO    3
+#endif
+
+#define STANDBY_TIMEOUT 30000
+
+/*
+ * Support Low-power mode USB standby.
+ */
+#if IS_ENABLED(CONFIG_ARCH_SUN8IW15) || IS_ENABLED(CONFIG_ARCH_SUN50IW9) \
+	|| IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+#define SUNXI_USB_STANDBY_LOW_POW_MODE		1
+#endif
+
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW9) || IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+#define SUNXI_USB_STANDBY_NEW_MODE		1
+#endif
+
+#if 0
+#define DMSG_DEBUG                              DMSG_PRINT
+#else
+#define DMSG_DEBUG(...)
+#endif
+
+#if 1
+#define DMSG_INFO                               DMSG_PRINT
+#else
+#define DMSG_INFO(...)
+#endif
+
+#if 1
+#define DMSG_PANIC                              DMSG_ERR
+#else
+#define DMSG_PANIC(...)
+#endif
+
+#define  USBC_Readb(reg)                        readb(reg)
+#define  USBC_Readw(reg)                        readw(reg)
+#define  USBC_Readl(reg)                        readl(reg)
+
+#define  USBC_Writeb(value, reg)                writeb(value, reg)
+#define  USBC_Writew(value, reg)                writew(value, reg)
+#define  USBC_Writel(value, reg)                writel(value, reg)
+
+#define  USBC_REG_test_bit_b(bp, reg)           (USBC_Readb(reg) & (1 << (bp)))
+#define  USBC_REG_test_bit_w(bp, reg)           (USBC_Readw(reg) & (1 << (bp)))
+#define  USBC_REG_test_bit_l(bp, reg)           (USBC_Readl(reg) & (1 << (bp)))
+
+#define  USBC_REG_set_bit_b(bp, reg)            (USBC_Writeb((USBC_Readb(reg) | (1 << (bp))), (reg)))
+#define  USBC_REG_set_bit_w(bp, reg)            (USBC_Writew((USBC_Readw(reg) | (1 << (bp))), (reg)))
+#define  USBC_REG_set_bit_l(bp, reg)            (USBC_Writel((USBC_Readl(reg) | (1 << (bp))), (reg)))
+
+#define  USBC_REG_clear_bit_b(bp, reg)          (USBC_Writeb((USBC_Readb(reg) & (~(1 << (bp)))), (reg)))
+#define  USBC_REG_clear_bit_w(bp, reg)          (USBC_Writew((USBC_Readw(reg) & (~(1 << (bp)))), (reg)))
+#define  USBC_REG_clear_bit_l(bp, reg)          (USBC_Writel((USBC_Readl(reg) & (~(1 << (bp)))), (reg)))
+
+#define SUNXI_USB_EHCI_BASE_OFFSET              0x00
+#define SUNXI_USB_OHCI_BASE_OFFSET              0x400
+#define SUNXI_USB_EHCI_LEN                      0x58
+#define SUNXI_USB_OHCI_LEN                      0x58
+
+#define SUNXI_USB_EHCI_TIME_INT			0x30
+#define SUNXI_USB_EHCI_STANDBY_IRQ_STATUS	1
+#define SUNXI_USB_EHCI_STANDBY_IRQ		2
+
+#define SUNXI_USB_PMU_IRQ_ENABLE                0x800
+#define SUNXI_HCI_CTRL_3			0X808
+#define SUNXI_HCI_PHY_CTRL                      0x810
+#define SUNXI_HCI_PHY_TUNE                      0x818
+#define SUNXI_HCI_UTMI_PHY_STATUS               0x824
+#define SUNXI_HCI_CTRL_3_REMOTE_WAKEUP		3
+#define SUNXI_HCI_RC16M_CLK_ENBALE		2
+#if defined(CONFIG_ARCH_SUN8IW12) || defined(CONFIG_ARCH_SUN50IW6) \
+	|| defined(CONFIG_ARCH_SUN50IW3) || defined(CONFIG_ARCH_SUN8IW15) \
+	|| defined(CONFIG_ARCH_SUN50IW8) || defined(CONFIG_ARCH_SUN8IW18) \
+	|| defined(CONFIG_ARCH_SUN8IW16) || defined(CONFIG_ARCH_SUN50IW9) \
+	|| defined(CONFIG_ARCH_SUN50IW10) || defined(CONFIG_ARCH_SUN8IW19) \
+	|| defined(CONFIG_ARCH_SUN50IW11) || defined(CONFIG_ARCH_SUN8IW20)\
+	|| defined(CONFIG_ARCH_SUN20IW1) || defined(CONFIG_ARCH_SUN50IW12)
+#define SUNXI_HCI_PHY_CTRL_SIDDQ                3
+#else
+#define SUNXI_HCI_PHY_CTRL_SIDDQ                1
+#endif
+
+#define SUNXI_OTG_PHY_CTRL	0x410
+#define SUNXI_OTG_PHY_CFG	0x420
+#define SUNXI_OTG_PHY_STATUS	0x424
+#define SUNXI_USBC_REG_INTUSBE	0x0050
+
+#define EHCI_CAP_OFFSET		(0x00)
+#define EHCI_CAP_LEN		(0x10)
+
+#define EHCI_CAP_CAPLEN		(EHCI_CAP_OFFSET + 0x00)
+#define EHCI_CAP_HCIVER		(EHCI_CAP_OFFSET + 0x00)
+#define EHCI_CAP_HCSPAR		(EHCI_CAP_OFFSET + 0x04)
+#define EHCI_CAP_HCCPAR		(EHCI_CAP_OFFSET + 0x08)
+#define EHCI_CAP_COMPRD		(EHCI_CAP_OFFSET + 0x0c)
+
+
+#define EHCI_OPR_OFFSET		(EHCI_CAP_OFFSET + EHCI_CAP_LEN)
+
+#define EHCI_OPR_USBCMD		(EHCI_OPR_OFFSET + 0x00)
+#define EHCI_OPR_USBSTS		(EHCI_OPR_OFFSET + 0x04)
+#define EHCI_OPR_USBINTR	(EHCI_OPR_OFFSET + 0x08)
+#define EHCI_OPR_FRINDEX	(EHCI_OPR_OFFSET + 0x0c)
+#define EHCI_OPR_CRTLDSS	(EHCI_OPR_OFFSET + 0x10)
+#define EHCI_OPR_PDLIST		(EHCI_OPR_OFFSET + 0x14)
+#define EHCI_OPR_ASLIST		(EHCI_OPR_OFFSET + 0x18)
+#define EHCI_OPR_CFGFLAG	(EHCI_OPR_OFFSET + 0x40)
+#define EHCI_OPR_PORTSC		(EHCI_OPR_OFFSET + 0x44)
+
+/**
+ * PORT Control and Status Register
+ * port_no is 0 based, 0, 1, 2, .....
+ *
+ * Reg EHCI_OPR_PORTSC
+ */
+
+/* Port Test Control bits */
+#define EHCI_PORTSC_PTC_MASK	(0xf<<16)
+#define EHCI_PORTSC_PTC_DIS	(0x0<<16)
+#define EHCI_PORTSC_PTC_J	(0x1<<16)
+#define EHCI_PORTSC_PTC_K	(0x2<<16)
+#define EHCI_PORTSC_PTC_SE0NAK	(0x3<<16)
+#define EHCI_PORTSC_PTC_PACKET	(0x4<<16)
+#define EHCI_PORTSC_PTC_FORCE	(0x5<<16)
+
+#define EHCI_PORTSC_OWNER	(0x1<<13)
+#define EHCI_PORTSC_POWER	(0x1<<12)
+
+#define EHCI_PORTSC_LS_MASK	(0x3<<10)
+#define EHCI_PORTSC_LS_SE0	(0x0<<10)
+#define EHCI_PORTSC_LS_J	(0x2<<10)
+#define EHCI_PORTSC_LS_K	(0x1<<10)
+#define EHCI_PORTSC_LS_UDF	(0x3<<10)
+
+#define EHCI_PORTSC_RESET	(0x1<<8)
+#define EHCI_PORTSC_SUSPEND	(0x1<<7)
+#define EHCI_PORTSC_RESUME	(0x1<<6)
+#define EHCI_PORTSC_OCC		(0x1<<5)
+#define EHCI_PORTSC_OC		(0x1<<4)
+#define EHCI_PORTSC_PEC		(0x1<<3)
+#define EHCI_PORTSC_PE		(0x1<<2)
+#define EHCI_PORTSC_CSC		(0x1<<1)
+#define EHCI_PORTSC_CCS		(0x1<<0)
+
+#define	EHCI_PORTSC_CHANGE	(EHCI_PORTSC_OCC | EHCI_PORTSC_PEC | EHCI_PORTSC_CSC)
+
+#define  SUNXI_USB_HCI_DEBUG
+
+#define  KEY_USB_WAKEUP_SUSPEND         "usb_wakeup_suspend"
+#define  KEY_USB_HSIC_USBED             "usb_hsic_used"
+#define  KEY_USB_HSIC_CTRL              "usb_hsic_ctrl"
+#define  KEY_USB_HSIC_RDY_GPIO          "usb_hsic_rdy_gpio"
+#define  KEY_USB_HSIC_REGULATOR_IO	"usb_hsic_regulator_io"
+#define  KEY_WAKEUP_SOURCE              "wakeup-source"
+#define  KEY_USB_PORT_TYPE		"usb_port_type"
+
+/* xHCI */
+#define XHCI_RESOURCES_NUM	2
+#define XHCI_REGS_START		0x0
+#define XHCI_REGS_END		0x7fff
+
+/* xHCI Operational Registers */
+#define XHCI_OP_REGS_HCUSBCMD		0X0020
+#define XHCI_OP_REGS_HCUSBSTS		0X0024
+#define XHCI_OP_REGS_HCPORT1SC		0X0420
+#define XHCI_OP_REGS_HCPORT1PMSC	0X0424
+
+#define SUNXI_GLOBALS_REGS_START	0xc100
+#define SUNXI_GLOBALS_REGS_END		0xc6ff
+
+/* Global Registers */
+#define SUNXI_GLOBALS_REGS_GCTL		0xc110
+#define SUNXI_GUSB2PHYCFG(n)		(0xc200 + (n * 0x04))
+#define SUNXI_GUSB3PIPECTL(n)		(0xc2c0 + (n * 0x04))
+
+/* Interface Status and Control Register */
+#define SUNXI_APP			0x10000
+#define SUNXI_PIPE_CLOCK_CONTROL	0x10014
+#define SUNXI_PHY_TUNE_LOW		0x10018
+#define SUNXI_PHY_TUNE_HIGH		0x1001c
+#define SUNXI_PHY_EXTERNAL_CONTROL	0x10020
+
+/* Bit fields */
+
+/* Global Configuration Register */
+#define SUNXI_GCTL_PRTCAPDIR(n)		((n) << 12)
+#define SUNXI_GCTL_PRTCAP_HOST		1
+#define SUNXI_GCTL_PRTCAP_DEVICE	2
+#define SUNXI_GCTL_PRTCAP_OTG		3
+#define SUNXI_GCTL_SOFITPSYNC		(0x01 << 10)
+#define SUNXI_GCTL_CORESOFTRESET	(1 << 11)
+
+/* Global USB2 PHY Configuration Register n */
+#define SUNXI_USB2PHYCFG_SUSPHY		(0x01 << 6)
+#define SUNXI_USB2PHYCFG_PHYSOFTRST	(1 << 31)
+
+/* Global USB3 PIPE Control Register */
+#define SUNXI_USB3PIPECTL_PHYSOFTRST	(1 << 31)
+
+/* USB2.0 Interface Status and Control Register */
+#define SUNXI_APP_FOCE_VBUS	(0x03 << 12)
+
+/* PIPE Clock Control Register */
+#define SUNXI_PPC_PIPE_CLK_OPEN	(0x01 << 6)
+
+/* PHY External Control Register */
+#define SUNXI_PEC_EXTERN_VBUS	(0x03 << 1)
+#define SUNXI_PEC_SSC_EN	(0x01 << 24)
+#define SUNXI_PEC_REF_SSP_EN	(0x01 << 26)
+
+/* PHY Tune High Register */
+#define SUNXI_TX_DEEMPH_3P5DB(n)	((n) << 19)
+#define SUNXI_TX_DEEMPH_6DB(n)		((n) << 13)
+#define SUNXI_TX_SWING_FULL(n)		((n) << 6)
+#define SUNXI_LOS_BIAS(n)		((n) << 3)
+#define SUNXI_TXVBOOSTLVL(n)		((n) << 0)
+
+/* HCI UTMI PHY TUNE */
+#define SUNXI_TX_VREF_TUNE_OFFSET	8
+#define SUNXI_TX_RISE_TUNE_OFFSET	4
+#define SUNXI_TX_RES_TUNE_OFFSET	2
+#define SUNXI_TX_PREEMPAMP_TUNE_OFFSET	0
+#define SUNXI_TX_VREF_TUNE		(0xf << SUNXI_TX_VREF_TUNE_OFFSET)
+#define SUNXI_TX_RISE_TUNE		(0x3 << SUNXI_TX_RISE_TUNE_OFFSET)
+#define SUNXI_TX_RES_TUNE		(0x3 << SUNXI_TX_RES_TUNE_OFFSET)
+#define SUNXI_TX_PREEMPAMP_TUNE		(0x3 << SUNXI_TX_PREEMPAMP_TUNE_OFFSET)
+
+/* PHYS EFUSE offest */
+#define EFUSE_OFFSET					0x18		//esuse offset
+#define SUNXI_HCI_PHY_EFUSE_ADJUST		0x10000		//bit16
+#define SUNXI_HCI_PHY_EFUSE_MODE		0x20000		//bit17
+#define SUNXI_HCI_PHY_EFUSE_RES			0x3C0000	//bit18-21
+#define SUNXI_HCI_PHY_EFUSE_COM			0x1C00000	//bit22-24
+#define SUNXI_HCI_PHY_EFUSE_USB0TX		0x1C00000	//bit22-24
+#define SUNXI_HCI_PHY_EFUSE_USB1TX		0xE000000	//bit25-27
+
+#if defined(CONFIG_FPGA_V4_PLATFORM) || defined(CONFIG_FPGA_V7_PLATFORM)
+#define SUNXI_USB_FPGA
+#endif
+
+enum sunxi_usbc_type {
+	SUNXI_USB_UNKNOWN = 0,
+	SUNXI_USB_EHCI,
+	SUNXI_USB_OHCI,
+	SUNXI_USB_XHCI,
+	SUNXI_USB_PHY,
+	SUNXI_USB_ALL,
+};
+
+enum usb_drv_vbus_type {
+	USB_DRV_VBUS_TYPE_NULL = 0,
+	USB_DRV_VBUS_TYPE_GIPO,
+	USB_DRV_VBUS_TYPE_AXP,
+};
+
+/* 0: device only; 1: host only; 2: otg */
+enum usb_port_type {
+	USB_PORT_TYPE_DEVICE = 0,
+	USB_PORT_TYPE_HOST,
+	USB_PORT_TYPE_OTG,
+};
+
+enum usb_wakeup_source_type {
+	SUPER_STANDBY = 0,
+	USB_STANDBY,
+};
+
+struct sunxi_hci_hcd {
+	__u32 usbc_no;                          /* usb controller number */
+	__u32 irq_no;                           /* interrupt number */
+	char hci_name[32];                      /* hci name */
+
+	struct resource	*usb_base_res;          /* USB  resources */
+	struct resource	*usb_base_req;          /* USB  resources */
+	void __iomem	*usb_vbase;             /* USB  base address */
+
+	void __iomem	*otg_vbase;             /* USB  base address */
+
+	void __iomem	*ehci_base;
+	__u32 ehci_reg_length;
+	void __iomem	*ohci_base;
+	__u32 ohci_reg_length;
+
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+/* for usb standby*/
+	void __iomem	*prcm;
+
+/* for keep common circuit configuration */
+	void __iomem	*usb_common_phy_config;
+	void __iomem	*usb_ccmu_config;
+
+#define SUNXI_CCMU_SCLK_GATING_USBPHY1_OFFSET	(1UL << 29)
+#define SUNXI_CCMU_USBPHY1_RST_OFFSET		(1UL << 30)
+#define SUNXI_CCMU_SCLK_GATING_OHCI1_OFFSET	(1UL << 31)
+
+#define SUNXI_CCMU_USBEHCI1_GATING_OFFSET	(1UL << 5)
+#define SUNXI_CCMU_USBEHCI1_RST_OFFSET		(1UL << 21)
+#endif
+
+	struct resource	*sram_base_res;         /* SRAM resources */
+	struct resource	*sram_base_req;         /* SRAM resources */
+	void __iomem	*sram_vbase;            /* SRAM base address */
+	__u32 sram_reg_start;
+	__u32 sram_reg_length;
+
+	struct resource	*clock_base_res;        /* clock resources */
+	struct resource	*clock_base_req;        /* clock resources */
+	void __iomem	*clock_vbase;           /* clock base address */
+	__u32 clock_reg_start;
+	__u32 clock_reg_length;
+
+	struct resource	*gpio_base_res;         /* gpio resources */
+	struct resource	*gpio_base_req;         /* gpio resources */
+	void __iomem	*gpio_vbase;            /* gpio base address */
+	__u32 gpio_reg_start;
+	__u32 gpio_reg_length;
+
+	struct resource	*sdram_base_res;        /* sdram resources */
+	struct resource	*sdram_base_req;        /* sdram resources */
+	void __iomem	*sdram_vbase;           /* sdram base address */
+	__u32 sdram_reg_start;
+	__u32 sdram_reg_length;
+
+	struct platform_device *pdev;
+	struct usb_hcd *hcd;
+
+	struct clk	*clk_bus_hci;
+	struct clk	*clk_ohci;
+	struct clk	*clk_phy;
+
+	/* legacy, fix me */
+	struct clk	*mod_usb;               /* mod_usb otg clock handle */
+	struct clk	*hsic_usbphy;            /* hsic clock handle */
+	struct clk	*pll_hsic;               /* pll_hsic clock handle */
+	struct clk	*clk_usbhsic12m;          /* pll_hsic clock handle */
+	struct clk	*clk_usbohci12m;          /* clk_usbohci12m clock handle */
+	struct clk	*clk_hoscx2;              /* clk_hoscx2 clock handle */
+	struct clk	*clk_hosc;                /* clk_hosc clock handle */
+	struct clk	*clk_losc;	          /* clk_losc clock handle */
+
+	struct reset_control	*reset_hci;
+	struct reset_control	*reset_phy;
+
+	__u32 clk_is_open;                      /* is usb clock open */
+
+	struct gpio_config drv_vbus_gpio_set;
+
+	const char  *regulator_io;
+	const char  *used_status;
+	int   regulator_value;
+	struct regulator *regulator_io_hdle;
+	enum usb_drv_vbus_type drv_vbus_type;
+	const char *drv_vbus_name;
+	const char *det_vbus_name;
+	u32 usb_restrict_valid;
+	__u8 power_flag;                        /* flag. power on or not */
+	struct regulator *supply;
+	struct regulator *hci_regulator;        /* hci regulator: VCC_USB */
+
+	int used;                              /* flag. in use or not */
+	__u8 probe;                             /* hc initialize */
+	__u8 no_suspend;                        /* when usb is being enable, stop system suspend */
+	enum usb_port_type port_type;		/* usb port type */
+	int wakeup_suspend;                       /* flag. not suspend */
+
+	int wakeup_source_flag;
+
+	/* HSIC device susport */
+	u32 hsic_flag;                         /* flag. hsic usbed */
+	const char *hsic_regulator_io;
+	struct regulator *hsic_regulator_io_hdle;
+
+	/* Marvell 4G HSIC ctrl */
+	struct gpio_config usb_host_hsic_rdy;
+	u32 usb_host_hsic_rdy_valid;
+	u32 hsic_ctrl_flag;                    /* flag. hsic ctrl */
+	u32 hsic_enable_flag;                  /* flag. hsic enable */
+
+	/* SMSC usb3503 HSIC HUB ctrl */
+	u32 usb_hsic_usb3503_flag;
+
+	struct gpio_config usb_hsic_hub_connect;
+	u32 usb_hsic_hub_connect_valid;
+
+	struct gpio_config usb_hsic_int_n;
+	u32 usb_hsic_int_n_valid;
+
+	struct gpio_config usb_hsic_reset_n;
+	u32 usb_hsic_reset_n_valid;
+
+
+	int (*open_clock)(struct sunxi_hci_hcd *sunxi_hci, u32 ohci);
+	int (*close_clock)(struct sunxi_hci_hcd *sunxi_hci, u32 ohci);
+	void (*set_power)(struct sunxi_hci_hcd *sunxi_hci, int is_on);
+	void (*port_configure)(struct sunxi_hci_hcd *sunxi_hci, u32 enable);
+	void (*usb_passby)(struct sunxi_hci_hcd *sunxi_hci, u32 enable);
+	void (*hci_phy_ctrl)(struct sunxi_hci_hcd *sunxi_hci, u32 enable);
+
+	/* xhci */
+	struct resource xhci_resources[XHCI_RESOURCES_NUM];
+	spinlock_t		lock;
+	struct device		*dev;
+	void			*mem;
+	void __iomem	*regs;
+	size_t		regs_size;
+	void __iomem	*xhci_base;
+	__u32 xhci_reg_length;
+
+	/* resume work */
+	struct work_struct resume_work;
+	struct completion standby_complete;
+};
+
+int sunxi_hci_standby_completion(int usbc_type);
+int init_sunxi_hci(struct platform_device *pdev, int usbc_type);
+int exit_sunxi_hci(struct sunxi_hci_hcd *sunxi_hci);
+int sunxi_get_hci_num(struct platform_device *pdev);
+void sunxi_set_host_hisc_rdy(struct sunxi_hci_hcd *sunxi_hci, int is_on);
+void sunxi_set_host_vbus(struct sunxi_hci_hcd *sunxi_hci, int is_on);
+int usb_phyx_tp_write(struct sunxi_hci_hcd *sunxi_hci,
+		int addr, int data, int len);
+int usb_phyx_write(struct sunxi_hci_hcd *sunxi_hci, int data);
+int usb_phyx_read(struct sunxi_hci_hcd *sunxi_hci);
+int usb_phyx_tp_read(struct sunxi_hci_hcd *sunxi_hci, int addr, int len);
+int sunxi_usb_enable_xhci(void);
+int sunxi_usb_disable_xhci(void);
+void enter_usb_standby(struct sunxi_hci_hcd *sunxi_hci);
+void exit_usb_standby(struct sunxi_hci_hcd *sunxi_hci);
+#if IS_ENABLED(SUNXI_USB_STANDBY_LOW_POW_MODE)
+void sunxi_hci_set_siddq(struct sunxi_hci_hcd *sunxi_hci, int is_on);
+void sunxi_hci_set_wakeup_ctrl(struct sunxi_hci_hcd *sunxi_hci, int is_on);
+void sunxi_hci_set_rc_clk(struct sunxi_hci_hcd *sunxi_hci, int is_on);
+void sunxi_hci_set_standby_irq(struct sunxi_hci_hcd *sunxi_hci, int is_on);
+void sunxi_hci_clean_standby_irq(struct sunxi_hci_hcd *sunxi_hci);
+#endif
+
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+void sunxi_hci_common_set_rc_clk(struct sunxi_hci_hcd *sunxi_hci,
+					int is_on);
+void sunxi_hci_common_switch_clk(struct sunxi_hci_hcd *sunxi_hci,
+					int is_on);
+void sunxi_hci_common_set_rcgating(struct sunxi_hci_hcd *sunxi_hci,
+				   int is_on);
+void sunxi_hci_set_rcgating(struct sunxi_hci_hcd *sunxi_hci,
+				   int is_on);
+void sunxi_hci_switch_clk(struct sunxi_hci_hcd *sunxi_hci,
+				 int is_on);
+#endif
+#endif /* __SUNXI_HCI_SUNXI_H__ */
diff --git a/drivers/usb/host/xhci-pci-renesas.c b/drivers/usb/host/xhci-pci-renesas.c
new file mode 100644
index 000000000..02fcb01bc
--- /dev/null
+++ b/drivers/usb/host/xhci-pci-renesas.c
@@ -0,0 +1,985 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2019-2020 Linaro Limited */
+
+#include <linux/acpi.h>
+#include <linux/debugfs.h>
+#include <linux/firmware.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <asm/unaligned.h>
+
+#include "xhci.h"
+#include "xhci-trace.h"
+#include "xhci-pci.h"
+
+#define RENESAS_FW_VERSION				0x6C
+#define RENESAS_ROM_CONFIG				0xF0
+#define RENESAS_FW_STATUS				0xF4
+#define RENESAS_FW_STATUS_MSB				0xF5
+#define RENESAS_ROM_STATUS				0xF6
+#define RENESAS_ROM_STATUS_MSB				0xF7
+#define RENESAS_DATA0					0xF8
+#define RENESAS_DATA1					0xFC
+
+#define RENESAS_FW_VERSION_FIELD			GENMASK(23, 7)
+#define RENESAS_FW_VERSION_OFFSET			8
+
+#define RENESAS_FW_STATUS_DOWNLOAD_ENABLE		BIT(0)
+#define RENESAS_FW_STATUS_LOCK				BIT(1)
+#define RENESAS_FW_STATUS_RESULT			GENMASK(6, 4)
+  #define RENESAS_FW_STATUS_INVALID			0
+  #define RENESAS_FW_STATUS_SUCCESS			BIT(4)
+  #define RENESAS_FW_STATUS_ERROR			BIT(5)
+#define RENESAS_FW_STATUS_SET_DATA0			BIT(8)
+#define RENESAS_FW_STATUS_SET_DATA1			BIT(9)
+
+#define RENESAS_ROM_STATUS_ACCESS			BIT(0)
+#define RENESAS_ROM_STATUS_ERASE			BIT(1)
+#define RENESAS_ROM_STATUS_RELOAD			BIT(2)
+#define RENESAS_ROM_STATUS_RESULT			GENMASK(6, 4)
+  #define RENESAS_ROM_STATUS_INVALID			0
+  #define RENESAS_ROM_STATUS_SUCCESS			BIT(4)
+  #define RENESAS_ROM_STATUS_ERROR			BIT(5)
+#define RENESAS_ROM_STATUS_SET_DATA0			BIT(8)
+#define RENESAS_ROM_STATUS_SET_DATA1			BIT(9)
+#define RENESAS_ROM_STATUS_ROM_EXISTS			BIT(15)
+
+#define RENESAS_ROM_ERASE_MAGIC				0x5A65726F
+#define RENESAS_ROM_WRITE_MAGIC				0x53524F4D
+
+#define RENESAS_RETRY	10000
+#define RENESAS_DELAY	10
+
+static struct hc_driver __read_mostly xhci_pci_hc_driver;
+
+static const struct xhci_driver_overrides xhci_pci_overrides __initconst = {
+	.reset = xhci_pci_setup,
+};
+
+static const struct renesas_fw_entry {
+	const char *firmware_name;
+	u16 device;
+	u8 revision;
+	u16 expected_version;
+} renesas_fw_table[] = {
+	/*
+	 * Only the uPD720201K8-711-BAC-A or uPD720202K8-711-BAA-A
+	 * are listed in R19UH0078EJ0500 Rev.5.00 as devices which
+	 * need the software loader.
+	 *
+	 * PP2U/ReleaseNote_USB3-201-202-FW.txt:
+	 *
+	 * Note: This firmware is for the following devices.
+	 *  - uPD720201 ES 2.0 sample whose revision ID is 2.
+	 *  - uPD720201 ES 2.1 sample & CS sample & Mass product, ID is 3.
+	 *  - uPD720202 ES 2.0 sample & CS sample & Mass product, ID is 2.
+	 *
+	 *  Entry expected_version should be kept in decreasing order for a
+	 *  chip, so that driver will pick latest version and if that fails
+	 *  then next one will be picked
+	 */
+	{ "K2013080.mem", 0x0014, 0x02, 0x2013 },
+	{ "K2026090.mem", 0x0014, 0x03, 0x2026 },
+	{ "K2013080.mem", 0x0014, 0x03, 0x2013 },
+	{ "K2026090.mem", 0x0015, 0x02, 0x2026 },
+	{ "K2013080.mem", 0x0015, 0x02, 0x2013 },
+};
+
+MODULE_FIRMWARE("K2013080.mem");
+MODULE_FIRMWARE("K2026090.mem");
+
+static const struct renesas_fw_entry *renesas_needs_fw_dl(struct pci_dev *dev)
+{
+	const struct renesas_fw_entry *entry;
+	size_t i;
+
+	/* This loader will only work with a RENESAS device. */
+	if (!(dev->vendor == PCI_VENDOR_ID_RENESAS))
+		return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(renesas_fw_table); i++) {
+		entry = &renesas_fw_table[i];
+		if (entry->device == dev->device &&
+		    entry->revision == dev->revision)
+			return entry;
+	}
+
+	return NULL;
+}
+
+static const struct
+renesas_fw_entry *renesas_get_next_entry(struct pci_dev *dev,
+					 const struct renesas_fw_entry *entry)
+{
+	const struct renesas_fw_entry *next_entry;
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(renesas_fw_table); i++) {
+		next_entry = &renesas_fw_table[i];
+		if (next_entry->device == dev->device &&
+		    next_entry->revision == dev->revision &&
+		    next_entry->expected_version < entry->expected_version)
+			return next_entry;
+	}
+
+	return NULL;
+}
+
+static int renesas_fw_download_image(struct pci_dev *dev,
+				     const u32 *fw,
+				     size_t step)
+{
+	size_t i;
+	int err;
+	u8 fw_status;
+	bool data0_or_data1;
+
+	/*
+	 * The hardware does alternate between two 32-bit pages.
+	 * (This is because each row of the firmware is 8 bytes).
+	 *
+	 * for even steps we use DATA0, for odd steps DATA1.
+	 */
+	data0_or_data1 = (step & 1) == 1;
+
+	/* step+1. Read "Set DATAX" and confirm it is cleared. */
+	for (i = 0; i < RENESAS_RETRY; i++) {
+		err = pci_read_config_byte(dev, RENESAS_FW_STATUS_MSB,
+					   &fw_status);
+		if (err)
+			return pcibios_err_to_errno(err);
+		if (!(fw_status & BIT(data0_or_data1)))
+			break;
+
+		udelay(RENESAS_DELAY);
+	}
+	if (i == RENESAS_RETRY)
+		return -ETIMEDOUT;
+
+	/*
+	 * step+2. Write FW data to "DATAX".
+	 * "LSB is left" => force little endian
+	 */
+	err = pci_write_config_dword(dev, data0_or_data1 ?
+				     RENESAS_DATA1 : RENESAS_DATA0,
+				     (__force u32)cpu_to_le32(fw[step]));
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	udelay(100);
+
+	/* step+3. Set "Set DATAX". */
+	err = pci_write_config_byte(dev, RENESAS_FW_STATUS_MSB,
+				    BIT(data0_or_data1));
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	return 0;
+}
+
+static int renesas_fw_verify(struct pci_dev *dev,
+			     const void *fw_data,
+			     size_t length)
+{
+	const struct renesas_fw_entry *entry = renesas_needs_fw_dl(dev);
+	u16 fw_version_pointer;
+	u16 fw_version;
+
+	if (!entry)
+		return -EINVAL;
+
+	/*
+	 * The Firmware's Data Format is describe in
+	 * "6.3 Data Format" R19UH0078EJ0500 Rev.5.00 page 124
+	 */
+
+	/*
+	 * The bootrom chips of the big brother have sizes up to 64k, let's
+	 * assume that's the biggest the firmware can get.
+	 */
+	if (length < 0x1000 || length >= 0x10000) {
+		dev_err(&dev->dev, "firmware is size %zd is not (4k - 64k).",
+			length);
+		return -EINVAL;
+	}
+
+	/* The First 2 bytes are fixed value (55aa). "LSB on Left" */
+	if (get_unaligned_le16(fw_data) != 0x55aa) {
+		dev_err(&dev->dev, "no valid firmware header found.");
+		return -EINVAL;
+	}
+
+	/* verify the firmware version position and print it. */
+	fw_version_pointer = get_unaligned_le16(fw_data + 4);
+	if (fw_version_pointer + 2 >= length) {
+		dev_err(&dev->dev,
+			"firmware version pointer is outside of the firmware image.");
+		return -EINVAL;
+	}
+
+	fw_version = get_unaligned_le16(fw_data + fw_version_pointer);
+	dev_dbg(&dev->dev, "got firmware version: %02x.", fw_version);
+
+	if (fw_version != entry->expected_version) {
+		dev_err(&dev->dev,
+			"firmware version mismatch, expected version: %02x.",
+			entry->expected_version);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void debugfs_init(struct pci_dev *pdev);
+
+static int renesas_check_rom_state(struct pci_dev *pdev)
+{
+	const struct renesas_fw_entry *entry;
+	u16 rom_state;
+	u32 version;
+	bool valid_version = false;
+	int err, i;
+
+	/* check FW version */
+	err = pci_read_config_dword(pdev, RENESAS_FW_VERSION, &version);
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	version &= RENESAS_FW_VERSION_FIELD;
+	version = version >> RENESAS_FW_VERSION_OFFSET;
+	dev_dbg(&pdev->dev, "Found FW version loaded is %x\n", version);
+
+	/* treat version in renesas_fw_table as correct ones */
+	for (i = 0; i < ARRAY_SIZE(renesas_fw_table); i++) {
+		entry = &renesas_fw_table[i];
+		if (version == entry->expected_version) {
+			dev_dbg(&pdev->dev, "Detected valid ROM version..\n");
+			valid_version = true;
+			debugfs_init(pdev);
+		}
+	}
+	if (valid_version == false)
+		dev_dbg(&pdev->dev, "Didn't find valid ROM version\n");
+
+	/*
+	 * Test if ROM is present and loaded, if so we can skip everything
+	 */
+	err = pci_read_config_word(pdev, RENESAS_ROM_STATUS, &rom_state);
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	if (rom_state & BIT(15)) {
+		/* ROM exists */
+		dev_dbg(&pdev->dev, "ROM exists\n");
+
+		/* Check the "Result Code" Bits (6:4) and act accordingly */
+		switch (rom_state & RENESAS_ROM_STATUS_RESULT) {
+		case RENESAS_ROM_STATUS_SUCCESS:
+			dev_dbg(&pdev->dev, "Success ROM load...");
+			/* we have valid version and status so success */
+			if (valid_version)
+				return 0;
+			break;
+
+		case RENESAS_ROM_STATUS_INVALID: /* No result yet */
+			dev_dbg(&pdev->dev, "No result as it is ROM...");
+			/* we have valid version and status so success */
+			if (valid_version)
+				return 0;
+			break;
+
+		case RENESAS_ROM_STATUS_ERROR: /* Error State */
+		default: /* All other states are marked as "Reserved states" */
+			dev_err(&pdev->dev, "Invalid ROM..");
+			break;
+		}
+	}
+
+	return -EIO;
+}
+
+static int renesas_fw_check_running(struct pci_dev *pdev)
+{
+	int err;
+	u8 fw_state;
+
+	/* Check if device has ROM and loaded, if so skip everything */
+	err = renesas_check_rom_state(pdev);
+	if (!err)
+		return err;
+
+	/*
+	 * Test if the device is actually needing the firmware. As most
+	 * BIOSes will initialize the device for us. If the device is
+	 * initialized.
+	 */
+	err = pci_read_config_byte(pdev, RENESAS_FW_STATUS, &fw_state);
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	/*
+	 * Check if "FW Download Lock" is locked. If it is and the FW is
+	 * ready we can simply continue. If the FW is not ready, we have
+	 * to give up.
+	 */
+	if (fw_state & RENESAS_FW_STATUS_LOCK) {
+		dev_dbg(&pdev->dev, "FW Download Lock is engaged.");
+
+		if (fw_state & RENESAS_FW_STATUS_SUCCESS)
+			return 0;
+
+		dev_err(&pdev->dev,
+			"FW Download Lock is set and FW is not ready. Giving Up.");
+		return -EIO;
+	}
+
+	/*
+	 * Check if "FW Download Enable" is set. If someone (us?) tampered
+	 * with it and it can't be resetted, we have to give up too... and
+	 * ask for a forgiveness and a reboot.
+	 */
+	if (fw_state & RENESAS_FW_STATUS_DOWNLOAD_ENABLE) {
+		dev_err(&pdev->dev,
+			"FW Download Enable is stale. Giving Up (poweroff/reboot needed).");
+		return -EIO;
+	}
+
+	/* Otherwise, Check the "Result Code" Bits (6:4) and act accordingly */
+	switch (fw_state & RENESAS_FW_STATUS_RESULT) {
+	case 0: /* No result yet */
+		dev_dbg(&pdev->dev, "FW is not ready/loaded yet.");
+
+		/* tell the caller, that this device needs the firmware. */
+		return 1;
+
+	case RENESAS_FW_STATUS_SUCCESS: /* Success, device should be working. */
+		dev_dbg(&pdev->dev, "FW is ready.");
+		return 0;
+
+	case RENESAS_FW_STATUS_ERROR: /* Error State */
+		dev_err(&pdev->dev,
+			"hardware is in an error state. Giving up (poweroff/reboot needed).");
+		return -ENODEV;
+
+	default: /* All other states are marked as "Reserved states" */
+		dev_err(&pdev->dev,
+			"hardware is in an invalid state %lx. Giving up (poweroff/reboot needed).",
+			(fw_state & RENESAS_FW_STATUS_RESULT) >> 4);
+		return -EINVAL;
+	}
+}
+
+static int renesas_fw_download(struct pci_dev *pdev,
+			       const struct firmware *fw)
+{
+	const u32 *fw_data = (const u32 *)fw->data;
+	size_t i;
+	int err;
+	u8 fw_status;
+
+	/*
+	 * For more information and the big picture: please look at the
+	 * "Firmware Download Sequence" in "7.1 FW Download Interface"
+	 * of R19UH0078EJ0500 Rev.5.00 page 131
+	 */
+
+	/*
+	 * 0. Set "FW Download Enable" bit in the
+	 * "FW Download Control & Status Register" at 0xF4
+	 */
+	err = pci_write_config_byte(pdev, RENESAS_FW_STATUS,
+				    RENESAS_FW_STATUS_DOWNLOAD_ENABLE);
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	/* 1 - 10 follow one step after the other. */
+	for (i = 0; i < fw->size / 4; i++) {
+		err = renesas_fw_download_image(pdev, fw_data, i);
+		if (err) {
+			dev_err(&pdev->dev,
+				"Firmware Download Step %zd failed at position %zd bytes with (%d).",
+				i, i * 4, err);
+			return err;
+		}
+	}
+
+	/*
+	 * This sequence continues until the last data is written to
+	 * "DATA0" or "DATA1". Naturally, we wait until "SET DATA0/1"
+	 * is cleared by the hardware beforehand.
+	 */
+	for (i = 0; i < RENESAS_RETRY; i++) {
+		err = pci_read_config_byte(pdev, RENESAS_FW_STATUS_MSB,
+					   &fw_status);
+		if (err)
+			return pcibios_err_to_errno(err);
+		if (!(fw_status & (BIT(0) | BIT(1))))
+			break;
+
+		udelay(RENESAS_DELAY);
+	}
+	if (i == RENESAS_RETRY)
+		dev_warn(&pdev->dev, "Final Firmware Download step timed out.");
+
+	/*
+	 * 11. After finishing writing the last data of FW, the
+	 * System Software must clear "FW Download Enable"
+	 */
+	err = pci_write_config_byte(pdev, RENESAS_FW_STATUS, 0);
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	/* 12. Read "Result Code" and confirm it is good. */
+	for (i = 0; i < RENESAS_RETRY; i++) {
+		err = pci_read_config_byte(pdev, RENESAS_FW_STATUS, &fw_status);
+		if (err)
+			return pcibios_err_to_errno(err);
+		if (fw_status & RENESAS_FW_STATUS_SUCCESS)
+			break;
+
+		udelay(RENESAS_DELAY);
+	}
+	if (i == RENESAS_RETRY) {
+		/* Timed out / Error - let's see if we can fix this */
+		err = renesas_fw_check_running(pdev);
+		switch (err) {
+		case 0: /*
+			 * we shouldn't end up here.
+			 * maybe it took a little bit longer.
+			 * But all should be well?
+			 */
+			break;
+
+		case 1: /* (No result yet! */
+			return -ETIMEDOUT;
+
+		default:
+			return err;
+		}
+	}
+	/*
+	 * Optional last step: Engage Firmware Lock
+	 *
+	 * err = pci_write_config_byte(pdev, 0xF4, BIT(2));
+	 * if (err)
+	 *	return pcibios_err_to_errno(err);
+	 */
+
+	return 0;
+}
+
+struct renesas_fw_ctx {
+	struct pci_dev *pdev;
+	const struct pci_device_id *id;
+	bool resume;
+	const struct renesas_fw_entry *entry;
+};
+
+static bool renesas_check_rom(struct pci_dev *pdev)
+{
+	u16 rom_status;
+	int retval;
+
+	/* 1. Check if external ROM exists */
+	retval = pci_read_config_word(pdev, RENESAS_ROM_STATUS, &rom_status);
+	if (retval)
+		return false;
+
+	rom_status &= RENESAS_ROM_STATUS_ROM_EXISTS;
+	if (rom_status) {
+		dev_dbg(&pdev->dev, "External ROM exists\n");
+		return true; /* External ROM exists */
+	}
+
+	return false;
+}
+
+static void renesas_rom_erase(struct pci_dev *pdev)
+{
+	int retval, i;
+	u8 status;
+
+	dev_dbg(&pdev->dev, "Performing ROM Erase...\n");
+	retval = pci_write_config_dword(pdev, RENESAS_DATA0,
+					RENESAS_ROM_ERASE_MAGIC);
+	if (retval) {
+		dev_err(&pdev->dev, "ROM erase, magic word write failed: %d\n",
+			pcibios_err_to_errno(retval));
+		return;
+	}
+
+	retval = pci_read_config_byte(pdev, RENESAS_ROM_STATUS, &status);
+	if (retval) {
+		dev_err(&pdev->dev, "ROM status read failed: %d\n",
+			pcibios_err_to_errno(retval));
+		return;
+	}
+	status |= RENESAS_ROM_STATUS_ERASE;
+	retval = pci_write_config_byte(pdev, RENESAS_ROM_STATUS, status);
+	if (retval) {
+		dev_err(&pdev->dev, "ROM erase set word write failed\n");
+		return;
+	}
+
+	/* sleep a bit while ROM is erased */
+	msleep(20);
+
+	for (i = 0; i < RENESAS_RETRY; i++) {
+		retval = pci_read_config_byte(pdev, RENESAS_ROM_STATUS,
+					      &status);
+		status &= RENESAS_ROM_STATUS_ERASE;
+		if (!status)
+			break;
+
+		mdelay(RENESAS_DELAY);
+	}
+
+	if (i == RENESAS_RETRY)
+		dev_dbg(&pdev->dev, "Chip erase timedout: %x\n", status);
+
+	dev_dbg(&pdev->dev, "ROM Erase... Done success\n");
+}
+
+static int debugfs_rom_erase(void *data, u64 value)
+{
+	struct pci_dev *pdev = data;
+
+	if (value == 1) {
+		dev_dbg(&pdev->dev, "Userspace requested ROM erase\n");
+		renesas_rom_erase(pdev);
+		return 0;
+	}
+	return -EINVAL;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(rom_erase_ops, NULL, debugfs_rom_erase, "%llu\n");
+
+static struct dentry *debugfs_root;
+
+static void debugfs_init(struct pci_dev *pdev)
+{
+	debugfs_root = debugfs_create_dir("renesas-usb", NULL);
+
+	debugfs_create_file("rom_erase", 0200, debugfs_root,
+			    pdev, &rom_erase_ops);
+}
+
+static void debugfs_exit(void)
+{
+	debugfs_remove_recursive(debugfs_root);
+}
+
+static bool renesas_download_rom(struct pci_dev *pdev,
+				 const u32 *fw, size_t step)
+{
+	bool data0_or_data1;
+	u8 fw_status;
+	size_t i;
+	int err;
+
+	/*
+	 * The hardware does alternate between two 32-bit pages.
+	 * (This is because each row of the firmware is 8 bytes).
+	 *
+	 * for even steps we use DATA0, for odd steps DATA1.
+	 */
+	data0_or_data1 = (step & 1) == 1;
+
+	/* Read "Set DATAX" and confirm it is cleared. */
+	for (i = 0; i < RENESAS_RETRY; i++) {
+		err = pci_read_config_byte(pdev, RENESAS_ROM_STATUS_MSB,
+					   &fw_status);
+		if (err) {
+			dev_err(&pdev->dev, "Read ROM Status failed: %d\n",
+				pcibios_err_to_errno(err));
+			return false;
+		}
+		if (!(fw_status & BIT(data0_or_data1)))
+			break;
+
+		udelay(RENESAS_DELAY);
+	}
+	if (i == RENESAS_RETRY) {
+		dev_err(&pdev->dev, "Timeout for Set DATAX step: %zd\n", step);
+		return false;
+	}
+
+	/*
+	 * Write FW data to "DATAX".
+	 * "LSB is left" => force little endian
+	 */
+	err = pci_write_config_dword(pdev, data0_or_data1 ?
+				     RENESAS_DATA1 : RENESAS_DATA0,
+				     (__force u32)cpu_to_le32(fw[step]));
+	if (err) {
+		dev_err(&pdev->dev, "Write to DATAX failed: %d\n",
+			pcibios_err_to_errno(err));
+		return false;
+	}
+
+	udelay(100);
+
+	/* Set "Set DATAX". */
+	err = pci_write_config_byte(pdev, RENESAS_ROM_STATUS_MSB,
+				    BIT(data0_or_data1));
+	if (err) {
+		dev_err(&pdev->dev, "Write config for DATAX failed: %d\n",
+			pcibios_err_to_errno(err));
+		return false;
+	}
+
+	return true;
+}
+
+static bool renesas_setup_rom(struct pci_dev *pdev, const struct firmware *fw)
+{
+	const u32 *fw_data = (const u32 *)fw->data;
+	int err, i;
+	u8 status;
+
+	/* 2. Write magic word to Data0 */
+	err = pci_write_config_dword(pdev, RENESAS_DATA0,
+				     RENESAS_ROM_WRITE_MAGIC);
+	if (err)
+		return false;
+
+	/* 3. Set External ROM access */
+	err = pci_write_config_byte(pdev, RENESAS_ROM_STATUS,
+				    RENESAS_ROM_STATUS_ACCESS);
+	if (err)
+		goto remove_bypass;
+
+	/* 4. Check the result */
+	err = pci_read_config_byte(pdev, RENESAS_ROM_STATUS, &status);
+	if (err)
+		goto remove_bypass;
+	status &= GENMASK(6, 4);
+	if (status) {
+		dev_err(&pdev->dev,
+			"setting external rom failed: %x\n", status);
+		goto remove_bypass;
+	}
+
+	/* 5 to 16 Write FW to DATA0/1 while checking SetData0/1 */
+	for (i = 0; i < fw->size / 4; i++) {
+		err = renesas_download_rom(pdev, fw_data, i);
+		if (!err) {
+			dev_err(&pdev->dev,
+				"ROM Download Step %d failed at position %d bytes\n",
+				 i, i * 4);
+			goto remove_bypass;
+		}
+	}
+
+	/*
+	 * wait till DATA0/1 is cleared
+	 */
+	for (i = 0; i < RENESAS_RETRY; i++) {
+		err = pci_read_config_byte(pdev, RENESAS_ROM_STATUS_MSB,
+					   &status);
+		if (err)
+			goto remove_bypass;
+		if (!(status & (BIT(0) | BIT(1))))
+			break;
+
+		udelay(RENESAS_DELAY);
+	}
+	if (i == RENESAS_RETRY) {
+		dev_err(&pdev->dev, "Final Firmware ROM Download step timed out\n");
+		goto remove_bypass;
+	}
+
+	/* 17. Remove bypass */
+	err = pci_write_config_byte(pdev, RENESAS_ROM_STATUS, 0);
+	if (err)
+		return false;
+
+	udelay(10);
+
+	/* 18. check result */
+	for (i = 0; i < RENESAS_RETRY; i++) {
+		err = pci_read_config_byte(pdev, RENESAS_ROM_STATUS, &status);
+		if (err) {
+			dev_err(&pdev->dev, "Read ROM status failed:%d\n",
+				pcibios_err_to_errno(err));
+			return false;
+		}
+		status &= RENESAS_ROM_STATUS_RESULT;
+		if (status ==  RENESAS_ROM_STATUS_SUCCESS) {
+			dev_dbg(&pdev->dev, "Download ROM success\n");
+			break;
+		}
+		udelay(RENESAS_DELAY);
+	}
+	if (i == RENESAS_RETRY) { /* Timed out */
+		dev_err(&pdev->dev,
+			"Download to external ROM TO: %x\n", status);
+		return false;
+	}
+
+	dev_dbg(&pdev->dev, "Download to external ROM scuceeded\n");
+
+	/* Last step set Reload */
+	err = pci_write_config_byte(pdev, RENESAS_ROM_STATUS,
+				    RENESAS_ROM_STATUS_RELOAD);
+	if (err) {
+		dev_err(&pdev->dev, "Set ROM execute failed: %d\n",
+			pcibios_err_to_errno(err));
+		return false;
+	}
+
+	/*
+	 * wait till Reload is cleared
+	 */
+	for (i = 0; i < RENESAS_RETRY; i++) {
+		err = pci_read_config_byte(pdev, RENESAS_ROM_STATUS, &status);
+		if (err)
+			return false;
+		if (!(status & RENESAS_ROM_STATUS_RELOAD))
+			break;
+
+		udelay(RENESAS_DELAY);
+	}
+	if (i == RENESAS_RETRY) {
+		dev_err(&pdev->dev, "ROM Exec timed out: %x\n", status);
+		return false;
+	}
+
+	return true;
+
+remove_bypass:
+	pci_write_config_byte(pdev, RENESAS_ROM_STATUS, 0);
+	return false;
+}
+
+static void renesas_fw_callback(const struct firmware *fw,
+				void *context)
+{
+	struct renesas_fw_ctx *ctx = context;
+	struct pci_dev *pdev = ctx->pdev;
+	struct device *parent = pdev->dev.parent;
+	const struct renesas_fw_entry *next_entry;
+	bool rom;
+	int err;
+
+	if (!fw) {
+		dev_err(&pdev->dev, "firmware failed to load\n");
+		/*
+		 * we didn't find firmware, check if we have another
+		 * entry for this device
+		 */
+		next_entry = renesas_get_next_entry(ctx->pdev, ctx->entry);
+		if (next_entry) {
+			ctx->entry = next_entry;
+			dev_dbg(&pdev->dev, "Found next entry, requesting: %s\n",
+				next_entry->firmware_name);
+			request_firmware_nowait(THIS_MODULE, 1,
+						next_entry->firmware_name,
+						&pdev->dev, GFP_KERNEL,
+						ctx, renesas_fw_callback);
+			return;
+		} else {
+			goto cleanup;
+		}
+	}
+
+	err = renesas_fw_verify(pdev, fw->data, fw->size);
+	if (err)
+		goto cleanup;
+
+	/* Check if the device has external ROM */
+	rom = renesas_check_rom(pdev);
+	if (rom) {
+		/* perfrom chip erase first */
+		renesas_rom_erase(pdev);
+
+		/* lets try loading fw on ROM first */
+		rom = renesas_setup_rom(pdev, fw);
+		if (!rom) {
+			dev_err(&pdev->dev,
+				"ROM load failed, falling back on FW load\n");
+		} else {
+			dev_dbg(&pdev->dev, "ROM load done..\n");
+
+			release_firmware(fw);
+			goto do_probe;
+		}
+	}
+
+	err = renesas_fw_download(pdev, fw);
+	release_firmware(fw);
+	if (err) {
+		dev_err(&pdev->dev, "firmware failed to download (%d).", err);
+		goto cleanup;
+	}
+
+do_probe:
+	if (ctx->resume)
+		return;
+
+	err = xhci_pci_probe(pdev, ctx->id);
+	if (!err) {
+		/* everything worked */
+		devm_kfree(&pdev->dev, ctx);
+		return;
+	}
+
+cleanup:
+	/* in case of an error - fall through */
+	dev_info(&pdev->dev, "Unloading driver");
+
+	if (parent)
+		device_lock(parent);
+
+	device_release_driver(&pdev->dev);
+
+	if (parent)
+		device_unlock(parent);
+
+	pci_dev_put(pdev);
+}
+
+static int renesas_fw_alive_check(struct pci_dev *pdev)
+{
+	const struct renesas_fw_entry *entry;
+
+	/* check if we have a eligible RENESAS' uPD720201/2 w/o FW. */
+	entry = renesas_needs_fw_dl(pdev);
+	if (!entry)
+		return 0;
+
+	return renesas_fw_check_running(pdev);
+}
+
+static int renesas_fw_download_to_hw(struct pci_dev *pdev,
+				     const struct pci_device_id *id,
+				     bool do_resume)
+{
+	const struct renesas_fw_entry *entry;
+	struct renesas_fw_ctx *ctx;
+	int err;
+
+	/* check if we have a eligible RENESAS' uPD720201/2 w/o FW. */
+	entry = renesas_needs_fw_dl(pdev);
+	if (!entry)
+		return 0;
+
+	err = renesas_fw_check_running(pdev);
+	/* Continue ahead, if the firmware is already running. */
+	if (err == 0)
+		return 0;
+
+	if (err != 1)
+		return err;
+
+	ctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	ctx->pdev = pdev;
+	ctx->resume = do_resume;
+	ctx->id = id;
+	ctx->entry = entry;
+
+	pci_dev_get(pdev);
+	err = request_firmware_nowait(THIS_MODULE, 1, entry->firmware_name,
+				      &pdev->dev, GFP_KERNEL,
+				      ctx, renesas_fw_callback);
+	if (err) {
+		pci_dev_put(pdev);
+		return err;
+	}
+
+	/*
+	 * The renesas_fw_callback() callback will continue the probe
+	 * process, once it aquires the firmware.
+	 */
+	return 1;
+}
+
+static int renesas_xhci_pci_probe(struct pci_dev *dev,
+				  const struct pci_device_id *id)
+{
+	int retval;
+
+	/*
+	 * Check if this device is a RENESAS uPD720201/2 device.
+	 * Otherwise, we can continue with xhci_pci_probe as usual.
+	 */
+	retval = renesas_fw_download_to_hw(dev, id, false);
+	switch (retval) {
+	case 0:
+		break;
+
+	case 1: /* let it load the firmware and recontinue the probe. */
+		return 0;
+
+	default:
+		return retval;
+	};
+
+	return xhci_pci_probe(dev, id);
+}
+
+static void renesas_xhci_pci_remove(struct pci_dev *dev)
+{
+	debugfs_exit();
+
+	if (renesas_fw_alive_check(dev)) {
+		/*
+		 * bail out early, if this was a renesas device w/o FW.
+		 * Else we might hit the NMI watchdog in xhci_handsake
+		 * during xhci_reset as part of the driver's unloading.
+		 * which we forced in the renesas_fw_callback().
+		 */
+		return;
+	}
+
+	xhci_pci_remove(dev);
+}
+
+static const struct pci_device_id pci_ids[] = {
+	{ PCI_DEVICE(0x1912, 0x0014),
+		.driver_data =	(unsigned long)&xhci_pci_hc_driver,
+	},
+	{ PCI_DEVICE(0x1912, 0x0015),
+		.driver_data =	(unsigned long)&xhci_pci_hc_driver,
+	},
+	{ /* sentinal */ }
+};
+MODULE_DEVICE_TABLE(pci, pci_ids);
+
+static struct pci_driver renesas_xhci_pci_driver = {
+	.name =		"renesas xhci",
+	.id_table =	pci_ids,
+
+	.probe =	renesas_xhci_pci_probe,
+	.remove =	renesas_xhci_pci_remove,
+	/* suspend and resume implemented later */
+
+	.shutdown =	usb_hcd_pci_shutdown,
+#ifdef CONFIG_PM
+	.driver = {
+		.pm = &usb_hcd_pci_pm_ops
+	},
+#endif
+};
+
+static int __init xhci_pci_init(void)
+{
+	xhci_init_driver(&xhci_pci_hc_driver, &xhci_pci_overrides);
+#ifdef CONFIG_PM
+	xhci_pci_hc_driver.pci_suspend = xhci_pci_suspend;
+	xhci_pci_hc_driver.pci_resume = xhci_pci_resume;
+#endif
+	return pci_register_driver(&renesas_xhci_pci_driver);
+}
+module_init(xhci_pci_init);
+
+static void __exit xhci_pci_exit(void)
+{
+	pci_unregister_driver(&renesas_xhci_pci_driver);
+}
+module_exit(xhci_pci_exit);
+
+MODULE_DESCRIPTION("xHCI PCI Host Controller Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index bbd616324..00dfe42c9 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -15,6 +15,7 @@
 
 #include "xhci.h"
 #include "xhci-trace.h"
+#include "xhci-pci.h"
 
 #define SSIC_PORT_NUM		2
 #define SSIC_PORT_CFG2		0x880c
@@ -64,8 +65,6 @@ static const char hcd_name[] = "xhci_hcd";
 
 static struct hc_driver __read_mostly xhci_pci_hc_driver;
 
-static int xhci_pci_setup(struct usb_hcd *hcd);
-
 static const struct xhci_driver_overrides xhci_pci_overrides __initconst = {
 	.reset = xhci_pci_setup,
 };
@@ -292,7 +291,7 @@ static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev) { }
 #endif /* CONFIG_ACPI */
 
 /* called during probe() after chip reset completes */
-static int xhci_pci_setup(struct usb_hcd *hcd)
+int xhci_pci_setup(struct usb_hcd *hcd)
 {
 	struct xhci_hcd		*xhci;
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
@@ -320,12 +319,13 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	/* Find any debug ports */
 	return xhci_pci_reinit(xhci, pdev);
 }
+EXPORT_SYMBOL_GPL(xhci_pci_setup);
 
 /*
  * We need to register our own PCI probe function (instead of the USB core's
  * function) in order to create a second roothub under xHCI.
  */
-static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	int retval;
 	struct xhci_hcd *xhci;
@@ -388,8 +388,9 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	pm_runtime_put_noidle(&dev->dev);
 	return retval;
 }
+EXPORT_SYMBOL_GPL(xhci_pci_probe);
 
-static void xhci_pci_remove(struct pci_dev *dev)
+void xhci_pci_remove(struct pci_dev *dev)
 {
 	struct xhci_hcd *xhci;
 
@@ -411,6 +412,7 @@ static void xhci_pci_remove(struct pci_dev *dev)
 
 	usb_hcd_pci_remove(dev);
 }
+EXPORT_SYMBOL_GPL(xhci_pci_remove);
 
 #ifdef CONFIG_PM
 /*
@@ -467,7 +469,7 @@ static void xhci_pme_quirk(struct usb_hcd *hcd)
 	readl(reg);
 }
 
-static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
+int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
@@ -492,8 +494,9 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(xhci_pci_suspend);
 
-static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
+int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 {
 	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
@@ -541,6 +544,7 @@ static void xhci_pci_shutdown(struct usb_hcd *hcd)
 	if (xhci->quirks & XHCI_SPURIOUS_WAKEUP)
 		pci_set_power_state(pdev, PCI_D3hot);
 }
+EXPORT_SYMBOL_GPL(xhci_pci_resume);
 #endif /* CONFIG_PM */
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/xhci-pci.h b/drivers/usb/host/xhci-pci.h
new file mode 100644
index 000000000..587f71dc5
--- /dev/null
+++ b/drivers/usb/host/xhci-pci.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2008 Intel Corp. */
+
+#ifndef XHCI_PCI_H
+#define XHCI_PCI_H
+
+int xhci_pci_setup(struct usb_hcd *hcd);
+
+int xhci_pci_probe(struct pci_dev *pdev,
+		   const struct pci_device_id *id);
+
+void xhci_pci_remove(struct pci_dev *dev);
+
+int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup);
+
+int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated);
+
+#endif
diff --git a/drivers/usb/host/xhci_sunxi.c b/drivers/usb/host/xhci_sunxi.c
new file mode 100644
index 000000000..859686986
--- /dev/null
+++ b/drivers/usb/host/xhci_sunxi.c
@@ -0,0 +1,798 @@
+/*
+ * drivers/usb/host/xhci_sunxi.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * wangjx, 2016-9-9, create this file
+ *
+ * SoftWinner XHCI Driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <linux/clk.h>
+#include "sunxi-hci.h"
+#include "xhci.h"
+
+#if IS_ENABLED(CONFIG_PM)
+static void sunxi_xhci_resume_work(struct work_struct *work);
+#endif
+
+#define  SUNXI_XHCI_NAME	"sunxi-xhci"
+static const char xhci_name[] = SUNXI_XHCI_NAME;
+#define SUNXI_ALIGN_MASK		(16 - 1)
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_XHCI)
+#define  SUNXI_XHCI_OF_MATCH	"allwinner,sunxi-xhci"
+#else
+#define  SUNXI_XHCI_OF_MATCH   "NULL"
+#endif
+
+static void sunxi_xhci_open_clock(struct sunxi_hci_hcd *sunxi_xhci);
+static void sunxi_set_mode(struct sunxi_hci_hcd *sunxi_xhci, u32 mode);
+static void sunxi_core_soft_reset(void __iomem *regs);
+static int sunxi_core_open_phy(void __iomem *regs);
+
+static struct sunxi_hci_hcd *g_sunxi_xhci;
+static struct sunxi_hci_hcd *g_dev_data;
+
+static ssize_t xhci_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+
+	if (dev == NULL) {
+		DMSG_PANIC("Argment is invalid\n");
+		return 0;
+	}
+
+	sunxi_xhci = dev->platform_data;
+	if (sunxi_xhci == NULL) {
+		DMSG_PANIC("sunxi_xhci is null\n");
+		return 0;
+	}
+
+	return sprintf(buf, "xhci:%d, probe:%u\n",
+			sunxi_xhci->usbc_no, sunxi_xhci->probe);
+}
+
+static ssize_t xhci_enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	int value = 0;
+	int ret = 0;
+
+	if (dev == NULL) {
+		DMSG_PANIC("Argment is invalid\n");
+		return count;
+	}
+
+	sunxi_xhci = dev->platform_data;
+	if (sunxi_xhci == NULL) {
+		DMSG_PANIC("sunxi_xhci is null\n");
+		return count;
+	}
+
+	ret = kstrtoint(buf, 10, &value);
+	if (ret != 0)
+		return -EINVAL;
+	if (value == 1)
+		sunxi_usb_enable_xhci();
+	else if (value == 0)
+		sunxi_usb_disable_xhci();
+	else
+		DMSG_INFO("unknown value (%d)\n", value);
+
+	return count;
+}
+
+static DEVICE_ATTR(xhci_enable, 0664, xhci_enable_show, xhci_enable_store);
+
+static int xhci_host2_test_mode(void __iomem *regs, int param)
+{
+	int reg_value = 0;
+
+	switch (param) {
+	case TEST_J:
+		DMSG_INFO("xhci_host2_test_mode: TEST_J\n");
+		break;
+	case TEST_K:
+		DMSG_INFO("xhci_host2_test_mode: TEST_K\n");
+		break;
+	case TEST_SE0_NAK:
+		DMSG_INFO("xhci_host2_test_mode: TEST_SE0_NAK\n");
+		break;
+	case TEST_PACKET:
+		DMSG_INFO("xhci_host2_test_mode: TEST_PACKET\n");
+		break;
+	case TEST_FORCE_EN:
+		DMSG_INFO("xhci_host2_test_mode: TEST_FORCE_EN\n");
+		break;
+
+	default:
+		DMSG_INFO("not support test mode(%d)\n", param);
+		return -1;
+	}
+
+	reg_value = USBC_Readl(regs + XHCI_OP_REGS_HCPORT1SC);
+	reg_value &= ~(0x1 << 9);
+	USBC_Writel(reg_value, regs + XHCI_OP_REGS_HCPORT1SC);
+	msleep(20);
+
+	reg_value = USBC_Readl(regs + XHCI_OP_REGS_HCUSBCMD);
+	reg_value &= ~(0x1 << 0);
+	USBC_Writel(reg_value, regs + XHCI_OP_REGS_HCUSBCMD);
+	msleep(20);
+
+	reg_value = USBC_Readl(regs + XHCI_OP_REGS_HCUSBSTS);
+	reg_value &= ~(0x1 << 0);
+	USBC_Writel(reg_value, regs + XHCI_OP_REGS_HCUSBSTS);
+	msleep(20);
+	DMSG_INFO("Halted: 0x%x, param: %d\n",
+			USBC_Readl(regs + XHCI_OP_REGS_HCUSBSTS), param);
+
+	reg_value = USBC_Readl(regs + XHCI_OP_REGS_HCPORT1PMSC);
+	reg_value |= (param << 28);
+	USBC_Writel(reg_value, regs + XHCI_OP_REGS_HCPORT1PMSC);
+	msleep(20);
+	DMSG_INFO("test_code: %x\n",
+			USBC_Readl(regs + XHCI_OP_REGS_HCPORT1PMSC));
+
+	return 0;
+}
+
+static ssize_t ed_test_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	struct sunxi_hci_hcd *dev_data = NULL;
+
+	if (dev == NULL) {
+		DMSG_PANIC("Argment is invalid\n");
+		return 0;
+	}
+
+	sunxi_xhci = g_sunxi_xhci;
+	dev_data = g_dev_data;
+	if (sunxi_xhci == NULL) {
+		DMSG_PANIC("sunxi_xhci is null\n");
+		return 0;
+	}
+
+	return sprintf(buf, "USB2.0 host test mode:\n"
+				"echo:\ntest_j_state\ntest_k_state\ntest_se0_nak\n"
+				"test_pack\ntest_force_enable\n\n"
+				"USB3.0 host test mode:\n"
+				"echo:\ntest_host3\n");
+}
+
+static ssize_t ed_test_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	struct sunxi_hci_hcd *dev_data = NULL;
+	struct usb_hcd *hcd = NULL;
+	u32 testmode = 0;
+
+	if (dev == NULL) {
+		DMSG_PANIC("Argment is invalid\n");
+		return count;
+	}
+
+	sunxi_xhci = g_sunxi_xhci;
+	dev_data = g_dev_data;
+	if (sunxi_xhci == NULL) {
+		DMSG_PANIC("sunxi_xhci is null\n");
+		return count;
+	}
+
+	if (dev_data->probe == 0) {
+		DMSG_INFO("[%s]: is disable, can not enter test mode\n",
+			dev_data->hci_name);
+		return count;
+	}
+
+	hcd = dev_get_drvdata(&sunxi_xhci->pdev->dev);
+	if (hcd == NULL) {
+		DMSG_PANIC("xhci hcd is null\n");
+		return count;
+	}
+
+	/* USB3.0 test mode */
+	if (!strncmp(buf, "test_host3", 10)) {
+		DMSG_INFO("xhci usb3.0 host test mode\n");
+		sunxi_usb_disable_xhci();
+		sunxi_xhci_open_clock(dev_data);
+		sunxi_core_open_phy(sunxi_xhci->regs);
+		sunxi_core_soft_reset(sunxi_xhci->regs);
+		sunxi_set_mode(sunxi_xhci, SUNXI_GCTL_PRTCAP_HOST);
+		return count;
+	}
+
+	/* USB2.0 test mode */
+	if (!strncmp(buf, "test_j_state", 12))
+		testmode = TEST_J;
+	else if (!strncmp(buf, "test_k_state", 12))
+		testmode = TEST_K;
+	else if (!strncmp(buf, "test_se0_nak", 12))
+		testmode = TEST_SE0_NAK;
+	else if (!strncmp(buf, "test_pack", 9))
+		testmode = TEST_PACKET;
+	else if (!strncmp(buf, "test_force_enable", 17))
+		testmode = TEST_FORCE_EN;
+	else
+		testmode = 0;
+
+	xhci_host2_test_mode(hcd->regs, testmode);
+
+	return count;
+}
+
+static DEVICE_ATTR(ed_test, 0664, ed_test_show, ed_test_store);
+
+/**
+ * sunxi_core_soft_reset - Issues core soft reset and PHY reset
+ * @sunxi_xhci: pointer to our context structure
+ */
+static void sunxi_core_soft_reset(void __iomem *regs)
+{
+	int reg = 0;
+
+	/* Before Resetting PHY, put Core in Reset */
+	reg = USBC_Readl(regs + (SUNXI_GLOBALS_REGS_GCTL - SUNXI_GLOBALS_REGS_START));
+	reg |= SUNXI_GCTL_CORESOFTRESET;
+	USBC_Writel(reg, regs + (SUNXI_GLOBALS_REGS_GCTL - SUNXI_GLOBALS_REGS_START));
+
+	/* Assert USB3 PHY reset */
+	reg = USBC_Readl(regs + (SUNXI_GUSB3PIPECTL(0) - SUNXI_GLOBALS_REGS_START));
+	reg |= SUNXI_USB3PIPECTL_PHYSOFTRST;
+	USBC_Writel(reg, regs + (SUNXI_GUSB3PIPECTL(0) - SUNXI_GLOBALS_REGS_START));
+
+	/* Assert USB2 PHY reset */
+	reg = USBC_Readl(regs + (SUNXI_GUSB2PHYCFG(0) - SUNXI_GLOBALS_REGS_START));
+	reg |= SUNXI_USB2PHYCFG_PHYSOFTRST;
+	USBC_Writel(reg, regs + (SUNXI_GUSB2PHYCFG(0) - SUNXI_GLOBALS_REGS_START));
+
+	mdelay(100);
+
+	/* Clear USB3 PHY reset */
+	reg = USBC_Readl(regs + (SUNXI_GUSB3PIPECTL(0) - SUNXI_GLOBALS_REGS_START));
+	reg &= ~SUNXI_USB3PIPECTL_PHYSOFTRST;
+	USBC_Writel(reg, regs + (SUNXI_GUSB3PIPECTL(0) - SUNXI_GLOBALS_REGS_START));
+
+	/* Clear USB2 PHY reset */
+	reg = USBC_Readl(regs + (SUNXI_GUSB2PHYCFG(0) - SUNXI_GLOBALS_REGS_START));
+	reg &= ~SUNXI_USB2PHYCFG_PHYSOFTRST;
+	USBC_Writel(reg, regs + (SUNXI_GUSB2PHYCFG(0) - SUNXI_GLOBALS_REGS_START));
+
+	mdelay(100);
+
+	/* After PHYs are stable we can take Core out of reset state */
+	reg = USBC_Readl(regs + (SUNXI_GLOBALS_REGS_GCTL - SUNXI_GLOBALS_REGS_START));
+	reg &= ~SUNXI_GCTL_CORESOFTRESET;
+	USBC_Writel(reg, regs + (SUNXI_GLOBALS_REGS_GCTL - SUNXI_GLOBALS_REGS_START));
+}
+
+static int sunxi_core_open_phy(void __iomem *regs)
+{
+	int reg_val = 0;
+
+	reg_val = USBC_Readl(regs + (SUNXI_PHY_EXTERNAL_CONTROL - SUNXI_GLOBALS_REGS_START));
+	reg_val |= SUNXI_PEC_EXTERN_VBUS; /* Use extern vbus to phy */
+	reg_val |= SUNXI_PEC_SSC_EN; /* SSC_EN */
+	reg_val |= SUNXI_PEC_REF_SSP_EN; /*REF_SSP_EN */
+	USBC_Writel(reg_val, regs + (SUNXI_PHY_EXTERNAL_CONTROL - SUNXI_GLOBALS_REGS_START));
+
+	reg_val = USBC_Readl(regs + (SUNXI_PIPE_CLOCK_CONTROL - SUNXI_GLOBALS_REGS_START));
+	reg_val |= SUNXI_PPC_PIPE_CLK_OPEN; /* open PIPE clock */
+	USBC_Writel(reg_val, regs + (SUNXI_PIPE_CLOCK_CONTROL - SUNXI_GLOBALS_REGS_START));
+
+	reg_val = USBC_Readl(regs + (SUNXI_APP - SUNXI_GLOBALS_REGS_START));
+	reg_val |= SUNXI_APP_FOCE_VBUS; /* open PIPE clock */
+	USBC_Writel(reg_val, regs + (SUNXI_APP - SUNXI_GLOBALS_REGS_START));
+
+	/* It is set 0x0047fc87 on bare-metal.*/
+	USBC_Writel(0x0047fc57, regs + (SUNXI_PHY_TUNE_LOW - SUNXI_GLOBALS_REGS_START));
+
+	reg_val = USBC_Readl(regs + (SUNXI_PHY_TUNE_HIGH - SUNXI_GLOBALS_REGS_START));
+	reg_val |= SUNXI_TXVBOOSTLVL(0x7);
+	reg_val |= SUNXI_LOS_BIAS(0x7);
+
+	reg_val &= ~(SUNXI_TX_SWING_FULL(0x7f));
+	reg_val |= SUNXI_TX_SWING_FULL(0x55);
+
+	reg_val &= ~(SUNXI_TX_DEEMPH_6DB(0x3f));
+	reg_val |= SUNXI_TX_DEEMPH_6DB(0x20);
+
+	reg_val &= ~(SUNXI_TX_DEEMPH_3P5DB(0x3f));
+	reg_val |= SUNXI_TX_DEEMPH_3P5DB(0x15);
+	USBC_Writel(reg_val, regs + (SUNXI_PHY_TUNE_HIGH - SUNXI_GLOBALS_REGS_START));
+
+	/* Enable USB2.0 PHY Suspend mode. */
+	reg_val = USBC_Readl(regs + (SUNXI_GUSB2PHYCFG(0) - SUNXI_GLOBALS_REGS_START));
+	reg_val |= SUNXI_USB2PHYCFG_SUSPHY;
+	USBC_Writel(reg_val, regs + (SUNXI_GUSB2PHYCFG(0) - SUNXI_GLOBALS_REGS_START));
+
+	/* Enable SOFITPSYNC for suspend. */
+	reg_val = USBC_Readl(regs + (SUNXI_GLOBALS_REGS_GCTL - SUNXI_GLOBALS_REGS_START));
+	reg_val |= SUNXI_GCTL_SOFITPSYNC;
+	USBC_Writel(reg_val, regs + (SUNXI_GLOBALS_REGS_GCTL - SUNXI_GLOBALS_REGS_START));
+
+	return 0;
+}
+
+static void sunxi_xhci_open_clock(struct sunxi_hci_hcd *sunxi_xhci)
+{
+	sunxi_xhci->open_clock(sunxi_xhci, 0);
+}
+
+static void sunxi_xhci_set_vbus(struct sunxi_hci_hcd *sunxi_xhci, int is_on)
+{
+	sunxi_xhci->set_power(sunxi_xhci, is_on);
+}
+
+static void sunxi_start_xhci(struct sunxi_hci_hcd *sunxi_xhci)
+{
+	sunxi_xhci->open_clock(sunxi_xhci, 1);
+	sunxi_xhci->set_power(sunxi_xhci, 1);
+}
+
+static void sunxi_stop_xhci(struct sunxi_hci_hcd *sunxi_xhci)
+{
+	sunxi_xhci->set_power(sunxi_xhci, 0);
+	sunxi_xhci->close_clock(sunxi_xhci, 0);
+}
+
+static void sunxi_set_mode(struct sunxi_hci_hcd *sunxi_xhci, u32 mode)
+{
+	u32 reg;
+
+	reg = USBC_Readl(sunxi_xhci->regs + (SUNXI_GLOBALS_REGS_GCTL - SUNXI_GLOBALS_REGS_START));
+	reg &= ~(SUNXI_GCTL_PRTCAPDIR(SUNXI_GCTL_PRTCAP_OTG));
+	reg |= SUNXI_GCTL_PRTCAPDIR(mode);
+	USBC_Writel(reg, sunxi_xhci->regs + (SUNXI_GLOBALS_REGS_GCTL - SUNXI_GLOBALS_REGS_START));
+}
+
+int xhci_host_init(struct sunxi_hci_hcd *sunxi_xhci)
+{
+	struct platform_device	*xhci;
+	int			ret;
+
+	xhci = platform_device_alloc("xhci-hcd", PLATFORM_DEVID_AUTO);
+	if (!xhci) {
+		dev_err(sunxi_xhci->dev, "couldn't allocate xHCI device\n");
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	dma_set_coherent_mask(&xhci->dev, sunxi_xhci->dev->coherent_dma_mask);
+
+	xhci->dev.parent	= sunxi_xhci->dev;
+	xhci->dev.dma_mask	= sunxi_xhci->dev->dma_mask;
+	xhci->dev.dma_parms	= sunxi_xhci->dev->dma_parms;
+	xhci->dev.archdata.dma_ops	= sunxi_xhci->dev->archdata.dma_ops;
+	xhci->dev.archdata.dma_coherent	= sunxi_xhci->dev->archdata.dma_coherent;
+
+	sunxi_xhci->pdev = xhci;
+
+	ret = platform_device_add_resources(xhci, sunxi_xhci->xhci_resources,
+						XHCI_RESOURCES_NUM);
+	if (ret) {
+		dev_err(sunxi_xhci->dev, "couldn't add resources to xHCI device\n");
+		goto err1;
+	}
+
+	ret = platform_device_add(xhci);
+	if (ret) {
+		dev_err(sunxi_xhci->dev, "failed to register xHCI device\n");
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	platform_device_put(xhci);
+
+err0:
+	return ret;
+}
+
+void xhci_host_exit(struct sunxi_hci_hcd *sunxi_xhci)
+{
+	platform_device_unregister(sunxi_xhci->pdev);
+}
+
+static int sunxi_xhci_hcd_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	void			*mem;
+
+	struct device		*dev = &pdev->dev;
+
+	struct resource		*res;
+	void __iomem	*regs;
+
+	if (pdev == NULL) {
+		DMSG_PANIC("%s, Argment is invalid\n", __func__);
+		return -1;
+	}
+
+	/* if usb is disabled, can not probe */
+	if (usb_disabled()) {
+		DMSG_PANIC("usb hcd is disabled\n");
+		return -ENODEV;
+	}
+
+	mem = devm_kzalloc(dev, sizeof(*sunxi_xhci) + SUNXI_ALIGN_MASK, GFP_KERNEL);
+	if (!mem) {
+		dev_err(dev, "not enough memory\n");
+		return -ENOMEM;
+	}
+	sunxi_xhci = PTR_ALIGN(mem, SUNXI_ALIGN_MASK + 1);
+	sunxi_xhci->mem = mem;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(dev, "missing IRQ\n");
+		return -ENODEV;
+	}
+	sunxi_xhci->xhci_resources[1].start = res->start;
+	sunxi_xhci->xhci_resources[1].end = res->end;
+	sunxi_xhci->xhci_resources[1].flags = res->flags;
+	sunxi_xhci->xhci_resources[1].name = res->name;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "missing memory resource\n");
+		return -ENODEV;
+	}
+	sunxi_xhci->xhci_resources[0].start = res->start;
+	sunxi_xhci->xhci_resources[0].end = sunxi_xhci->xhci_resources[0].start +
+					XHCI_REGS_END;
+	sunxi_xhci->xhci_resources[0].flags = res->flags;
+	sunxi_xhci->xhci_resources[0].name = res->name;
+
+	/*
+	* Request memory region but exclude xHCI regs,
+	* since it will be requested by the xhci-plat driver.
+	*/
+	res = devm_request_mem_region(dev, res->start + SUNXI_GLOBALS_REGS_START,
+			resource_size(res) - SUNXI_GLOBALS_REGS_START,
+			dev_name(dev));
+	if (!res) {
+		dev_err(dev, "can't request mem region\n");
+		return -ENOMEM;
+	}
+
+	regs = devm_ioremap_nocache(dev, res->start, resource_size(res));
+	if (!regs) {
+		dev_err(dev, "ioremap failed\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&sunxi_xhci->lock);
+
+	sunxi_xhci->regs	= regs;
+	sunxi_xhci->regs_size	= resource_size(res);
+	sunxi_xhci->dev	= dev;
+
+	dev->dma_mask	= dev->parent->dma_mask;
+	dev->dma_parms	= dev->parent->dma_parms;
+	dma_set_coherent_mask(dev, dev->parent->coherent_dma_mask);
+
+	ret = init_sunxi_hci(pdev, SUNXI_USB_XHCI);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "init_sunxi_hci is fail\n");
+		return 0;
+	}
+
+	platform_set_drvdata(pdev, sunxi_xhci);
+
+	sunxi_start_xhci(pdev->dev.platform_data);
+	sunxi_core_open_phy(sunxi_xhci->regs);
+	sunxi_set_mode(sunxi_xhci, SUNXI_GCTL_PRTCAP_HOST);
+
+	xhci_host_init(sunxi_xhci);
+
+	device_create_file(&pdev->dev, &dev_attr_xhci_enable);
+	device_create_file(&pdev->dev, &dev_attr_ed_test);
+
+	g_sunxi_xhci = sunxi_xhci;
+	g_dev_data = pdev->dev.platform_data;
+
+	g_dev_data->probe = 1;
+
+#if IS_ENABLED(CONFIG_PM)
+	if (!g_dev_data->wakeup_suspend)
+		INIT_WORK(&g_dev_data->resume_work, sunxi_xhci_resume_work);
+#endif
+
+	return 0;
+}
+
+static int sunxi_xhci_hcd_remove(struct platform_device *pdev)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	struct sunxi_hci_hcd *dev_data = NULL;
+
+	if (pdev == NULL) {
+		DMSG_PANIC("%s, Argment is invalid\n", __func__);
+		return -1;
+	}
+
+	sunxi_xhci = g_sunxi_xhci;
+	dev_data = g_dev_data;
+	if (sunxi_xhci == NULL) {
+		DMSG_PANIC("%s, sunxi_xhci is null\n", __func__);
+		return -1;
+	}
+
+	device_remove_file(&pdev->dev, &dev_attr_xhci_enable);
+
+	xhci_host_exit(sunxi_xhci);
+	sunxi_stop_xhci(dev_data);
+
+	dev_data->probe = 0;
+
+	return 0;
+}
+
+static void sunxi_xhci_hcd_shutdown(struct platform_device *pdev)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	struct sunxi_hci_hcd *dev_data = NULL;
+
+	if (pdev == NULL) {
+		DMSG_PANIC("%s, Argment is invalid\n", __func__);
+		return;
+	}
+
+	sunxi_xhci = g_sunxi_xhci;
+	dev_data = g_dev_data;
+	if (sunxi_xhci == NULL) {
+		DMSG_PANIC("%s, is null\n", __func__);
+		return;
+	}
+
+	if (dev_data->probe == 0) {
+		DMSG_INFO("%s, %s is disable, need not shutdown\n",  __func__, sunxi_xhci->hci_name);
+		return;
+	}
+
+	DMSG_INFO("[%s]: xhci shutdown start\n", sunxi_xhci->hci_name);
+
+	usb_hcd_platform_shutdown(sunxi_xhci->pdev);
+
+	DMSG_INFO("[%s]: xhci shutdown end\n", sunxi_xhci->hci_name);
+
+	return;
+}
+
+int sunxi_usb_disable_xhci(void)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	struct sunxi_hci_hcd *dev_data = NULL;
+
+	sunxi_xhci = g_sunxi_xhci;
+	dev_data = g_dev_data;
+	if (sunxi_xhci == NULL || dev_data == NULL) {
+		DMSG_PANIC("sunxi_xhci is null\n");
+		return -1;
+	}
+
+	if (dev_data->probe == 0) {
+		DMSG_PANIC("sunxi_xhci is disable, can not disable again\n");
+		return -1;
+	}
+
+	dev_data->probe = 0;
+
+	DMSG_INFO("[%s]: sunxi_usb_disable_xhci\n", sunxi_xhci->hci_name);
+
+	xhci_host_exit(sunxi_xhci);
+	sunxi_stop_xhci(dev_data);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_usb_disable_xhci);
+
+int sunxi_usb_enable_xhci(void)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	struct sunxi_hci_hcd *dev_data = NULL;
+
+	sunxi_xhci = g_sunxi_xhci;
+	dev_data = g_dev_data;
+	if (sunxi_xhci == NULL || dev_data == NULL) {
+		DMSG_PANIC("sunxi_xhci is null\n");
+		return -1;
+	}
+
+	if (dev_data->probe == 1) {
+		DMSG_PANIC("sunxi_xhci is already enable, can not enable again\n");
+		return -1;
+	}
+
+	dev_data->probe = 1;
+
+	DMSG_INFO("[%s]: sunxi_usb_enable_xhci\n", sunxi_xhci->hci_name);
+
+	sunxi_start_xhci(dev_data);
+	sunxi_core_open_phy(sunxi_xhci->regs);
+	sunxi_set_mode(sunxi_xhci, SUNXI_GCTL_PRTCAP_HOST);
+
+	xhci_host_init(sunxi_xhci);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_usb_enable_xhci);
+
+#if IS_ENABLED(CONFIG_PM)
+static int sunxi_xhci_hcd_suspend(struct device *dev)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	struct sunxi_hci_hcd *dev_data = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct xhci_hcd *xhci = NULL;
+
+	if (dev == NULL) {
+		DMSG_PANIC("%s, Argment is invalid\n", __func__);
+		return 0;
+	}
+
+	sunxi_xhci = g_sunxi_xhci;
+	dev_data = g_dev_data;
+	if (sunxi_xhci == NULL) {
+		DMSG_PANIC("sunxi_xhci is null\n");
+		return 0;
+	}
+
+	if (dev_data->probe == 0) {
+		DMSG_INFO("[%s]: is disable, need not suspend\n",
+			dev_data->hci_name);
+		return 0;
+	}
+
+	hcd = dev_get_drvdata(&sunxi_xhci->pdev->dev);
+	if (hcd == NULL) {
+		DMSG_PANIC("xhci hcd is null\n");
+		return 0;
+	}
+
+	xhci = hcd_to_xhci(hcd);
+	if (xhci == NULL) {
+		DMSG_PANIC("xhci is null\n");
+		return 0;
+	}
+
+	if (dev_data->wakeup_suspend) {
+		DMSG_INFO("[%s]: not suspend\n", dev_data->hci_name);
+	} else {
+		DMSG_INFO("[%s]: sunxi_xhci_hcd_suspend\n", dev_data->hci_name);
+
+		xhci_suspend(xhci, false);
+		sunxi_stop_xhci(dev_data);
+
+		cancel_work_sync(&dev_data->resume_work);
+	}
+
+	return 0;
+}
+
+static void sunxi_xhci_resume_work(struct work_struct *work)
+{
+	struct sunxi_hci_hcd *dev_data = NULL;
+
+	dev_data = container_of(work, struct sunxi_hci_hcd, resume_work);
+
+	/* Waiting hci to resume. */
+	msleep(5000);
+
+	sunxi_xhci_set_vbus(dev_data, 1);
+}
+
+static int sunxi_xhci_hcd_resume(struct device *dev)
+{
+	struct sunxi_hci_hcd *sunxi_xhci = NULL;
+	struct sunxi_hci_hcd *dev_data = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct xhci_hcd *xhci = NULL;
+
+	if (dev == NULL) {
+		DMSG_PANIC("Argment is invalid\n");
+		return 0;
+	}
+
+	sunxi_xhci = g_sunxi_xhci;
+	dev_data = g_dev_data;
+	if (sunxi_xhci == NULL) {
+		DMSG_PANIC("sunxi_xhci is null\n");
+		return 0;
+	}
+
+	if (dev_data->probe == 0) {
+		DMSG_INFO("[%s]: is disable, need not resume\n",
+			dev_data->hci_name);
+		return 0;
+	}
+
+	hcd = dev_get_drvdata(&sunxi_xhci->pdev->dev);
+	if (hcd == NULL) {
+		DMSG_PANIC("xhci hcd is null\n");
+		return 0;
+	}
+
+	xhci = hcd_to_xhci(hcd);
+	if (xhci == NULL) {
+		DMSG_PANIC("xhci is null\n");
+		return 0;
+	}
+
+	if (dev_data->wakeup_suspend) {
+		DMSG_INFO("[%s]: controller not suspend, need not resume\n",
+				dev_data->hci_name);
+	} else {
+		DMSG_INFO("[%s]: sunxi_xhci_hcd_resume\n", dev_data->hci_name);
+
+		sunxi_xhci_open_clock(dev_data);
+		sunxi_core_open_phy(sunxi_xhci->regs);
+		sunxi_set_mode(sunxi_xhci, SUNXI_GCTL_PRTCAP_HOST);
+		xhci_resume(xhci, false);
+
+		schedule_work(&dev_data->resume_work);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops  xhci_pmops = {
+	.suspend	= sunxi_xhci_hcd_suspend,
+	.resume		= sunxi_xhci_hcd_resume,
+};
+#endif
+
+static const struct of_device_id sunxi_xhci_match[] = {
+	{.compatible = SUNXI_XHCI_OF_MATCH, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_xhci_match);
+
+static struct platform_driver sunxi_xhci_hcd_driver = {
+	.probe  = sunxi_xhci_hcd_probe,
+	.remove	= sunxi_xhci_hcd_remove,
+	.shutdown = sunxi_xhci_hcd_shutdown,
+	.driver = {
+			.name	= xhci_name,
+			.owner	= THIS_MODULE,
+#if IS_ENABLED(CONFIG_PM)
+			.pm	= &xhci_pmops,
+#endif
+			.of_match_table = sunxi_xhci_match,
+		}
+};
+
+module_platform_driver(sunxi_xhci_hcd_driver);
+
+MODULE_ALIAS("platform:sunxi xhci");
+MODULE_AUTHOR("wangjx <wangjx@allwinnertech.com>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Allwinnertech Xhci Controller Driver");
diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 52f8e2b57..767c5da90 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -116,6 +116,13 @@ config USB_MUSB_JZ4740
 	depends on USB_MUSB_GADGET
 	depends on USB=n || USB_OTG_BLACKLIST_HUB
 
+config USB_MUSB_MEDIATEK
+	tristate "MediaTek platforms"
+	depends on ARCH_MEDIATEK || COMPILE_TEST
+	depends on NOP_USB_XCEIV
+	depends on GENERIC_PHY
+	select USB_ROLE_SWITCH
+
 config USB_MUSB_AM335X_CHILD
 	tristate
 
@@ -142,7 +149,7 @@ config USB_UX500_DMA
 
 config USB_INVENTRA_DMA
 	bool 'Inventra'
-	depends on USB_MUSB_OMAP2PLUS
+	depends on USB_MUSB_OMAP2PLUS || USB_MUSB_MEDIATEK
 	help
 	  Enable DMA transfers using Mentor's engine.
 
diff --git a/drivers/usb/musb/Makefile b/drivers/usb/musb/Makefile
index 3a88c79e6..63d82d0fa 100644
--- a/drivers/usb/musb/Makefile
+++ b/drivers/usb/musb/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_USB_MUSB_DA8XX)			+= da8xx.o
 obj-$(CONFIG_USB_MUSB_UX500)			+= ux500.o
 obj-$(CONFIG_USB_MUSB_JZ4740)			+= jz4740.o
 obj-$(CONFIG_USB_MUSB_SUNXI)			+= sunxi.o
+obj-$(CONFIG_USB_MUSB_MEDIATEK)      		+= mediatek.o
 
 
 obj-$(CONFIG_USB_MUSB_AM335X_CHILD)		+= musb_am335x.o
diff --git a/drivers/usb/musb/mediatek.c b/drivers/usb/musb/mediatek.c
new file mode 100644
index 000000000..df013d66d
--- /dev/null
+++ b/drivers/usb/musb/mediatek.c
@@ -0,0 +1,588 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 MediaTek Inc.
+ *
+ * Author:
+ *  Min Guo <min.guo@mediatek.com>
+ *  Yonglong Wu <yonglong.wu@mediatek.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/usb/role.h>
+#include <linux/usb/usb_phy_generic.h>
+#include "musb_core.h"
+#include "musb_dma.h"
+
+#define USB_L1INTS		0x00a0
+#define USB_L1INTM		0x00a4
+#define MTK_MUSB_TXFUNCADDR	0x0480
+
+/* MediaTek controller toggle enable and status reg */
+#define MUSB_RXTOG		0x80
+#define MUSB_RXTOGEN		0x82
+#define MUSB_TXTOG		0x84
+#define MUSB_TXTOGEN		0x86
+#define MTK_TOGGLE_EN		GENMASK(15, 0)
+
+#define TX_INT_STATUS		BIT(0)
+#define RX_INT_STATUS		BIT(1)
+#define USBCOM_INT_STATUS	BIT(2)
+#define DMA_INT_STATUS		BIT(3)
+
+#define DMA_INTR_STATUS_MSK	GENMASK(7, 0)
+#define DMA_INTR_UNMASK_SET_MSK	GENMASK(31, 24)
+
+struct mtk_glue {
+	struct device *dev;
+	struct musb *musb;
+	struct platform_device *musb_pdev;
+	struct platform_device *usb_phy;
+	struct phy *phy;
+	struct usb_phy *xceiv;
+	enum phy_mode phy_mode;
+	struct clk *main;
+	struct clk *mcu;
+	struct clk *univpll;
+	enum usb_role role;
+	struct usb_role_switch *role_sw;
+};
+
+static int mtk_musb_clks_get(struct mtk_glue *glue)
+{
+	struct device *dev = glue->dev;
+
+	glue->main = devm_clk_get(dev, "main");
+	if (IS_ERR(glue->main)) {
+		dev_err(dev, "fail to get main clock\n");
+		return PTR_ERR(glue->main);
+	}
+
+	glue->mcu = devm_clk_get(dev, "mcu");
+	if (IS_ERR(glue->mcu)) {
+		dev_err(dev, "fail to get mcu clock\n");
+		return PTR_ERR(glue->mcu);
+	}
+
+	glue->univpll = devm_clk_get(dev, "univpll");
+	if (IS_ERR(glue->univpll)) {
+		dev_err(dev, "fail to get univpll clock\n");
+		return PTR_ERR(glue->univpll);
+	}
+
+	return 0;
+}
+
+static int mtk_musb_clks_enable(struct mtk_glue *glue)
+{
+	int ret;
+
+	ret = clk_prepare_enable(glue->main);
+	if (ret) {
+		dev_err(glue->dev, "failed to enable main clock\n");
+		goto err_main_clk;
+	}
+
+	ret = clk_prepare_enable(glue->mcu);
+	if (ret) {
+		dev_err(glue->dev, "failed to enable mcu clock\n");
+		goto err_mcu_clk;
+	}
+
+	ret = clk_prepare_enable(glue->univpll);
+	if (ret) {
+		dev_err(glue->dev, "failed to enable univpll clock\n");
+		goto err_univpll_clk;
+	}
+
+	return 0;
+
+err_univpll_clk:
+	clk_disable_unprepare(glue->mcu);
+err_mcu_clk:
+	clk_disable_unprepare(glue->main);
+err_main_clk:
+	return ret;
+}
+
+static void mtk_musb_clks_disable(struct mtk_glue *glue)
+{
+	clk_disable_unprepare(glue->univpll);
+	clk_disable_unprepare(glue->mcu);
+	clk_disable_unprepare(glue->main);
+}
+
+static int musb_usb_role_sx_set(struct device *dev, enum usb_role role)
+{
+	struct mtk_glue *glue = dev_get_drvdata(dev);
+	struct musb *musb = glue->musb;
+	u8 devctl = readb(musb->mregs + MUSB_DEVCTL);
+	enum usb_role new_role;
+
+	if (role == glue->role)
+		return 0;
+
+	switch (role) {
+	case USB_ROLE_HOST:
+		musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
+		glue->phy_mode = PHY_MODE_USB_HOST;
+		new_role = USB_ROLE_HOST;
+		if (glue->role == USB_ROLE_NONE)
+			phy_power_on(glue->phy);
+
+		devctl |= MUSB_DEVCTL_SESSION;
+		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+		MUSB_HST_MODE(musb);
+		break;
+	case USB_ROLE_DEVICE:
+		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
+		glue->phy_mode = PHY_MODE_USB_DEVICE;
+		new_role = USB_ROLE_DEVICE;
+		devctl &= ~MUSB_DEVCTL_SESSION;
+		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+		if (glue->role == USB_ROLE_NONE)
+			phy_power_on(glue->phy);
+
+		MUSB_DEV_MODE(musb);
+		break;
+	case USB_ROLE_NONE:
+		glue->phy_mode = PHY_MODE_USB_OTG;
+		new_role = USB_ROLE_NONE;
+		devctl &= ~MUSB_DEVCTL_SESSION;
+		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+		if (glue->role != USB_ROLE_NONE)
+			phy_power_off(glue->phy);
+
+		break;
+	default:
+		dev_err(glue->dev, "Invalid State\n");
+		return -EINVAL;
+	}
+
+	glue->role = new_role;
+	phy_set_mode(glue->phy, glue->phy_mode);
+
+	return 0;
+}
+
+static enum usb_role musb_usb_role_sx_get(struct device *dev)
+{
+	struct mtk_glue *glue = dev_get_drvdata(dev);
+
+	return glue->role;
+}
+
+static int mtk_otg_switch_init(struct mtk_glue *glue)
+{
+	struct usb_role_switch_desc role_sx_desc = { 0 };
+
+	role_sx_desc.set = musb_usb_role_sx_set;
+	role_sx_desc.get = musb_usb_role_sx_get;
+	role_sx_desc.fwnode = dev_fwnode(glue->dev);
+	glue->role_sw = usb_role_switch_register(glue->dev, &role_sx_desc);
+
+	return PTR_ERR_OR_ZERO(glue->role_sw);
+}
+
+static void mtk_otg_switch_exit(struct mtk_glue *glue)
+{
+	return usb_role_switch_unregister(glue->role_sw);
+}
+
+static irqreturn_t generic_interrupt(int irq, void *__hci)
+{
+	unsigned long flags;
+	irqreturn_t retval = IRQ_NONE;
+	struct musb *musb = __hci;
+
+	spin_lock_irqsave(&musb->lock, flags);
+	musb->int_usb = musb_clearb(musb->mregs, MUSB_INTRUSB);
+	musb->int_rx = musb_clearw(musb->mregs, MUSB_INTRRX);
+	musb->int_tx = musb_clearw(musb->mregs, MUSB_INTRTX);
+
+	if ((musb->int_usb & MUSB_INTR_RESET) && !is_host_active(musb)) {
+		/* ep0 FADDR must be 0 when (re)entering peripheral mode */
+		musb_ep_select(musb->mregs, 0);
+		musb_writeb(musb->mregs, MUSB_FADDR, 0);
+	}
+
+	if (musb->int_usb || musb->int_tx || musb->int_rx)
+		retval = musb_interrupt(musb);
+
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return retval;
+}
+
+static irqreturn_t mtk_musb_interrupt(int irq, void *dev_id)
+{
+	irqreturn_t retval = IRQ_NONE;
+	struct musb *musb = (struct musb *)dev_id;
+	u32 l1_ints;
+
+	l1_ints = musb_readl(musb->mregs, USB_L1INTS) &
+			musb_readl(musb->mregs, USB_L1INTM);
+
+	if (l1_ints & (TX_INT_STATUS | RX_INT_STATUS | USBCOM_INT_STATUS))
+		retval = generic_interrupt(irq, musb);
+
+#if defined(CONFIG_USB_INVENTRA_DMA)
+	if (l1_ints & DMA_INT_STATUS)
+		retval = dma_controller_irq(irq, musb->dma_controller);
+#endif
+	return retval;
+}
+
+static u32 mtk_musb_busctl_offset(u8 epnum, u16 offset)
+{
+	return MTK_MUSB_TXFUNCADDR + offset + 8 * epnum;
+}
+
+static u8 mtk_musb_clearb(void __iomem *addr, unsigned int offset)
+{
+	u8 data;
+
+	/* W1C */
+	data = musb_readb(addr, offset);
+	musb_writeb(addr, offset, data);
+	return data;
+}
+
+static u16 mtk_musb_clearw(void __iomem *addr, unsigned int offset)
+{
+	u16 data;
+
+	/* W1C */
+	data = musb_readw(addr, offset);
+	musb_writew(addr, offset, data);
+	return data;
+}
+
+static int mtk_musb_set_mode(struct musb *musb, u8 mode)
+{
+	struct device *dev = musb->controller;
+	struct mtk_glue *glue = dev_get_drvdata(dev->parent);
+	enum phy_mode new_mode;
+	enum usb_role new_role;
+
+	switch (mode) {
+	case MUSB_HOST:
+		new_mode = PHY_MODE_USB_HOST;
+		new_role = USB_ROLE_HOST;
+		break;
+	case MUSB_PERIPHERAL:
+		new_mode = PHY_MODE_USB_DEVICE;
+		new_role = USB_ROLE_DEVICE;
+		break;
+	case MUSB_OTG:
+		new_mode = PHY_MODE_USB_OTG;
+		new_role = USB_ROLE_NONE;
+		break;
+	default:
+		dev_err(glue->dev, "Invalid mode request\n");
+		return -EINVAL;
+	}
+
+	if (glue->phy_mode == new_mode)
+		return 0;
+
+	if (musb->port_mode != MUSB_OTG) {
+		dev_err(glue->dev, "Does not support changing modes\n");
+		return -EINVAL;
+	}
+
+	glue->role = new_role;
+	musb_usb_role_sx_set(dev, glue->role);
+	return 0;
+}
+
+static int mtk_musb_init(struct musb *musb)
+{
+	struct device *dev = musb->controller;
+	struct mtk_glue *glue = dev_get_drvdata(dev->parent);
+	int ret;
+
+	glue->musb = musb;
+	musb->phy = glue->phy;
+	musb->xceiv = glue->xceiv;
+	musb->is_host = false;
+	musb->isr = mtk_musb_interrupt;
+
+	/* Set TX/RX toggle enable */
+	musb_writew(musb->mregs, MUSB_TXTOGEN, MTK_TOGGLE_EN);
+	musb_writew(musb->mregs, MUSB_RXTOGEN, MTK_TOGGLE_EN);
+
+	if (musb->port_mode == MUSB_OTG) {
+		ret = mtk_otg_switch_init(glue);
+		if (ret)
+			return ret;
+	}
+
+	ret = phy_init(glue->phy);
+	if (ret)
+		goto err_phy_init;
+
+	ret = phy_power_on(glue->phy);
+	if (ret)
+		goto err_phy_power_on;
+
+	phy_set_mode(glue->phy, glue->phy_mode);
+
+#if defined(CONFIG_USB_INVENTRA_DMA)
+	musb_writel(musb->mregs, MUSB_HSDMA_INTR,
+		    DMA_INTR_STATUS_MSK | DMA_INTR_UNMASK_SET_MSK);
+#endif
+	musb_writel(musb->mregs, USB_L1INTM, TX_INT_STATUS | RX_INT_STATUS |
+		    USBCOM_INT_STATUS | DMA_INT_STATUS);
+	return 0;
+
+err_phy_power_on:
+	phy_exit(glue->phy);
+err_phy_init:
+	mtk_otg_switch_exit(glue);
+	return ret;
+}
+
+static u16 mtk_musb_get_toggle(struct musb_qh *qh, int is_out)
+{
+	struct musb *musb = qh->hw_ep->musb;
+	u8 epnum = qh->hw_ep->epnum;
+	u16 toggle;
+
+	toggle = musb_readw(musb->mregs, is_out ? MUSB_TXTOG : MUSB_RXTOG);
+	return toggle & (1 << epnum);
+}
+
+static u16 mtk_musb_set_toggle(struct musb_qh *qh, int is_out, struct urb *urb)
+{
+	struct musb *musb = qh->hw_ep->musb;
+	u8 epnum = qh->hw_ep->epnum;
+	u16 value, toggle;
+
+	toggle = usb_gettoggle(urb->dev, qh->epnum, is_out);
+
+	if (is_out) {
+		value = musb_readw(musb->mregs, MUSB_TXTOG);
+		value |= toggle << epnum;
+		musb_writew(musb->mregs, MUSB_TXTOG, value);
+	} else {
+		value = musb_readw(musb->mregs, MUSB_RXTOG);
+		value |= toggle << epnum;
+		musb_writew(musb->mregs, MUSB_RXTOG, value);
+	}
+
+	return 0;
+}
+
+static int mtk_musb_exit(struct musb *musb)
+{
+	struct device *dev = musb->controller;
+	struct mtk_glue *glue = dev_get_drvdata(dev->parent);
+
+	mtk_otg_switch_exit(glue);
+	phy_power_off(glue->phy);
+	phy_exit(glue->phy);
+	mtk_musb_clks_disable(glue);
+
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+	return 0;
+}
+
+static const struct musb_platform_ops mtk_musb_ops = {
+	.quirks = MUSB_DMA_INVENTRA,
+	.init = mtk_musb_init,
+	.get_toggle = mtk_musb_get_toggle,
+	.set_toggle = mtk_musb_set_toggle,
+	.exit = mtk_musb_exit,
+#ifdef CONFIG_USB_INVENTRA_DMA
+	.dma_init = musbhs_dma_controller_create_noirq,
+	.dma_exit = musbhs_dma_controller_destroy,
+#endif
+	.clearb = mtk_musb_clearb,
+	.clearw = mtk_musb_clearw,
+	.busctl_offset = mtk_musb_busctl_offset,
+	.set_mode = mtk_musb_set_mode,
+};
+
+#define MTK_MUSB_MAX_EP_NUM	8
+#define MTK_MUSB_RAM_BITS	11
+
+static struct musb_fifo_cfg mtk_musb_mode_cfg[] = {
+	{ .hw_ep_num = 1, .style = FIFO_TX, .maxpacket = 512, },
+	{ .hw_ep_num = 1, .style = FIFO_RX, .maxpacket = 512, },
+	{ .hw_ep_num = 2, .style = FIFO_TX, .maxpacket = 512, },
+	{ .hw_ep_num = 2, .style = FIFO_RX, .maxpacket = 512, },
+	{ .hw_ep_num = 3, .style = FIFO_TX, .maxpacket = 512, },
+	{ .hw_ep_num = 3, .style = FIFO_RX, .maxpacket = 512, },
+	{ .hw_ep_num = 4, .style = FIFO_TX, .maxpacket = 512, },
+	{ .hw_ep_num = 4, .style = FIFO_RX, .maxpacket = 512, },
+	{ .hw_ep_num = 5, .style = FIFO_TX, .maxpacket = 512, },
+	{ .hw_ep_num = 5, .style = FIFO_RX, .maxpacket = 512, },
+	{ .hw_ep_num = 6, .style = FIFO_TX, .maxpacket = 1024, },
+	{ .hw_ep_num = 6, .style = FIFO_RX, .maxpacket = 1024, },
+	{ .hw_ep_num = 7, .style = FIFO_TX, .maxpacket = 512, },
+	{ .hw_ep_num = 7, .style = FIFO_RX, .maxpacket = 64, },
+};
+
+static const struct musb_hdrc_config mtk_musb_hdrc_config = {
+	.fifo_cfg = mtk_musb_mode_cfg,
+	.fifo_cfg_size = ARRAY_SIZE(mtk_musb_mode_cfg),
+	.multipoint = true,
+	.dyn_fifo = true,
+	.num_eps = MTK_MUSB_MAX_EP_NUM,
+	.ram_bits = MTK_MUSB_RAM_BITS,
+};
+
+static const struct platform_device_info mtk_dev_info = {
+	.name = "musb-hdrc",
+	.id = PLATFORM_DEVID_AUTO,
+	.dma_mask = DMA_BIT_MASK(32),
+};
+
+static int mtk_musb_probe(struct platform_device *pdev)
+{
+	struct musb_hdrc_platform_data *pdata;
+	struct mtk_glue *glue;
+	struct platform_device_info pinfo;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret = -ENOMEM;
+
+	glue = devm_kzalloc(dev, sizeof(*glue), GFP_KERNEL);
+	if (!glue)
+		return -ENOMEM;
+
+	glue->dev = dev;
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	ret = of_platform_populate(np, NULL, NULL, dev);
+	if (ret) {
+		dev_err(dev, "failed to create child devices at %p\n", np);
+		return ret;
+	}
+
+	ret = mtk_musb_clks_get(glue);
+	if (ret)
+		return ret;
+
+	pdata->config = &mtk_musb_hdrc_config;
+	pdata->platform_ops = &mtk_musb_ops;
+	pdata->mode = usb_get_dr_mode(dev);
+
+	if (IS_ENABLED(CONFIG_USB_MUSB_HOST))
+		pdata->mode = USB_DR_MODE_HOST;
+	else if (IS_ENABLED(CONFIG_USB_MUSB_GADGET))
+		pdata->mode = USB_DR_MODE_PERIPHERAL;
+
+	switch (pdata->mode) {
+	case USB_DR_MODE_HOST:
+		glue->phy_mode = PHY_MODE_USB_HOST;
+		glue->role = USB_ROLE_HOST;
+		break;
+	case USB_DR_MODE_PERIPHERAL:
+		glue->phy_mode = PHY_MODE_USB_DEVICE;
+		glue->role = USB_ROLE_DEVICE;
+		break;
+	case USB_DR_MODE_OTG:
+		glue->phy_mode = PHY_MODE_USB_OTG;
+		glue->role = USB_ROLE_NONE;
+		break;
+	default:
+		dev_err(&pdev->dev, "Error 'dr_mode' property\n");
+		return -EINVAL;
+	}
+
+	glue->phy = devm_of_phy_get_by_index(dev, np, 0);
+	if (IS_ERR(glue->phy)) {
+		dev_err(dev, "fail to getting phy %ld\n",
+			PTR_ERR(glue->phy));
+		return PTR_ERR(glue->phy);
+	}
+
+	glue->usb_phy = usb_phy_generic_register();
+	if (IS_ERR(glue->usb_phy)) {
+		dev_err(dev, "fail to registering usb-phy %ld\n",
+			PTR_ERR(glue->usb_phy));
+		return PTR_ERR(glue->usb_phy);
+	}
+
+	glue->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
+	if (IS_ERR(glue->xceiv)) {
+		dev_err(dev, "fail to getting usb-phy %d\n", ret);
+		ret = PTR_ERR(glue->xceiv);
+		goto err_unregister_usb_phy;
+	}
+
+	platform_set_drvdata(pdev, glue);
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
+	ret = mtk_musb_clks_enable(glue);
+	if (ret)
+		goto err_enable_clk;
+
+	pinfo = mtk_dev_info;
+	pinfo.parent = dev;
+	pinfo.res = pdev->resource;
+	pinfo.num_res = pdev->num_resources;
+	pinfo.data = pdata;
+	pinfo.size_data = sizeof(*pdata);
+
+	glue->musb_pdev = platform_device_register_full(&pinfo);
+	if (IS_ERR(glue->musb_pdev)) {
+		ret = PTR_ERR(glue->musb_pdev);
+		dev_err(dev, "failed to register musb device: %d\n", ret);
+		goto err_device_register;
+	}
+
+	return 0;
+
+err_device_register:
+	mtk_musb_clks_disable(glue);
+err_enable_clk:
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+err_unregister_usb_phy:
+	usb_phy_generic_unregister(glue->usb_phy);
+	return ret;
+}
+
+static int mtk_musb_remove(struct platform_device *pdev)
+{
+	struct mtk_glue *glue = platform_get_drvdata(pdev);
+	struct platform_device *usb_phy = glue->usb_phy;
+
+	platform_device_unregister(glue->musb_pdev);
+	usb_phy_generic_unregister(usb_phy);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id mtk_musb_match[] = {
+	{.compatible = "mediatek,mtk-musb",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mtk_musb_match);
+#endif
+
+static struct platform_driver mtk_musb_driver = {
+	.probe = mtk_musb_probe,
+	.remove = mtk_musb_remove,
+	.driver = {
+		   .name = "musb-mtk",
+		   .of_match_table = of_match_ptr(mtk_musb_match),
+	},
+};
+
+module_platform_driver(mtk_musb_driver);
+
+MODULE_DESCRIPTION("MediaTek MUSB Glue Layer");
+MODULE_AUTHOR("Min Guo <min.guo@mediatek.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 0fbf9adef..66e269d2b 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -246,7 +246,7 @@ static u32 musb_default_busctl_offset(u8 epnum, u16 offset)
 	return 0x80 + (0x08 * epnum) + offset;
 }
 
-static u8 musb_default_readb(const void __iomem *addr, unsigned offset)
+static u8 musb_default_readb(void __iomem *addr, u32 offset)
 {
 	u8 data =  __raw_readb(addr + offset);
 
@@ -254,13 +254,13 @@ static u8 musb_default_readb(const void __iomem *addr, unsigned offset)
 	return data;
 }
 
-static void musb_default_writeb(void __iomem *addr, unsigned offset, u8 data)
+static void musb_default_writeb(void __iomem *addr, u32 offset, u8 data)
 {
 	trace_musb_writeb(__builtin_return_address(0), addr, offset, data);
 	__raw_writeb(data, addr + offset);
 }
 
-static u16 musb_default_readw(const void __iomem *addr, unsigned offset)
+static u16 musb_default_readw(void __iomem *addr, u32 offset)
 {
 	u16 data = __raw_readw(addr + offset);
 
@@ -268,12 +268,44 @@ static u16 musb_default_readw(const void __iomem *addr, unsigned offset)
 	return data;
 }
 
-static void musb_default_writew(void __iomem *addr, unsigned offset, u16 data)
+static void musb_default_writew(void __iomem *addr, u32 offset, u16 data)
 {
 	trace_musb_writew(__builtin_return_address(0), addr, offset, data);
 	__raw_writew(data, addr + offset);
 }
 
+static u16 musb_default_get_toggle(struct musb_qh *qh, int is_out)
+{
+	void __iomem *epio = qh->hw_ep->regs;
+	u16 csr;
+
+	if (is_out)
+		csr = musb_readw(epio, MUSB_TXCSR) & MUSB_TXCSR_H_DATATOGGLE;
+	else
+		csr = musb_readw(epio, MUSB_RXCSR) & MUSB_RXCSR_H_DATATOGGLE;
+
+	return csr;
+}
+
+static u16 musb_default_set_toggle(struct musb_qh *qh, int is_out,
+				   struct urb *urb)
+{
+	u16 csr;
+	u16 toggle;
+
+	toggle = usb_gettoggle(urb->dev, qh->epnum, is_out);
+
+	if (is_out)
+		csr = toggle ? (MUSB_TXCSR_H_WR_DATATOGGLE
+				| MUSB_TXCSR_H_DATATOGGLE)
+				: MUSB_TXCSR_CLRDATATOG;
+	else
+		csr = toggle ? (MUSB_RXCSR_H_WR_DATATOGGLE
+				| MUSB_RXCSR_H_DATATOGGLE) : 0;
+
+	return csr;
+}
+
 /*
  * Load an endpoint's FIFO
  */
@@ -364,19 +396,25 @@ static void musb_default_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)
 /*
  * Old style IO functions
  */
-u8 (*musb_readb)(const void __iomem *addr, unsigned offset);
+u8 (*musb_readb)(void __iomem *addr, u32 offset);
 EXPORT_SYMBOL_GPL(musb_readb);
 
-void (*musb_writeb)(void __iomem *addr, unsigned offset, u8 data);
+void (*musb_writeb)(void __iomem *addr, u32 offset, u8 data);
 EXPORT_SYMBOL_GPL(musb_writeb);
 
-u16 (*musb_readw)(const void __iomem *addr, unsigned offset);
+u8 (*musb_clearb)(void __iomem *addr, u32 offset);
+EXPORT_SYMBOL_GPL(musb_clearb);
+
+u16 (*musb_readw)(void __iomem *addr, u32 offset);
 EXPORT_SYMBOL_GPL(musb_readw);
 
-void (*musb_writew)(void __iomem *addr, unsigned offset, u16 data);
+void (*musb_writew)(void __iomem *addr, u32 offset, u16 data);
 EXPORT_SYMBOL_GPL(musb_writew);
 
-u32 musb_readl(const void __iomem *addr, unsigned offset)
+u16 (*musb_clearw)(void __iomem *addr, u32 offset);
+EXPORT_SYMBOL_GPL(musb_clearw);
+
+u32 musb_readl(void __iomem *addr, u32 offset)
 {
 	u32 data = __raw_readl(addr + offset);
 
@@ -385,7 +423,7 @@ u32 musb_readl(const void __iomem *addr, unsigned offset)
 }
 EXPORT_SYMBOL_GPL(musb_readl);
 
-void musb_writel(void __iomem *addr, unsigned offset, u32 data)
+void musb_writel(void __iomem *addr, u32 offset, u32 data)
 {
 	trace_musb_writel(__builtin_return_address(0), addr, offset, data);
 	__raw_writel(data, addr + offset);
@@ -1015,7 +1053,6 @@ static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,
 static void musb_disable_interrupts(struct musb *musb)
 {
 	void __iomem	*mbase = musb->mregs;
-	u16	temp;
 
 	/* disable interrupts */
 	musb_writeb(mbase, MUSB_INTRUSBE, 0);
@@ -1025,9 +1062,9 @@ static void musb_disable_interrupts(struct musb *musb)
 	musb_writew(mbase, MUSB_INTRRXE, 0);
 
 	/*  flush pending interrupts */
-	temp = musb_readb(mbase, MUSB_INTRUSB);
-	temp = musb_readw(mbase, MUSB_INTRTX);
-	temp = musb_readw(mbase, MUSB_INTRRX);
+	musb_clearb(mbase, MUSB_INTRUSB);
+	musb_clearw(mbase, MUSB_INTRTX);
+	musb_clearw(mbase, MUSB_INTRRX);
 }
 
 static void musb_enable_interrupts(struct musb *musb)
@@ -2254,10 +2291,19 @@ musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
 		musb_readb = musb->ops->readb;
 	if (musb->ops->writeb)
 		musb_writeb = musb->ops->writeb;
+	if (musb->ops->clearb)
+		musb_clearb = musb->ops->clearb;
+	else
+		musb_clearb = musb_readb;
+
 	if (musb->ops->readw)
 		musb_readw = musb->ops->readw;
 	if (musb->ops->writew)
 		musb_writew = musb->ops->writew;
+	if (musb->ops->clearw)
+		musb_clearw = musb->ops->clearw;
+	else
+		musb_clearw = musb_readw;
 
 #ifndef CONFIG_MUSB_PIO_ONLY
 	if (!musb->ops->dma_init || !musb->ops->dma_exit) {
@@ -2279,6 +2325,16 @@ musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
 	else
 		musb->io.write_fifo = musb_default_write_fifo;
 
+	if (musb->ops->get_toggle)
+		musb->io.get_toggle = musb->ops->get_toggle;
+	else
+		musb->io.get_toggle = musb_default_get_toggle;
+
+	if (musb->ops->set_toggle)
+		musb->io.set_toggle = musb->ops->set_toggle;
+	else
+		musb->io.set_toggle = musb_default_set_toggle;
+
 	if (!musb->xceiv->io_ops) {
 		musb->xceiv->io_dev = musb->controller;
 		musb->xceiv->io_priv = musb->mregs;
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 04203b712..6060a7c99 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -27,6 +27,7 @@
 struct musb;
 struct musb_hw_ep;
 struct musb_ep;
+struct musb_qh;
 
 /* Helper defines for struct musb->hwvers */
 #define MUSB_HWVERS_MAJOR(x)	((x >> 10) & 0x1f)
@@ -119,10 +120,14 @@ struct musb_io;
  * @fifo_offset: returns the fifo offset
  * @readb:	read 8 bits
  * @writeb:	write 8 bits
+ * @clearb:	could be clear-on-readb or W1C
  * @readw:	read 16 bits
  * @writew:	write 16 bits
+ * @clearw:	could be clear-on-readw or W1C
  * @read_fifo:	reads the fifo
  * @write_fifo:	writes to fifo
+ * @get_toggle:	platform specific get toggle function
+ * @set_toggle:	platform specific set toggle function
  * @dma_init:	platform specific dma init function
  * @dma_exit:	platform specific dma exit function
  * @init:	turns on clocks, sets up platform-specific registers, etc
@@ -161,12 +166,16 @@ struct musb_platform_ops {
 	u16	fifo_mode;
 	u32	(*fifo_offset)(u8 epnum);
 	u32	(*busctl_offset)(u8 epnum, u16 offset);
-	u8	(*readb)(const void __iomem *addr, unsigned offset);
-	void	(*writeb)(void __iomem *addr, unsigned offset, u8 data);
-	u16	(*readw)(const void __iomem *addr, unsigned offset);
-	void	(*writew)(void __iomem *addr, unsigned offset, u16 data);
+	u8	(*readb)(void __iomem *addr, u32 offset);
+	void	(*writeb)(void __iomem *addr, u32 offset, u8 data);
+	u8	(*clearb)(void __iomem *addr, u32 offset);
+	u16	(*readw)(void __iomem *addr, u32 offset);
+	void	(*writew)(void __iomem *addr, u32 offset, u16 data);
+	u16	(*clearw)(void __iomem *addr, u32 offset);
 	void	(*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);
 	void	(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
+	u16	(*get_toggle)(struct musb_qh *qh, int is_out);
+	u16	(*set_toggle)(struct musb_qh *qh, int is_out, struct urb *urb);
 	struct dma_controller *
 		(*dma_init) (struct musb *musb, void __iomem *base);
 	void	(*dma_exit)(struct dma_controller *c);
diff --git a/drivers/usb/musb/musb_dma.h b/drivers/usb/musb/musb_dma.h
index 8f60271c0..4b4d8dc5d 100644
--- a/drivers/usb/musb/musb_dma.h
+++ b/drivers/usb/musb/musb_dma.h
@@ -35,6 +35,12 @@ struct musb_hw_ep;
  *    whether shared with the Inventra core or separate.
  */
 
+#define MUSB_HSDMA_BASE		0x200
+#define MUSB_HSDMA_INTR		(MUSB_HSDMA_BASE + 0)
+#define MUSB_HSDMA_CONTROL	0x4
+#define MUSB_HSDMA_ADDRESS	0x8
+#define MUSB_HSDMA_COUNT	0xc
+
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 
 #ifdef CONFIG_MUSB_PIO_ONLY
@@ -191,6 +197,9 @@ extern void (*musb_dma_controller_destroy)(struct dma_controller *);
 extern struct dma_controller *
 musbhs_dma_controller_create(struct musb *musb, void __iomem *base);
 extern void musbhs_dma_controller_destroy(struct dma_controller *c);
+extern struct dma_controller *
+musbhs_dma_controller_create_noirq(struct musb *musb, void __iomem *base);
+extern irqreturn_t dma_controller_irq(int irq, void *private_data);
 
 extern struct dma_controller *
 tusb_dma_controller_create(struct musb *musb, void __iomem *base);
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index fa9922c0c..5267ad298 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -286,26 +286,6 @@ __acquires(musb->lock)
 	spin_lock(&musb->lock);
 }
 
-/* For bulk/interrupt endpoints only */
-static inline void musb_save_toggle(struct musb_qh *qh, int is_in,
-				    struct urb *urb)
-{
-	void __iomem		*epio = qh->hw_ep->regs;
-	u16			csr;
-
-	/*
-	 * FIXME: the current Mentor DMA code seems to have
-	 * problems getting toggle correct.
-	 */
-
-	if (is_in)
-		csr = musb_readw(epio, MUSB_RXCSR) & MUSB_RXCSR_H_DATATOGGLE;
-	else
-		csr = musb_readw(epio, MUSB_TXCSR) & MUSB_TXCSR_H_DATATOGGLE;
-
-	usb_settoggle(urb->dev, qh->epnum, !is_in, csr ? 1 : 0);
-}
-
 /*
  * Advance this hardware endpoint's queue, completing the specified URB and
  * advancing to either the next URB queued to that qh, or else invalidating
@@ -320,6 +300,7 @@ static void musb_advance_schedule(struct musb *musb, struct urb *urb,
 	struct musb_hw_ep	*ep = qh->hw_ep;
 	int			ready = qh->is_ready;
 	int			status;
+	u16			toggle;
 
 	status = (urb->status == -EINPROGRESS) ? 0 : urb->status;
 
@@ -327,7 +308,8 @@ static void musb_advance_schedule(struct musb *musb, struct urb *urb,
 	switch (qh->type) {
 	case USB_ENDPOINT_XFER_BULK:
 	case USB_ENDPOINT_XFER_INT:
-		musb_save_toggle(qh, is_in, urb);
+		toggle = musb->io.get_toggle(qh, !is_in);
+		usb_settoggle(urb->dev, qh->epnum, !is_in, toggle ? 1 : 0);
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
 		if (status == 0 && urb->error_count)
@@ -772,13 +754,8 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 					);
 			csr |= MUSB_TXCSR_MODE;
 
-			if (!hw_ep->tx_double_buffered) {
-				if (usb_gettoggle(urb->dev, qh->epnum, 1))
-					csr |= MUSB_TXCSR_H_WR_DATATOGGLE
-						| MUSB_TXCSR_H_DATATOGGLE;
-				else
-					csr |= MUSB_TXCSR_CLRDATATOG;
-			}
+			if (!hw_ep->tx_double_buffered)
+				csr |= musb->io.set_toggle(qh, is_out, urb);
 
 			musb_writew(epio, MUSB_TXCSR, csr);
 			/* REVISIT may need to clear FLUSHFIFO ... */
@@ -860,17 +837,12 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 
 	/* IN/receive */
 	} else {
-		u16	csr;
+		u16 csr = 0;
 
 		if (hw_ep->rx_reinit) {
 			musb_rx_reinit(musb, qh, epnum);
+			csr |= musb->io.set_toggle(qh, is_out, urb);
 
-			/* init new state: toggle and NYET, maybe DMA later */
-			if (usb_gettoggle(urb->dev, qh->epnum, 0))
-				csr = MUSB_RXCSR_H_WR_DATATOGGLE
-					| MUSB_RXCSR_H_DATATOGGLE;
-			else
-				csr = 0;
 			if (qh->type == USB_ENDPOINT_XFER_INT)
 				csr |= MUSB_RXCSR_DISNYET;
 
@@ -933,6 +905,7 @@ static void musb_bulk_nak_timeout(struct musb *musb, struct musb_hw_ep *ep,
 	void __iomem		*epio = ep->regs;
 	struct musb_qh		*cur_qh, *next_qh;
 	u16			rx_csr, tx_csr;
+	u16			toggle;
 
 	musb_ep_select(mbase, ep->epnum);
 	if (is_in) {
@@ -970,7 +943,8 @@ static void musb_bulk_nak_timeout(struct musb *musb, struct musb_hw_ep *ep,
 			urb->actual_length += dma->actual_len;
 			dma->actual_len = 0L;
 		}
-		musb_save_toggle(cur_qh, is_in, urb);
+		toggle = musb->io.get_toggle(cur_qh, !is_in);
+		usb_settoggle(urb->dev, cur_qh->epnum, !is_in, toggle ? 1 : 0);
 
 		if (is_in) {
 			/* move cur_qh to end of queue */
diff --git a/drivers/usb/musb/musb_io.h b/drivers/usb/musb/musb_io.h
index 8058a5809..f17aabd95 100644
--- a/drivers/usb/musb/musb_io.h
+++ b/drivers/usb/musb/musb_io.h
@@ -22,6 +22,8 @@
  * @read_fifo:	platform specific function to read fifo
  * @write_fifo:	platform specific function to write fifo
  * @busctl_offset: platform specific function to get busctl offset
+ * @get_toggle: platform specific function to get toggle
+ * @set_toggle: platform specific function to set toggle
  */
 struct musb_io {
 	u32	(*ep_offset)(u8 epnum, u16 offset);
@@ -30,14 +32,18 @@ struct musb_io {
 	void	(*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);
 	void	(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
 	u32	(*busctl_offset)(u8 epnum, u16 offset);
+	u16	(*get_toggle)(struct musb_qh *qh, int is_out);
+	u16	(*set_toggle)(struct musb_qh *qh, int is_out, struct urb *urb);
 };
 
 /* Do not add new entries here, add them the struct musb_io instead */
-extern u8 (*musb_readb)(const void __iomem *addr, unsigned offset);
-extern void (*musb_writeb)(void __iomem *addr, unsigned offset, u8 data);
-extern u16 (*musb_readw)(const void __iomem *addr, unsigned offset);
-extern void (*musb_writew)(void __iomem *addr, unsigned offset, u16 data);
-extern u32 musb_readl(const void __iomem *addr, unsigned offset);
-extern void musb_writel(void __iomem *addr, unsigned offset, u32 data);
+extern u8 (*musb_readb)(void __iomem *addr, u32 offset);
+extern void (*musb_writeb)(void __iomem *addr, u32 offset, u8 data);
+extern u8 (*musb_clearb)(void __iomem *addr, u32 offset);
+extern u16 (*musb_readw)(void __iomem *addr, u32 offset);
+extern void (*musb_writew)(void __iomem *addr, u32 offset, u16 data);
+extern u16 (*musb_clearw)(void __iomem *addr, u32 offset);
+extern u32 musb_readl(void __iomem *addr, u32 offset);
+extern void musb_writel(void __iomem *addr, u32 offset, u32 data);
 
 #endif
diff --git a/drivers/usb/musb/musbhsdma.c b/drivers/usb/musb/musbhsdma.c
index 2d3751d88..0aacfc8be 100644
--- a/drivers/usb/musb/musbhsdma.c
+++ b/drivers/usb/musb/musbhsdma.c
@@ -10,12 +10,7 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include "musb_core.h"
-
-#define MUSB_HSDMA_BASE		0x200
-#define MUSB_HSDMA_INTR		(MUSB_HSDMA_BASE + 0)
-#define MUSB_HSDMA_CONTROL		0x4
-#define MUSB_HSDMA_ADDRESS		0x8
-#define MUSB_HSDMA_COUNT		0xc
+#include "musb_dma.h"
 
 #define MUSB_HSDMA_CHANNEL_OFFSET(_bchannel, _offset)		\
 		(MUSB_HSDMA_BASE + (_bchannel << 4) + _offset)
@@ -268,7 +263,7 @@ static int dma_channel_abort(struct dma_channel *channel)
 	return 0;
 }
 
-static irqreturn_t dma_controller_irq(int irq, void *private_data)
+irqreturn_t dma_controller_irq(int irq, void *private_data)
 {
 	struct musb_dma_controller *controller = private_data;
 	struct musb *musb = controller->private_data;
@@ -289,7 +284,7 @@ static irqreturn_t dma_controller_irq(int irq, void *private_data)
 
 	spin_lock_irqsave(&musb->lock, flags);
 
-	int_hsdma = musb_readb(mbase, MUSB_HSDMA_INTR);
+	int_hsdma = musb_clearb(mbase, MUSB_HSDMA_INTR);
 
 	if (!int_hsdma) {
 		musb_dbg(musb, "spurious DMA irq");
@@ -383,6 +378,7 @@ static irqreturn_t dma_controller_irq(int irq, void *private_data)
 	spin_unlock_irqrestore(&musb->lock, flags);
 	return retval;
 }
+EXPORT_SYMBOL_GPL(dma_controller_irq);
 
 void musbhs_dma_controller_destroy(struct dma_controller *c)
 {
@@ -398,18 +394,10 @@ void musbhs_dma_controller_destroy(struct dma_controller *c)
 }
 EXPORT_SYMBOL_GPL(musbhs_dma_controller_destroy);
 
-struct dma_controller *musbhs_dma_controller_create(struct musb *musb,
-						    void __iomem *base)
+static struct musb_dma_controller *
+dma_controller_alloc(struct musb *musb, void __iomem *base)
 {
 	struct musb_dma_controller *controller;
-	struct device *dev = musb->controller;
-	struct platform_device *pdev = to_platform_device(dev);
-	int irq = platform_get_irq_byname(pdev, "dma");
-
-	if (irq <= 0) {
-		dev_err(dev, "No DMA interrupt line!\n");
-		return NULL;
-	}
 
 	controller = kzalloc(sizeof(*controller), GFP_KERNEL);
 	if (!controller)
@@ -423,6 +411,25 @@ struct dma_controller *musbhs_dma_controller_create(struct musb *musb,
 	controller->controller.channel_release = dma_channel_release;
 	controller->controller.channel_program = dma_channel_program;
 	controller->controller.channel_abort = dma_channel_abort;
+	return controller;
+}
+
+struct dma_controller *
+musbhs_dma_controller_create(struct musb *musb, void __iomem *base)
+{
+	struct musb_dma_controller *controller;
+	struct device *dev = musb->controller;
+	struct platform_device *pdev = to_platform_device(dev);
+	int irq = platform_get_irq_byname(pdev, "dma");
+
+	if (irq <= 0) {
+		dev_err(dev, "No DMA interrupt line!\n");
+		return NULL;
+	}
+
+	controller = dma_controller_alloc(musb, base);
+	if (!controller)
+		return NULL;
 
 	if (request_irq(irq, dma_controller_irq, 0,
 			dev_name(musb->controller), controller)) {
@@ -437,3 +444,16 @@ struct dma_controller *musbhs_dma_controller_create(struct musb *musb,
 	return &controller->controller;
 }
 EXPORT_SYMBOL_GPL(musbhs_dma_controller_create);
+
+struct dma_controller *
+musbhs_dma_controller_create_noirq(struct musb *musb, void __iomem *base)
+{
+	struct musb_dma_controller *controller;
+
+	controller = dma_controller_alloc(musb, base);
+	if (!controller)
+		return NULL;
+
+	return &controller->controller;
+}
+EXPORT_SYMBOL_GPL(musbhs_dma_controller_create_noirq);
diff --git a/drivers/usb/musb/sunxi.c b/drivers/usb/musb/sunxi.c
index 832a41f9e..e6b3d7170 100644
--- a/drivers/usb/musb/sunxi.c
+++ b/drivers/usb/musb/sunxi.c
@@ -407,7 +407,7 @@ static u32 sunxi_musb_busctl_offset(u8 epnum, u16 offset)
 	return SUNXI_MUSB_TXFUNCADDR + offset;
 }
 
-static u8 sunxi_musb_readb(const void __iomem *addr, unsigned offset)
+static u8 sunxi_musb_readb(void __iomem *addr, u32 offset)
 {
 	struct sunxi_glue *glue;
 
@@ -520,7 +520,7 @@ static void sunxi_musb_writeb(void __iomem *addr, unsigned offset, u8 data)
 		(int)(addr - sunxi_musb->mregs));
 }
 
-static u16 sunxi_musb_readw(const void __iomem *addr, unsigned offset)
+static u16 sunxi_musb_readw(void __iomem *addr, u32 offset)
 {
 	if (addr == sunxi_musb->mregs) {
 		/* generic control or fifo control reg access */
diff --git a/drivers/usb/musb/tusb6010.c b/drivers/usb/musb/tusb6010.c
index 39453287b..5d449089e 100644
--- a/drivers/usb/musb/tusb6010.c
+++ b/drivers/usb/musb/tusb6010.c
@@ -142,7 +142,7 @@ static void tusb_ep_select(void __iomem *mbase, u8 epnum)
 /*
  * TUSB6010 doesn't allow 8-bit access; 16-bit access is the minimum.
  */
-static u8 tusb_readb(const void __iomem *addr, unsigned offset)
+static u8 tusb_readb(void __iomem *addr, u32 offset)
 {
 	u16 tmp;
 	u8 val;
diff --git a/drivers/usb/sunxi_usb/Kconfig b/drivers/usb/sunxi_usb/Kconfig
new file mode 100644
index 000000000..03b3aa53b
--- /dev/null
+++ b/drivers/usb/sunxi_usb/Kconfig
@@ -0,0 +1,52 @@
+#
+# softwinner SUNXI USB2.0 Dual Role Controller Driver.
+#
+
+#---------------------------------------------
+#-
+#- config USB2.0 Dual Role Controller.
+#-
+#---------------------------------------------
+menuconfig USB_SUNXI_USB
+    tristate "SUNXI USB2.0 Dual Role Controller support"
+    depends on ARCH_SUNXI
+    help
+      SUNXI USB2.0 Dual Role Controller
+
+      This option is of interest only to developers who need to
+      develop on AllWinner SoC.
+
+      If unsure, say N.
+
+config USB_SUNXI_USB_MANAGER
+    tristate "SUNXI USB2.0 Manager"
+    depends on USB_SUNXI_USB && USB_SUNXI_UDC0 && USB_SUNXI_HCI
+    help
+      manager all usb controller.
+
+      This option is of interest only to developers who need to
+      develop on AllWinner SoC.
+
+      If unsure, say N.
+
+config USB_SUNXI_USB_DEBUG
+    tristate "SUNXI USB driver debug message"
+    depends on USB_SUNXI_USB
+    help
+      SUNXI USB driver debug message.
+
+      This option is of interest only to developers who need to
+      develop on AllWinner SoC.
+
+      If unsure, say N.
+
+config USB_SUNXI_USB_ADB
+    tristate "SUNXI USB driver use adb source"
+    depends on USB_SUNXI_USB
+    help
+      SUNXI USB driver debug message.
+
+      This option is of interest only to developers who need to
+      develop on AllWinner SoC.
+
+      If unsure, say N.
diff --git a/drivers/usb/sunxi_usb/Makefile b/drivers/usb/sunxi_usb/Makefile
new file mode 100644
index 000000000..536f15b4a
--- /dev/null
+++ b/drivers/usb/sunxi_usb/Makefile
@@ -0,0 +1,35 @@
+#
+# Makefile for SUNXI USB2.0 Dual Role Controller Driver.
+#
+
+sunxi_usbc-objs := manager/usb_manager.o \
+			manager/usbc0_platform.o \
+			manager/usb_hcd_servers.o \
+			manager/usb_hw_scan.o \
+			manager/usb_msg_center.o
+
+ifeq ($(CONFIG_USB_SUNXI_HCD0),y)
+        sunxi_usbc-objs +=hcd/core/sunxi_hcd_core.o \
+                                        hcd/core/sunxi_hcd_host.o \
+                                        hcd/core/sunxi_hcd_virt_hub.o \
+                                        hcd/core/sunxi_hcd_debug.o \
+                                        hcd/core/sunxi_hcd_dma.o \
+                                        usbc/usbc_host.o
+
+        sunxi_usb_hcd0-objs := hcd/hcd0/sunxi_hcd0.o
+endif
+
+obj-$(CONFIG_USB_SUNXI_HCD0) += sunxi_usb_hcd0.o
+obj-$(CONFIG_USB_SUNXI_USB_MANAGER) += sunxi_usbc.o
+
+sunxi_usb_udc-objs :=  udc/sunxi_udc.o \
+                    udc/sunxi_udc_board.o \
+                    udc/sunxi_udc_debug.o \
+                    udc/sunxi_udc_dma.o \
+                    usbc/usbc.o \
+                    usbc/usbc_dev.o \
+                    usbc/usbc_phy.o \
+                    misc/sunxi_usb_debug.o
+
+obj-$(CONFIG_USB_SUNXI_UDC0) += sunxi_usb_udc.o
+
diff --git a/drivers/usb/sunxi_usb/include/sunxi_hcd.h b/drivers/usb/sunxi_usb/include/sunxi_hcd.h
new file mode 100644
index 000000000..fe8ad70b0
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_hcd.h
@@ -0,0 +1,103 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_hcd.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * usb board config.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_HCD_H__
+#define __SUNXI_HCD_H__
+
+/**
+ * The USB role is defined by the connector used on the board, so long as
+ * standards are being followed. (Developer boards sometimes won't.)
+ */
+enum sunxi_hcd_mode {
+	SW_HCD_UNDEFINED = 0,
+	SW_HCD_HOST,		/* A or Mini-A connector */
+	SW_HCD_PERIPHERAL,	/* B or Mini-B connector */
+	SW_HCD_OTG		/* Mini-AB connector */
+};
+
+struct clk;
+
+typedef struct sunxi_hcd_eps_bits {
+	const char	name[16];
+	u8		bits;
+} sunxi_hcd_eps_bits_t;
+
+typedef struct sunxi_hcd_config {
+	/* sunxi_hcd configuration-specific details */
+	unsigned	multipoint:1;	/* multipoint device */
+	unsigned	dyn_fifo:1;	/* supports dynamic fifo sizing */
+	unsigned	soft_con:1;	/* soft connect required */
+	unsigned	utm_16:1;	/* utm data witdh is 16 bits */
+	unsigned	big_endian:1;	/* true if CPU uses big-endian */
+	unsigned	mult_bulk_tx:1;	/* Tx ep required for multbulk pkts */
+	unsigned	mult_bulk_rx:1;	/* Rx ep required for multbulk pkts */
+	unsigned	high_iso_tx:1;	/* Tx ep required for HB iso */
+	unsigned	high_iso_rx:1;	/* Rx ep required for HD iso */
+	unsigned	dma:1;		/* supports DMA */
+	unsigned	vendor_req:1;	/* vendor registers required */
+
+	u8		num_eps;	/* number of endpoints _with_ ep0 */
+	u8		dma_channels;	/* number of dma channels */
+	u8		dyn_fifo_size;	/* dynamic size in bytes */
+	u8		vendor_ctrl;	/* vendor control reg width */
+	u8		vendor_stat;	/* vendor status reg witdh */
+	u8		dma_req_chan;	/* bitmask for required dma channels */
+	u32		ram_size;	/* ram address size */
+
+	struct sunxi_hcd_eps_bits *eps_bits;
+	struct usb_port_info *port_info;
+} sunxi_hcd_config_t;
+
+typedef struct sunxi_hcd_platform_data {
+	u32 usbc_base;
+
+	/* sunxi_USB_HOST, SW_USB_PERIPHERAL, or SW_USB_OTG */
+	u8		mode;
+
+	/* (HOST or OTG) switch VBUS on/off */
+	int		(*set_vbus)(struct device *dev, int is_on);
+
+	/* (HOST or OTG) mA/2 power supplied on (default = 8mA) */
+	u8		power;
+
+	/* (PERIPHERAL) mA/2 max power consumed (default = 100mA) */
+	u8		min_power;
+
+	/* (HOST or OTG) msec/2 after VBUS on till power good */
+	u8		potpgt;
+
+	/* Power the device on or off */
+	int		(*set_power)(int state);
+
+	/* Turn device clock on or off */
+	int		(*set_clock)(struct clk *clock, int is_on);
+
+	/* sunxi_hcd configuration-specific details */
+	struct sunxi_hcd_config	*config;
+} sunxi_hcd_platform_data_t;
+
+int sunxi_usb_host0_enable(void);
+int sunxi_usb_host0_disable(void);
+
+int sunxi_usb_disable_hcd0(void);
+int sunxi_usb_enable_hcd0(void);
+
+int sunxi_usb_disable_hcd1(void);
+int sunxi_usb_enable_hcd1(void);
+
+int sunxi_usb_disable_hcd2(void);
+int sunxi_usb_enable_hcd2(void);
+
+#endif /* __SUNXI_HCD_H__ */
diff --git a/drivers/usb/sunxi_usb/include/sunxi_sys_reg.h b/drivers/usb/sunxi_usb/include/sunxi_sys_reg.h
new file mode 100644
index 000000000..300fab469
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_sys_reg.h
@@ -0,0 +1,22 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_sys_reg.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * usb register defination.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_SYS_REG_H__
+#define __SUNXI_SYS_REG_H__
+
+
+#define SRAMC_BASE	            0x01c00000
+
+#endif /* __SUNXI_SYS_REG_H__ */
diff --git a/drivers/usb/sunxi_usb/include/sunxi_udc.h b/drivers/usb/sunxi_usb/include/sunxi_udc.h
new file mode 100644
index 000000000..c18a8fc19
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_udc.h
@@ -0,0 +1,299 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_udc.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-3-3, create this file
+ *
+ * usb udc head file.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_UDC_H__
+#define __SUNXI_UDC_H__
+
+#include <linux/usb.h>
+#include <linux/usb/gadget.h>
+#include <linux/dma-mapping.h>
+#include <linux/regulator/consumer.h>
+
+#if 1
+typedef struct sunxi_udc_dma {
+	char name[32];
+	int is_start;
+#ifdef SW_UDC_DMA_INNER
+	int *dma_hdle; /* dma channel handle */
+#else
+	struct dma_chan *chan;
+#endif
+} sunxi_udc_dma_t;
+
+typedef struct sunxi_udc_ep {
+	struct list_head	queue;
+	unsigned long		last_io; /* jiffies timestamp */
+	struct usb_gadget	*gadget;
+	struct sunxi_udc	*dev;
+	const struct usb_endpoint_descriptor *desc;
+	struct usb_ep		ep;
+	u8			num;
+
+	unsigned short		fifo_size;
+	u8			bEndpointAddress;
+	u8			bmAttributes;
+
+	unsigned		halted : 1;
+	unsigned		already_seen : 1;
+	unsigned		setup_stage : 1;
+
+#ifdef SW_UDC_DMA_INNER
+	int				*dma_hdle;
+#else
+	sunxi_udc_dma_t			sunxi_udc_dma[6];
+#endif
+	__u32			dma_working; /* flag. is dma busy? */
+	__u32			dma_transfer_len; /* dma want transfer length */
+} sunxi_udc_ep_t;
+
+/**
+ * Warning : ep0 has a fifo of 16 bytes.
+ * Don't try to set 32 or 64.
+ * Also testusb 14 fails  wit 16 but is fine with 8.
+ */
+#define EP0_FIFO_SIZE			64
+
+#define SW_UDC_EP_FIFO_SIZE		512
+#define SW_UDC_EP_ISO_FIFO_SIZE		1024
+
+#define	SW_UDC_EP_CTRL_INDEX		0x00
+#define SW_UDC_EP_BULK_IN_INDEX	0x01
+#define SW_UDC_EP_BULK_OUT_INDEX	0x02
+
+#ifdef SW_UDC_DOUBLE_FIFO
+#define SW_UDC_FIFO_NUM		1
+#else
+#define SW_UDC_FIFO_NUM		0
+#endif
+
+#define	SUNXI_UDC_TEST_J		0x0100
+#define	SUNXI_UDC_TEST_K		0x0200
+#define	SUNXI_UDC_TEST_SE0_NAK		0x0300
+#define	SUNXI_UDC_TEST_PACKET		0x0400
+
+static const char ep0name[] = "ep0";
+static const char ep1in_bulk_name[]  = "ep1in-bulk";
+static const char ep1out_bulk_name[] = "ep1out-bulk";
+static const char ep2in_bulk_name[]  = "ep2in-bulk";
+static const char ep2out_bulk_name[] = "ep2out-bulk";
+static const char ep3_iso_name[]     = "ep3-iso";
+static const char ep4_int_name[]     = "ep4-int";
+static const char ep5in_bulk_name[]  = "ep5in-bulk";
+static const char ep5out_bulk_name[] = "ep5out-bulk";
+
+struct sw_udc_fifo {
+	const char *name;
+	u32 fifo_addr;
+	u32 fifo_size;
+	u8  double_fifo;
+};
+
+#if defined(CONFIG_ARCH_SUN50IW1) || defined(CONFIG_ARCH_SUN50IW3) \
+	|| defined(CONFIG_ARCH_SUN8IW6) || defined(CONFIG_ARCH_SUN8IW15) \
+	|| defined(CONFIG_ARCH_SUN50IW10) || defined(CONFIG_ARCH_SUN50IW9) \
+	|| defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+/**
+ * fifo 8k
+ *
+ * ep				fifo_addr	fifo_size
+ * "ep0",			0,		0.5k
+ * "ep1in-bulk",		0.5k,		1k
+ * "ep1out-bulk",		1.5k,		1k
+ * "ep2in-bulk",		2.5k,		1k
+ * "ep2out-bulk",		3.5k,		1k
+ * "ep3-iso",			4.5k,		2k
+ * "ep4-int",			6.5k,		0.5k
+ * "ep5in-bulk",		7k,		0.5k
+ * "ep5out-bulk",		7.5k,		0.5k
+ */
+#define SW_UDC_EPNUMS	5
+static const struct sw_udc_fifo ep_fifo[] = {
+	{ep0name,          0,    512,  0},
+	{ep1in_bulk_name,  512,  1024, 1},
+	{ep1out_bulk_name, 1536, 1024, 1},
+	{ep2in_bulk_name,  2560, 1024, 1},
+	{ep2out_bulk_name, 3584, 1024, 1},
+	{ep3_iso_name,     4608, 1024, 0},
+	{ep4_int_name,     5632, 512,  0},
+	{ep5in_bulk_name,  6144, 1024, 1},
+	{ep5out_bulk_name, 7168, 1024, 1},
+};
+
+#else
+
+/**
+ * fifo 4k
+ *
+ * ep				fifo_addr	fifo_size
+ * "ep0",			0,		0.5k
+ * "ep1in-bulk",		0.5k,		0.5k
+ * "ep1out-bulk",		1k,		0.5k
+ * "ep2in-bulk",		1.5k,		0.5k
+ * "ep2out-bulk",		2k,		0.5k
+ * "ep3-iso",			2.5k,		1k
+ * "ep4-int",			3.5k,		0.5k
+ */
+#define SW_UDC_EPNUMS	4
+
+static const struct sw_udc_fifo ep_fifo[] = {
+	{ep0name,          0,    512,  0},
+	{ep1in_bulk_name,  512,  512,  0},
+	{ep1out_bulk_name, 1024, 512,  0},
+	{ep2in_bulk_name,  1536, 512,  0},
+	{ep2out_bulk_name, 2048, 512,  0},
+	{ep3_iso_name,     2560, 1024, 0},
+	{ep4_int_name,     3584, 512,  0},
+};
+#endif
+
+/**
+ * ep_fifo_in[i] = {n} i: the physic ep index, n: ep_fifo's index for the ep
+ *
+ * eg: ep_fifo_in[2] = {3} ===> ep2_in is in ep_fifo[3]
+ *
+ * ep3_iso_name and ep4_int_name cannot be tx or rx simultaneously.
+ *
+ */
+static const int ep_fifo_in[] = {0, 1, 3, 5, 6, 7};
+static const int ep_fifo_out[] = {0, 2, 4, 5, 6, 8};
+
+#define SW_UDC_ENDPOINTS	ARRAY_SIZE(ep_fifo)
+
+#define  is_tx_ep(ep)		((ep->bEndpointAddress) & USB_DIR_IN)
+
+enum sunxi_buffer_map_state {
+	UN_MAPPED = 0,
+	PRE_MAPPED,
+	SW_UDC_USB_MAPPED
+};
+
+struct sunxi_udc_request {
+	struct list_head	queue;	/* ep's requests */
+	struct usb_request	req;
+
+	__u32 is_queue;			/* flag... */
+	enum sunxi_buffer_map_state map_state;
+	void *saved_req_buf;
+};
+
+enum ep0_state {
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_END_XFER,
+	EP0_STALL,
+};
+
+typedef struct sunxi_udc_dma_parg {
+	struct sunxi_udc *dev;
+	struct sunxi_udc_ep *ep[6];
+	struct sunxi_udc_request *req;
+} sunxi_udc_dma_parg_t;
+#endif
+
+typedef struct sunxi_udc_io {
+	struct resource	*usb_base_res;		/* USB  resources */
+	struct resource	*usb_base_req;		/* USB  resources */
+	void __iomem	*usb_vbase;		/* USB  base address */
+
+	struct resource	*sram_base_res;		/* SRAM resources */
+	struct resource	*sram_base_req;		/* SRAM resources */
+	void __iomem	*sram_vbase;		/* SRAM base address */
+
+	struct resource	*clock_base_res;	/* clock resources */
+	struct resource	*clock_base_req;	/* clock resources */
+	void __iomem	*clock_vbase;		/* clock base address */
+
+	bsp_usbc_t usbc;			/* usb bsp config */
+	__hdle usb_bsp_hdle;			/* usb bsp handle */
+
+	__u32 clk_is_open;			/* is usb clock open? */
+	struct clk	*clk_bus_otg;
+	struct clk	*clk_phy;
+
+	struct reset_control	*reset_otg;
+	struct reset_control	*reset_phy;
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+/* for keep common circuit configuration */
+	void __iomem	*usb_common_phy_config;
+
+#define SUNXI_HCI_PHY_CTRL		0x810
+#define SUNXI_HCI_PHY_CTRL_SIDDQ	3
+#endif
+} sunxi_udc_io_t;
+
+typedef struct sunxi_udc {
+	spinlock_t			lock;
+	struct platform_device		*pdev;
+	struct device		        *controller;
+
+	struct sunxi_udc_ep		ep[SW_UDC_ENDPOINTS];
+	int				address;
+	struct usb_gadget		gadget;
+	struct usb_gadget_driver	*driver;
+	struct sunxi_udc_request	fifo_req;
+	u8				fifo_buf[SW_UDC_EP_FIFO_SIZE];
+	u16				devstatus;
+
+	u32				port_status;
+	int				ep0state;
+
+	unsigned			got_irq : 1;
+
+	unsigned			req_std : 1;
+	unsigned			req_config : 1;
+	unsigned			req_pending : 1;
+	u8				vbus;
+	struct dentry			*regs_info;
+
+	sunxi_udc_io_t			*sunxi_udc_io;
+	char				driver_name[32];
+	__u32				usbc_no; /* controller port index */
+
+	u32				stopped; /* controller stop work */
+	u32				irq_no;	/* usb irq no */
+
+	struct work_struct		vbus_det_work;
+	struct work_struct		set_cur_vol_work;
+
+	struct wakeup_source		*ws;
+	struct regulator		*udc_regulator; /* usbc regulator:vcc-USB */
+} sunxi_udc_t;
+
+enum sunxi_udc_cmd_e {
+	SW_UDC_P_ENABLE	= 1,		/* Pull-up enable        */
+	SW_UDC_P_DISABLE = 2,		/* Pull-up disable       */
+	SW_UDC_P_RESET	= 3,		/* UDC reset, in case of */
+};
+
+typedef struct sunxi_udc_mach_info {
+	struct usb_port_info *port_info;
+	unsigned int usbc_base;
+} sunxi_udc_mach_info_t;
+
+extern atomic_t thread_suspend_flag;
+extern int device_insmod_delay;
+
+extern atomic_t vfs_read_flag;
+extern atomic_t vfs_write_flag;
+extern unsigned int vfs_amount;
+extern loff_t vfs_file_offset;
+
+int sunxi_usb_device_enable(void);
+int sunxi_usb_device_disable(void);
+int get_dp_dm_status_normal(void);
+
+#endif   /* __SUNXI_UDC_H__ */
diff --git a/drivers/usb/sunxi_usb/include/sunxi_usb_board.h b/drivers/usb/sunxi_usb/include/sunxi_usb_board.h
new file mode 100644
index 000000000..6fd39312c
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_usb_board.h
@@ -0,0 +1,136 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_usb_board.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * usb board config.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_USB_BOARD_H__
+#define __SUNXI_USB_BOARD_H__
+
+#include <linux/sunxi-gpio.h>
+#include <linux/of_gpio.h>
+
+#if defined(CONFIG_DUAL_ROLE_USB_INTF)
+#include <linux/usb/class-dual-role.h>
+#endif
+
+#if defined(CONFIG_TYPEC)
+#include <linux/usb/typec.h>
+#endif
+
+#define  SET_USB_PARA				"usb_para"
+#define  SET_USB0				"usbc0"
+#define  SET_USB1				"usbc1"
+#define  SET_USB2				"usbc2"
+
+#define  KEY_USB_GLOBAL_ENABLE			"usb_global_enable"
+#define  KEY_USBC_NUM				"usbc_num"
+
+#define  KEY_USB_ENABLE				"usbc0_used"
+#define  KEY_USB_PORT_TYPE			"usb_port_type"
+#define  KEY_USB_DET_MODE			"usb_detect_mode"
+#define  KEY_USB_ID_GPIO			"usb_id_gpio"
+#define  KEY_USB_DETVBUS_GPIO			"usb_det_vbus_gpio"
+
+#define  KEY_USB_REGULATOR_IO			"usb_regulator_io"
+#define  KEY_USB_REGULATOR_IO_VOL		"usb_regulator_vol"
+#define  KEY_USB_REGULATOR_ID_VBUS		"usb_regulator_id_vbus"
+#define  KEY_USB_REGULATOR_ID_VBUS_VOL		"usb_regulator_id_vbus_vol"
+
+#define  KEY_USB_WAKEUP_SUSPEND		        "usb_wakeup_suspend"
+
+/* USB config info */
+enum usb_gpio_group_type {
+	GPIO_GROUP_TYPE_PIO = 0,
+	GPIO_GROUP_TYPE_POWER,
+};
+
+/* 0: device only; 1: host only; 2: otg */
+enum usb_port_type {
+	USB_PORT_TYPE_DEVICE = 0,
+	USB_PORT_TYPE_HOST,
+	USB_PORT_TYPE_OTG,
+};
+
+/* 0: dp/dm detect, 1: vbus/id detect */
+enum usb_detect_type {
+	USB_DETECT_TYPE_DP_DM = 0,
+	USB_DETECT_TYPE_VBUS_ID,
+};
+
+/* 0: thread scan mode; 1: gpio interrupt mode */
+enum usb_detect_mode {
+	USB_DETECT_MODE_THREAD = 0,
+	USB_DETECT_MODE_INTR,
+};
+
+enum usb_det_vbus_type {
+	USB_DET_VBUS_TYPE_NULL = 0,
+	USB_DET_VBUS_TYPE_GPIO,
+	USB_DET_VBUS_TYPE_AXP,
+};
+
+enum usb_id_type {
+	USB_ID_TYPE_NULL = 0,
+	USB_ID_TYPE_GPIO,
+	USB_ID_TYPE_AXP,
+};
+
+/* pio info */
+typedef struct usb_gpio {
+	/* pio valid, 1 - valid, 0 - invalid */
+	__u32 valid;
+	struct gpio_config gpio_set;
+} usb_gpio_t;
+
+typedef struct usb_port_info {
+	__u32 enable;				/* port valid */
+
+	__u32 port_no;				/* usb port number */
+	enum usb_port_type port_type;		/* usb port type */
+	enum usb_detect_type detect_type;	/* usb detect type */
+	enum usb_detect_mode detect_mode;	/* usb detect mode */
+	enum usb_det_vbus_type det_vbus_type;
+	enum usb_id_type id_type;
+	const char *det_vbus_name;
+	const char *id_name;
+	usb_gpio_t id;				/* usb id pin info */
+	usb_gpio_t det_vbus;			/* usb vbus pin info */
+	usb_gpio_t drv_vbus;			/* usb drv_vbus pin info */
+	usb_gpio_t restrict_gpio_set;		/* usb drv_vbus pin info */
+	__u32 usb_restrict_flag;		/* usb port number(?) */
+	__u32 voltage;				/* usb port number(?) */
+	__u32 capacity;				/* usb port number(?) */
+
+	int id_irq_num;				/* id gpio irq num */
+
+#if defined(CONFIG_DUAL_ROLE_USB_INTF)
+	struct dual_role_phy_instance *dual_role;
+	struct dual_role_phy_desc dr_desc;
+#endif
+#if defined(CONFIG_TYPEC)
+	struct typec_port *typec_port;
+	struct typec_partner *partner;
+	struct typec_capability typec_caps;
+	bool connected;
+#endif
+} usb_port_info_t;
+
+typedef struct usb_cfg {
+	u32 usb_global_enable;
+	u32 usbc_num;
+	struct platform_device *pdev;
+
+	struct usb_port_info port;
+} usb_cfg_t;
+
+#endif /* __SUNXI_USB_BOARD_H__ */
diff --git a/drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h b/drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h
new file mode 100644
index 000000000..8c4bbdf1b
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h
@@ -0,0 +1,966 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * register defination.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+
+#ifndef __SUNXI_USB_BSP_H__
+#define __SUNXI_USB_BSP_H__
+
+#include <linux/io.h>
+
+#define  USBC_Readb(reg)	readb(reg)
+#define  USBC_Readw(reg)	readw(reg)
+#define  USBC_Readl(reg)	readl(reg)
+#define  USBC_Readq(reg)	readq(reg)
+
+#define  USBC_Writeb(value, reg)	writeb(value, reg)
+#define  USBC_Writew(value, reg)	writew(value, reg)
+#define  USBC_Writel(value, reg)	writel(value, reg)
+#define  USBC_Writeq(value, reg)	writeq(value, reg)
+
+#define  USBC_REG_test_bit_b(bp, reg)	(USBC_Readb(reg) & (1 << (bp)))
+#define  USBC_REG_test_bit_w(bp, reg)	(USBC_Readw(reg) & (1 << (bp)))
+#define  USBC_REG_test_bit_l(bp, reg)	(USBC_Readl(reg) & (1 << (bp)))
+
+#define  USBC_REG_set_bit_b(bp, reg)	(USBC_Writeb((USBC_Readb(reg) \
+						| (1 << (bp))), (reg)))
+#define  USBC_REG_set_bit_w(bp, reg)	(USBC_Writew((USBC_Readw(reg) \
+						| (1 << (bp))), (reg)))
+#define  USBC_REG_set_bit_l(bp, reg)	(USBC_Writel((USBC_Readl(reg) \
+						| (1 << (bp))), (reg)))
+#define  USBC_REG_clear_bit_b(bp, reg)	(USBC_Writeb((USBC_Readb(reg) \
+						& (~(1 << (bp)))), (reg)))
+#define  USBC_REG_clear_bit_w(bp, reg)	(USBC_Writew((USBC_Readw(reg) \
+						& (~(1 << (bp)))), (reg)))
+#define  USBC_REG_clear_bit_l(bp, reg)	(USBC_Writel((USBC_Readl(reg) \
+						& (~(1 << (bp)))), (reg)))
+
+/* reg base */
+#define  USBC0_BASE	0x01c13000
+#define  USBC1_BASE	0x01c14000
+#define  USBC2_BASE	0x01c1E000
+
+/* reg offset */
+#define  USBC_REG_o_FADDR	0x0098
+#define  USBC_REG_o_PCTL	0x0040
+#define  USBC_REG_o_INTTx	0x0044
+#define  USBC_REG_o_INTRx	0x0046
+#define  USBC_REG_o_INTTxE	0x0048
+#define  USBC_REG_o_INTRxE	0x004A
+#define  USBC_REG_o_INTUSB	0x004C
+#define  USBC_REG_o_INTUSBE	0x0050
+#define  USBC_REG_o_FRNUM	0x0054
+#define  USBC_REG_o_EPIND	0x0042
+#define  USBC_REG_o_TMCTL	0x007C
+
+#define  USBC_REG_o_TXMAXP	0x0080
+#define  USBC_REG_o_CSR0	0x0082
+#define  USBC_REG_o_TXCSR	0x0082
+#define  USBC_REG_o_RXMAXP	0x0084
+#define  USBC_REG_o_RXCSR	0x0086
+#define  USBC_REG_o_COUNT0	0x0088
+#define  USBC_REG_o_RXCOUNT	0x0088
+#define  USBC_REG_o_EP0TYPE	0x008C
+#define  USBC_REG_o_TXTYPE	0x008C
+#define  USBC_REG_o_NAKLIMIT0	0x008D
+#define  USBC_REG_o_TXINTERVAL	0x008D
+#define  USBC_REG_o_RXTYPE	0x008E
+#define  USBC_REG_o_RXINTERVAL	0x008F
+
+#define  USBC_REG_o_CONFIGDATA	0x00c0
+
+#define  USBC_REG_o_EPFIFO0	0x0000
+#define  USBC_REG_o_EPFIFO1	0x0004
+#define  USBC_REG_o_EPFIFO2	0x0008
+#define  USBC_REG_o_EPFIFO3	0x000C
+#define  USBC_REG_o_EPFIFO4	0x0010
+#define  USBC_REG_o_EPFIFO5	0x0014
+#define  USBC_REG_o_EPFIFOx(n)	(0x0000 + (n<<2))
+
+#define  USBC_REG_o_DEVCTL	0x0041
+
+#define  USBC_REG_o_TXFIFOSZ	0x0090
+#define  USBC_REG_o_RXFIFOSZ	0x0094
+#define  USBC_REG_o_TXFIFOAD	0x0092
+#define  USBC_REG_o_RXFIFOAD	0x0096
+
+#define  USBC_REG_o_VEND0	0x0043
+#define  USBC_REG_o_VEND1	0x007D
+#define  USBC_REG_o_VEND3	0x007E
+
+#define  USBC_REG_o_EPINFO	0x0078
+#define  USBC_REG_o_RAMINFO	0x0079
+#define  USBC_REG_o_LINKINFO	0x007A
+#define  USBC_REG_o_VPLEN	0x007B
+#define  USBC_REG_o_HSEOF	0x007C
+#define  USBC_REG_o_FSEOF	0x007D
+#define  USBC_REG_o_LSEOF	0x007E
+
+/* new */
+#define  USBC_REG_o_FADDR0	0x0098
+#define  USBC_REG_o_HADDR0	0x009A
+#define  USBC_REG_o_HPORT0	0x009B
+#define  USBC_REG_o_TXFADDRx	0x0098
+#define  USBC_REG_o_TXHADDRx	0x009A
+#define  USBC_REG_o_TXHPORTx	0x009B
+#define  USBC_REG_o_RXFADDRx	0x009C
+#define  USBC_REG_o_RXHADDRx	0x009E
+#define  USBC_REG_o_RXHPORTx	0x009F
+
+#define  USBC_REG_o_RPCOUNT	0x008A
+
+/* new */
+#define  USBC_REG_o_ISCR	0x0400
+#define  USBC_REG_o_PHYCTL	0x0404
+#define  USBC_REG_o_PHYBIST	0x0408
+#define  USBC_REG_o_PHYTUNE	0x0418
+#define  USBC_REG_o_PHYSTATUS	0x0424
+
+#if defined(CONFIG_ARCH_SUN50I) \
+		|| defined(CONFIG_ARCH_SUN8IW10) \
+		|| defined(CONFIG_ARCH_SUN8IW11) \
+		|| defined(CONFIG_ARCH_SUN8IW12) \
+		|| defined(CONFIG_ARCH_SUN8IW15) \
+		|| defined(CONFIG_ARCH_SUN8IW8) \
+		|| defined(CONFIG_ARCH_SUN8IW7) \
+		|| defined(CONFIG_ARCH_SUN8IW6) \
+		|| defined(CONFIG_ARCH_SUN8IW17) \
+		|| defined(CONFIG_ARCH_SUN8IW18) \
+		|| defined(CONFIG_ARCH_SUN8IW16) \
+		|| defined(CONFIG_ARCH_SUN8IW19) \
+		|| defined(CONFIG_ARCH_SUN8IW20)\
+		|| defined(CONFIG_ARCH_SUN20IW1)
+#define  USBPHYC_REG_o_PHYCTL	0x0410
+#else
+#define  USBPHYC_REG_o_PHYCTL	0x0404
+#endif
+
+/* dma */
+#define  USBC_REG_o_DMA_INTE		0x0500
+#define  USBC_REG_o_DMA_INTS		0x0504
+#define  USBC_REG_o_DMA_CHAN_CFN(n)	(0x0540 + (0x10 * n))
+#define  USBC_REG_o_DMA_SDRAM_ADD(n)	(0x0544 + (0x10 * n))
+#define  USBC_REG_o_DMA_BC(n)		(0x0548 + (0x10 * n))
+#define  USBC_REG_o_DMA_RESIDUAL_BC(n)	(0x054c + (0x10 * n))
+
+/* registers */
+#define  USBC_REG_FADDR(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_FADDR)
+#define  USBC_REG_PCTL(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_PCTL)
+#define  USBC_REG_INTTx(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_INTTx)
+#define  USBC_REG_INTRx(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_INTRx)
+#define  USBC_REG_INTTxE(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_INTTxE)
+#define  USBC_REG_INTRxE(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_INTRxE)
+#define  USBC_REG_INTUSB(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_INTUSB)
+#define  USBC_REG_INTUSBE(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_INTUSBE)
+#define  USBC_REG_FRNUM(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_FRNUM)
+#define  USBC_REG_EPIND(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_EPIND)
+#define  USBC_REG_TMCTL(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_TMCTL)
+#define  USBC_REG_TXMAXP(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_TXMAXP)
+
+#define  USBC_REG_CSR0(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_CSR0)
+#define  USBC_REG_TXCSR(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_TXCSR)
+
+#define  USBC_REG_RXMAXP(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_RXMAXP)
+#define  USBC_REG_RXCSR(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_RXCSR)
+
+#define  USBC_REG_COUNT0(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_COUNT0)
+#define  USBC_REG_RXCOUNT(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_RXCOUNT)
+
+#define  USBC_REG_EP0TYPE(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_EP0TYPE)
+#define  USBC_REG_TXTYPE(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_TXTYPE)
+
+#define  USBC_REG_NAKLIMIT0(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_NAKLIMIT0)
+#define  USBC_REG_TXINTERVAL(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_TXINTERVAL)
+
+#define  USBC_REG_RXTYPE(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_RXTYPE)
+#define  USBC_REG_RXINTERVAL(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_RXINTERVAL)
+#define  USBC_REG_CONFIGDATA(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_CONFIGDATA)
+#define  USBC_REG_EPFIFO0(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_EPFIFO0)
+#define  USBC_REG_EPFIFO1(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_EPFIFO1)
+#define  USBC_REG_EPFIFO2(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_EPFIFO2)
+#define  USBC_REG_EPFIFO3(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_EPFIFO3)
+#define  USBC_REG_EPFIFO4(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_EPFIFO4)
+#define  USBC_REG_EPFIFO5(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_EPFIFO5)
+#define  USBC_REG_EPFIFOx(usbc_base_addr, n)	((usbc_base_addr) \
+							+ USBC_REG_o_EPFIFOx(n))
+#define  USBC_REG_DEVCTL(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_DEVCTL)
+#define  USBC_REG_TXFIFOSZ(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_TXFIFOSZ)
+#define  USBC_REG_RXFIFOSZ(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_RXFIFOSZ)
+#define  USBC_REG_TXFIFOAD(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_TXFIFOAD)
+#define  USBC_REG_RXFIFOAD(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_RXFIFOAD)
+#define  USBC_REG_VEND0(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_VEND0)
+#define  USBC_REG_VEND1(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_VEND1)
+#define  USBC_REG_EPINFO(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_EPINFO)
+#define  USBC_REG_RAMINFO(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_RAMINFO)
+#define  USBC_REG_LINKINFO(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_LINKINFO)
+#define  USBC_REG_VPLEN(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_VPLEN)
+#define  USBC_REG_HSEOF(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_HSEOF)
+#define  USBC_REG_FSEOF(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_FSEOF)
+#define  USBC_REG_LSEOF(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_LSEOF)
+
+#define  USBC_REG_FADDR0(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_FADDR0)
+#define  USBC_REG_HADDR0(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_HADDR0)
+#define  USBC_REG_HPORT0(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_HPORT0)
+
+#define  USBC_REG_TXFADDRx(usbc_base_addr, n)	((usbc_base_addr) \
+							+ USBC_REG_o_TXFADDRx)
+#define  USBC_REG_TXHADDRx(usbc_base_addr, n)	((usbc_base_addr) \
+							+ USBC_REG_o_TXHADDRx)
+#define  USBC_REG_TXHPORTx(usbc_base_addr, n)	((usbc_base_addr) \
+							+ USBC_REG_o_TXHPORTx)
+#define  USBC_REG_RXFADDRx(usbc_base_addr, n)	((usbc_base_addr) \
+							+ USBC_REG_o_RXFADDRx)
+#define  USBC_REG_RXHADDRx(usbc_base_addr, n)	((usbc_base_addr) \
+							+ USBC_REG_o_RXHADDRx)
+#define  USBC_REG_RXHPORTx(usbc_base_addr, n)	((usbc_base_addr) \
+							+ USBC_REG_o_RXHPORTx)
+
+#define  USBC_REG_RPCOUNTx(usbc_base_addr, n)	((usbc_base_addr) \
+							+ USBC_REG_o_RPCOUNT)
+
+#define  USBC_REG_ISCR(usbc_base_addr)		((usbc_base_addr) \
+							+ USBC_REG_o_ISCR)
+#define  USBC_REG_PHYCTL(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_PHYCTL)
+#define  USBC_REG_PHYBIST(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_PHYBIST)
+#define  USBC_REG_PHYTUNE(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_PHYTUNE)
+
+#define  USBC_REG_RXFADDRx_Ex(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_RXFADDRx)
+
+/* dma */
+#define  USBC_REG_DMA_INTE(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_DMA_INTE)
+#define  USBC_REG_DMA_INTS(usbc_base_addr)	((usbc_base_addr) \
+							+ USBC_REG_o_DMA_INTS)
+#define  USBC_REG_DMA_CHAN_CFN(usbc_base_addr, n)	\
+			((usbc_base_addr) + USBC_REG_o_DMA_CHAN_CFN(n))
+#define  USBC_REG_DMA_SDRAM_ADD(usbc_base_addr, n)	\
+			((usbc_base_addr) + USBC_REG_o_DMA_SDRAM_ADD(n))
+#define  USBC_REG_DMA_BC(usbc_base_addr, n)		\
+			((usbc_base_addr) + USBC_REG_o_DMA_BC(n))
+#define  USBC_REG_DMA_RESIDUAL_BC(usbc_base_addr, n)	\
+			((usbc_base_addr) + USBC_REG_o_DMA_RESIDUAL_BC(n))
+
+/* registers extern */
+#define  USBC_REG_EX_USB_EPFIFOn(usbc_base_addr)	\
+				((usbc_base_addr) + (0x00 + (n << 2)))
+#define  USBC_REG_EX_USB_GCS(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0040)
+#define  USBC_REG_EX_USB_EPINTF(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0044)
+#define  USBC_REG_EX_USB_EPINTE(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0048)
+#define  USBC_REG_EX_USB_BUSINTF(usbc_base_addr)	\
+				((usbc_base_addr) + 0x004C)
+#define  USBC_REG_EX_USB_BUSINTE(usbc_base_addr)	\
+				((usbc_base_addr) + 0x0050)
+#define  USBC_REG_EX_USB_FNUM(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0054)
+#define  USBC_REG_EX_USB_TESTC(usbc_base_addr)		\
+				((usbc_base_addr) + 0x007C)
+
+#define  USBC_REG_EX_USB_CSR0(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0080)
+#define  USBC_REG_EX_USB_TXCSR(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0080)
+#define  USBC_REG_EX_USB_RXCSR(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0084)
+#define  USBC_REG_EX_USB_COUNT0(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0088)
+#define  USBC_REG_EX_USB_RXCOUNT(usbc_base_addr)	\
+				((usbc_base_addr) + 0x0088)
+#define  USBC_REG_EX_USB_ATTR0(usbc_base_addr)		\
+				((usbc_base_addr) + 0x008C)
+#define  USBC_REG_EX_USB_EPATTR(usbc_base_addr)		\
+				((usbc_base_addr) + 0x008C)
+#define  USBC_REG_EX_USB_TXFIFO(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0090)
+#define  USBC_REG_EX_USB_RXFIFO(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0094)
+#define  USBC_REG_EX_USB_FADDR(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0098)
+#define  USBC_REG_EX_USB_TXFADDR(usbc_base_addr)	\
+				((usbc_base_addr) + 0x0098)
+#define  USBC_REG_EX_USB_RXFADDR(usbc_base_addr)	\
+				((usbc_base_addr) + 0x009C)
+
+#define  USBC_REG_EX_USB_CONFIGINFO(usbc_base_addr)	\
+				((usbc_base_addr) + 0x00C0)
+#define  USBC_REG_EX_USB_LINKTIM(usbc_base_addr)	\
+				((usbc_base_addr) + 0x00C4)
+#define  USBC_REG_EX_USB_OTGTIM(usbc_base_addr)		\
+				((usbc_base_addr) + 0x00C8)
+
+#define  USBC_REG_EX_USB_ISCR(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0400)
+#define  USBC_REG_EX_USB_PHYCTL(usbc_base_addr)		\
+				((usbc_base_addr) + 0x0404)
+#define  USBC_REG_EX_USB_PHYBIST(usbc_base_addr)	\
+				((usbc_base_addr) + 0x0408)
+
+/* bit position */
+
+/* USB Power Control for Host only */
+#define  USBC_BP_POWER_H_HIGH_SPEED_EN			5
+#define  USBC_BP_POWER_H_HIGH_SPEED_FLAG		4
+#define  USBC_BP_POWER_H_RESET				3
+#define  USBC_BP_POWER_H_RESUME				2
+#define  USBC_BP_POWER_H_SUSPEND			1
+#define  USBC_BP_POWER_H_SUEPEND_EN			0
+
+/* USB Power Control for device only */
+#define  USBC_BP_POWER_D_ISO_UPDATE_EN			7
+#define  USBC_BP_POWER_D_SOFT_CONNECT			6
+#define  USBC_BP_POWER_D_HIGH_SPEED_EN			5
+#define  USBC_BP_POWER_D_HIGH_SPEED_FLAG		4
+#define  USBC_BP_POWER_D_RESET_FLAG			3
+#define  USBC_BP_POWER_D_RESUME				2
+#define  USBC_BP_POWER_D_SUSPEND			1
+#define  USBC_BP_POWER_D_ENABLE_SUSPENDM		0
+
+/* interrupt flags for ep0 and the Tx ep1~4 */
+#define  USBC_BP_INTTx_FLAG_EP5				5
+#define  USBC_BP_INTTx_FLAG_EP4				4
+#define  USBC_BP_INTTx_FLAG_EP3				3
+#define  USBC_BP_INTTx_FLAG_EP2				2
+#define  USBC_BP_INTTx_FLAG_EP1				1
+#define  USBC_BP_INTTx_FLAG_EP0				0
+
+/* interrupt flags for Rx ep1~4 */
+#define  USBC_BP_INTRx_FLAG_EP5				5
+#define  USBC_BP_INTRx_FLAG_EP4				4
+#define  USBC_BP_INTRx_FLAG_EP3				3
+#define  USBC_BP_INTRx_FLAG_EP2				2
+#define  USBC_BP_INTRx_FLAG_EP1				1
+
+/* interrupt enable for Tx ep0~4 */
+#define  USBC_BP_INTTxE_EN_EP5				5
+#define  USBC_BP_INTTxE_EN_EP4				4
+#define  USBC_BP_INTTxE_EN_EP3				3
+#define  USBC_BP_INTTxE_EN_EP2				2
+#define  USBC_BP_INTTxE_EN_EP1				1
+#define  USBC_BP_INTTxE_EN_EP0				0
+
+/* interrupt enable for Rx ep1~4 */
+#define  USBC_BP_INTRxE_EN_EP5				5
+#define  USBC_BP_INTRxE_EN_EP4				4
+#define  USBC_BP_INTRxE_EN_EP3				3
+#define  USBC_BP_INTRxE_EN_EP2				2
+#define  USBC_BP_INTRxE_EN_EP1				1
+
+/* USB interrupt */
+#define  USBC_BP_INTUSB_VBUS_ERROR			7
+#define  USBC_BP_INTUSB_SESSION_REQ			6
+#define  USBC_BP_INTUSB_DISCONNECT			5
+#define  USBC_BP_INTUSB_CONNECT				4
+#define  USBC_BP_INTUSB_SOF				3
+#define  USBC_BP_INTUSB_RESET				2
+#define  USBC_BP_INTUSB_RESUME				1
+#define  USBC_BP_INTUSB_SUSPEND				0
+
+/* USB interrupt enable */
+#define  USBC_BP_INTUSBE_EN_VBUS_ERROR			7
+#define  USBC_BP_INTUSBE_EN_SESSION_REQ			6
+#define  USBC_BP_INTUSBE_EN_DISCONNECT			5
+#define  USBC_BP_INTUSBE_EN_CONNECT			4
+#define  USBC_BP_INTUSBE_EN_SOF				3
+#define  USBC_BP_INTUSBE_EN_RESET			2
+#define  USBC_BP_INTUSBE_EN_RESUME			1
+#define  USBC_BP_INTUSBE_EN_SUSPEND			0
+
+/* Test Mode Control */
+#define  USBC_BP_TMCTL_FORCE_HOST			7
+#define  USBC_BP_TMCTL_FIFO_ACCESS			6
+#define  USBC_BP_TMCTL_FORCE_FS				5
+#define  USBC_BP_TMCTL_FORCE_HS				4
+#define  USBC_BP_TMCTL_TEST_PACKET			3
+#define  USBC_BP_TMCTL_TEST_K				 2
+#define  USBC_BP_TMCTL_TEST_J				1
+#define  USBC_BP_TMCTL_TEST_SE0_NAK			0
+
+/* Tx Max packet */
+#define  USBC_BP_TXMAXP_PACKET_COUNT			11
+#define  USBC_BP_TXMAXP_MAXIMUM_PAYLOAD			0
+
+/* Control and Status Register for ep0 for Host only */
+#define  USBC_BP_CSR0_H_DisPing				11
+#define  USBC_BP_CSR0_H_FlushFIFO			8
+#define  USBC_BP_CSR0_H_NAK_Timeout			7
+#define  USBC_BP_CSR0_H_StatusPkt			6
+#define  USBC_BP_CSR0_H_ReqPkt				5
+#define  USBC_BP_CSR0_H_Error				4
+#define  USBC_BP_CSR0_H_SetupPkt			3
+#define  USBC_BP_CSR0_H_RxStall				2
+#define  USBC_BP_CSR0_H_TxPkRdy				1
+#define  USBC_BP_CSR0_H_RxPkRdy				0
+
+/* Control and Status Register for ep0 for device only */
+#define  USBC_BP_CSR0_D_FLUSH_FIFO			8
+#define  USBC_BP_CSR0_D_SERVICED_SETUP_END		7
+#define  USBC_BP_CSR0_D_SERVICED_RX_PKT_READY		6
+#define  USBC_BP_CSR0_D_SEND_STALL			5
+#define  USBC_BP_CSR0_D_SETUP_END			4
+#define  USBC_BP_CSR0_D_DATA_END			3
+#define  USBC_BP_CSR0_D_SENT_STALL			2
+#define  USBC_BP_CSR0_D_TX_PKT_READY			1
+#define  USBC_BP_CSR0_D_RX_PKT_READY			0
+
+/* Tx ep Control and Status Register for Host only */
+#define  USBC_BP_TXCSR_H_AUTOSET			15
+#define  USBC_BP_TXCSR_H_RESERVED			14
+#define  USBC_BP_TXCSR_H_MODE				13
+#define  USBC_BP_TXCSR_H_DMA_REQ_EN			12
+#define  USBC_BP_TXCSR_H_FORCE_DATA_TOGGLE		11
+#define  USBC_BP_TXCSR_H_DMA_REQ_MODE			10
+#define  USBC_BP_TXCSR_H_DATA_TOGGLE_WR_EN		9
+#define  USBC_BP_TXCSR_H_DATA_TOGGLE			8
+#define  USBC_BP_TXCSR_H_NAK_TIMEOUT			7
+#define  USBC_BP_TXCSR_H_CLEAR_DATA_TOGGLE		6
+#define  USBC_BP_TXCSR_H_TX_STALL			5
+#define  USBC_BP_TXCSR_H_FLUSH_FIFO			3
+#define  USBC_BP_TXCSR_H_ERROR				2
+#define  USBC_BP_TXCSR_H_FIFO_NOT_EMPTY			1
+#define  USBC_BP_TXCSR_H_TX_READY			0
+
+#define  USBC_TXCSR_H_WZC_BITS	((1 << USBC_BP_TXCSR_H_NAK_TIMEOUT) \
+				| (1 << USBC_BP_TXCSR_H_TX_STALL) \
+				| (1 << USBC_BP_TXCSR_H_ERROR) \
+				| (1 << USBC_BP_TXCSR_H_FIFO_NOT_EMPTY))
+
+/* Tx ep Control and Status Register for Device only */
+#define  USBC_BP_TXCSR_D_AUTOSET			15
+#define  USBC_BP_TXCSR_D_ISO				14
+#define  USBC_BP_TXCSR_D_MODE				13
+#define  USBC_BP_TXCSR_D_DMA_REQ_EN			12
+#define  USBC_BP_TXCSR_D_FORCE_DATA_TOGGLE		11
+#define  USBC_BP_TXCSR_D_DMA_REQ_MODE			10
+#define  USBC_BP_TXCSR_D_INCOMPLETE			7
+#define  USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE		6
+#define  USBC_BP_TXCSR_D_SENT_STALL			5
+#define  USBC_BP_TXCSR_D_SEND_STALL			4
+#define  USBC_BP_TXCSR_D_FLUSH_FIFO			3
+#define  USBC_BP_TXCSR_D_UNDER_RUN			2
+#define  USBC_BP_TXCSR_D_FIFO_NOT_EMPTY			1
+#define  USBC_BP_TXCSR_D_TX_READY			0
+
+/* Rx Max Packet */
+#define  USBC_BP_RXMAXP_PACKET_COUNT			11
+#define  USBC_BP_RXMAXP_MAXIMUM_PAYLOAD			0
+
+/* Rx ep Control and Status Register for Host only */
+#define  USBC_BP_RXCSR_H_AUTO_CLEAR			15
+#define  USBC_BP_RXCSR_H_AUTO_REQ			14
+#define  USBC_BP_RXCSR_H_DMA_REQ_EN			13
+#define  USBC_BP_RXCSR_H_DISNYET			12  /* dis nyet */
+#define  USBC_BP_RXCSR_H_PID_ERROR			12  /* pid error */
+#define  USBC_BP_RXCSR_H_DMA_REQ_MODE			11
+#define  USBC_BP_RXCSR_H_DATA_TOGGLE_WR_EN		10
+#define  USBC_BP_RXCSR_H_DATA_TOGGLE			9
+#define  USBC_BP_RXCSR_H_INCOMPLETE			8
+#define  USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE		7
+#define  USBC_BP_RXCSR_H_RX_STALL			6
+#define  USBC_BP_RXCSR_H_REQ_PACKET			5
+#define  USBC_BP_RXCSR_H_FLUSH_FIFO			4
+#define  USBC_BP_RXCSR_H_DATA_ERR			3   /* iso */
+#define  USBC_BP_RXCSR_H_NAK_TIMEOUT			3   /* bulk */
+#define  USBC_BP_RXCSR_H_ERROR				2
+#define  USBC_BP_RXCSR_H_FIFO_FULL			1
+#define  USBC_BP_RXCSR_H_RX_PKT_READY			0
+
+#define  USBC_RXCSR_H_WZC_BITS	((1 << USBC_BP_RXCSR_H_RX_STALL) \
+				| (1 << USBC_BP_RXCSR_H_ERROR) \
+				| (1 << USBC_BP_RXCSR_H_DATA_ERR) \
+				| (1 << USBC_BP_RXCSR_H_RX_PKT_READY))
+
+/* Rx ep Control and Status Register for Device only */
+#define  USBC_BP_RXCSR_D_AUTO_CLEAR			15
+#define  USBC_BP_RXCSR_D_ISO				14
+#define  USBC_BP_RXCSR_D_DMA_REQ_EN			13
+#define  USBC_BP_RXCSR_D_DISABLE_NYET			12
+#define  USBC_BP_RXCSR_D_DMA_REQ_MODE			11
+
+#define  USBC_BP_RXCSR_D_INCOMPLETE			8
+#define  USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE		7
+#define  USBC_BP_RXCSR_D_SENT_STALL			6
+#define  USBC_BP_RXCSR_D_SEND_STALL			5
+#define  USBC_BP_RXCSR_D_FLUSH_FIFO			4
+#define  USBC_BP_RXCSR_D_DATA_ERROR			3
+#define  USBC_BP_RXCSR_D_OVERRUN			2
+#define  USBC_BP_RXCSR_D_FIFO_FULL			1
+#define  USBC_BP_RXCSR_D_RX_PKT_READY			0
+
+/* Tx Type Register for host only */
+#define  USBC_BP_TXTYPE_SPEED				6   /* new */
+#define  USBC_BP_TXTYPE_PROROCOL			4
+#define  USBC_BP_TXTYPE_TARGET_EP_NUM			0
+
+/* Rx Type Register for host only */
+#define  USBC_BP_RXTYPE_SPEED				6   /* new */
+#define  USBC_BP_RXTYPE_PROROCOL			4
+#define  USBC_BP_RXTYPE_TARGET_EP_NUM			0
+
+/* Core Configueation */
+#define  USBC_BP_CONFIGDATA_MPRXE			7
+#define  USBC_BP_CONFIGDATA_MPTXE			6
+#define  USBC_BP_CONFIGDATA_BIGENDIAN			5
+#define  USBC_BP_CONFIGDATA_HBRXE			4
+#define  USBC_BP_CONFIGDATA_HBTXE			3
+#define  USBC_BP_CONFIGDATA_DYNFIFO_SIZING		2
+#define  USBC_BP_CONFIGDATA_SOFTCONE			1
+#define  USBC_BP_CONFIGDATA_UTMI_DATAWIDTH		0
+
+/* OTG Device Control */
+#define  USBC_BP_DEVCTL_B_DEVICE			7
+#define  USBC_BP_DEVCTL_FS_DEV				6
+#define  USBC_BP_DEVCTL_LS_DEV				5
+
+#define  USBC_BP_DEVCTL_VBUS				3
+#define  USBC_BP_DEVCTL_HOST_MODE			2
+#define  USBC_BP_DEVCTL_HOST_REQ			1
+#define  USBC_BP_DEVCTL_SESSION				0
+
+/* Tx EP FIFO size control */
+#define  USBC_BP_TXFIFOSZ_DPB				4
+#define  USBC_BP_TXFIFOSZ_SZ				0
+
+/* Rx EP FIFO size control */
+#define  USBC_BP_RXFIFOSZ_DPB				4
+#define  USBC_BP_RXFIFOSZ_SZ				0
+
+/* vendor0 */
+#define  USBC_BP_VEND0_DRQ_SEL				1
+#define  USBC_BP_VEND0_BUS_SEL				0
+
+/* hub address */
+#define  USBC_BP_HADDR_MULTI_TT				7
+
+/* Interface Status and Control */
+#define  USBC_BP_ISCR_VBUS_VALID_FROM_DATA		30
+#define  USBC_BP_ISCR_VBUS_VALID_FROM_VBUS		29
+#define  USBC_BP_ISCR_EXT_ID_STATUS			28
+#define  USBC_BP_ISCR_EXT_DM_STATUS			27
+#define  USBC_BP_ISCR_EXT_DP_STATUS			26
+#define  USBC_BP_ISCR_MERGED_VBUS_STATUS		25
+#define  USBC_BP_ISCR_MERGED_ID_STATUS			24
+
+#define  USBC_BP_ISCR_ID_PULLUP_EN			17
+#define  USBC_BP_ISCR_DPDM_PULLUP_EN			16
+#define  USBC_BP_ISCR_FORCE_ID				14
+#define  USBC_BP_ISCR_FORCE_VBUS_VALID			12
+#define  USBC_BP_ISCR_VBUS_VALID_SRC			10
+
+#define  USBC_BP_ISCR_HOSC_EN				7
+#define  USBC_BP_ISCR_VBUS_CHANGE_DETECT		6
+#define  USBC_BP_ISCR_ID_CHANGE_DETECT			5
+#define  USBC_BP_ISCR_DPDM_CHANGE_DETECT		4
+#define  USBC_BP_ISCR_IRQ_ENABLE			3
+#define  USBC_BP_ISCR_VBUS_CHANGE_DETECT_EN		2
+#define  USBC_BP_ISCR_ID_CHANGE_DETECT_EN		1
+#define  USBC_BP_ISCR_DPDM_CHANGE_DETECT_EN		0
+
+/* usb resource description */
+#define  USBC_MAX_CTL_NUM				1
+/* max EP support, ep0~5 */
+#define  USBC_MAX_EP_NUM				6
+#define  USBC0_MAX_FIFO_SIZE				(8 * 1024)
+/* This is non-configurable */
+#define  USBC_EP0_FIFOSIZE				64
+
+/* usb OTG mode */
+#define  USBC_OTG_HOST					0
+#define  USBC_OTG_DEVICE				1
+
+/* usb device type */
+#define  USBC_DEVICE_HSDEV				0
+#define  USBC_DEVICE_FSDEV				1
+#define  USBC_DEVICE_LSDEV				2
+
+/* usb transfer type */
+#define  USBC_TS_TYPE_IDLE				0
+#define  USBC_TS_TYPE_CTRL				1
+#define  USBC_TS_TYPE_ISO				2
+#define  USBC_TS_TYPE_INT				3
+#define  USBC_TS_TYPE_BULK				4
+
+/* usb transfer mode */
+#define  USBC_TS_MODE_UNKNOWN				0
+#define  USBC_TS_MODE_LS				1
+#define  USBC_TS_MODE_FS				2
+#define  USBC_TS_MODE_HS				3
+
+/* usb Vbus status */
+#define  USBC_VBUS_STATUS_BELOW_SESSIONEND		0
+#define  USBC_VBUS_STATUS_ABOVE_SESSIONEND_BELOW_AVALID	1
+#define  USBC_VBUS_STATUS_ABOVE_AVALID_BELOW_VBUSVALID	2
+#define  USBC_VBUS_STATUS_ABOVE_VBUSVALID		3
+
+/* usb io type */
+#define  USBC_IO_TYPE_PIO				0
+#define  USBC_IO_TYPE_DMA				1
+
+/* usb ep type */
+#define  USBC_EP_TYPE_IDLE				0
+#define  USBC_EP_TYPE_EP0				1
+#define  USBC_EP_TYPE_TX				2
+#define  USBC_EP_TYPE_RX				3
+
+/* usb id type */
+#define  USBC_ID_TYPE_DISABLE				0
+#define  USBC_ID_TYPE_HOST				1
+#define  USBC_ID_TYPE_DEVICE				2
+
+/* usb vbus valid type */
+#define  USBC_VBUS_TYPE_DISABLE				0
+#define  USBC_VBUS_TYPE_LOW				1
+#define  USBC_VBUS_TYPE_HIGH				2
+
+/* usb a valid source */
+#define  USBC_A_VALID_SOURCE_UTMI_AVALID		0
+#define  USBC_A_VALID_SOURCE_UTMI_VBUS			1
+
+/* usb device switch */
+#define  USBC_DEVICE_SWITCH_OFF				0
+#define  USBC_DEVICE_SWITCH_ON				1
+
+/* usb fifo config mode */
+#define  USBC_FIFO_MODE_4K				(4 * 1024)
+#define  USBC_FIFO_MODE_8K				(8 * 1024)
+
+/* usb interrupt mask */
+
+/* interrupt flags for ep0 and the Tx ep1~4 */
+#define  USBC_INTTx_FLAG_EP5		(1 << USBC_BP_INTTx_FLAG_EP5)
+#define  USBC_INTTx_FLAG_EP4		(1 << USBC_BP_INTTx_FLAG_EP4)
+#define  USBC_INTTx_FLAG_EP3		(1 << USBC_BP_INTTx_FLAG_EP3)
+#define  USBC_INTTx_FLAG_EP2		(1 << USBC_BP_INTTx_FLAG_EP2)
+#define  USBC_INTTx_FLAG_EP1		(1 << USBC_BP_INTTx_FLAG_EP1)
+#define  USBC_INTTx_FLAG_EP0		(1 << USBC_BP_INTTx_FLAG_EP0)
+
+/* interrupt flags for Rx ep1~4 */
+#define  USBC_INTRx_FLAG_EP5		(1 << USBC_BP_INTRx_FLAG_EP5)
+#define  USBC_INTRx_FLAG_EP4		(1 << USBC_BP_INTRx_FLAG_EP4)
+#define  USBC_INTRx_FLAG_EP3		(1 << USBC_BP_INTRx_FLAG_EP3)
+#define  USBC_INTRx_FLAG_EP2		(1 << USBC_BP_INTRx_FLAG_EP2)
+#define  USBC_INTRx_FLAG_EP1		(1 << USBC_BP_INTRx_FLAG_EP1)
+
+/* USB interrupt */
+#define  USBC_INTUSB_VBUS_ERROR		(1 << USBC_BP_INTUSB_VBUS_ERROR)
+#define  USBC_INTUSB_SESSION_REQ	(1 << USBC_BP_INTUSB_SESSION_REQ)
+#define  USBC_INTUSB_DISCONNECT		(1 << USBC_BP_INTUSB_DISCONNECT)
+#define  USBC_INTUSB_CONNECT		(1 << USBC_BP_INTUSB_CONNECT)
+#define  USBC_INTUSB_SOF		(1 << USBC_BP_INTUSB_SOF)
+#define  USBC_INTUSB_RESET		(1 << USBC_BP_INTUSB_RESET)
+#define  USBC_INTUSB_RESUME		(1 << USBC_BP_INTUSB_RESUME)
+#define  USBC_INTUSB_SUSPEND		(1 << USBC_BP_INTUSB_SUSPEND)
+
+#define  USBC_PHY_CTL_LOOPBACKENB		7
+#define  USBC_PHY_CTL_VBUSVLDEXT		5
+#define  USBC_PHY_CTL_SIDDQ			3
+
+/* USB host operations */
+void USBC_Host_SetFunctionAddress_Default(__hdle hUSB,
+						__u32 ep_type,
+						__u32 ep_index);
+void USBC_Host_SetFunctionAddress(__hdle hUSB,
+						__u32 EpType,
+						__u32 EpIndex,
+						__u32 FunctionAdress,
+						__u32 MultiTT,
+						__u32 HubAddress,
+						__u32 HubPortNumber);
+void USBC_Host_SetHubAddress_Default(__hdle hUSB,
+						__u32 ep_type,
+						__u32 ep_index);
+void USBC_Host_SetHubAddress(__hdle hUSB,
+					__u32 ep_type,
+					__u32 ep_index,
+					__u32 is_multi_tt,
+					__u8 address);
+void USBC_Host_SetHPortAddress_Default(__hdle hUSB,
+						__u32 ep_type,
+						__u32 ep_index);
+void USBC_Host_SetHPortAddress(__hdle hUSB,
+					__u32 ep_type,
+					__u32 ep_index,
+					__u8 address);
+
+__u32 USBC_Host_QueryTransferMode(__hdle hUSB);
+void USBC_Host_ConfigTransferMode(__hdle hUSB, __u32 speed_mode);
+
+void USBC_Host_ResetPort(__hdle hUSB);
+void USBC_Host_ClearResetPortFlag(__hdle hUSB);
+void USBC_Host_RusumePort(__hdle hUSB);
+void USBC_Host_ClearRusumePortFlag(__hdle hUSB);
+void USBC_Host_SuspendPort(__hdle hUSB);
+__u32 USBC_Host_QueryPowerStatus(__hdle hUSB);
+
+void USBC_Host_EnablePing(__hdle hUSB);
+void USBC_Host_DisablePing(__hdle hUSB);
+__u32 USBC_Host_IsReqPktSet(__hdle hUSB, __u32 ep_type);
+void USBC_Host_StartInToken(__hdle hUSB, __u32 ep_type);
+void USBC_Host_StopInToken(__hdle hUSB, __u32 ep_type);
+void USBC_Host_SendCtrlStatus(__hdle hUSB, __u32 is_after_in);
+void USBC_Host_SendSetupPkt(__hdle hUSB);
+
+void USBC_Host_StartSession(__hdle hUSB);
+void USBC_Host_EndSession(__hdle hUSB);
+void USBC_Host_ConfigRqPktCount(__hdle hUSB, __u32 ep_index, __u32 RqPktCount);
+void USBC_Host_ClearRqPktCount(__hdle hUSB, __u32 ep_index);
+
+__u32 USBC_Host_PeripheralType(__hdle hUSB);
+
+void USBC_Host_FlushFifo(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ConfigEp_Default(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ConfigEp(__hdle hUSB,
+				__u32 ep_type,
+				__u32 ep_index,
+				__u32 ts_mode,
+				__u32 ts_type,
+				__u32 is_double_fifo,
+				__u32 ep_MaxPkt,
+				__u32 interval);
+void USBC_Host_ConfigEpDma(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpDma(__hdle hUSB, __u32 ep_type);
+
+__u32 USBC_Host_IsEpStall(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpStall(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Host_IsEpNakTimeOut(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpNakTimeOut(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Host_IsEpError(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpError(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpCSR(__hdle hUSB, __u32 ep_type);
+
+__u32 USBC_Host_IsReadDataReady(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Host_IsWriteDataReady(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Host_ReadDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete);
+__s32 USBC_Host_WriteDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete);
+
+/* USB device operations */
+void USBC_Dev_SetAddress_default(__hdle hUSB);
+void USBC_Dev_SetAddress(__hdle hUSB, __u8 address);
+
+__u32 USBC_Dev_QueryTransferMode(__hdle hUSB);
+void USBC_Dev_ConfigTransferMode(__hdle hUSB, __u8 ts_type, __u8 speed_mode);
+void USBC_Dev_ConectSwitch(__hdle hUSB, __u32 is_on);
+__u32 USBC_Dev_QueryPowerStatus(__hdle hUSB);
+
+__s32 USBC_Dev_ConfigEp(__hdle hUSB,
+				__u32 ts_type,
+				__u32 ep_type,
+				__u32 is_double_fifo,
+				__u32 ep_MaxPkt);
+__s32 USBC_Dev_ConfigEp_Default(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_ConfigEpDma(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_ClearEpDma(__hdle hUSB, __u32 ep_type);
+
+__s32 USBC_Dev_IsEpStall(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_EpSendStall(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_EpClearStall(__hdle hUSB, __u32 ep_type);
+
+__u32 USBC_Dev_Ctrl_IsSetupEnd(__hdle hUSB);
+void USBC_Dev_Ctrl_ClearSetupEnd(__hdle hUSB);
+
+__u32 USBC_Dev_IsReadDataReady(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Dev_IsWriteDataReady(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Dev_IsWriteDataReady_FifoEmpty(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_WriteDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete);
+__s32 USBC_Dev_ReadDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete);
+__s32 USBC_Dev_IsoUpdateEnable(__hdle hUSB);
+void USBC_Dev_FlushFifo(__hdle hUSB, __u32 ep_type);
+void USBC_Phyx_Write(__hdle hUSB, __u32 data);
+__u32 USBC_Phyx_Read(__hdle hUSB);
+
+
+/* usb common ops */
+
+/* USB transfer type select, read/write.. */
+void USBC_OTG_SelectMode(__hdle hUSB, __u32 mode);
+
+__u32 USBC_ReadLenFromFifo(__hdle hUSB, __u32 ep_type);
+__u32 USBC_WritePacket(__hdle hUSB, void __iomem *fifo, __u32 cnt, void *buff);
+__u32 USBC_ReadPacket(__hdle hUSB, void __iomem *fifo, __u32 cnt, void *buff);
+
+void USBC_ConfigFIFO_Base(__hdle hUSB, __u32 fifo_mode);
+void __iomem *USBC_GetPortFifoStartAddr(__hdle hUSB);
+__u32 USBC_GetPortFifoSize(__hdle hUSB);
+void __iomem *USBC_SelectFIFO(__hdle hUSB, __u32 ep_index);
+void USBC_ConfigFifo_Default(__hdle hUSB, __u32 ep_type);
+void USBC_ConfigFifo(__hdle hUSB,
+				__u32 ep_type,
+				__u32 is_double_fifo,
+				__u32 fifo_size,
+				__u32 fifo_addr);
+
+void USBC_SelectBus(__hdle hUSB, __u32 io_type, __u32 ep_type, __u32 ep_index);
+void USBC_SelectPhyToDevice(void __iomem *usbc_base_addr);
+
+__u32 USBC_GetActiveEp(__hdle hUSB);
+void USBC_SelectActiveEp(__hdle hUSB, __u8 ep_index);
+
+void USBC_EnhanceSignal(__hdle hUSB);
+
+__u32 USBC_GetLastFrameNumber(__hdle hUSB);
+
+/* usb interrupt ops */
+__u32 USBC_INT_EpPending(__hdle hUSB, __u32 ep_type);
+__u32 USBC_INT_MiscPending(__hdle hUSB);
+void USBC_INT_ClearEpPending(__hdle hUSB, __u32 ep_type, __u8 ep_index);
+void USBC_INT_ClearMiscPending(__hdle hUSB, __u32 mask);
+void USBC_INT_ClearEpPendingAll(__hdle hUSB, __u32 ep_type);
+void USBC_INT_ClearMiscPendingAll(__hdle hUSB);
+
+void USBC_INT_EnableEp(__hdle hUSB, __u32 ep_type, __u8 ep_index);
+void USBC_INT_EnableUsbMiscUint(__hdle hUSB, __u32 mask);
+
+void USBC_INT_DisableEp(__hdle hUSB, __u32 ep_type, __u8 ep_index);
+void USBC_INT_DisableUsbMiscUint(__hdle hUSB, __u32 mask);
+
+void USBC_INT_DisableEpAll(__hdle hUSB, __u32 ep_type);
+void USBC_INT_DisableUsbMiscAll(__hdle hUSB);
+
+/* usb control ops */
+__u32 USBC_GetVbusStatus(__hdle hUSB);
+__u32 USBC_GetStatus_Dp(__hdle hUSB);
+__u32 USBC_GetStatus_Dm(__hdle hUSB);
+__u32 USBC_GetStatus_DpDm(__hdle hUSB);
+
+__u32 USBC_GetOtgMode_Form_ID(__hdle hUSB);
+__u32 USBC_GetOtgMode_Form_BDevice(__hdle hUSB);
+
+void USBC_SetWakeUp_Default(__hdle hUSB);
+
+void USBC_EnableIdPullUp(__hdle hUSB);
+void USBC_DisableIdPullUp(__hdle hUSB);
+void USBC_EnableDpDmPullUp(__hdle hUSB);
+void USBC_DisableDpDmPullUp(__hdle hUSB);
+
+void USBC_ForceId(__hdle hUSB, __u32 id_type);
+void USBC_ForceVbusValid(__hdle hUSB, __u32 vbus_type);
+
+void USBC_A_valid_InputSelect(__hdle hUSB, __u32 source);
+
+void USBC_EnableUsbLineStateBypass(__hdle hUSB);
+void USBC_DisableUsbLineStateBypass(__hdle hUSB);
+void USBC_EnableHosc(__hdle hUSB);
+void USBC_DisableHosc(__hdle hUSB);
+
+__u32 USBC_IsVbusChange(__hdle hUSB);
+__u32 USBC_IsIdChange(__hdle hUSB);
+__u32 USBC_IsDpDmChange(__hdle hUSB);
+
+void USBC_DisableWakeIrq(__hdle hUSB);
+void USBC_DisableVbusChange(__hdle hUSB);
+void USBC_DisableIdChange(__hdle hUSB);
+void USBC_DisableDpDmChange(__hdle hUSB);
+
+void USBC_EnableWakeIrq(__hdle hUSB);
+void USBC_EnableVbusChange(__hdle hUSB);
+void USBC_EnableIdChange(__hdle hUSB);
+void USBC_EnableDpDmChange(__hdle hUSB);
+
+/* usb phy control*/
+void USBC_PHY_SetCommonConfig(void);
+void USBC_PHY_SetPrivateConfig(__hdle hUSB);
+__u32 USBC_PHY_GetCommonConfig(void);
+void USBC_phy_Standby(__hdle hUSB, __u32 phy_index);
+void USBC_Phy_Standby_Recover(__hdle hUSB, __u32 phy_index);
+void UsbPhyCtl(void __iomem *regs);
+void USBC_PHY_Set_Ctl(void __iomem *regs, __u32 mask);
+void USBC_PHY_Clear_Ctl(void __iomem *regs, __u32 mask);
+void UsbPhyInit(__u32 usbc_no);
+void UsbPhyEndReset(__u32 usbc_no);
+void usb_otg_phy_txtune(void __iomem *regs);
+void usbc_new_phy_res_cal(void __iomem *regs);
+void usbc_new_phy_init(void __iomem *regs);
+
+/* usb test mode */
+void USBC_EnterMode_TestPacket(__hdle hUSB);
+void USBC_EnterMode_Test_K(__hdle hUSB);
+void USBC_EnterMode_Test_J(__hdle hUSB);
+void USBC_EnterMode_Test_SE0_NAK(__hdle hUSB);
+void USBC_EnterMode_Idle(__hdle hUSB);
+
+__u32 USBC_TestMode_ReadReg(__hdle hUSB, __u32 offset, __u32 reg_width);
+
+/* controller info */
+typedef struct tag_usbc_info {
+	__u32 num;		/* controller index */
+	void __iomem	*base;		/* controller address */
+} usbc_info_t;
+
+typedef struct tag_bsp_usbc {
+	usbc_info_t usbc_info;
+	void __iomem	*sram_base;
+} bsp_usbc_t;
+
+/* open device */
+__hdle USBC_open_otg(__u32 otg_no);
+__s32  USBC_close_otg(__hdle hUSB);
+
+/* initialization */
+__s32 USBC_init(bsp_usbc_t *usbc);
+__s32 USBC_exit(bsp_usbc_t *usbc);
+
+#endif /* __SUNXI_USB_BSP_H__ */
diff --git a/drivers/usb/sunxi_usb/include/sunxi_usb_config.h b/drivers/usb/sunxi_usb/include/sunxi_usb_config.h
new file mode 100644
index 000000000..f1e55b19c
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_usb_config.h
@@ -0,0 +1,44 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_usb_config.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb config head file.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_USB_CONFIG_H__
+#define __SUNXI_USB_CONFIG_H__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+
+#include  "sunxi_usb_typedef.h"
+#include  "sunxi_usb_debug.h"
+#include  "sunxi_usb_bsp.h"
+
+#include  "sunxi_usb_board.h"
+#include  "sunxi_udc.h"
+#include  <linux/sunxi-gpio.h>
+#include  <linux/gpio.h>
+
+#if defined(CONFIG_USB_SUNXI_HCD0)
+#include "sunxi_hcd.h"
+#endif
+
+#if defined(CONFIG_FPGA_V4_PLATFORM) || defined(CONFIG_FPGA_V7_PLATFORM)
+#define SUNXI_USB_FPGA
+#endif
+
+#endif /* __SUNXI_USB_CONFIG_H__ */
diff --git a/drivers/usb/sunxi_usb/include/sunxi_usb_debug.h b/drivers/usb/sunxi_usb/include/sunxi_usb_debug.h
new file mode 100644
index 000000000..d4b17890a
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_usb_debug.h
@@ -0,0 +1,93 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_usb_debug.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * usb debug head file.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_USB_DEBUG_H__
+#define __SUNXI_USB_DEBUG_H__
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_USB_DEBUG)
+#define  DMSG_PRINT(stuff...)		printk(stuff)
+#define  DMSG_PR(fmt, stuff...)	pr_debug(fmt, ##stuff)
+#define  DMSG_INFO_UDC(fmt, ...)	DMSG_PR("[udc]: "fmt, ##__VA_ARGS__)
+#define  DMSG_INFO_HCD0(fmt, ...)	DMSG_PR("[hcd0]: "fmt, ##__VA_ARGS__)
+#define  DMSG_INFO_MANAGER(fmt, ...)	DMSG_PR("[magr]: "fmt, ##__VA_ARGS__)
+#else
+#define  DMSG_PRINT(stuff...)
+#define  DMSG_PR(fmt, ...)
+#define  DMSG_INFO_UDC(fmt, ...)
+#define  DMSG_INFO_HCD0(fmt, ...)
+#define  DMSG_INFO_MANAGER(fmt, ...)
+#endif
+
+/* test */
+#if 0
+#define DMSG_TEST			DMSG_PRINT
+#else
+#define DMSG_TEST(...)
+#endif
+
+/* code debug */
+#if 0
+#define DMSG_MANAGER_DEBUG		DMSG_PRINT
+#else
+#define DMSG_MANAGER_DEBUG(...)
+#endif
+
+#if 0
+#define DMSG_DEBUG			DMSG_PRINT
+#else
+#define DMSG_DEBUG(...)
+#endif
+
+/* normal print */
+#if 1
+#define DMSG_INFO			DMSG_PRINT
+#else
+#define DMSG_INFO(...)
+#endif
+
+/* serious warn */
+#if 1
+#define DMSG_PANIC			DMSG_PRINT
+#else
+#define DMSG_PANIC(...)
+#endif
+
+/* normal warn */
+#if 0
+#define DMSG_WRN			DMSG_ERR
+#else
+#define DMSG_WRN(...)
+#endif
+
+/* dma debug print */
+#if	0
+#define DMSG_DBG_DMA			DMSG_PRINT
+#else
+#define DMSG_DBG_DMA(...)
+#endif
+
+void print_usb_reg_by_ep(spinlock_t *lock,
+				void __iomem *usbc_base,
+				__s32 ep_index,
+				char *str);
+void print_all_usb_reg(spinlock_t *lock,
+				void __iomem *usbc_base,
+				__s32 ep_start,
+				__u32 ep_end,
+				char *str);
+
+void clear_usb_reg(void __iomem *usb_base);
+
+#endif /* __SUNXI_USB_DEBUG_H__ */
diff --git a/drivers/usb/sunxi_usb/include/sunxi_usb_typedef.h b/drivers/usb/sunxi_usb/include/sunxi_usb_typedef.h
new file mode 100644
index 000000000..93cbf8660
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_usb_typedef.h
@@ -0,0 +1,68 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_usb_typedef.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * type definations.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_USB_TYPEDEF_H__
+#define __SUNXI_USB_TYPEDEF_H__
+
+#undef int8
+typedef signed char           int8;
+
+#undef int16
+typedef signed short          int16;
+
+#undef int32
+typedef signed int            int32;
+
+#undef uint8
+typedef unsigned char         uint8;
+
+#undef uint16
+typedef unsigned short        uint16;
+
+#undef uint32
+typedef unsigned int          uint32;
+
+#undef  __hdle
+typedef void *__hdle;
+
+/* set bit */
+#undef  x_set_bit
+#define x_set_bit(value, bit)			((value) |= (1U << (bit)))
+
+/* clear bit */
+#undef  x_clear_bit
+#define x_clear_bit(value, bit)			((value) &= ~(1U << (bit)))
+
+/* reverse bit */
+#undef  x_reverse_bit
+#define x_reverse_bit(value, bit)		((value) ^= (1U << (bit)))
+
+/* test bit */
+#undef  x_test_bit
+#define x_test_bit(value, bit)			((value) & (1U << (bit)))
+
+/* get min valude */
+#undef  x_min
+#define x_min(x, y)				((x) < (y) ? (x) : (y))
+
+/* get max valude */
+#undef  x_max
+#define x_max(x, y)				((x) > (y) ? (x) : (y))
+
+/* get absolute valude */
+#undef  x_absolute
+#define x_absolute(p)				((p) > 0 ? (p) : -(p))
+
+#endif /* __SUNXI_USB_TYPEDEF_H__ */
diff --git a/drivers/usb/sunxi_usb/manager/usb_hcd_servers.c b/drivers/usb/sunxi_usb/manager/usb_hcd_servers.c
new file mode 100644
index 000000000..fcb0e7f12
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_hcd_servers.c
@@ -0,0 +1,147 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_hcd_servers.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb host contoller driver, service function set.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include  "../include/sunxi_usb_config.h"
+#include  "usb_hcd_servers.h"
+
+#if defined(CONFIG_ARCH_SUN50I) \
+			|| defined(CONFIG_ARCH_SUN8IW8) \
+			|| defined(CONFIG_ARCH_SUN8IW10) \
+			|| defined(CONFIG_ARCH_SUN8IW11)
+#define HCI0_USBC_NO    0
+#define HCI1_USBC_NO    1
+#define HCI2_USBC_NO    2
+#define HCI3_USBC_NO    3
+#else
+#define HCI0_USBC_NO    1
+#define HCI1_USBC_NO    2
+#define HCI2_USBC_NO    3
+#define HCI3_USBC_NO    4
+#endif
+
+int sunxi_usb_disable_hcd(__u32 usbc_no)
+{
+#ifndef SUNXI_USB_FPGA
+	if (usbc_no == 0) {
+#if defined(CONFIG_ARCH_SUN8IW6)
+	#if IS_ENABLED(CONFIG_USB_SUNXI_HCD0)
+		sunxi_usb_disable_hcd0();
+	#endif
+#else
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI0)
+		sunxi_usb_disable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI0)
+		sunxi_usb_disable_ohci(usbc_no);
+	#endif
+#endif
+	} else if (usbc_no == HCI0_USBC_NO) {
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI0)
+		sunxi_usb_disable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI0)
+		sunxi_usb_disable_ohci(usbc_no);
+	#endif
+	} else if (usbc_no == HCI1_USBC_NO) {
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI1)
+		sunxi_usb_disable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI1)
+		sunxi_usb_disable_ohci(usbc_no);
+	#endif
+	} else if (usbc_no == HCI2_USBC_NO) {
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI2)
+		sunxi_usb_disable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI2)
+		sunxi_usb_disable_ohci(usbc_no);
+	#endif
+	} else if (usbc_no == HCI3_USBC_NO) {
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI3)
+		sunxi_usb_disable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI3)
+		sunxi_usb_disable_ohci(usbc_no);
+	#endif
+	} else {
+		DMSG_PANIC("ERR: unknown usbc_no(%d)\n", usbc_no);
+		return -1;
+	}
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_usb_disable_hcd);
+
+int sunxi_usb_enable_hcd(__u32 usbc_no)
+{
+#ifndef SUNXI_USB_FPGA
+	if (usbc_no == 0) {
+#if defined(CONFIG_ARCH_SUN8IW6)
+	#if IS_ENABLED(CONFIG_USB_SUNXI_HCD0)
+		sunxi_usb_enable_hcd0();
+	#endif
+#else
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI0)
+		sunxi_usb_enable_ehci(usbc_no);
+	#endif
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI0)
+		sunxi_usb_enable_ehci(usbc_no);
+	#endif
+#endif
+	} else if (usbc_no == HCI0_USBC_NO) {
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI0)
+		sunxi_usb_enable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI0)
+		sunxi_usb_enable_ohci(usbc_no);
+	#endif
+	} else if (usbc_no == HCI1_USBC_NO) {
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI1)
+		sunxi_usb_enable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI1)
+		sunxi_usb_enable_ohci(usbc_no);
+	#endif
+	} else if (usbc_no == HCI2_USBC_NO) {
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI2)
+		sunxi_usb_enable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI2)
+		sunxi_usb_enable_ohci(usbc_no);
+	#endif
+	} else if (usbc_no == HCI3_USBC_NO) {
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI3)
+		sunxi_usb_enable_ehci(usbc_no);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI3)
+		sunxi_usb_enable_ohci(usbc_no);
+	#endif
+	} else {
+		DMSG_PANIC("ERR: unknown usbc_no(%d)\n", usbc_no);
+		return -1;
+	}
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_usb_enable_hcd);
diff --git a/drivers/usb/sunxi_usb/manager/usb_hcd_servers.h b/drivers/usb/sunxi_usb/manager/usb_hcd_servers.h
new file mode 100644
index 000000000..d7f5d98c5
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_hcd_servers.h
@@ -0,0 +1,27 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_hcd_servers.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb host contoller driver. service function set.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __USB_HCD_SERVERS_H__
+#define __USB_HCD_SERVERS_H__
+
+extern int sunxi_usb_disable_ehci(__u32 usbc_no);
+extern int sunxi_usb_enable_ehci(__u32 usbc_no);
+extern int sunxi_usb_disable_ohci(__u32 usbc_no);
+extern int sunxi_usb_enable_ohci(__u32 usbc_no);
+
+int sunxi_usb_disable_hcd(__u32 usbc_no);
+int sunxi_usb_enable_hcd(__u32 usbc_no);
+
+#endif /* __USB_HCD_SERVERS_H__ */
diff --git a/drivers/usb/sunxi_usb/manager/usb_hw_scan.c b/drivers/usb/sunxi_usb/manager/usb_hw_scan.c
new file mode 100644
index 000000000..f4f6a21f2
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_hw_scan.c
@@ -0,0 +1,646 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_hw_scan.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb detect module.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unaligned.h>
+#include <linux/gpio.h>
+#include  "../include/sunxi_usb_config.h"
+#include  "usb_manager.h"
+#include  "usb_hw_scan.h"
+#include  "usb_msg_center.h"
+
+#include <linux/power_supply.h>
+
+static struct usb_scan_info g_usb_scan_info;
+
+struct power_supply *psy = NULL;
+
+int device_insmod_delay;
+static void (*__usb_hw_scan)(struct usb_scan_info *);
+
+#ifndef SUNXI_USB_FPGA
+static __u32 get_pin_data(struct usb_gpio *usb_gpio)
+{
+	return __gpio_get_value(usb_gpio->gpio_set.gpio);
+}
+
+#if IS_ENABLED(CONFIG_USB_G_ANDROID) || IS_ENABLED(CONFIG_USB_MASS_STORAGE)
+static int get_usb_gadget_functions(void)
+{
+	struct file *filep;
+	loff_t pos;
+	char buf[32] = {0};
+
+	filep = filp_open("/sys/class/android_usb/android0/functions",
+			O_RDONLY, 0);
+	if (IS_ERR(filep))
+		return 0;
+
+	pos = 0;
+	vfs_read(filep, (char __user *)buf, 32, &pos);
+	filp_close(filep, NULL);
+
+	if (strlen(buf) == 0)
+		return 0;
+	else
+		return 1;
+}
+#endif
+
+/**
+ * filter the PIO burr
+ * @usb_gpio: .
+ * @value:    store the value to be read
+ *
+ * try 10 times, if value is the same, then consider no shake. return any one.
+ * if not the same, then the current read is invalid
+ *
+ * return: 0 - the valude is the same, valid, 1 - the value change, invalid.
+ */
+static __u32 PIODataIn_debounce(struct usb_gpio *usb_gpio, __u32 *value)
+{
+	__u32 retry  = 0;
+	__u32 time   = 10;
+	__u32 temp1  = 0;
+	__u32 cnt    = 0;
+	__u32 change = 0;	/* if have shake */
+
+	/**
+	 * try 10 times, if value is the same,
+	 * then current read is valid; otherwise invalid.
+	 */
+	if (usb_gpio->valid) {
+		retry = time;
+		while (retry--) {
+			temp1 = get_pin_data(usb_gpio);
+			if (temp1)
+				cnt++;
+		}
+
+		/* 10 times, the value is all 0 or 1 */
+		if ((cnt == time) || (cnt == 0))
+			change = 0;
+		else
+			change = 1;
+	} else {
+		change = 1;
+	}
+
+	if (!change)
+		*value = temp1;
+
+	DMSG_DBG_MANAGER("usb_gpio->valid = %x, cnt = %x, change= %d, temp1 = %x\n",
+		usb_gpio->valid, cnt, change, temp1);
+
+	return change;
+}
+
+static u32 get_id_state(struct usb_scan_info *info)
+{
+	enum usb_id_state id_state = USB_DEVICE_MODE;
+	__u32 pin_data = 0;
+
+	if (info->cfg->port.id_type == USB_ID_TYPE_GPIO) {
+		if (info->cfg->port.id.valid) {
+			if (!PIODataIn_debounce(&info->cfg->port.id, &pin_data)) {
+				if (pin_data)
+					id_state = USB_DEVICE_MODE;
+				else
+					id_state = USB_HOST_MODE;
+
+				info->id_old_state = id_state;
+			} else {
+				id_state = info->id_old_state;
+			}
+		}
+	} else if (info->cfg->port.id_type == USB_ID_TYPE_AXP) {
+#if IS_ENABLED(CONFIG_TYPE_C)
+		if (axp_usb_cc_status())
+			id_state = USB_DEVICE_MODE;
+		else
+			id_state = USB_HOST_MODE;
+#endif
+		} else {
+			id_state = info->id_old_state;
+	}
+
+	return id_state;
+}
+
+static u32 get_detect_vbus_state(struct usb_scan_info *info)
+{
+	enum usb_det_vbus_state det_vbus_state = USB_DET_VBUS_INVALID;
+	__u32 pin_data = 0;
+	union power_supply_propval temp;
+
+	if (info->cfg->port.detect_mode == USB_DETECT_MODE_THREAD) {
+		if (info->cfg->port.det_vbus_type == USB_DET_VBUS_TYPE_GPIO) {
+			if (info->cfg->port.det_vbus.valid) {
+				if (!PIODataIn_debounce(&info->cfg->port.det_vbus, &pin_data)) {
+					if (pin_data)
+						det_vbus_state = USB_DET_VBUS_VALID;
+					else
+						det_vbus_state = USB_DET_VBUS_INVALID;
+
+					info->det_vbus_old_state = det_vbus_state;
+				} else {
+					det_vbus_state = info->det_vbus_old_state;
+				}
+			}
+		} else if (info->cfg->port.det_vbus_type
+					== USB_DET_VBUS_TYPE_AXP) {
+				/*det_vbus is axp, get data only once*/
+				if (!psy) {
+					if (of_find_property(info->cfg->pdev->dev.of_node,
+								"det_vbus_supply", NULL))
+						psy = devm_power_supply_get_by_phandle(&info->cfg->pdev->dev,
+								"det_vbus_supply");
+
+					if (!psy || IS_ERR(psy)) {
+						DMSG_INFO("%s()%d WARN: "
+								"get power supply failed\n",
+								__func__, __LINE__);
+					} else {
+						goto get_property;
+					}
+
+				} else {
+get_property:
+					power_supply_get_property(psy,
+							POWER_SUPPLY_PROP_ONLINE, &temp);
+
+					if (temp.intval)
+						det_vbus_state = USB_DET_VBUS_VALID;
+					else
+						det_vbus_state = USB_DET_VBUS_INVALID;
+				}
+
+		} else {
+			det_vbus_state = info->det_vbus_old_state;
+		}
+	} else if (info->cfg->port.detect_mode == USB_DETECT_MODE_INTR) {
+		det_vbus_state = USB_DET_VBUS_VALID;
+	} else {
+		DMSG_PANIC("ERR: get_detect_vbus_state, ");
+		DMSG_PANIC("usb det mode isn't supported\n");
+	}
+
+	return det_vbus_state;
+}
+
+static u32 get_dp_dm_status(struct usb_scan_info *info)
+{
+	u32 ret  = 0;
+	u32 ret0 = 0;
+	u32 ret1 = 0;
+	u32 ret2 = 0;
+
+	ret0 = get_dp_dm_status_normal();
+	ret1 = get_dp_dm_status_normal();
+	ret2 = get_dp_dm_status_normal();
+
+	/* continuous 3 times, to avoid the voltage sudden changes */
+	if ((ret0 == ret1) && (ret0 == ret2)) {
+		ret = ret0;
+	} else if (ret2 == 0x11) {
+		if (get_usb_role() == USB_ROLE_DEVICE) {
+			ret = 0x11;
+			DMSG_PANIC("ERR: dp/dm status is continuous(0x11)\n");
+		}
+	} else {
+		ret = ret2;
+	}
+
+	return ret;
+}
+#endif
+
+static void do_vbus0_id0(struct usb_scan_info *info)
+{
+	enum usb_role role = USB_ROLE_NULL;
+
+	role = get_usb_role();
+	device_insmod_delay = 0;
+
+	switch (role) {
+	case USB_ROLE_NULL:
+		/* delay for vbus is stably */
+		if (atomic_read(&thread_suspend_flag))
+			break;
+		if (info->host_insmod_delay
+				< USB_SCAN_INSMOD_HOST_DRIVER_DELAY) {
+			info->host_insmod_delay++;
+			break;
+		}
+		info->host_insmod_delay = 0;
+
+		/* insmod usb host */
+		hw_insmod_usb_host();
+		break;
+
+	case USB_ROLE_HOST:
+		/* nothing to do */
+		break;
+
+	case USB_ROLE_DEVICE:
+		/* rmmod usb device */
+		if (atomic_read(&thread_suspend_flag))
+			break;
+		hw_rmmod_usb_device();
+		break;
+
+	default:
+		DMSG_PANIC("ERR: unknown usb role(%d)\n", role);
+	}
+}
+
+static void do_vbus0_id1(struct usb_scan_info *info)
+{
+	enum usb_role role = USB_ROLE_NULL;
+
+	role = get_usb_role();
+	device_insmod_delay = 0;
+	info->host_insmod_delay   = 0;
+
+	switch (role) {
+	case USB_ROLE_NULL:
+		/* nothing to do */
+		break;
+	case USB_ROLE_HOST:
+		if (atomic_read(&thread_suspend_flag))
+			break;
+		hw_rmmod_usb_host();
+		break;
+	case USB_ROLE_DEVICE:
+		if (atomic_read(&thread_suspend_flag))
+			break;
+		hw_rmmod_usb_device();
+		break;
+	default:
+		DMSG_PANIC("ERR: unknown usb role(%d)\n", role);
+	}
+}
+
+static void do_vbus1_id0(struct usb_scan_info *info)
+{
+	enum usb_role role = USB_ROLE_NULL;
+
+	role = get_usb_role();
+	device_insmod_delay = 0;
+
+	switch (role) {
+	case USB_ROLE_NULL:
+		if (info->cfg->port.detect_mode == USB_DETECT_MODE_THREAD) {
+			if (atomic_read(&thread_suspend_flag))
+				break;
+			/* delay for vbus is stably */
+			if (info->host_insmod_delay
+					< USB_SCAN_INSMOD_HOST_DRIVER_DELAY) {
+				info->host_insmod_delay++;
+				break;
+			}
+			info->host_insmod_delay = 0;
+
+			hw_insmod_usb_host();
+		} else if (info->cfg->port.detect_mode
+					== USB_DETECT_MODE_INTR) {
+			hw_insmod_usb_host();
+		} else {
+			DMSG_PANIC("ERR: do_vbus1_id0, ");
+			DMSG_PANIC("usb det mode isn't supported, role=%d\n",
+				role);
+		}
+		break;
+	case USB_ROLE_HOST:
+		/* nothing to do */
+		break;
+	case USB_ROLE_DEVICE:
+		if (info->cfg->port.detect_mode == USB_DETECT_MODE_THREAD) {
+			if (atomic_read(&thread_suspend_flag))
+				break;
+			hw_rmmod_usb_device();
+		} else if (info->cfg->port.detect_mode
+					== USB_DETECT_MODE_INTR) {
+			hw_rmmod_usb_device();
+		} else {
+			DMSG_PANIC("ERR: do_vbus1_id0, ");
+			DMSG_PANIC("usb det mode isn't supported, role=%d\n",
+				role);
+		}
+		break;
+	default:
+		DMSG_PANIC("ERR: unknown usb role(%d)\n", role);
+	}
+}
+
+static void do_vbus1_id1(struct usb_scan_info *info)
+{
+	enum usb_role role = USB_ROLE_NULL;
+
+	role = get_usb_role();
+	info->host_insmod_delay = 0;
+
+	switch (role) {
+	case USB_ROLE_NULL:
+#ifndef SUNXI_USB_FPGA
+		if (info->cfg->port.detect_mode == USB_DETECT_MODE_THREAD) {
+			if (get_dp_dm_status(info) == 0x00) {
+				if (atomic_read(&thread_suspend_flag))
+					break;
+				/* delay for vbus is stably */
+				if (device_insmod_delay < USB_SCAN_INSMOD_DEVICE_DRIVER_DELAY) {
+					device_insmod_delay++;
+					break;
+				}
+
+				device_insmod_delay = 0;
+#if IS_ENABLED(CONFIG_USB_G_ANDROID) || IS_ENABLED(CONFIG_USB_MASS_STORAGE)
+				if (get_usb_gadget_functions())
+#endif
+					hw_insmod_usb_device();
+			}
+		} else if (info->cfg->port.detect_mode
+					== USB_DETECT_MODE_INTR) {
+			hw_insmod_usb_device();
+		} else {
+			DMSG_PANIC("ERR: do_vbus1_id1, ");
+			DMSG_PANIC("usb det mode isn't supported, role=%d\n",
+				role);
+		}
+#else
+		hw_insmod_usb_device();
+#endif
+		break;
+	case USB_ROLE_HOST:
+		if (info->cfg->port.detect_mode == USB_DETECT_MODE_THREAD) {
+			if (atomic_read(&thread_suspend_flag))
+				break;
+			hw_rmmod_usb_host();
+		} else if (info->cfg->port.detect_mode
+					== USB_DETECT_MODE_INTR) {
+			hw_rmmod_usb_host();
+		} else {
+			DMSG_PANIC("ERR: do_vbus1_id1, ");
+			DMSG_PANIC("usb det mode isn't supported, role=%d\n",
+				role);
+		}
+		break;
+	case USB_ROLE_DEVICE:
+		/* nothing to do */
+		break;
+	default:
+		DMSG_PANIC("ERR: unknown usb role(%d)\n", role);
+	}
+}
+
+#ifdef SUNXI_USB_FPGA
+static u32 usb_vbus_id_state = 1;
+__u32 set_vbus_id_state(u32 state)
+{
+	usb_vbus_id_state = state;
+	return 0;
+}
+static __u32 get_vbus_id_state(struct usb_scan_info *info)
+{
+	return usb_vbus_id_state;
+}
+#else
+static __u32 get_vbus_id_state(struct usb_scan_info *info)
+{
+	u32 state = 0;
+
+	if (get_id_state(info) == USB_DEVICE_MODE)
+		x_set_bit(state, 0);
+
+	if (get_detect_vbus_state(info) == USB_DET_VBUS_VALID)
+		x_set_bit(state, 1);
+
+	return state;
+}
+#endif
+
+static void vbus_id_hw_scan(struct usb_scan_info *info)
+{
+	__u32 vbus_id_state = 0;
+
+	vbus_id_state = get_vbus_id_state(info);
+
+	if (usb_hw_scan_debug)
+		DMSG_INFO("Id=%d,role=%d\n", vbus_id_state, get_usb_role());
+
+	switch (vbus_id_state) {
+	case  0x00:
+		do_vbus0_id0(info);
+		break;
+	case  0x01:
+		do_vbus0_id1(info);
+		break;
+	case  0x02:
+		do_vbus1_id0(info);
+		break;
+	case  0x03:
+		do_vbus1_id1(info);
+		break;
+	default:
+		DMSG_PANIC("ERR: vbus_id_hw_scan: ");
+		DMSG_PANIC("unknown vbus_id_state(0x%x)\n",
+			vbus_id_state);
+	}
+}
+
+static void null_hw_scan(struct usb_scan_info *info)
+{
+	DMSG_DBG_MANAGER("null_hw_scan\n");
+}
+
+void usb_hw_scan(struct usb_cfg *cfg)
+{
+	__usb_hw_scan(&g_usb_scan_info);
+}
+
+__s32 usb_hw_scan_init(struct usb_cfg *cfg)
+{
+	struct usb_scan_info *scan_info = &g_usb_scan_info;
+	struct usb_port_info *port_info = NULL;
+	__s32 ret = 0;
+
+	memset(scan_info, 0, sizeof(struct usb_scan_info));
+	device_insmod_delay = 0;
+	scan_info->cfg			= cfg;
+	scan_info->id_old_state		= USB_DEVICE_MODE;
+	scan_info->det_vbus_old_state	= USB_DET_VBUS_INVALID;
+
+	port_info = &(cfg->port);
+	switch (port_info->port_type) {
+	case USB_PORT_TYPE_DEVICE:
+		__usb_hw_scan = null_hw_scan;
+		break;
+	case USB_PORT_TYPE_HOST:
+		__usb_hw_scan = null_hw_scan;
+		break;
+	case USB_PORT_TYPE_OTG:
+#ifdef SUNXI_USB_FPGA
+	{
+		__usb_hw_scan = vbus_id_hw_scan;
+	}
+#else
+	{
+		if (port_info->detect_mode == USB_DETECT_MODE_THREAD) {
+			__u32 need_det_vbus_req_gpio = 1;
+
+			if (port_info->det_vbus_type == USB_DET_VBUS_TYPE_GPIO
+				&& port_info->id_type == USB_ID_TYPE_GPIO) {
+				if ((port_info->id.valid == 0) || (port_info->det_vbus.valid == 0)) {
+					DMSG_PANIC("ERR: usb detect tpye is vbus/id, but id(%d)/vbus(%d) is invalid\n",
+						port_info->id.valid,
+						port_info->det_vbus.valid);
+					ret = -1;
+					port_info->id.valid = 0;
+					port_info->det_vbus.valid = 0;
+					goto failed;
+				}
+
+				/**
+				 * if id and vbus use the same pin,
+				 * then need not to pull pio.
+				 */
+				if (port_info->id.gpio_set.gpio == port_info->det_vbus.gpio_set.gpio) {
+					/**
+					 * when id and det_vbus reuse,
+					 * the det bus need not request
+					 * gpio again.
+					 */
+					need_det_vbus_req_gpio = 0;
+				}
+			}
+
+			/* request id gpio */
+			if (port_info->id.valid) {
+				ret = gpio_request(
+						port_info->id.gpio_set.gpio,
+						"otg_id");
+				if (ret != 0) {
+					DMSG_PANIC("ERR: id gpio_request failed\n");
+					ret = -1;
+					port_info->id.valid = 0;
+					port_info->det_vbus.valid = 0;
+					goto failed;
+				}
+
+				/* set config, input */
+				gpio_direction_input(
+						port_info->id.gpio_set.gpio);
+				__gpio_set_value(
+						port_info->id.gpio_set.gpio,
+						1);
+			}
+
+			/* request det_vbus gpio */
+			if (port_info->det_vbus.valid
+					&& need_det_vbus_req_gpio) {
+				ret = gpio_request(port_info->det_vbus.gpio_set.gpio, "otg_det");
+				if (ret != 0) {
+					DMSG_PANIC("ERR: det_vbus gpio_request failed\n");
+					ret = -1;
+					port_info->det_vbus.valid = 0;
+					goto failed;
+				}
+
+				/* set config, input */
+				gpio_direction_input(port_info->det_vbus.gpio_set.gpio);
+			}
+		} else if (port_info->detect_mode == USB_DETECT_MODE_INTR) {
+			if (port_info->id.valid) {
+				char pin_name[SUNXI_PIN_NAME_MAX_LEN];
+
+				ret = gpio_request(
+						port_info->id.gpio_set.gpio,
+						"otg_id");
+				if (ret != 0) {
+					DMSG_PANIC("ERR: id gpio_request failed\n");
+					ret = -1;
+					port_info->id.valid = 0;
+					port_info->det_vbus.valid = 0;
+					goto failed;
+				}
+
+				sunxi_gpio_to_name(
+						port_info->id.gpio_set.gpio,
+						pin_name);
+
+				/* set id gpio pull up */
+			}
+		}
+
+		__usb_hw_scan = vbus_id_hw_scan;
+	}
+#endif
+		break;
+	default:
+		DMSG_PANIC("ERR: unknown port_type(%d)\n", cfg->port.port_type);
+		ret = -1;
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+#ifndef SUNXI_USB_FPGA
+	if (port_info->id.valid)
+		gpio_free(port_info->id.gpio_set.gpio);
+
+	if (port_info->det_vbus.valid)
+		gpio_free(port_info->det_vbus.gpio_set.gpio);
+#endif
+	__usb_hw_scan = null_hw_scan;
+	return ret;
+}
+
+#ifdef SUNXI_USB_FPGA
+__s32 usb_hw_scan_exit(struct usb_cfg *cfg)
+{
+	return 0;
+}
+#else
+__s32 usb_hw_scan_exit(struct usb_cfg *cfg)
+{
+	if (cfg->port.id.valid)
+		gpio_free(cfg->port.id.gpio_set.gpio);
+
+	if (cfg->port.det_vbus.valid)
+		gpio_free(cfg->port.det_vbus.gpio_set.gpio);
+
+	return 0;
+}
+#endif
diff --git a/drivers/usb/sunxi_usb/manager/usb_hw_scan.h b/drivers/usb/sunxi_usb/manager/usb_hw_scan.h
new file mode 100644
index 000000000..576f98163
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_hw_scan.h
@@ -0,0 +1,61 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_hw_scan.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb detect module.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __USB_HW_SCAN_H__
+#define __USB_HW_SCAN_H__
+
+#define  USB_SCAN_INSMOD_DEVICE_DRIVER_DELAY	2
+#define  USB_SCAN_INSMOD_HOST_DRIVER_DELAY	1
+
+/* ubs id */
+typedef enum usb_id_state {
+	USB_HOST_MODE = 0,
+	USB_DEVICE_MODE = 1,
+} usb_id_state_t;
+
+/* usb detect vbus */
+typedef enum usb_det_vbus_state {
+	USB_DET_VBUS_INVALID = 0,
+	USB_DET_VBUS_VALID  = 1
+} usb_det_vbus_state_t;
+
+/* usb info */
+typedef struct usb_scan_info {
+	struct usb_cfg		*cfg;
+
+	usb_id_state_t		id_old_state;		/* last id state */
+	usb_det_vbus_state_t	det_vbus_old_state;	/* last vbus state */
+
+	u32			device_insmod_delay;	/* debounce time */
+	u32			host_insmod_delay;	/* debounce time */
+} usb_scan_info_t;
+
+#if IS_ENABLED(CONFIG_TYPE_C)
+extern int axp_usb_cc_status(void);
+#endif
+
+extern int usb_hw_scan_debug;
+extern int thread_stopped_flag;
+
+void usb_hw_scan(struct usb_cfg *cfg);
+__u32 set_vbus_id_state(u32 state);
+
+__s32 usb_hw_scan_init(struct usb_cfg *cfg);
+__s32 usb_hw_scan_exit(struct usb_cfg *cfg);
+__s32 usbc0_platform_device_init(struct usb_port_info *port_info);
+__s32 usbc0_platform_device_exit(struct usb_port_info *info);
+
+#endif /* __USB_HW_SCAN_H__ */
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_manager.c b/drivers/usb/sunxi_usb/manager/usb_manager.c
new file mode 100644
index 000000000..9bdadd6ea
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_manager.c
@@ -0,0 +1,562 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_manager.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb manager.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/kthread.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/of_gpio.h>
+
+#include  "../include/sunxi_usb_config.h"
+#include  "usb_manager.h"
+#include  "usbc_platform.h"
+#include  "usb_hw_scan.h"
+#include  "usb_msg_center.h"
+
+struct usb_cfg g_usb_cfg;
+int thread_id_irq_run_flag;
+int thread_device_run_flag;
+int thread_host_run_flag;
+
+__u32 thread_run_flag = 1;
+int thread_stopped_flag = 1;
+atomic_t thread_suspend_flag;
+
+#if defined(CONFIG_TYPEC)
+static int sunxi_dr_set(struct typec_port *p, enum typec_data_role data)
+{
+	return 0;
+}
+static int sunxi_pr_set(struct typec_port *p, enum typec_role data)
+{
+	return 0;
+}
+
+static const struct typec_operations sunxi_usb_ops = {
+	.dr_set = sunxi_dr_set,
+	.pr_set = sunxi_pr_set,
+};
+
+#endif
+
+#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
+static enum dual_role_property sunxi_usb_dr_properties[] = {
+	DUAL_ROLE_PROP_SUPPORTED_MODES,
+	DUAL_ROLE_PROP_MODE,
+	DUAL_ROLE_PROP_PR,
+	DUAL_ROLE_PROP_DR,
+};
+
+static int sunxi_dr_get_property(struct dual_role_phy_instance *dual_role,
+			enum dual_role_property prop, unsigned int *val)
+{
+	enum usb_role role = USB_ROLE_NULL;
+	int mode, pr, dr;
+
+	/*
+	 * FIXME: e.g
+	 * 1.mutex_lock is needed ?
+	 * 2.synchronize current status before updated role ?
+	 * ...
+	 */
+
+	role = get_usb_role();
+
+	if (role == USB_ROLE_HOST) {
+		DMSG_DEBUG("mode is HOST(DFP)\n");
+		mode = DUAL_ROLE_PROP_MODE_DFP;
+		pr = DUAL_ROLE_PROP_PR_SRC;
+		dr = DUAL_ROLE_PROP_DR_HOST;
+	} else if (role == USB_ROLE_DEVICE) {
+		DMSG_DEBUG("mode is DEVICE(UFP)\n");
+		mode = DUAL_ROLE_PROP_MODE_UFP;
+		pr = DUAL_ROLE_PROP_PR_SNK;
+		dr = DUAL_ROLE_PROP_DR_DEVICE;
+	} else {
+		DMSG_DEBUG("mode is NULL(NONE)\n");
+		mode = DUAL_ROLE_PROP_MODE_NONE;
+		pr = DUAL_ROLE_PROP_PR_NONE;
+		dr = DUAL_ROLE_PROP_DR_NONE;
+	}
+
+	switch (prop) {
+	case DUAL_ROLE_PROP_MODE:
+		*val = mode;
+		break;
+	case DUAL_ROLE_PROP_PR:
+		*val = pr;
+		break;
+	case DUAL_ROLE_PROP_DR:
+		*val = dr;
+		break;
+	default:
+		DMSG_PANIC("unsupported property %d\n", prop);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+static int usb_device_scan_thread(void *pArg)
+{
+
+	while (thread_device_run_flag) {
+
+		msleep(1000);  /* 1s */
+		hw_rmmod_usb_host();
+		hw_rmmod_usb_device();
+		usb_msg_center(&g_usb_cfg);
+
+		hw_insmod_usb_device();
+		usb_msg_center(&g_usb_cfg);
+		thread_device_run_flag = 0;
+		DMSG_INFO("device_chose finished %d!\n", __LINE__);
+	}
+
+	return 0;
+}
+
+static int usb_host_scan_thread(void *pArg)
+{
+
+	while (thread_host_run_flag) {
+
+		msleep(1000);  /* 1s */
+		hw_rmmod_usb_host();
+		hw_rmmod_usb_device();
+		usb_msg_center(&g_usb_cfg);
+
+		hw_insmod_usb_host();
+		usb_msg_center(&g_usb_cfg);
+		thread_host_run_flag = 0;
+		DMSG_INFO("host_chose finished %d!\n", __LINE__);
+	}
+
+	return 0;
+}
+
+static int usb_hardware_scan_thread(void *pArg)
+{
+	struct usb_cfg *cfg = pArg;
+
+	while (thread_run_flag) {
+		msleep(1000);  /* 1s */
+
+		if (atomic_read(&thread_suspend_flag))
+			continue;
+		usb_hw_scan(cfg);
+		usb_msg_center(cfg);
+	}
+
+	thread_stopped_flag = 1;
+	return 0;
+}
+
+static irqreturn_t usb_id_irq(int irq, void *parg)
+{
+	struct usb_cfg *cfg = parg;
+
+	mdelay(1000);
+
+	/**
+	 * rmmod usb device/host driver first,
+	 * then insmod usb host/device driver.
+	 */
+	usb_hw_scan(cfg);
+	usb_msg_center(cfg);
+
+	usb_hw_scan(cfg);
+	usb_msg_center(cfg);
+
+	return IRQ_HANDLED;
+}
+
+static int usb_id_irq_thread(void *parg)
+{
+	struct usb_cfg *cfg = parg;
+	int id_irq_num = 0;
+	unsigned long irq_flags = 0;
+	int ret = 0;
+
+	/* delay for udc & hcd ready */
+	msleep(3000);
+
+	while (thread_id_irq_run_flag) {
+		msleep(1000);
+		hw_rmmod_usb_host();
+		hw_rmmod_usb_device();
+		usb_msg_center(cfg);
+
+		hw_insmod_usb_device();
+		usb_msg_center(cfg);
+
+		if (cfg->port.id.valid) {
+			id_irq_num = gpio_to_irq(cfg->port.id.gpio_set.gpio);
+			if (IS_ERR_VALUE((unsigned long)id_irq_num)) {
+				DMSG_PANIC("ERR: map usb id gpio to virq failed, err %d\n",
+					   id_irq_num);
+				return -EINVAL;
+			}
+
+			irq_flags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING |
+				    IRQF_ONESHOT;
+			ret = request_threaded_irq(id_irq_num, NULL, usb_id_irq,
+						   irq_flags, "usb_id", cfg);
+			if (IS_ERR_VALUE((unsigned long)ret)) {
+				DMSG_PANIC("ERR: request usb id virq %d failed, err %d\n",
+					 id_irq_num, ret);
+				return -EINVAL;
+			}
+			cfg->port.id_irq_num = id_irq_num;
+		}
+
+		thread_id_irq_run_flag = 0;
+	}
+
+	return 0;
+}
+
+static __s32 usb_script_parse(struct device_node *np, struct usb_cfg *cfg)
+{
+	struct device_node *usbc_np = NULL;
+	int ret = -1;
+	const char  *used_status;
+
+	usbc_np = of_find_node_by_type(NULL, SET_USB0);
+
+	/* usbc enable */
+	ret = of_property_read_string(usbc_np, "status", &used_status);
+	if (ret) {
+		DMSG_INFO("get usb_used is fail, %d\n", ret);
+		cfg->port.enable = 0;
+	} else if (!strcmp(used_status, "okay")) {
+		cfg->port.enable = 1;
+	} else {
+		cfg->port.enable = 0;
+	}
+
+	/* usbc port type */
+	ret = of_property_read_u32(usbc_np,
+					KEY_USB_PORT_TYPE,
+					&cfg->port.port_type);
+	if (ret)
+		DMSG_INFO("get usb_port_type is fail, %d\n", ret);
+
+	/* usbc det mode */
+	ret = of_property_read_u32(usbc_np,
+					KEY_USB_DET_MODE,
+					&cfg->port.detect_mode);
+	if (ret)
+		DMSG_INFO("get usb_detect_mode is fail, %d\n", ret);
+
+	/* usbc det_vbus */
+	ret = of_property_read_string(usbc_np,
+					KEY_USB_DETVBUS_GPIO,
+					&cfg->port.det_vbus_name);
+	if (ret) {
+		DMSG_INFO("get det_vbus is fail, %d\n", ret);
+		cfg->port.det_vbus.valid = 0;
+	} else {
+		if (strncmp(cfg->port.det_vbus_name, "axp_ctrl", 8) == 0) {
+			cfg->port.det_vbus_type = USB_DET_VBUS_TYPE_AXP;
+			cfg->port.det_vbus.valid = 0;
+		} else {
+			/*get det vbus gpio */
+			cfg->port.det_vbus.gpio_set.gpio = of_get_named_gpio(usbc_np, KEY_USB_DETVBUS_GPIO, 0);
+			if (gpio_is_valid(cfg->port.det_vbus.gpio_set.gpio)) {
+				cfg->port.det_vbus.valid = 1;
+				cfg->port.det_vbus_type = USB_DET_VBUS_TYPE_GPIO;
+			} else {
+				cfg->port.det_vbus.valid = 0;
+			}
+		}
+	}
+
+	/* usbc id  */
+	ret = of_property_read_string(usbc_np,
+					KEY_USB_ID_GPIO,
+					&cfg->port.id_name);
+	if (ret) {
+		DMSG_INFO("get id is fail, %d\n", ret);
+		cfg->port.id.valid = 0;
+	} else {
+		if (strncmp(cfg->port.id_name, "axp_ctrl", 8) == 0) {
+			cfg->port.id_type = USB_ID_TYPE_AXP;
+			cfg->port.id.valid = 0;
+		} else {
+			/*get id gpio */
+			cfg->port.id.gpio_set.gpio = of_get_named_gpio(usbc_np, KEY_USB_ID_GPIO, 0);
+			if (gpio_is_valid(cfg->port.id.gpio_set.gpio)) {
+				cfg->port.id.valid = 1;
+				cfg->port.id_type = USB_ID_TYPE_GPIO;
+			} else {
+				cfg->port.id.valid = 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int usb_otg_id_status(void)
+{
+	struct usb_cfg *cfg = NULL;
+	int id_status = -1;
+
+	cfg = &g_usb_cfg;
+	if (cfg == NULL)
+		return -1;
+
+	if (cfg->port.port_type == USB_PORT_TYPE_DEVICE)
+		return 1;
+
+	if (cfg->port.port_type == USB_PORT_TYPE_OTG) {
+		if (cfg->port.id.valid)
+			id_status = __gpio_get_value(
+						cfg->port.id.gpio_set.gpio);
+	}
+
+	return id_status;
+}
+EXPORT_SYMBOL(usb_otg_id_status);
+
+static int sunxi_otg_manager_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct task_struct *device_th = NULL;
+	struct task_struct *host_th = NULL;
+	struct task_struct *th = NULL;
+	struct task_struct *id_irq_th = NULL;
+	int ret = -1;
+
+	memset(&g_usb_cfg, 0, sizeof(struct usb_cfg));
+	g_usb_cfg.usb_global_enable = 1;
+	g_usb_cfg.pdev = pdev;
+	usb_msg_center_init();
+
+	ret = usb_script_parse(np, &g_usb_cfg);
+	if (ret != 0) {
+		DMSG_PANIC("ERR: get_usb_cfg failed\n");
+		return -1;
+	}
+
+	if (g_usb_cfg.port.enable == 0) {
+		DMSG_PANIC("wrn: usb0 is disable\n");
+		return 0;
+	}
+
+	create_node_file(pdev);
+
+	if (g_usb_cfg.port.port_type == USB_PORT_TYPE_DEVICE) {
+		thread_device_run_flag = 1;
+		device_th = kthread_create(usb_device_scan_thread,
+						NULL,
+						"usb_device_chose");
+		if (IS_ERR(device_th)) {
+			DMSG_PANIC("ERR: device kthread_create failed\n");
+			return -1;
+		}
+
+		wake_up_process(device_th);
+	}
+
+	if (g_usb_cfg.port.port_type == USB_PORT_TYPE_HOST) {
+
+		set_usb_role_ex(USB_ROLE_HOST);
+
+		thread_host_run_flag = 0;
+		host_th = kthread_create(usb_host_scan_thread,
+						NULL,
+						"usb_host_chose");
+		if (IS_ERR(host_th)) {
+			DMSG_PANIC("ERR: host kthread_create failed\n");
+			return -1;
+		}
+
+		wake_up_process(host_th);
+	}
+
+	if (g_usb_cfg.port.port_type == USB_PORT_TYPE_OTG) {
+		usb_hw_scan_init(&g_usb_cfg);
+
+		if (g_usb_cfg.port.detect_mode == USB_DETECT_MODE_THREAD) {
+			atomic_set(&thread_suspend_flag, 0);
+			thread_run_flag = 1;
+			thread_stopped_flag = 0;
+
+			th = kthread_create(usb_hardware_scan_thread,
+						&g_usb_cfg,
+						"usb-hardware-scan");
+			if (IS_ERR(th)) {
+				DMSG_PANIC("ERR: kthread_create failed\n");
+				return -1;
+			}
+
+			wake_up_process(th);
+		} else if (g_usb_cfg.port.detect_mode == USB_DETECT_MODE_INTR) {
+			thread_id_irq_run_flag = 1;
+			id_irq_th = kthread_create(usb_id_irq_thread,
+							&g_usb_cfg,
+							"usb_id_irq");
+			if (IS_ERR(id_irq_th)) {
+				DMSG_PANIC("ERR: id_irq kthread_create failed\n");
+				return -1;
+			}
+
+			wake_up_process(id_irq_th);
+		} else {
+			DMSG_PANIC("ERR: usb detect mode isn't supported\n");
+			return -1;
+		}
+
+#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
+		g_usb_cfg.port.dr_desc.name = "dr_usbc0";
+		g_usb_cfg.port.dr_desc.supported_modes = DUAL_ROLE_SUPPORTED_MODES_DFP_AND_UFP;
+		g_usb_cfg.port.dr_desc.properties = sunxi_usb_dr_properties;
+		g_usb_cfg.port.dr_desc.num_properties = ARRAY_SIZE(sunxi_usb_dr_properties);
+		g_usb_cfg.port.dr_desc.get_property = sunxi_dr_get_property;
+		g_usb_cfg.port.dr_desc.set_property = NULL;
+		g_usb_cfg.port.dr_desc.property_is_writeable = NULL;
+
+		g_usb_cfg.port.dual_role = devm_dual_role_instance_register(&pdev->dev, &g_usb_cfg.port.dr_desc);
+		if (IS_ERR(g_usb_cfg.port.dual_role))
+			DMSG_PANIC("ERR: failed to register dual_role_class device\n");
+#endif
+
+#if defined(CONFIG_TYPEC)
+		g_usb_cfg.port.typec_caps.type = TYPEC_PORT_SNK;
+		g_usb_cfg.port.typec_caps.ops = &sunxi_usb_ops;
+		g_usb_cfg.port.typec_port = typec_register_port(&pdev->dev, &g_usb_cfg.port.typec_caps);
+#endif
+	}
+
+	return 0;
+}
+
+static int sunxi_otg_manager_remove(struct platform_device *pdev)
+{
+
+#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
+	struct dual_role_phy_instance *dual_role = g_usb_cfg.port.dual_role;
+#endif
+
+	if (g_usb_cfg.port.enable == 0) {
+		DMSG_PANIC("wrn: usb0 is disable\n");
+		return 0;
+	}
+
+	if (g_usb_cfg.port.port_type == USB_PORT_TYPE_OTG) {
+#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
+		devm_dual_role_instance_unregister(&pdev->dev, dual_role);
+		dual_role = NULL;
+#endif
+
+		thread_run_flag = 0;
+		while (!thread_stopped_flag) {
+			DMSG_INFO("waitting for usb_hardware_scan_thread stop\n");
+			msleep(20);
+		}
+		if (g_usb_cfg.port.detect_mode == USB_DETECT_MODE_INTR)
+			if (g_usb_cfg.port.id.valid
+					&& g_usb_cfg.port.id_irq_num)
+				free_irq(g_usb_cfg.port.id_irq_num, &g_usb_cfg);
+		usb_hw_scan_exit(&g_usb_cfg);
+	}
+
+	remove_node_file(pdev);
+
+	/* Remove host and device driver before manager exit. */
+	hw_rmmod_usb_host();
+	hw_rmmod_usb_device();
+	usb_msg_center(&g_usb_cfg);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_PM)
+static int sunxi_otg_manager_suspend(struct device *dev)
+{
+	device_insmod_delay = 0;
+	atomic_set(&thread_suspend_flag, 1);
+	return 0;
+}
+
+static int sunxi_otg_manager_resume(struct device *dev)
+{
+	device_insmod_delay = 0;
+	atomic_set(&thread_suspend_flag, 0);
+	return 0;
+}
+
+static const struct dev_pm_ops sunxi_otg_manager_pm_ops = {
+	.suspend = sunxi_otg_manager_suspend,
+	.resume = sunxi_otg_manager_resume,
+};
+#define OTG_MANAGER_PM_OPS        (&sunxi_otg_manager_pm_ops)
+
+#else /* !CONFIG_PM_SLEEP */
+
+#define OTG_MANAGER_PM_OPS        NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct of_device_id sunxi_otg_manager_match[] = {
+	{.compatible = "allwinner,sunxi-otg-manager", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_otg_manager_match);
+
+static struct platform_driver sunxi_otg_manager_platform_driver = {
+	.probe  = sunxi_otg_manager_probe,
+	.remove = sunxi_otg_manager_remove,
+	.driver = {
+		.name  = "otg manager",
+		.pm    = OTG_MANAGER_PM_OPS,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_otg_manager_match,
+	},
+};
+
+static int __init usb_manager_init(void)
+{
+	return platform_driver_register(&sunxi_otg_manager_platform_driver);
+}
+
+static void __exit usb_manager_exit(void)
+{
+	return platform_driver_unregister(&sunxi_otg_manager_platform_driver);
+}
+
+late_initcall(usb_manager_init);
+module_exit(usb_manager_exit);
+
+MODULE_AUTHOR("wangjx<wangjx@allwinnertech.com>");
+MODULE_DESCRIPTION("Driver for Allwinner usb otg manager");
+MODULE_ALIAS("platform: usb manager for host and udc");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.10");
diff --git a/drivers/usb/sunxi_usb/manager/usb_manager.h b/drivers/usb/sunxi_usb/manager/usb_manager.h
new file mode 100644
index 000000000..a9f917613
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_manager.h
@@ -0,0 +1,28 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_manager.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb manager programme.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __USB_MANAGER_H__
+#define __USB_MANAGER_H__
+
+#if	0
+#define DMSG_DBG_MANAGER	pr_debug
+#else
+#define DMSG_DBG_MANAGER(...)
+#endif
+__s32 create_node_file(struct platform_device *pdev);
+__s32 remove_node_file(struct platform_device *pdev);
+
+#endif   /* __USB_MANAGER_H__ */
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_msg_center.c b/drivers/usb/sunxi_usb/manager/usb_msg_center.c
new file mode 100644
index 000000000..02cd56988
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_msg_center.c
@@ -0,0 +1,340 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_msg_center.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb msg center.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unaligned.h>
+
+#include  "../include/sunxi_usb_config.h"
+#include  "usb_manager.h"
+#include  "usbc_platform.h"
+#include  "usb_hw_scan.h"
+#include  "usb_msg_center.h"
+
+#include <linux/power_supply.h>
+
+static struct usb_msg_center_info g_center_info;
+
+enum usb_role get_usb_role(void)
+{
+	return g_center_info.role;
+}
+
+static void set_usb_role(
+		struct usb_msg_center_info *center_info,
+		enum usb_role role)
+{
+	center_info->role = role;
+}
+
+void set_usb_role_ex(enum usb_role role)
+{
+	set_usb_role(&g_center_info, role);
+}
+
+void hw_insmod_usb_host(void)
+{
+	g_center_info.msg.hw_insmod_host = 1;
+}
+
+void hw_rmmod_usb_host(void)
+{
+	g_center_info.msg.hw_rmmod_host = 1;
+}
+
+void hw_insmod_usb_device(void)
+{
+	g_center_info.msg.hw_insmod_device = 1;
+}
+
+void hw_rmmod_usb_device(void)
+{
+	g_center_info.msg.hw_rmmod_device = 1;
+}
+
+static void modify_msg(struct usb_msg *msg)
+{
+	if (msg->hw_insmod_host && msg->hw_rmmod_host) {
+		msg->hw_insmod_host = 0;
+		msg->hw_rmmod_host  = 0;
+	}
+
+	if (msg->hw_insmod_device && msg->hw_rmmod_device) {
+		msg->hw_insmod_device = 0;
+		msg->hw_rmmod_device  = 0;
+	}
+}
+
+static void insmod_host_driver(struct usb_msg_center_info *center_info)
+{
+#if defined(CONFIG_TYPEC)
+	struct usb_cfg *cfg = &g_usb_cfg;
+	struct typec_port *port = cfg->port.typec_port;
+#endif
+	DMSG_INFO("\ninsmod_host_driver\n\n");
+
+	set_usb_role(center_info, USB_ROLE_HOST);
+
+#if defined(CONFIG_ARCH_SUN8IW6)
+#if IS_ENABLED(CONFIG_USB_SUNXI_HCD0)
+	sunxi_usb_host0_enable();
+#endif
+#else
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI0)
+		sunxi_usb_enable_ehci(0);
+	#endif
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI0)
+		sunxi_usb_enable_ohci(0);
+	#endif
+#endif
+
+#if defined(CONFIG_TYPEC)
+	typec_set_data_role(port, TYPEC_HOST);
+	typec_set_pwr_role(port, TYPEC_SOURCE);
+	typec_set_vconn_role(port, TYPEC_SOURCE);
+#endif
+}
+
+static void rmmod_host_driver(struct usb_msg_center_info *center_info)
+{
+	DMSG_INFO("\nrmmod_host_driver\n\n");
+
+#if defined(CONFIG_ARCH_SUN8IW6)
+#if IS_ENABLED(CONFIG_USB_SUNXI_HCD0)
+{
+	int ret = 0;
+
+	ret = sunxi_usb_host0_disable();
+	if (ret != 0) {
+		DMSG_PANIC("err: disable hcd0 failed\n");
+		return;
+	}
+}
+#endif
+#else
+	#if IS_ENABLED(CONFIG_USB_SUNXI_EHCI0)
+		sunxi_usb_disable_ehci(0);
+	#endif
+
+
+
+
+	#if IS_ENABLED(CONFIG_USB_SUNXI_OHCI0)
+		sunxi_usb_disable_ohci(0);
+	#endif
+#endif
+	set_usb_role(center_info, USB_ROLE_NULL);
+}
+
+static void insmod_device_driver(struct usb_msg_center_info *center_info)
+{
+
+#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
+	struct usb_cfg *cfg = &g_usb_cfg;
+	struct dual_role_phy_instance *dual_role = cfg->port.dual_role;
+#endif
+#if defined(CONFIG_TYPEC)
+	struct usb_cfg *cfg = &g_usb_cfg;
+	struct typec_port *port = cfg->port.typec_port;
+	struct typec_partner_desc desc;
+	desc.accessory = TYPEC_ACCESSORY_NONE; /* XXX: handle accessories */
+	desc.identity = NULL;
+
+#endif
+	DMSG_INFO("\ninsmod_device_driver\n\n");
+
+	set_usb_role(center_info, USB_ROLE_DEVICE);
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_UDC0)
+	sunxi_usb_device_enable();
+#endif
+
+#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
+	dual_role_instance_changed(dual_role);
+#endif
+
+#if defined(CONFIG_TYPEC)
+	typec_set_data_role(port, TYPEC_DEVICE);
+	typec_set_pwr_role(port, TYPEC_SINK);
+
+	cfg->port.partner = typec_register_partner(port, &desc);
+	cfg->port.connected = true;
+#endif
+
+}
+
+static void rmmod_device_driver(struct usb_msg_center_info *center_info)
+{
+#if !defined(SUNXI_USB_FPGA)
+	struct power_supply *psy = NULL;
+	union power_supply_propval temp;
+#endif
+
+#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
+	struct usb_cfg *cfg = &g_usb_cfg;
+	struct dual_role_phy_instance *dual_role = cfg->port.dual_role;
+#endif
+#if defined(CONFIG_TYPEC)
+	struct usb_cfg *cfg = &g_usb_cfg;
+	struct typec_partner *partner = cfg->port.partner;
+#endif
+
+	DMSG_INFO("\nrmmod_device_driver\n\n");
+
+	set_usb_role(center_info, USB_ROLE_NULL);
+
+#if !defined(SUNXI_USB_FPGA)
+	if (of_find_property(center_info->cfg->pdev->dev.of_node, "det_vbus_supply", NULL))
+		psy = devm_power_supply_get_by_phandle(&center_info->cfg->pdev->dev,
+						     "det_vbus_supply");
+
+	if (!psy || IS_ERR(psy)) {
+		DMSG_PANIC("%s()%d WARN: get power supply failed\n",
+			  __func__, __LINE__);
+	} else {
+		temp.intval = 0;
+
+		power_supply_set_property(psy,
+					POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT, &temp);
+	}
+#endif
+
+#if IS_ENABLED(CONFIG_USB_SUNXI_UDC0)
+	sunxi_usb_device_disable();
+#endif
+
+#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
+	dual_role_instance_changed(dual_role);
+#endif
+#if defined(CONFIG_TYPEC)
+	if (cfg->port.connected) {
+		typec_unregister_partner(partner);
+		cfg->port.connected = false;
+	}
+#endif
+}
+
+static void do_usb_role_null(struct usb_msg_center_info *center_info)
+{
+	if (center_info->msg.hw_insmod_host) {
+		insmod_host_driver(center_info);
+		center_info->msg.hw_insmod_host = 0;
+
+		goto end;
+	}
+
+	if (center_info->msg.hw_insmod_device) {
+		insmod_device_driver(center_info);
+		center_info->msg.hw_insmod_device = 0;
+
+		goto end;
+	}
+
+end:
+	memset(&center_info->msg, 0, sizeof(struct usb_msg));
+}
+
+static void do_usb_role_host(struct usb_msg_center_info *center_info)
+{
+	if (center_info->msg.hw_rmmod_host) {
+		rmmod_host_driver(center_info);
+		center_info->msg.hw_rmmod_host = 0;
+
+		goto end;
+	}
+
+end:
+	memset(&center_info->msg, 0, sizeof(struct usb_msg));
+}
+
+static void do_usb_role_device(struct usb_msg_center_info *center_info)
+{
+	if (center_info->msg.hw_rmmod_device) {
+		rmmod_device_driver(center_info);
+		center_info->msg.hw_rmmod_device = 0;
+
+		goto end;
+	}
+
+end:
+	memset(&center_info->msg, 0, sizeof(struct usb_msg));
+}
+
+void usb_msg_center(struct usb_cfg *cfg)
+{
+	enum usb_role role = USB_ROLE_NULL;
+	struct usb_msg_center_info *center_info = &g_center_info;
+
+	center_info->cfg = cfg;
+
+	/* receive massage */
+	modify_msg(&center_info->msg);
+
+	/* execute cmd */
+	role = get_usb_role();
+
+	DMSG_DBG_MANAGER("role=%d\n", get_usb_role());
+
+	switch (role) {
+	case USB_ROLE_NULL:
+		do_usb_role_null(center_info);
+		break;
+
+	case USB_ROLE_HOST:
+		do_usb_role_host(center_info);
+		break;
+
+	case USB_ROLE_DEVICE:
+		do_usb_role_device(center_info);
+		break;
+
+	default:
+		DMSG_PANIC("ERR: unknown role(%x)\n", role);
+	}
+}
+
+s32 usb_msg_center_init(void)
+{
+	struct usb_msg_center_info *center_info = &g_center_info;
+
+	memset(center_info, 0, sizeof(struct usb_msg_center_info));
+	return 0;
+}
+
+s32 usb_msg_center_exit(void)
+{
+	struct usb_msg_center_info *center_info = &g_center_info;
+
+	memset(center_info, 0, sizeof(struct usb_msg_center_info));
+	return 0;
+}
diff --git a/drivers/usb/sunxi_usb/manager/usb_msg_center.h b/drivers/usb/sunxi_usb/manager/usb_msg_center.h
new file mode 100644
index 000000000..07bfee3b7
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_msg_center.h
@@ -0,0 +1,67 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_msg_center.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb msg distribution.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __USB_MSG_CENTER_H__
+#define __USB_MSG_CENTER_H__
+
+/* usb role mode */
+typedef enum usb_role {
+	USB_ROLE_NULL = 0,
+	USB_ROLE_HOST,
+	USB_ROLE_DEVICE,
+} usb_role_t;
+
+typedef struct usb_msg {
+	u8  app_drv_null;		/* not install any driver */
+	u8  app_insmod_host;
+	u8  app_rmmod_host;
+	u8  app_insmod_device;
+	u8  app_rmmod_device;
+
+	u8  hw_insmod_host;
+	u8  hw_rmmod_host;
+	u8  hw_insmod_device;
+	u8  hw_rmmod_device;
+} usb_msg_t;
+
+typedef struct usb_msg_center_info {
+	struct usb_cfg *cfg;
+
+	struct usb_msg msg;
+	enum usb_role role;
+
+	u32 skip;			/* if skip, not enter msg process */
+	/* mainly to omit invalid msg */
+} usb_msg_center_info_t;
+
+extern int sunxi_usb_disable_ehci(__u32 usbc_no);
+extern int sunxi_usb_enable_ehci(__u32 usbc_no);
+extern int sunxi_usb_disable_ohci(__u32 usbc_no);
+extern int sunxi_usb_enable_ohci(__u32 usbc_no);
+
+void hw_insmod_usb_host(void);
+void hw_rmmod_usb_host(void);
+void hw_insmod_usb_device(void);
+void hw_rmmod_usb_device(void);
+
+enum usb_role get_usb_role(void);
+void set_usb_role_ex(enum usb_role role);
+void usb_msg_center(struct usb_cfg *cfg);
+
+s32 usb_msg_center_init(void);
+s32 usb_msg_center_exit(void);
+
+#endif /* __USB_MSG_CENTER_H__ */
+
diff --git a/drivers/usb/sunxi_usb/manager/usbc0_platform.c b/drivers/usb/sunxi_usb/manager/usbc0_platform.c
new file mode 100644
index 000000000..67f59f0b9
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usbc0_platform.c
@@ -0,0 +1,227 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usbc0_platform.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb controller0 device info.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/io.h>
+#include <asm/unaligned.h>
+
+#include  "../include/sunxi_usb_config.h"
+#include  "usb_hw_scan.h"
+#include  "usb_msg_center.h"
+#include  "usbc_platform.h"
+
+int usb_hw_scan_debug;
+
+static ssize_t device_chose(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	/* stop usb scan */
+	thread_run_flag = 0;
+
+	while (!thread_stopped_flag)
+		msleep(1000);
+
+	hw_rmmod_usb_host();
+	hw_rmmod_usb_device();
+	usb_msg_center(&g_usb_cfg);
+
+	hw_insmod_usb_device();
+	usb_msg_center(&g_usb_cfg);
+
+	return sprintf(buf, "%s\n", "device_chose finished!");
+}
+
+static ssize_t host_chose(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	/* stop usb scan */
+	thread_run_flag = 0;
+
+	while (!thread_stopped_flag)
+		msleep(1000);
+
+	g_usb_cfg.port.port_type = USB_PORT_TYPE_HOST;
+
+	hw_rmmod_usb_host();
+	hw_rmmod_usb_device();
+	usb_msg_center(&g_usb_cfg);
+
+	hw_insmod_usb_host();
+	usb_msg_center(&g_usb_cfg);
+
+	return sprintf(buf, "%s\n", "host_chose finished!");
+}
+
+static ssize_t null_chose(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	/* stop usb scan */
+	thread_run_flag = 0;
+
+	while (!thread_stopped_flag)
+		msleep(1000);
+
+	hw_rmmod_usb_host();
+	hw_rmmod_usb_device();
+	usb_msg_center(&g_usb_cfg);
+
+	return sprintf(buf, "%s\n", "null_chose finished!");
+}
+
+static ssize_t show_otg_role(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int value = 0;
+	char buf_role[16];
+
+	value = get_usb_role();
+
+	switch (value) {
+	case USB_ROLE_NULL:
+		strcpy(buf_role, "null");
+		break;
+
+	case USB_ROLE_DEVICE:
+		strcpy(buf_role, "usb_device");
+		break;
+
+	case USB_ROLE_HOST:
+		strcpy(buf_role, "usb_host");
+		break;
+
+	default:
+		DMSG_INFO("err: unknown otg role(%d)\n", value);
+		strcpy(buf_role, "unknown");
+	}
+
+	return sprintf(buf, "%s\n", buf_role);
+}
+
+static ssize_t set_otg_role(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int value = 0;
+	int ret = 0;
+
+	if (strncmp(buf, "usb_host", 8) == 0) {
+		value = USB_ROLE_HOST;
+	} else if (strncmp(buf, "usb_device", 10) == 0) {
+		value = USB_ROLE_DEVICE;
+	} else if (strncmp(buf, "null", 4) == 0) {
+		value = USB_ROLE_NULL;
+	} else {
+		ret = kstrtoint(buf, 0, &value);
+		if (ret != 0)
+			return ret;
+	}
+
+	switch (value) {
+	case USB_ROLE_NULL:
+		null_chose(dev, attr, (char *)buf);
+		break;
+
+	case USB_ROLE_DEVICE:
+		device_chose(dev, attr, (char *)buf);
+		break;
+
+	case USB_ROLE_HOST:
+		host_chose(dev, attr, (char *)buf);
+		break;
+
+	default:
+		DMSG_INFO("err: unknown otg role(%d)\n", value);
+		null_chose(dev, attr, (char *)buf);
+	}
+
+	return count;
+}
+
+static struct device_attribute chose_attrs[] = {
+	__ATTR(usb_null, 0400, null_chose, NULL),
+	__ATTR(usb_host, 0400, host_chose, NULL),
+	__ATTR(usb_device, 0400, device_chose, NULL),
+	__ATTR(otg_role, 0644, show_otg_role, set_otg_role),
+};
+
+static ssize_t show_otg_hw_scan_debug(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", usb_hw_scan_debug);
+}
+
+static ssize_t otg_hw_scan_debug(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int debug = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &debug);
+	if (ret != 0)
+		return ret;
+
+	usb_hw_scan_debug = debug;
+
+	return count;
+}
+static DEVICE_ATTR(hw_scan_debug,
+		0644,
+		show_otg_hw_scan_debug,
+		otg_hw_scan_debug);
+
+__s32 create_node_file(struct platform_device *pdev)
+{
+	int ret = 0;
+	int i = 0;
+
+	device_create_file(&pdev->dev, &dev_attr_hw_scan_debug);
+
+	for (i = 0; i < ARRAY_SIZE(chose_attrs); i++) {
+		ret = device_create_file(&pdev->dev, &chose_attrs[i]);
+		if (ret)
+			DMSG_INFO("create_chose_attrs_file fail\n");
+	}
+
+	return 0;
+}
+
+__s32 remove_node_file(struct platform_device *pdev)
+{
+	int i = 0;
+
+	device_remove_file(&pdev->dev, &dev_attr_hw_scan_debug);
+
+	for (i = 0; i < ARRAY_SIZE(chose_attrs); i++)
+		device_remove_file(&pdev->dev, &chose_attrs[i]);
+
+	return 0;
+}
diff --git a/drivers/usb/sunxi_usb/manager/usbc_platform.h b/drivers/usb/sunxi_usb/manager/usbc_platform.h
new file mode 100644
index 000000000..6b445e318
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usbc_platform.h
@@ -0,0 +1,23 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usbc_platform.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2011-4-14, create this file
+ *
+ * usb contoller device info.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __USBC_PLATFORM_H__
+#define __USBC_PLATFORM_H__
+
+extern struct usb_cfg g_usb_cfg;
+extern __u32 thread_run_flag;
+
+#endif /* __USBC_PLATFORM_H__ */
+
diff --git a/drivers/usb/sunxi_usb/misc/sunxi_usb_debug.c b/drivers/usb/sunxi_usb/misc/sunxi_usb_debug.c
new file mode 100644
index 000000000..ec70d961b
--- /dev/null
+++ b/drivers/usb/sunxi_usb/misc/sunxi_usb_debug.c
@@ -0,0 +1,238 @@
+/*
+ * drivers/usb/sunxi_usb/misc/sunxi_usb_debug.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * usb debug.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include  "../include/sunxi_usb_config.h"
+
+void print_usb_reg_by_ep(spinlock_t *lock,
+		void __iomem *usbc_base,
+		__s32 ep_index,
+		char *str)
+{
+	__u32 old_ep_index = 0;
+
+	DMSG_INFO("\n");
+	DMSG_INFO("----------------ep%d: %s----------------\n",
+		ep_index, str);
+
+	if (ep_index >= 0) {
+		old_ep_index = USBC_Readw(usbc_base + USBC_REG_o_EPIND);
+		USBC_Writew(ep_index, (usbc_base + USBC_REG_o_EPIND));
+		DMSG_INFO("old_ep_index = %d, ep_index = %d\n",
+			old_ep_index, ep_index);
+	}
+
+	DMSG_INFO("USBC_REG_o_FADDR = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_FADDR));
+	DMSG_INFO("USBC_REG_o_PCTL  = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_PCTL));
+	DMSG_INFO("USBC_REG_o_INTTx = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_INTTx));
+	DMSG_INFO("USBC_REG_o_INTRx = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_INTRx));
+	DMSG_INFO("USBC_REG_o_INTTxE = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_INTTxE));
+	DMSG_INFO("USBC_REG_o_INTRxE = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_INTRxE));
+	DMSG_INFO("USBC_REG_o_INTUSB = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_INTUSB));
+	DMSG_INFO("USBC_REG_o_INTUSBE = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_INTUSBE));
+	DMSG_INFO("USBC_REG_o_EPIND = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_EPIND));
+	DMSG_INFO("USBC_REG_o_TXMAXP = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_TXMAXP));
+	DMSG_INFO("USBC_REG_o_CSR0 = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_CSR0));
+	DMSG_INFO("USBC_REG_o_TXCSR = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_TXCSR));
+	DMSG_INFO("USBC_REG_o_RXMAXP = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_RXMAXP));
+	DMSG_INFO("USBC_REG_o_RXCSR = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_RXCSR));
+
+	DMSG_INFO("USBC_REG_o_COUNT0 = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_COUNT0));
+	DMSG_INFO("USBC_REG_o_RXCOUNT = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_RXCOUNT));
+	DMSG_INFO("USBC_REG_o_TXTYPE = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_TXTYPE));
+	DMSG_INFO("USBC_REG_o_NAKLIMIT0 = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_NAKLIMIT0));
+	DMSG_INFO("USBC_REG_o_TXINTERVAL = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_TXINTERVAL));
+	DMSG_INFO("USBC_REG_o_RXTYPE = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_RXTYPE));
+	DMSG_INFO("USBC_REG_o_RXINTERVAL = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_RXINTERVAL));
+	DMSG_INFO("USBC_REG_o_CONFIGDATA = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_CONFIGDATA));
+
+	DMSG_INFO("USBC_REG_o_DEVCTL = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_DEVCTL));
+	DMSG_INFO("USBC_REG_o_TXFIFOSZ = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_TXFIFOSZ));
+	DMSG_INFO("USBC_REG_o_RXFIFOSZ = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_RXFIFOSZ));
+	DMSG_INFO("USBC_REG_o_TXFIFOAD = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_TXFIFOAD));
+	DMSG_INFO("USBC_REG_o_RXFIFOAD = 0x%x\n",
+		USBC_Readw(usbc_base + USBC_REG_o_RXFIFOAD));
+	DMSG_INFO("USBC_REG_o_VEND0 = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_VEND0));
+	DMSG_INFO("USBC_REG_o_VEND1 = 0x%x\n",
+		USBC_Readb(usbc_base + USBC_REG_o_VEND1));
+
+	DMSG_INFO("TXFADDRx(%d) = 0x%x\n",
+		ep_index, USBC_Readb(usbc_base + USBC_REG_o_TXFADDRx));
+	DMSG_INFO("TXHADDRx(%d) = 0x%x\n",
+		ep_index, USBC_Readb(usbc_base + USBC_REG_o_TXHADDRx));
+	DMSG_INFO("TXHPORTx(%d) = 0x%x\n",
+		ep_index, USBC_Readb(usbc_base + USBC_REG_o_TXHPORTx));
+	DMSG_INFO("RXFADDRx(%d) = 0x%x\n",
+		ep_index, USBC_Readb(usbc_base + USBC_REG_o_RXFADDRx));
+	DMSG_INFO("RXHADDRx(%d) = 0x%x\n",
+		ep_index, USBC_Readb(usbc_base + USBC_REG_o_RXHADDRx));
+	DMSG_INFO("RXHPORTx(%d) = 0x%x\n",
+		ep_index, USBC_Readb(usbc_base + USBC_REG_o_RXHPORTx));
+	DMSG_INFO("RPCOUNTx(%d) = 0x%x\n",
+		ep_index, (u32)USBC_Readl(usbc_base + USBC_REG_o_RPCOUNT));
+
+	DMSG_INFO("USBC_REG_o_ISCR = 0x%x\n",
+		(u32)USBC_Readl(usbc_base + USBC_REG_o_ISCR));
+	DMSG_INFO("USBC_REG_o_PHYCTL = 0x%x\n",
+		(u32)USBC_Readl(usbc_base + USBC_REG_o_PHYCTL));
+	DMSG_INFO("USBC_REG_o_PHYBIST = 0x%x\n",
+		(u32)USBC_Readl(usbc_base + USBC_REG_o_PHYBIST));
+
+	if (ep_index >= 0)
+		USBC_Writew(old_ep_index, (usbc_base + USBC_REG_o_EPIND));
+
+	DMSG_INFO("---------------------------------------------\n");
+	DMSG_INFO("\n");
+}
+
+void print_all_usb_reg(spinlock_t *lock,
+		void __iomem *usbc_base,
+		__s32 ep_start,
+		__u32 ep_end,
+		char *str)
+{
+	__u32 i = 0;
+	__u32 old_ep_index = 0;
+	unsigned long flags = 0;
+
+	if (lock) {
+		spin_lock_irqsave(lock, flags);
+
+		DMSG_INFO("\n");
+		DMSG_INFO("--------print_all_usb_reg: %s--------\n", str);
+
+		old_ep_index = USBC_Readw(usbc_base + USBC_REG_o_EPIND);
+
+		for (i = ep_start; i <= ep_end; i++)
+			print_usb_reg_by_ep(lock, usbc_base, i, str);
+
+		USBC_Writew(old_ep_index, (usbc_base + USBC_REG_o_EPIND));
+
+		DMSG_INFO("--------------------------------------\n");
+		DMSG_INFO("\n");
+
+		spin_unlock_irqrestore(lock, flags);
+	} else {
+
+		DMSG_INFO("\n");
+		DMSG_INFO("--------print_all_usb_reg: %s---------\n", str);
+
+		old_ep_index = USBC_Readw(usbc_base + USBC_REG_o_EPIND);
+
+		for (i = ep_start; i <= ep_end; i++)
+			print_usb_reg_by_ep(lock, usbc_base, i, str);
+
+		USBC_Writew(old_ep_index, (usbc_base + USBC_REG_o_EPIND));
+
+		DMSG_INFO("---------------------------------------\n");
+		DMSG_INFO("\n");
+	}
+}
+
+void clear_usb_reg(void __iomem *usb_base)
+{
+	__u32 reg_val = 0;
+	__u32 i = 0;
+
+	/* global control and status */
+	reg_val = USBC_Readl(USBC_REG_EX_USB_GCS(usb_base));
+	reg_val = 0x20;
+	USBC_Writel(reg_val, USBC_REG_EX_USB_GCS(usb_base));
+
+	/* endpoint interrupt flag */
+	reg_val = USBC_Readl(USBC_REG_EX_USB_EPINTF(usb_base));
+	reg_val = 0x44;
+	USBC_Writel(reg_val, USBC_REG_EX_USB_EPINTF(usb_base));
+
+	/* endpoint interrupt enable */
+	reg_val = USBC_Readl(USBC_REG_EX_USB_EPINTE(usb_base));
+	reg_val = 0x48;
+	USBC_Writel(reg_val, USBC_REG_EX_USB_EPINTE(usb_base));
+
+	/* bus interrupt flag */
+	reg_val = USBC_Readl(USBC_REG_EX_USB_BUSINTF(usb_base));
+	reg_val = 0x4c;
+	USBC_Writel(reg_val, USBC_REG_EX_USB_BUSINTF(usb_base));
+
+	/* bus interrupt enable */
+	reg_val = USBC_Readl(USBC_REG_EX_USB_BUSINTE(usb_base));
+	reg_val = 0x50;
+	USBC_Writel(reg_val, USBC_REG_EX_USB_BUSINTE(usb_base));
+
+	/* endpoint control status */
+	for (i = 0; i < USBC_MAX_EP_NUM; i++) {
+		USBC_Writeb(i, USBC_REG_EPIND(usb_base));
+
+		/* endpoint control status */
+		if (i == 0) {
+			reg_val = USBC_Readl(USBC_REG_EX_USB_CSR0(usb_base));
+			reg_val = 0x00;
+			USBC_Writel(reg_val, USBC_REG_EX_USB_CSR0(usb_base));
+		} else {
+			/* TX endpoint control status */
+			reg_val = USBC_Readl(USBC_REG_EX_USB_TXCSR(usb_base));
+			reg_val = 0x00;
+			USBC_Writel(reg_val, USBC_REG_EX_USB_TXCSR(usb_base));
+
+			/* RX endpoint control status */
+			reg_val = USBC_Readl(USBC_REG_EX_USB_RXCSR(usb_base));
+			reg_val = 0x00;
+			USBC_Writel(reg_val, USBC_REG_EX_USB_RXCSR(usb_base));
+		}
+
+		/* TX fifo seting */
+		reg_val = USBC_Readl(USBC_REG_EX_USB_TXFIFO(usb_base));
+		reg_val = 0x90;
+		USBC_Writel(reg_val, USBC_REG_EX_USB_TXFIFO(usb_base));
+
+		/* RX fifo seting */
+		reg_val = USBC_Readl(USBC_REG_EX_USB_RXFIFO(usb_base));
+		reg_val = 0x94;
+		USBC_Writel(reg_val, USBC_REG_EX_USB_RXFIFO(usb_base));
+
+		/* function address */
+		reg_val = USBC_Readl(USBC_REG_EX_USB_FADDR(usb_base));
+		reg_val = 0x00;
+		USBC_Writel(reg_val, USBC_REG_EX_USB_FADDR(usb_base));
+	}
+
+	USBC_Writeb(0x00, USBC_REG_EPIND(usb_base));
+}
diff --git a/drivers/usb/sunxi_usb/udc/sunxi_udc.c b/drivers/usb/sunxi_usb/udc/sunxi_udc.c
new file mode 100644
index 000000000..c651b3d4d
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sunxi_udc.c
@@ -0,0 +1,3961 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sunxi_udc.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-3-3, create this file
+ *
+ * usb device contoller driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/dma-mapping.h>
+#include <linux/prefetch.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unaligned.h>
+
+#include <linux/regulator/consumer.h>
+
+#include  "sunxi_udc_config.h"
+#include  "sunxi_udc_board.h"
+
+#include  "sunxi_udc_debug.h"
+#include  "sunxi_udc_dma.h"
+#include  <linux/of.h>
+#include  <linux/of_address.h>
+#include  <linux/of_device.h>
+#include  <linux/dma-mapping.h>
+
+#if defined(CONFIG_POWER_SUPPLY)
+#include <linux/power_supply.h>
+#endif
+
+#define DRIVER_DESC	"SoftWinner USB Device Controller"
+#define DRIVER_AUTHOR	"SoftWinner USB Developer"
+
+static const char	gadget_name[] = "sunxi_usb_udc";
+static const char	driver_desc[] = DRIVER_DESC;
+
+static u64 sunxi_udc_mask = ~0ULL; // DMA_BIT_MASK(64); /* Avoid Clang waring: shift count >= width of type */
+
+static struct sunxi_udc	*the_controller;
+static u32 usbd_port_no;
+static sunxi_udc_io_t g_sunxi_udc_io;
+static u32 usb_connect;
+static u32 is_controller_alive;
+static u8 is_udc_enable;   /* is udc enable by gadget? */
+
+static bool charger_mode;
+
+static struct platform_device *g_udc_pdev;
+
+static __u32 dma_working;
+
+static __u8 first_enable = 1;
+
+#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
+
+static u8 crq_bRequest;
+static u8 crq_wIndex;
+static const unsigned char TestPkt[54] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
+	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xEE, 0xEE, 0xEE,
+	0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF,
+	0xEF, 0xF7, 0xFB, 0xFD, 0xFC, 0x7E, 0xBF, 0xDF, 0xEF, 0xF7,
+	0xFB, 0xFD, 0x7E, 0x00
+};
+
+/* debug */
+unsigned static int g_queue_debug;
+int g_dma_debug;
+unsigned static int g_write_debug;
+unsigned static int g_read_debug;
+unsigned static int g_irq_debug;
+unsigned static int g_msc_write_debug;
+unsigned static int g_msc_read_debug;
+
+
+
+static ssize_t show_ed_test(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	return sprintf(buf, "%d\n", g_queue_debug);
+}
+
+static ssize_t ed_test(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	void __iomem *fifo = NULL;
+	int reg_val;
+
+	if (!strncmp(buf, "test_j_state", 12)) {
+		USBC_EnterMode_Test_J(g_sunxi_udc_io.usb_bsp_hdle);
+		DMSG_INFO("test_mode:%s\n", "test_j_state");
+	} else if (!strncmp(buf, "test_k_state", 12)) {
+		USBC_EnterMode_Test_K(g_sunxi_udc_io.usb_bsp_hdle);
+		DMSG_INFO("test_mode:%s\n", "test_k_state");
+	} else if (!strncmp(buf, "test_se0_nak", 12)) {
+		USBC_EnterMode_Test_SE0_NAK(g_sunxi_udc_io.usb_bsp_hdle);
+		DMSG_INFO("test_mode:%s\n", "test_se0_nak");
+	} else if (!strncmp(buf, "test_pack", 9)) {
+		DMSG_INFO("test_mode___:%s\n", "test_pack");
+		reg_val = USBC_Readl(USBC_REG_PCTL(g_sunxi_udc_io.usb_vbase));
+		reg_val |= (0x1 << 0);
+		USBC_Writel(reg_val, USBC_REG_PCTL(g_sunxi_udc_io.usb_vbase));
+		msleep(1000);
+		fifo = USBC_SelectFIFO(g_sunxi_udc_io.usb_bsp_hdle, 0);
+		USBC_WritePacket(g_sunxi_udc_io.usb_bsp_hdle,
+				fifo, 54, (u32 *)TestPkt);
+		USBC_Dev_WriteDataStatus(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0, 0);
+		USBC_EnterMode_TestPacket(g_sunxi_udc_io.usb_bsp_hdle);
+	} else if (!strncmp(buf, "disable_test_mode", 17)) {
+		DMSG_INFO("start disable_test_mode\n");
+		USBC_EnterMode_Idle(g_sunxi_udc_io.usb_bsp_hdle);
+	} else {
+		DMSG_PANIC("ERR: test_mode Argment is invalid\n");
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(otg_ed_test, 0644, show_ed_test, ed_test);
+
+static ssize_t show_phy_range(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "rate:0x%x\n",
+			USBC_Phyx_Read(g_sunxi_udc_io.usb_bsp_hdle));
+}
+
+static ssize_t udc_phy_range(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int val = 0;
+	int err;
+
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: Argment is invalid\n");
+		return 0;
+	}
+
+	err = kstrtoint(buf, 16, &val);
+	if (err != 0)
+		return -EINVAL;
+
+	if ((val >= 0x0) && (val <= 0x3ff)) {
+		USBC_Phyx_Write(g_sunxi_udc_io.usb_bsp_hdle, val);
+	} else {
+		DMSG_PANIC("adjust PHY's paraments 0x%x is fail! value:0x0~0x3ff\n", val);
+		return count;
+	}
+
+	DMSG_INFO("adjust succeed, PHY's paraments:0x%x.\n",
+		USBC_Phyx_Read(g_sunxi_udc_io.usb_bsp_hdle));
+
+	return count;
+}
+
+static DEVICE_ATTR(otg_phy_range, 0644, show_phy_range, udc_phy_range);
+
+
+static ssize_t show_udc_debug(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", g_queue_debug);
+}
+
+static ssize_t udc_queue_debug(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int debug = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &debug);
+	if (ret != 0)
+		return ret;
+
+	g_queue_debug = debug;
+
+	return count;
+}
+
+static DEVICE_ATTR(queue_debug, 0644, show_udc_debug, udc_queue_debug);
+
+static ssize_t show_dma_debug(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", g_dma_debug);
+}
+
+static ssize_t udc_dma_debug(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int debug = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &debug);
+	if (ret != 0)
+		return ret;
+
+	g_dma_debug = debug;
+
+	return count;
+}
+
+static DEVICE_ATTR(dma_debug, 0644, show_dma_debug, udc_dma_debug);
+
+static ssize_t show_write_debug(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", g_write_debug);
+}
+
+static ssize_t udc_write_debug(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int debug = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &debug);
+	if (ret != 0)
+		return ret;
+
+	g_write_debug = debug;
+
+	return count;
+}
+
+static DEVICE_ATTR(write_debug, 0644, show_write_debug, udc_write_debug);
+
+static ssize_t show_read_debug(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", g_read_debug);
+}
+
+static ssize_t udc_read_debug(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int debug = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &debug);
+	if (ret != 0)
+		return ret;
+
+	g_read_debug = debug;
+
+	return count;
+}
+
+static DEVICE_ATTR(read_debug, 0644, show_read_debug, udc_read_debug);
+
+static ssize_t show_irq_debug(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", g_irq_debug);
+}
+
+static ssize_t udc_irq_debug(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int debug = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &debug);
+	if (ret != 0)
+		return ret;
+
+	g_irq_debug = debug;
+
+	return count;
+}
+
+static DEVICE_ATTR(irq_debug, 0644, show_irq_debug, udc_irq_debug);
+
+static ssize_t show_msc_write_debug(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", g_msc_write_debug);
+}
+
+static ssize_t udc_msc_write_debug(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int debug = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &debug);
+	if (ret != 0)
+		return ret;
+
+	g_msc_write_debug = debug;
+
+	return count;
+}
+
+static DEVICE_ATTR(msc_write_debug, 0644,
+		show_msc_write_debug, udc_msc_write_debug);
+
+static ssize_t show_msc_read_debug(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", g_msc_read_debug);
+}
+
+static ssize_t udc_msc_read_debug(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int debug = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &debug);
+	if (ret != 0)
+		return ret;
+
+	g_msc_read_debug = debug;
+
+	return count;
+}
+
+static DEVICE_ATTR(msc_read_debug, 0644,
+		show_msc_read_debug, udc_msc_read_debug);
+
+/* function defination */
+static void cfg_udc_command(enum sunxi_udc_cmd_e cmd);
+static void cfg_vbus_draw(unsigned int ma);
+
+static __u32 is_peripheral_active(void)
+{
+	return is_controller_alive;
+}
+
+/**
+ * DMA transfer conditions:
+ * 1. the driver support dma transfer
+ * 2. not EP0
+ * 3. more than one packet
+ */
+#define  big_req(req, ep)	((req->req.length != req->req.actual) \
+				? ((req->req.length >= 512) \
+				&& ((req->req.length - req->req.actual) \
+				> ep->ep.maxpacket)) \
+				: (req->req.length > ep->ep.maxpacket))
+#define  is_sunxi_udc_dma_capable(req, ep)	(is_udc_support_dma() \
+						&& big_req(req, ep) \
+						&& ep->num)
+
+#define is_buffer_mapped(req, ep)	(is_sunxi_udc_dma_capable(req, ep) \
+					&& (req->map_state != UN_MAPPED))
+
+void sunxi_set_cur_vol_work(struct work_struct *work)
+{
+#if !defined(SUNXI_USB_FPGA) && defined(CONFIG_POWER_SUPPLY)
+	struct power_supply *psy = NULL;
+	union power_supply_propval temp;
+
+	if (of_find_property(g_udc_pdev->dev.of_node, "det_vbus_supply", NULL))
+		psy = devm_power_supply_get_by_phandle(&g_udc_pdev->dev,
+						     "det_vbus_supply");
+
+	if (!psy || IS_ERR(psy)) {
+		DMSG_PANIC("%s()%d WARN: get power supply failed\n",
+			   __func__, __LINE__);
+	} else {
+		temp.intval = 500;
+
+		power_supply_set_property(psy,
+					POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT, &temp);
+	}
+#endif
+}
+
+/* Maps the buffer to dma */
+static inline void sunxi_udc_map_dma_buffer(
+		struct sunxi_udc_request *req,
+		struct sunxi_udc *udc,
+		struct sunxi_udc_ep *ep)
+{
+	if (!is_sunxi_udc_dma_capable(req, ep)) {
+		DMSG_PANIC("err: need not to dma map\n");
+		return;
+	}
+
+	req->map_state = UN_MAPPED;
+
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		req->req.dma = dma_map_single(
+					udc->controller,
+					req->req.buf,
+					req->req.length,
+					(is_tx_ep(ep) ? DMA_TO_DEVICE
+							: DMA_FROM_DEVICE));
+		if (dma_mapping_error(udc->controller,
+						req->req.dma)){
+			DMSG_PANIC("dma_mapping_error, %p, %x\n",
+				req->req.buf, req->req.length);
+			return;
+		}
+		req->map_state = SW_UDC_USB_MAPPED;
+	} else {
+		dma_sync_single_for_device(udc->controller,
+			req->req.dma,
+			req->req.length,
+			(is_tx_ep(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
+			req->map_state = PRE_MAPPED;
+	}
+}
+
+/* Unmap the buffer from dma and maps it back to cpu */
+static inline void sunxi_udc_unmap_dma_buffer(
+		struct sunxi_udc_request *req,
+		struct sunxi_udc *udc,
+		struct sunxi_udc_ep *ep)
+{
+	if (!is_buffer_mapped(req, ep))
+		return;
+
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		DMSG_PANIC("not unmapping a never mapped buffer\n");
+		return;
+	}
+
+	if (req->map_state == SW_UDC_USB_MAPPED) {
+		dma_unmap_single(udc->controller,
+			req->req.dma,
+			req->req.length,
+			(is_tx_ep(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
+
+		req->req.dma = DMA_ADDR_INVALID;
+	} else { /* PRE_MAPPED */
+		dma_sync_single_for_cpu(udc->controller,
+			req->req.dma,
+			req->req.length,
+			(is_tx_ep(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
+	}
+
+	req->map_state = UN_MAPPED;
+}
+
+static int sunxi_udc_handle_unaligned_buf_start(struct sunxi_udc_ep *ep, struct sunxi_udc_request *req)
+{
+	void *req_buf = req->req.buf;
+
+	/* if dma is not being used and buffer is aligned */
+	if (!is_sunxi_udc_dma_capable(req, ep))
+		return 0;
+
+	if (!((long)req_buf & 0x3))
+		return 0;
+
+	req->req.buf = kmalloc(req->req.length, GFP_ATOMIC);
+	if (!req->req.buf) {
+		req->req.buf = req_buf;
+		DMSG_PANIC("%s: unable to allocate memory for bounce buffer\n", __func__);
+		return -ENOMEM;
+	}
+
+	req->saved_req_buf = req_buf;
+
+	if (ep->bEndpointAddress & USB_DIR_IN)
+		memcpy(req->req.buf, req_buf, req->req.length);
+
+	return 0;
+}
+
+static void sunxi_udc_handle_unaligned_buf_complete(struct sunxi_udc_ep *ep, struct sunxi_udc_request *req)
+{
+
+	/* if dma is not being used and buffer is aligned */
+	if (!req->saved_req_buf)
+		return;
+
+	if (!is_sunxi_udc_dma_capable(req, ep))
+		return;
+
+	/* Copy data from bounce buffer on successful out transfer */
+	if (!(ep->bEndpointAddress & USB_DIR_IN) && !req->req.status)
+		memcpy(req->saved_req_buf, req->req.buf,
+		       req->req.actual);
+
+	/* Free bounce buffer */
+	kfree(req->req.buf);
+
+	req->req.buf = req->saved_req_buf;
+	req->saved_req_buf = NULL;
+}
+
+static void sunxi_udc_done(struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req, int status)
+__releases(ep->dev->lock)
+__acquires(ep->dev->lock)
+{
+	unsigned halted = ep->halted;
+
+	if (g_queue_debug) {
+		DMSG_INFO("d: (%s, %p, %d, %d)\n\n\n", ep->ep.name,
+				&(req->req), req->req.length, req->req.actual);
+	}
+
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	ep->halted = 1;
+	if (is_sunxi_udc_dma_capable(req, ep)) {
+		spin_unlock(&ep->dev->lock);
+		sunxi_udc_unmap_dma_buffer(req, ep->dev, ep);
+		sunxi_udc_handle_unaligned_buf_complete(ep, req);
+		req->req.complete(&ep->ep, &req->req);
+		spin_lock(&ep->dev->lock);
+	} else {
+		spin_unlock(&ep->dev->lock);
+		req->req.complete(&ep->ep, &req->req);
+		spin_lock(&ep->dev->lock);
+	}
+
+	ep->halted = halted;
+}
+
+static void sunxi_udc_nuke(struct sunxi_udc *udc,
+		struct sunxi_udc_ep *ep, int status)
+{
+	/* Sanity check */
+	if (&ep->queue == NULL)
+		return;
+
+	while (!list_empty(&ep->queue)) {
+		struct sunxi_udc_request *req;
+
+		req = list_entry(ep->queue.next,
+				struct sunxi_udc_request, queue);
+		DMSG_INFO_UDC("nuke: ep num is %d\n", ep->num);
+		sunxi_udc_done(ep, req, status);
+	}
+}
+
+static inline void sunxi_udc_clear_ep_state(struct sunxi_udc *dev)
+{
+	unsigned i = 0;
+
+	/**
+	 * hardware SET_{CONFIGURATION,INTERFACE} automagic resets endpoint
+	 * fifos, and pending transactions mustn't be continued in any case.
+	 */
+	for (i = 1; i < SW_UDC_ENDPOINTS; i++)
+		sunxi_udc_nuke(dev, &dev->ep[i], -ECONNABORTED);
+}
+
+static inline int sunxi_udc_fifo_count_out(__hdle usb_bsp_hdle, __u8 ep_index)
+{
+	if (ep_index) {
+		return USBC_ReadLenFromFifo(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_RX);
+	} else {
+		return USBC_ReadLenFromFifo(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0);
+	}
+}
+
+static inline int sunxi_udc_write_packet(void __iomem *fifo,
+					struct sunxi_udc_request *req,
+					unsigned max)
+{
+	unsigned len = min(req->req.length - req->req.actual, max);
+	void *buf = req->req.buf + req->req.actual;
+
+	prefetch(buf);
+
+	DMSG_DBG_UDC("W: req.actual(%d), req.length(%d), len(%d), total(%d)\n",
+		req->req.actual, req->req.length, len, req->req.actual + len);
+
+	req->req.actual += len;
+
+	udelay(5);
+	USBC_WritePacket(g_sunxi_udc_io.usb_bsp_hdle, fifo, len, buf);
+
+	return len;
+}
+
+static int pio_write_fifo(struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req)
+{
+	unsigned	count		= 0;
+	int		is_last		= 0;
+	u32		idx		= 0;
+	void __iomem    *fifo_reg	= 0;
+	__s32		ret		= 0;
+	u8		old_ep_index	= 0;
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	/* write data */
+
+	/* select ep */
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	/* select fifo */
+	fifo_reg = USBC_SelectFIFO(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	count = sunxi_udc_write_packet(fifo_reg, req, ep->ep.maxpacket);
+
+	/* check if the last packet */
+
+	/* last packet is often short (sometimes a zlp) */
+	if (count != ep->ep.maxpacket)
+		is_last = 1;
+	else if (req->req.length != req->req.actual || req->req.zero)
+		is_last = 0;
+	else
+		is_last = 2;
+
+	if (g_write_debug) {
+		DMSG_INFO("pw: (0x%p, %d, %d)\n",
+			&(req->req), req->req.length, req->req.actual);
+	}
+
+	if (idx) { /* ep1~4 */
+		ret = USBC_Dev_WriteDataStatus(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_TX, is_last);
+		if (ret != 0) {
+			DMSG_PANIC("ERR: USBC_Dev_WriteDataStatus, failed\n");
+			req->req.status = -EOVERFLOW;
+		}
+	} else {  /* ep0 */
+		ret = USBC_Dev_WriteDataStatus(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0, is_last);
+		if (ret != 0) {
+			DMSG_PANIC("ERR: USBC_Dev_WriteDataStatus, failed\n");
+			req->req.status = -EOVERFLOW;
+		}
+	}
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+	if (is_last) {
+		if (!idx) {  /* ep0 */
+			ep->dev->ep0state = EP0_IDLE;
+		}
+
+		sunxi_udc_done(ep, req, 0);
+		is_last = 1;
+	}
+
+	return is_last;
+}
+
+static int dma_write_fifo(struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req)
+{
+	u32	left_len	= 0;
+	u32	idx		= 0;
+	void __iomem  *fifo_reg	= 0;
+	u8	old_ep_index	= 0;
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	/* select ep */
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	/* select fifo */
+	fifo_reg = USBC_SelectFIFO(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	/* auto_set, tx_mode, dma_tx_en, mode1 */
+	USBC_Dev_ConfigEpDma(
+			ep->dev->sunxi_udc_io->usb_bsp_hdle,
+			USBC_EP_TYPE_TX);
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+	/* cut fragment part(??) */
+	left_len = req->req.length - req->req.actual;
+	left_len = left_len - (left_len % ep->ep.maxpacket);
+
+	ep->dma_working	= 1;
+	dma_working = 1;
+	ep->dma_transfer_len = left_len;
+
+	spin_unlock(&ep->dev->lock);
+
+	sunxi_udc_dma_set_config(ep, req, (__u32)req->req.dma, left_len);
+	sunxi_udc_dma_start(ep, fifo_reg, (__u32)req->req.dma, left_len);
+	spin_lock(&ep->dev->lock);
+
+	return 0;
+}
+
+/* return: 0 = still running, 1 = completed, negative = errno */
+static int sunxi_udc_write_fifo(struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req)
+{
+	if (ep->dma_working) {
+		if (g_dma_debug) {
+			struct sunxi_udc_request *req_next = NULL;
+
+			DMSG_PANIC("ERR: dma is busy, write fifo. ep(0x%p, %d), req(0x%p, 0x%p, 0x%p, %d, %d)\n\n",
+				ep, ep->num,
+				req, &(req->req),
+				req->req.buf,
+				req->req.length,
+				req->req.actual);
+
+			if (likely(!list_empty(&ep->queue)))
+				req_next = list_entry(ep->queue.next,
+						struct sunxi_udc_request,
+						queue);
+			else
+				req_next = NULL;
+
+			if (req_next) {
+				DMSG_PANIC("ERR: dma is busy, write fifo. req(0x%p, 0x%p, 0x%p, %d, %d)\n\n",
+					req_next,
+					&(req_next->req),
+					req_next->req.buf,
+					req_next->req.length,
+					req_next->req.actual);
+			}
+		}
+		return 0;
+	}
+
+	if (is_sunxi_udc_dma_capable(req, ep))
+		return dma_write_fifo(ep, req);
+	else
+		return pio_write_fifo(ep, req);
+}
+
+static inline int sunxi_udc_read_packet(void __iomem *fifo,
+		void *buf, struct sunxi_udc_request *req, unsigned avail)
+{
+	unsigned len = 0;
+
+	len = min(req->req.length - req->req.actual, avail);
+	req->req.actual += len;
+
+	DMSG_DBG_UDC("R: req.actual(%d), req.length(%d), len(%d), total(%d)\n",
+		req->req.actual, req->req.length, len, req->req.actual + len);
+
+	USBC_ReadPacket(g_sunxi_udc_io.usb_bsp_hdle, fifo, len, buf);
+
+	return len;
+}
+
+/* return: 0 = still running, 1 = completed, negative = errno */
+static int pio_read_fifo(struct sunxi_udc_ep *ep, struct sunxi_udc_request *req)
+{
+	void		*buf		= NULL;
+	unsigned	bufferspace	= 0;
+	int		is_last		= 1;
+	unsigned	avail		= 0;
+	int		fifo_count	= 0;
+	u32		idx		= 0;
+	void __iomem	*fifo_reg	= 0;
+	__s32		ret		= 0;
+	u8		old_ep_index	= 0;
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	/* select fifo */
+	fifo_reg = USBC_SelectFIFO(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	if (!req->req.length) {
+		DMSG_PANIC("ERR: req->req.length == 0\n");
+		return 1;
+	}
+
+	buf = req->req.buf + req->req.actual;
+	bufferspace = req->req.length - req->req.actual;
+	if (!bufferspace) {
+		DMSG_PANIC("ERR: buffer full!\n");
+		return -1;
+	}
+
+	/* select ep */
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	fifo_count = sunxi_udc_fifo_count_out(g_sunxi_udc_io.usb_bsp_hdle, idx);
+	if (fifo_count > ep->ep.maxpacket)
+		avail = ep->ep.maxpacket;
+	else
+		avail = fifo_count;
+
+	fifo_count = sunxi_udc_read_packet(fifo_reg, buf, req, avail);
+
+	/**
+	 * checking this with ep0 is not accurate as we already
+	 * read a control request
+	 */
+	if (idx != 0 && fifo_count < ep->ep.maxpacket) {
+		is_last = 1;
+		/* overflowed this request? flush extra data */
+		if (fifo_count != avail)
+			req->req.status = -EOVERFLOW;
+	} else {
+		is_last = (req->req.length <= req->req.actual) ? 1 : 0;
+	}
+
+	if (g_read_debug) {
+		DMSG_INFO("pr: (0x%p, %d, %d)\n",
+				&(req->req), req->req.length, req->req.actual);
+	}
+
+	if (idx) {
+		ret = USBC_Dev_ReadDataStatus(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_RX, is_last);
+		if (ret != 0) {
+			DMSG_PANIC("ERR: pio_read_fifo: ");
+			DMSG_PANIC("USBC_Dev_WriteDataStatus, failed\n");
+			req->req.status = -EOVERFLOW;
+		}
+	} else {
+		ret = USBC_Dev_ReadDataStatus(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0, is_last);
+		if (ret != 0) {
+			DMSG_PANIC("ERR: pio_read_fifo: ");
+			DMSG_PANIC("USBC_Dev_WriteDataStatus, failed\n");
+			req->req.status = -EOVERFLOW;
+		}
+	}
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+	if (is_last) {
+		if (!idx)
+			ep->dev->ep0state = EP0_IDLE;
+
+		sunxi_udc_done(ep, req, 0);
+		is_last = 1;
+	}
+
+	return is_last;
+}
+
+static int dma_read_fifo(struct sunxi_udc_ep *ep, struct sunxi_udc_request *req)
+{
+	u32	left_len	= 0;
+	u32	idx		= 0;
+	void __iomem *fifo_reg	= 0;
+	u8	old_ep_index	= 0;
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	/* select ep */
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	/* select fifo */
+	fifo_reg = USBC_SelectFIFO(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	/* auto_set, tx_mode, dma_tx_en, mode1 */
+	USBC_Dev_ConfigEpDma(
+			ep->dev->sunxi_udc_io->usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+	/* cut fragment packet part */
+	left_len = req->req.length - req->req.actual;
+	left_len = left_len - (left_len % ep->ep.maxpacket);
+
+	if (g_dma_debug) {
+		DMSG_INFO("dr: (0x%p, %d, %d)\n", &(req->req),
+				req->req.length, req->req.actual);
+	}
+
+	ep->dma_working	= 1;
+	dma_working = 1;
+	ep->dma_transfer_len = left_len;
+
+	spin_unlock(&ep->dev->lock);
+
+	sunxi_udc_dma_set_config(ep, req, (__u32)req->req.dma, left_len);
+	sunxi_udc_dma_start(ep, fifo_reg, (__u32)req->req.dma, left_len);
+	spin_lock(&ep->dev->lock);
+
+	return 0;
+}
+
+/*
+ * If dma is working, RxPktRdy should be clear automatically.
+ * If not, we consider a short packet comes in and we will
+ * deal with it then.
+ *
+ * FIXME: The longest time to confirm is up to (5us * 1000).
+ */
+#ifdef SW_UDC_DMA_INNER
+static int sunxi_udc_confirm_rx_ready(void)
+{
+	int i = 0;
+	int rx_ready_flag = 1;
+
+	for (i = 0; i < 1000; i++) {
+		if (!USBC_Dev_IsReadDataReady(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX)) {
+			rx_ready_flag = 0;
+			break;
+		}
+		udelay(5);
+	}
+	DMSG_DBG_UDC("[confirm rx ready] rx_ready_flag = %d, i = %d\n",
+			rx_ready_flag, i);
+
+	return rx_ready_flag;
+}
+
+static int dma_got_short_pkt(struct sunxi_udc_ep *ep, struct sunxi_udc_request *req)
+{
+	dma_channel_t *pchan = NULL;
+	int dma_bc = 0;
+	int dma_r_bc = 0;
+	int fifo_count = 0;
+	unsigned long flags = 0;
+	__s32		ret		= 0;
+
+	pchan = (dma_channel_t *)ep->dma_hdle;
+	if (pchan == NULL) {
+		DMSG_DBG_UDC("[dma_got_short_pkt] dma_hdle is NULL!\n");
+		return 0;
+	}
+
+	dma_bc = USBC_Readw(USBC_REG_DMA_BC(pchan->reg_base, pchan->channel_num));
+	dma_r_bc = USBC_Readw(USBC_REG_DMA_RESIDUAL_BC(pchan->reg_base, pchan->channel_num));
+	fifo_count = USBC_ReadLenFromFifo(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+	if (g_dma_debug) {
+		DMSG_INFO("read_fifo: dma_working... rx_cnt = %d, dma_channel = %d, dma_bc = %d, dma_r_bc = %d\n",
+				fifo_count, pchan->channel_num, dma_bc, dma_r_bc);
+	}
+
+	if (!sunxi_udc_confirm_rx_ready())
+		return 0;
+
+	if (!fifo_count) {
+		ret = USBC_Dev_ReadDataStatus(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_RX, 1);
+		if (ret != 0) {
+			DMSG_PANIC("USBC_Dev_WriteDataStatus, failed\n");
+			req->req.status = -EOVERFLOW;
+			return 0;
+		}
+
+		goto reassign;
+	}
+	/*
+	 * rx fifo got a short packet, reassign the transfer len
+	 */
+	if (fifo_count > 0 && fifo_count < ep->ep.maxpacket) {
+reassign:
+		req->req.length = dma_bc - dma_r_bc + fifo_count;
+		ep->dma_transfer_len = dma_bc - dma_r_bc;
+
+		if (g_dma_debug) {
+			DMSG_INFO("reassign: req.length = %d, req.actual = %d, ep->dma_transfer_len = %d\n",
+					req->req.length, req->req.actual, ep->dma_transfer_len);
+		}
+		/*
+		* we need to stop dma manually
+		*/
+		sunxi_udc_dma_chan_disable((dm_hdl_t)ep->dma_hdle);
+		sunxi_udc_dma_release((dm_hdl_t)ep->dma_hdle);
+		ep->dma_hdle = NULL;
+
+		spin_unlock_irqrestore(&ep->dev->lock, flags);
+		sunxi_udc_dma_completion(ep->dev, ep, req);
+		spin_lock_irqsave(&ep->dev->lock, flags);
+
+		return 1;
+	}
+
+	return 0;
+}
+#endif
+
+/* return: 0 = still running, 1 = completed, negative = errno */
+static int sunxi_udc_read_fifo(struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req)
+{
+	int fifo_count = 0;
+
+	if (ep->dma_working) {
+#ifdef SW_UDC_DMA_INNER
+		if (dma_got_short_pkt(ep, req))
+			return 1;
+#endif
+
+		if (g_dma_debug) {
+			struct sunxi_udc_request *req_next = NULL;
+
+			DMSG_PANIC("ERR: dma is busy, read fifo. ep(0x%p, %d), req(0x%p, 0x%p, 0x%p, %d, %d)\n\n",
+				ep,
+				ep->num,
+				req,
+				&(req->req),
+				req->req.buf,
+				req->req.length,
+				req->req.actual);
+
+			if (likely(!list_empty(&ep->queue)))
+				req_next = list_entry(ep->queue.next,
+						struct sunxi_udc_request,
+						queue);
+			else
+				req_next = NULL;
+
+			if (req_next) {
+				DMSG_PANIC("ERR: dma is busy, read fifo. req(0x%p, 0x%p, 0x%p, %d, %d)\n\n",
+					req_next,
+					&(req_next->req),
+					req_next->req.buf,
+					req_next->req.length,
+					req_next->req.actual);
+			}
+		}
+		return 0;
+	}
+
+	fifo_count = USBC_ReadLenFromFifo(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+	if ((is_sunxi_udc_dma_capable(req, ep)) && (fifo_count == ep->ep.maxpacket))
+		return dma_read_fifo(ep, req);
+	else
+		return pio_read_fifo(ep, req);
+}
+
+static int sunxi_udc_read_fifo_crq(struct usb_ctrlrequest *crq)
+{
+	u32 fifo_count  = 0;
+	u32 i		= 0;
+	void *pOut	= crq;
+	void __iomem *fifo = 0;
+
+	fifo = USBC_SelectFIFO(g_sunxi_udc_io.usb_bsp_hdle, 0);
+	fifo_count = USBC_ReadLenFromFifo(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0);
+
+	if (fifo_count != 8) {
+		i = 0;
+
+		while (i < 16 && (fifo_count != 8)) {
+			fifo_count = USBC_ReadLenFromFifo(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0);
+			i++;
+		}
+
+		if (i >= 16)
+			DMSG_PANIC("ERR: get ep0 fifo len failed\n");
+	}
+
+	return USBC_ReadPacket(g_sunxi_udc_io.usb_bsp_hdle,
+			fifo, fifo_count, pOut);
+}
+
+static int sunxi_udc_get_status(struct sunxi_udc *dev,
+		struct usb_ctrlrequest *crq)
+{
+	u16 status  = 0;
+	u8  buf[8];
+	u8  ep_num  = crq->wIndex & 0x7F;
+	u8  is_in   = crq->wIndex & USB_DIR_IN;
+	void __iomem *fifo = 0;
+	u8 old_ep_index = 0;
+	int  ret = 0;
+
+	switch (crq->bRequestType & USB_RECIP_MASK) {
+	case USB_RECIP_INTERFACE:
+		buf[0] = 0x00;
+		buf[1] = 0x00;
+		break;
+
+	case USB_RECIP_DEVICE:
+		status = dev->devstatus;
+		buf[0] = 0x01;
+		buf[1] = 0x00;
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		if (ep_num > 4 || crq->wLength > 2)
+			return 1;
+
+		old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+		USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, ep_num);
+		if (ep_num == 0) {
+			status = USBC_Dev_IsEpStall(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_EP0);
+		} else {
+			if (is_in) {
+				ret = readw(g_sunxi_udc_io.usb_vbase
+						+ USBC_REG_o_TXCSR);
+				status = ret & (0x1 << USBC_BP_TXCSR_D_SEND_STALL);
+			} else {
+				ret = readw(g_sunxi_udc_io.usb_vbase
+						+ USBC_REG_o_RXCSR);
+				status = ret & (0x1 << USBC_BP_RXCSR_D_SEND_STALL);
+			}
+		}
+		status = status ? 1 : 0;
+		if (status) {
+			buf[0] = 0x01;
+			buf[1] = 0x00;
+		} else {
+			buf[0] = 0x00;
+			buf[1] = 0x00;
+		}
+		USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+		break;
+
+	default:
+		return 1;
+	}
+
+	/* Seems to be needed to get it working. ouch :( */
+	udelay(5);
+	USBC_Dev_ReadDataStatus(
+			g_sunxi_udc_io.usb_bsp_hdle,
+			USBC_EP_TYPE_EP0, 0);
+
+	fifo = USBC_SelectFIFO(g_sunxi_udc_io.usb_bsp_hdle, 0);
+	USBC_WritePacket(g_sunxi_udc_io.usb_bsp_hdle, fifo, crq->wLength, buf);
+	USBC_Dev_WriteDataStatus(g_sunxi_udc_io.usb_bsp_hdle,
+			USBC_EP_TYPE_EP0, 1);
+
+	return 0;
+}
+
+static int sunxi_udc_set_halt(struct usb_ep *_ep, int value);
+static int sunxi_udc_set_halt_ex(struct usb_ep *_ep, int value, int is_in);
+
+static void sunxi_udc_handle_ep0_idle(struct sunxi_udc *dev,
+						struct sunxi_udc_ep *ep,
+						struct usb_ctrlrequest *crq,
+						u32 ep0csr)
+{
+	int len = 0, ret = 0, tmp = 0;
+	int is_in = 0;
+
+	/* start control request? */
+	if (!USBC_Dev_IsReadDataReady(
+			g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0)) {
+		DMSG_WRN("ERR: data is ready, can not read data.\n");
+		return;
+	}
+
+	sunxi_udc_nuke(dev, ep, -EPROTO);
+
+	len = sunxi_udc_read_fifo_crq(crq);
+	if (len != sizeof(*crq)) {
+		USBC_Dev_ReadDataStatus(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0, 0);
+		USBC_Dev_EpSendStall(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0);
+
+		return;
+	}
+
+	DMSG_DBG_UDC("ep0: bRequest = %d bRequestType %d wLength = %d\n",
+		crq->bRequest, crq->bRequestType, crq->wLength);
+
+	/* cope with automagic for some standard requests. */
+	dev->req_std = ((crq->bRequestType & USB_TYPE_MASK)
+						== USB_TYPE_STANDARD);
+	dev->req_config = 0;
+	dev->req_pending = 1;
+
+	if (dev->req_std) {   /* standard request */
+		switch (crq->bRequest) {
+		case USB_REQ_SET_CONFIGURATION:
+			DMSG_DBG_UDC("USB_REQ_SET_CONFIGURATION ...\n");
+
+			if (crq->bRequestType == USB_RECIP_DEVICE)
+				dev->req_config = 1;
+			break;
+		case USB_REQ_SET_INTERFACE:
+			DMSG_DBG_UDC("USB_REQ_SET_INTERFACE ...\n");
+
+			if (crq->bRequestType == USB_RECIP_INTERFACE)
+				dev->req_config = 1;
+			break;
+		case USB_REQ_SET_ADDRESS:
+			DMSG_DBG_UDC("USB_REQ_SET_ADDRESS ...\n");
+
+			if (crq->bRequestType == USB_RECIP_DEVICE) {
+				tmp = crq->wValue & 0x7F;
+				dev->address = tmp;
+
+				/* rx receive over, dataend, tx_pakect ready */
+				USBC_Dev_ReadDataStatus(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0, 1);
+
+				dev->ep0state = EP0_END_XFER;
+
+				crq_bRequest = USB_REQ_SET_ADDRESS;
+
+				return;
+			}
+			break;
+		case USB_REQ_GET_STATUS:
+			DMSG_DBG_UDC("USB_REQ_GET_STATUS ...\n");
+
+			if (!sunxi_udc_get_status(dev, crq))
+				return;
+			break;
+		case USB_REQ_CLEAR_FEATURE:
+			/* --<1>--data direction must be host to device */
+			if (x_test_bit(crq->bRequestType, 7)) {
+				DMSG_PANIC("USB_REQ_CLEAR_FEATURE: ");
+				DMSG_PANIC("data is not host to device\n");
+				break;
+			}
+
+			USBC_Dev_ReadDataStatus(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_EP0, 1);
+
+			/* --<3>--data stage */
+			if (crq->bRequestType == USB_RECIP_DEVICE) {
+				/* wValue 0-1 */
+				if (crq->wValue) {
+					dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+				} else {
+					int k = 0;
+
+					for (k = 0; k < SW_UDC_ENDPOINTS; k++) {
+						is_in = crq->wIndex & USB_DIR_IN;
+						sunxi_udc_set_halt_ex(&dev->ep[k].ep, 0, is_in);
+					}
+				}
+
+			} else if (crq->bRequestType == USB_RECIP_INTERFACE) {
+				/**
+				 * --<2>--token stage over
+				 * do nothing
+				 */
+			} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {
+				/* --<3>--release the forbidden of ep */
+				/* wValue 0-1 */
+				if (crq->wValue) {
+					dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+				} else {
+					int k = 0;
+
+					is_in = crq->wIndex & USB_DIR_IN;
+					for (k = 0; k < SW_UDC_ENDPOINTS; k++) {
+						if (dev->ep[k].bEndpointAddress == (crq->wIndex & 0xff))
+							sunxi_udc_set_halt_ex(&dev->ep[k].ep, 0, is_in);
+					}
+				}
+
+			} else {
+				DMSG_PANIC("PANIC : nonsupport set feature request. (%d)\n", crq->bRequestType);
+				USBC_Dev_EpSendStall(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_EP0);
+			}
+
+			dev->ep0state = EP0_IDLE;
+
+			return;
+
+		case USB_REQ_SET_FEATURE:
+			/* --<1>--data direction must be host to device */
+			if (x_test_bit(crq->bRequestType, 7)) {
+				DMSG_PANIC("USB_REQ_SET_FEATURE: data is not host to device\n");
+				break;
+			}
+
+			/* --<3>--data stage */
+			if (crq->bRequestType == USB_RECIP_DEVICE) {
+				if (crq->wValue == USB_DEVICE_TEST_MODE) {
+					/* setup packet receive over */
+					switch (crq->wIndex) {
+					case SUNXI_UDC_TEST_J:
+						USBC_Dev_ReadDataStatus(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+						dev->ep0state = EP0_END_XFER;
+						crq_wIndex = TEST_J;
+						crq_bRequest = USB_REQ_SET_FEATURE;
+						return;
+					case SUNXI_UDC_TEST_K:
+						USBC_Dev_ReadDataStatus(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+						dev->ep0state = EP0_END_XFER;
+						crq_wIndex = TEST_K;
+						crq_bRequest = USB_REQ_SET_FEATURE;
+						return;
+					case SUNXI_UDC_TEST_SE0_NAK:
+						USBC_Dev_ReadDataStatus(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+						dev->ep0state = EP0_END_XFER;
+						crq_wIndex = TEST_SE0_NAK;
+						crq_bRequest = USB_REQ_SET_FEATURE;
+						return;
+					case SUNXI_UDC_TEST_PACKET:
+						USBC_Dev_ReadDataStatus(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+						dev->ep0state = EP0_END_XFER;
+						crq_wIndex = TEST_PACKET;
+						crq_bRequest = USB_REQ_SET_FEATURE;
+						return;
+					default:
+						break;
+					}
+				}
+
+				USBC_Dev_ReadDataStatus(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0, 1);
+				dev->devstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+			} else if (crq->bRequestType == USB_RECIP_INTERFACE) {
+				/* --<2>--token stage over */
+				USBC_Dev_ReadDataStatus(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0, 1);
+				/* do nothing */
+			} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {
+				/* --<3>--forbidden ep */
+				int k = 0;
+
+				is_in = crq->wIndex & USB_DIR_IN;
+				USBC_Dev_ReadDataStatus(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0, 1);
+				for (k = 0; k < SW_UDC_ENDPOINTS; k++) {
+					if (dev->ep[k].bEndpointAddress == (crq->wIndex & 0xff))
+						sunxi_udc_set_halt_ex(&dev->ep[k].ep, 1, is_in);
+				}
+
+			} else {
+				DMSG_PANIC("PANIC : nonsupport set feature request. (%d)\n", crq->bRequestType);
+
+				USBC_Dev_ReadDataStatus(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0, 1);
+				USBC_Dev_EpSendStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0);
+			}
+
+			dev->ep0state = EP0_IDLE;
+
+			return;
+
+		default:
+			/* only receive setup_data packet, cannot set DataEnd */
+			USBC_Dev_ReadDataStatus(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_EP0, 0);
+			break;
+		}
+	} else {
+		USBC_Dev_ReadDataStatus(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0, 0);
+#if IS_ENABLED(CONFIG_USB_G_WEBCAM) || IS_ENABLED(CONFIG_USB_CONFIGFS_F_UVC)
+		/**
+		 * getinfo request about exposure time asolute,
+		 * iris absolute, brightness of webcam.
+		 */
+		if (crq->bRequest == 0x86
+		    && crq->bRequestType == 0xa1
+		    && crq->wLength == 0x1
+		    && ((crq->wValue == 0x400 && crq->wIndex == 0x100)
+			|| (crq->wValue == 0x900 && crq->wIndex == 0x100)
+			|| (crq->wValue == 0x200 && crq->wIndex == 0x200))) {
+			USBC_Dev_EpSendStall(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_EP0);
+			return;
+		}
+#endif
+	}
+
+	if (crq->bRequestType & USB_DIR_IN)
+		dev->ep0state = EP0_IN_DATA_PHASE;
+	else
+		dev->ep0state = EP0_OUT_DATA_PHASE;
+
+	if (!dev->driver)
+		return;
+
+	spin_unlock(&dev->lock);
+	ret = dev->driver->setup(&dev->gadget, crq);
+	spin_lock(&dev->lock);
+	if (ret < 0) {
+		if (dev->req_config) {
+			DMSG_PANIC("ERR: config change %02x fail %d?\n",
+				crq->bRequest, ret);
+			return;
+		}
+
+		if (ret == -EOPNOTSUPP)
+			DMSG_PANIC("ERR: Operation not supported\n");
+		else
+			DMSG_PANIC("ERR: dev->driver->setup failed. (%d)\n",
+				ret);
+
+		udelay(5);
+
+		USBC_Dev_ReadDataStatus(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0, 1);
+		USBC_Dev_EpSendStall(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0);
+
+		dev->ep0state = EP0_IDLE;
+		/* deferred i/o == no response yet */
+	} else if (dev->req_pending) {
+		dev->req_pending = 0;
+	}
+
+	if (dev->req_std) {
+		if (crq->bRequest == USB_REQ_SET_CONFIGURATION
+				|| crq->bRequest == USB_REQ_SET_INTERFACE) {
+			/* rx_packet receive over */
+			USBC_Dev_ReadDataStatus(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_EP0, 1);
+		}
+	}
+}
+
+static void sunxi_udc_handle_ep0(struct sunxi_udc *dev)
+{
+	u32 ep0csr = 0;
+	struct sunxi_udc_ep *ep = &dev->ep[0];
+	struct sunxi_udc_request *req = NULL;
+	struct usb_ctrlrequest crq;
+
+	DMSG_DBG_UDC("sunxi_udc_handle_ep0--1--\n");
+
+	if (list_empty(&ep->queue))
+		req = NULL;
+	else
+		req = list_entry(ep->queue.next,
+				struct sunxi_udc_request, queue);
+
+	DMSG_DBG_UDC("sunxi_udc_handle_ep0--2--\n");
+
+	/**
+	 * We make the assumption that sunxi_udc_UDC_IN_CSR1_REG equal to
+	 * sunxi_udc_UDC_EP0_CSR_REG when index is zero.
+	 */
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, 0);
+
+	/* clear stall status */
+	if (USBC_Dev_IsEpStall(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0)) {
+		DMSG_PANIC("ERR: ep0 stall\n");
+
+		sunxi_udc_nuke(dev, ep, -EPIPE);
+		USBC_Dev_EpClearStall(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0);
+		dev->ep0state = EP0_IDLE;
+		return;
+	}
+
+	/* clear setup end */
+	if (USBC_Dev_Ctrl_IsSetupEnd(g_sunxi_udc_io.usb_bsp_hdle)) {
+		DMSG_PANIC("handle_ep0: ep0 setup end\n");
+
+		sunxi_udc_nuke(dev, ep, 0);
+		USBC_Dev_Ctrl_ClearSetupEnd(g_sunxi_udc_io.usb_bsp_hdle);
+		dev->ep0state = EP0_IDLE;
+	}
+
+	DMSG_DBG_UDC("sunxi_udc_handle_ep0--3--%d\n", dev->ep0state);
+
+	ep0csr = USBC_Readw(USBC_REG_CSR0(g_sunxi_udc_io.usb_vbase));
+
+	switch (dev->ep0state) {
+	case EP0_IDLE:
+		sunxi_udc_handle_ep0_idle(dev, ep, &crq, ep0csr);
+		break;
+	case EP0_IN_DATA_PHASE:			/* GET_DESCRIPTOR etc */
+		DMSG_DBG_UDC("EP0_IN_DATA_PHASE ... what now?\n");
+
+		if (!USBC_Dev_IsWriteDataReady(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_EP0)
+				&& req) {
+			sunxi_udc_write_fifo(ep, req);
+		}
+		break;
+	case EP0_OUT_DATA_PHASE:		/* SET_DESCRIPTOR etc */
+		DMSG_DBG_UDC("EP0_OUT_DATA_PHASE ... what now?\n");
+
+		if (USBC_Dev_IsReadDataReady(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_EP0)
+				&& req) {
+			sunxi_udc_read_fifo(ep, req);
+		}
+		break;
+	case EP0_END_XFER:
+		DMSG_DBG_UDC("EP0_END_XFER ... what now?\n");
+		DMSG_DBG_UDC("crq_bRequest = 0x%x\n", crq_bRequest);
+
+		switch (crq_bRequest) {
+		case USB_REQ_SET_ADDRESS:
+			USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, 0);
+
+			USBC_Dev_Ctrl_ClearSetupEnd(
+					g_sunxi_udc_io.usb_bsp_hdle);
+			USBC_Dev_SetAddress(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					dev->address);
+
+			DMSG_INFO_UDC("Set address %d\n", dev->address);
+			break;
+		case USB_REQ_SET_FEATURE:
+			switch (crq_wIndex) {
+			case TEST_J:
+				USBC_EnterMode_Test_J(
+						g_sunxi_udc_io.usb_bsp_hdle);
+				break;
+
+			case TEST_K:
+				USBC_EnterMode_Test_K(
+						g_sunxi_udc_io.usb_bsp_hdle);
+				break;
+
+			case TEST_SE0_NAK:
+				USBC_EnterMode_Test_SE0_NAK(
+						g_sunxi_udc_io.usb_bsp_hdle);
+				break;
+
+			case TEST_PACKET:
+			{
+				void __iomem *fifo = 0;
+
+				fifo = USBC_SelectFIFO(
+						g_sunxi_udc_io.usb_bsp_hdle, 0);
+				USBC_WritePacket(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						fifo, 54, (u32 *)TestPkt);
+				USBC_EnterMode_TestPacket(
+						g_sunxi_udc_io.usb_bsp_hdle);
+				USBC_Dev_WriteDataStatus(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0, 0);
+			}
+				break;
+			default:
+				break;
+			}
+
+			crq_wIndex = 0;
+			break;
+		default:
+			break;
+		}
+
+		crq_bRequest = 0;
+
+		dev->ep0state = EP0_IDLE;
+		break;
+
+	case EP0_STALL:
+		DMSG_DBG_UDC("EP0_STALL ... what now?\n");
+		dev->ep0state = EP0_IDLE;
+		break;
+	}
+
+	DMSG_DBG_UDC("sunxi_udc_handle_ep0--4--%d\n", dev->ep0state);
+}
+
+static void sunxi_udc_handle_ep(struct sunxi_udc_ep *ep)
+{
+	struct sunxi_udc_request *req = NULL;
+	int is_in = ep->bEndpointAddress & USB_DIR_IN;
+	u32 idx = 0;
+	u8 old_ep_index = 0;
+
+	/* see sunxi_udc_queue. */
+	if (likely(!list_empty(&ep->queue)))
+		req = list_entry(ep->queue.next,
+				struct sunxi_udc_request, queue);
+	else
+		req = NULL;
+
+	if (g_irq_debug) {
+		DMSG_INFO("e: (%s), tx_csr=0x%x\n", ep->ep.name,
+			USBC_Readw(USBC_REG_TXCSR(g_sunxi_udc_io.usb_vbase)));
+		if (req) {
+			DMSG_INFO("req: (0x%p, %d, %d)\n", &(req->req),
+				req->req.length, req->req.actual);
+		}
+	}
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	if (is_in) {
+		if (USBC_Dev_IsEpStall(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_TX)) {
+			DMSG_PANIC("ERR: tx ep(%d) is stall\n", idx);
+			USBC_Dev_EpClearStall(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_TX);
+			goto end;
+		}
+	} else {
+		if (USBC_Dev_IsEpStall(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_RX)) {
+			DMSG_PANIC("ERR: rx ep(%d) is stall\n", idx);
+			USBC_Dev_EpClearStall(
+					g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_RX);
+			goto end;
+		}
+	}
+
+	if (req) {
+		if (is_in) {
+			if (!USBC_Dev_IsWriteDataReady(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX)) {
+				sunxi_udc_write_fifo(ep, req);
+			}
+		} else {
+			if (USBC_Dev_IsReadDataReady(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_RX)) {
+				sunxi_udc_read_fifo(ep, req);
+			}
+		}
+	}
+
+end:
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+}
+
+/* mask the useless irq, save disconect, reset, resume, suspend */
+static u32 filtrate_irq_misc(u32 irq_misc)
+{
+	u32 irq = irq_misc;
+
+	irq &= ~(USBC_INTUSB_VBUS_ERROR
+		| USBC_INTUSB_SESSION_REQ
+		| USBC_INTUSB_CONNECT
+		| USBC_INTUSB_SOF);
+	USBC_INT_ClearMiscPending(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_INTUSB_VBUS_ERROR);
+	USBC_INT_ClearMiscPending(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_INTUSB_SESSION_REQ);
+	USBC_INT_ClearMiscPending(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_INTUSB_CONNECT);
+	USBC_INT_ClearMiscPending(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_INTUSB_SOF);
+
+	return irq;
+}
+
+static void clear_all_irq(void)
+{
+	USBC_INT_ClearEpPendingAll(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_TX);
+	USBC_INT_ClearEpPendingAll(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_RX);
+	USBC_INT_ClearMiscPendingAll(g_sunxi_udc_io.usb_bsp_hdle);
+}
+
+static void throw_away_all_urb(struct sunxi_udc *dev)
+{
+	int k = 0;
+
+	DMSG_INFO_UDC("irq: reset happen, throw away all urb\n");
+	for (k = 0; k < SW_UDC_ENDPOINTS; k++)
+		sunxi_udc_nuke(dev,
+			(struct sunxi_udc_ep *)&(dev->ep[k]),
+			-ECONNRESET);
+}
+
+/* clear all dma status of the EP, called when dma exception */
+static void sunxi_udc_clean_dma_status(struct sunxi_udc_ep *ep)
+{
+	u8 ep_index = 0;
+	u8 old_ep_index = 0;
+	//struct sunxi_udc_request *req = NULL;
+
+	ep_index = ep->bEndpointAddress & 0x7F;
+
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, ep_index);
+
+	if ((ep->bEndpointAddress) & USB_DIR_IN) {  /* dma_mode1 */
+		/* clear ep dma status */
+		USBC_Dev_ClearEpDma(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_TX);
+
+		/* select bus to pio */
+		sunxi_udc_switch_bus_to_pio(ep, 1);
+	} else {  /* dma_mode0 */
+		/* clear ep dma status */
+		USBC_Dev_ClearEpDma(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_RX);
+
+		/* select bus to pio */
+		sunxi_udc_switch_bus_to_pio(ep, 0);
+	}
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+	ep->dma_working = 0;
+	dma_working = 0;
+}
+
+static void sunxi_udc_stop_dma_work(struct sunxi_udc *dev, u32 unlock)
+{
+	__u32 i = 0;
+	struct sunxi_udc_ep *ep = NULL;
+
+	for (i = 0; i < SW_UDC_ENDPOINTS; i++) {
+		ep = &dev->ep[i];
+
+		if (sunxi_udc_dma_is_busy(ep)) {
+			DMSG_PANIC("wrn: ep(%d) must stop working\n", i);
+
+			if (unlock) {
+				spin_unlock(&ep->dev->lock);
+				sunxi_udc_dma_stop(ep);
+				spin_lock(&ep->dev->lock);
+			} else {
+				sunxi_udc_dma_stop(ep);
+			}
+
+#ifdef SW_UDC_DMA_INNER
+			ep->dma_hdle = NULL;
+#else
+			ep->sunxi_udc_dma[ep->num].is_start = 0;
+#endif
+			ep->dma_transfer_len = 0;
+
+			sunxi_udc_clean_dma_status(ep);
+		}
+	}
+}
+
+void sunxi_udc_dma_completion(struct sunxi_udc *dev,
+		struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req)
+{
+	unsigned long		flags			= 0;
+	__u8			old_ep_index		= 0;
+	__u32			dma_transmit_len	= 0;
+	int			is_complete		= 0;
+	struct sunxi_udc_request *req_next		= NULL;
+
+	if (dev == NULL || ep == NULL || req == NULL) {
+		DMSG_PANIC("ERR: argment invaild. (0x%p, 0x%p, 0x%p)\n",
+			dev, ep, req);
+		return;
+	}
+
+	if (!ep->dma_working) {
+		DMSG_PANIC("ERR: dma is not work, can not callback\n");
+		return;
+	}
+
+	sunxi_udc_unmap_dma_buffer(req, dev, ep);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	old_ep_index = USBC_GetActiveEp(dev->sunxi_udc_io->usb_bsp_hdle);
+	USBC_SelectActiveEp(dev->sunxi_udc_io->usb_bsp_hdle, ep->num);
+
+	if ((ep->bEndpointAddress) & USB_DIR_IN) {  /* tx, dma_mode1 */
+		while (USBC_Dev_IsWriteDataReady_FifoEmpty(
+				dev->sunxi_udc_io->usb_bsp_hdle,
+				USBC_EP_TYPE_TX))
+			;
+		USBC_Dev_ClearEpDma(dev->sunxi_udc_io->usb_bsp_hdle,
+				USBC_EP_TYPE_TX);
+	} else {  /* rx, dma_mode0 */
+		USBC_Dev_ClearEpDma(dev->sunxi_udc_io->usb_bsp_hdle,
+				USBC_EP_TYPE_RX);
+	}
+
+	dma_transmit_len = sunxi_udc_dma_transmit_length(ep);
+	if (dma_transmit_len < req->req.length) {
+		if ((ep->bEndpointAddress) & USB_DIR_IN)
+			USBC_Dev_ClearEpDma(dev->sunxi_udc_io->usb_bsp_hdle,
+					USBC_EP_TYPE_TX);
+		else
+			USBC_Dev_ClearEpDma(dev->sunxi_udc_io->usb_bsp_hdle,
+					USBC_EP_TYPE_RX);
+	}
+
+	ep->dma_working = 0;
+	dma_working = 0;
+	ep->dma_transfer_len = 0;
+
+	/* if current data transfer not complete, then go on */
+	req->req.actual += dma_transmit_len;
+
+	if (g_dma_debug) {
+		DMSG_INFO("di: (0x%p, %d, %d),(%d,%d)\n",
+				&(req->req), req->req.length, req->req.actual,
+				ep->bEndpointAddress, USB_DIR_IN);
+	}
+
+	if (req->req.length > req->req.actual) {
+		if (((ep->bEndpointAddress & USB_DIR_IN) != 0)
+			&& !USBC_Dev_IsWriteDataReady_FifoEmpty(
+					dev->sunxi_udc_io->usb_bsp_hdle,
+					USBC_EP_TYPE_TX)) {
+			if (pio_write_fifo(ep, req)) {
+				req = NULL;
+				is_complete = 1;
+			}
+		} else if (((ep->bEndpointAddress & USB_DIR_IN) == 0)
+			&& USBC_Dev_IsReadDataReady(
+					dev->sunxi_udc_io->usb_bsp_hdle,
+					USBC_EP_TYPE_RX)) {
+			if (pio_read_fifo(ep, req)) {
+				req = NULL;
+				is_complete = 1;
+			}
+		}
+	} else {	/* if DMA transfer data over, then done */
+		/*tx need zero packet in sometime*/
+		if ((ep->bEndpointAddress & USB_DIR_IN) != 0 && req->req.zero)
+			pio_write_fifo(ep, req);
+		else
+			sunxi_udc_done(ep, req, 0);
+		is_complete = 1;
+	}
+
+	/* start next transfer */
+	if (is_complete) {
+		if (likely(!list_empty(&ep->queue)))
+			req_next = list_entry(ep->queue.next,
+					struct sunxi_udc_request, queue);
+		else
+			req_next = NULL;
+
+		if (req_next) {
+			if ((ep->bEndpointAddress & USB_DIR_IN) != 0) {
+				while (USBC_Dev_IsWriteDataReady_FifoEmpty(
+						dev->sunxi_udc_io->usb_bsp_hdle,
+						USBC_EP_TYPE_TX))
+					;
+				sunxi_udc_write_fifo(ep, req_next);
+			} else if (((ep->bEndpointAddress & USB_DIR_IN) == 0)
+				&& USBC_Dev_IsReadDataReady(
+						dev->sunxi_udc_io->usb_bsp_hdle,
+						USBC_EP_TYPE_RX)) {
+
+				sunxi_udc_read_fifo(ep, req_next);
+			}
+		}
+	}
+
+	USBC_SelectActiveEp(dev->sunxi_udc_io->usb_bsp_hdle, old_ep_index);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+static irqreturn_t sunxi_udc_irq(int dummy, void *_dev)
+{
+	struct sunxi_udc *dev = _dev;
+	int usb_irq	= 0;
+	int tx_irq	= 0;
+	int rx_irq	= 0;
+	int i		= 0;
+	int dma_irq	= 0;
+	u32 old_ep_idx  = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* Driver connected ? */
+	if (!dev->driver || !is_peripheral_active()) {
+		DMSG_PANIC("ERR: functoin driver is not exist, ");
+		DMSG_PANIC("or udc is not active.\n");
+
+		/* Clear interrupts */
+		clear_all_irq();
+
+		spin_unlock_irqrestore(&dev->lock, flags);
+
+		return IRQ_NONE;
+	}
+
+	/* Save index */
+	old_ep_idx = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+
+	/* Read status registers */
+	usb_irq = USBC_INT_MiscPending(g_sunxi_udc_io.usb_bsp_hdle);
+	tx_irq  = USBC_INT_EpPending(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_TX);
+	rx_irq  = USBC_INT_EpPending(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_RX);
+	dma_irq = USBC_Readw(USBC_REG_DMA_INTS(dev->sunxi_udc_io->usb_vbase));
+
+	usb_irq = filtrate_irq_misc(usb_irq);
+
+	if (g_irq_debug) {
+		DMSG_INFO("\nirq: %02x,tx_irq=%02x,rx_irq=%02x, dma_irq:%x\n",
+				usb_irq, tx_irq, rx_irq, dma_irq);
+	}
+
+	/**
+	 * Now, handle interrupts. There's two types :
+	 * - Reset, Resume, Suspend coming -> usb_int_reg
+	 * - EP -> ep_int_reg
+	 */
+
+	/* RESET */
+	if (usb_irq & USBC_INTUSB_RESET) {
+		DMSG_INFO_UDC("IRQ: reset\n");
+
+		USBC_INT_ClearMiscPending(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_INTUSB_RESET);
+
+		clear_all_irq();
+
+		usb_connect = 1;
+
+		if (!charger_mode) {
+			pr_debug("usb_connecting: hold wake lock.\n");
+			__pm_stay_awake(dev->ws);
+		}
+
+		USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, 0);
+		USBC_Dev_SetAddress_default(g_sunxi_udc_io.usb_bsp_hdle);
+
+		if (is_udc_support_dma())
+			sunxi_udc_stop_dma_work(dev, 1);
+
+		throw_away_all_urb(dev);
+
+		dev->address = 0;
+		dev->ep0state = EP0_IDLE;
+		dev->gadget.speed = USB_SPEED_UNKNOWN;
+		g_irq_debug = 0;
+		g_queue_debug = 0;
+		g_dma_debug = 0;
+
+		spin_unlock_irqrestore(&dev->lock, flags);
+
+#if !defined(SUNXI_USB_FPGA) && defined(CONFIG_POWER_SUPPLY)
+		schedule_work(&dev->set_cur_vol_work);
+#endif
+
+		return IRQ_HANDLED;
+	}
+
+	/* RESUME */
+	if (usb_irq & USBC_INTUSB_RESUME) {
+		DMSG_INFO_UDC("IRQ: resume\n");
+
+		/* clear interrupt */
+		USBC_INT_ClearMiscPending(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_INTUSB_RESUME);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+			&& dev->driver
+			&& dev->driver->resume) {
+			spin_unlock(&dev->lock);
+			dev->driver->resume(&dev->gadget);
+			spin_lock(&dev->lock);
+			usb_connect = 1;
+		}
+	}
+
+	/* SUSPEND */
+	if (usb_irq & USBC_INTUSB_SUSPEND) {
+		DMSG_INFO_UDC("IRQ: suspend\n");
+
+		/* clear interrupt */
+		USBC_INT_ClearMiscPending(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_INTUSB_SUSPEND);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN) {
+			spin_unlock_irqrestore(&dev->lock, flags);
+			schedule_work(&dev->vbus_det_work);
+			spin_lock_irqsave(&dev->lock, flags);
+			usb_connect = 0;
+			if (!charger_mode) {
+				__pm_relax(dev->ws);
+				pr_debug("usb_connecting: release wake lock\n");
+			}
+
+		} else {
+			DMSG_INFO_UDC("ERR: usb speed is unknown\n");
+		}
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+				&& dev->driver
+				&& dev->driver->suspend) {
+			spin_unlock(&dev->lock);
+			dev->driver->suspend(&dev->gadget);
+			spin_lock(&dev->lock);
+		}
+
+		dev->ep0state = EP0_IDLE;
+	}
+
+	/* DISCONNECT */
+	if (usb_irq & USBC_INTUSB_DISCONNECT) {
+		DMSG_INFO_UDC("IRQ: disconnect\n");
+
+		USBC_INT_ClearMiscPending(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_INTUSB_DISCONNECT);
+
+		dev->ep0state = EP0_IDLE;
+
+		usb_connect = 0;
+	}
+
+	/**
+	 * EP
+	 * control traffic
+	 * check on ep0csr != 0 is not a good idea as clearing in_pkt_ready
+	 * generate an interrupt
+	 */
+	if (tx_irq & USBC_INTTx_FLAG_EP0) {
+		DMSG_DBG_UDC("USB ep0 irq\n");
+
+		/* Clear the interrupt bit by setting it to 1 */
+		USBC_INT_ClearEpPending(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_TX, 0);
+
+		if (dev->gadget.speed == USB_SPEED_UNKNOWN) {
+			if (USBC_Dev_QueryTransferMode(g_sunxi_udc_io.usb_bsp_hdle)
+					== USBC_TS_MODE_HS) {
+				dev->gadget.speed = USB_SPEED_HIGH;
+
+				DMSG_INFO_UDC("\n++++++++++++++++++++\n");
+				DMSG_INFO_UDC(" usb enter high speed.\n");
+				DMSG_INFO_UDC("\n++++++++++++++++++++\n");
+			} else {
+				dev->gadget.speed = USB_SPEED_FULL;
+
+				DMSG_INFO_UDC("\n++++++++++++++++++++\n");
+				DMSG_INFO_UDC(" usb enter full speed.\n");
+				DMSG_INFO_UDC("\n++++++++++++++++++++\n");
+			}
+		}
+
+		sunxi_udc_handle_ep0(dev);
+	}
+
+#ifdef SW_UDC_DMA_INNER
+	if (is_udc_support_dma()) {
+		struct sunxi_udc_request *req = NULL;
+		struct sunxi_udc_ep *ep = NULL;
+		int i = 0;
+
+		/* tx endpoint data transfers */
+		for (i = 0; i < DMA_CHAN_TOTAL; i++) {
+			u32 tmp = 1 << i;
+
+			if (dma_irq & tmp) {
+				DMSG_DBG_UDC("USB dma chanle%d irq\n", i);
+
+				/* set 1 to clear pending */
+				writel(BIT(i),
+					USBC_REG_DMA_INTS(dev->sunxi_udc_io->usb_vbase));
+
+				ep = &dev->ep[dma_chnl[i].ep_num];
+
+				if (ep) {
+					/* find req */
+					sunxi_udc_dma_release((dm_hdl_t)ep->dma_hdle);
+					ep->dma_hdle = NULL;
+					if (likely(!list_empty(&ep->queue)))
+						req = list_entry(ep->queue.next, struct sunxi_udc_request, queue);
+					else
+						req = NULL;
+
+					/* call back */
+					if (req) {
+						spin_unlock_irqrestore(&dev->lock, flags);
+						sunxi_udc_dma_completion(dev, ep, req);
+						spin_lock_irqsave(&dev->lock, flags);
+					}
+				} else {
+					DMSG_PANIC("ERR: sunxi_udc_dma_callback: dma is remove, but dma irq is happened\n");
+				}
+			}
+		}
+	}
+#endif
+
+	/* rx endpoint data transfers */
+	for (i = 1; i <= SW_UDC_EPNUMS; i++) {
+		u32 tmp = 1 << i;
+
+		if (rx_irq & tmp) {
+			DMSG_DBG_UDC("USB rx ep%d irq\n", i);
+
+			/* Clear the interrupt bit by setting it to 1 */
+			USBC_INT_ClearEpPending(g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_RX, i);
+
+			sunxi_udc_handle_ep(&dev->ep[ep_fifo_out[i]]);
+		}
+	}
+
+	/* tx endpoint data transfers */
+	for (i = 1; i <= SW_UDC_EPNUMS; i++) {
+		u32 tmp = 1 << i;
+
+		if (tx_irq & tmp) {
+			DMSG_DBG_UDC("USB tx ep%d irq\n", i);
+
+			/* Clear the interrupt bit by setting it to 1 */
+			USBC_INT_ClearEpPending(g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX, i);
+
+			sunxi_udc_handle_ep(&dev->ep[ep_fifo_in[i]]);
+		}
+	}
+
+	/* Restore old index */
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_idx);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return IRQ_HANDLED;
+}
+
+/* sunxi_udc_ep_ops */
+static inline struct sunxi_udc_ep *to_sunxi_udc_ep(struct usb_ep *ep)
+{
+	return container_of(ep, struct sunxi_udc_ep, ep);
+}
+
+static inline struct sunxi_udc *to_sunxi_udc(struct usb_gadget *gadget)
+{
+	return container_of(gadget, struct sunxi_udc, gadget);
+}
+
+static inline struct sunxi_udc_request *to_sunxi_udc_req(struct usb_request *req)
+{
+	return container_of(req, struct sunxi_udc_request, req);
+}
+
+static void sunxi_udc_ep_config_reset(struct sunxi_udc_ep *ep)
+{
+	if (ep->bmAttributes == USB_ENDPOINT_XFER_CONTROL)
+		ep->ep.maxpacket = EP0_FIFO_SIZE;
+	else if (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)
+		ep->ep.maxpacket = SW_UDC_EP_ISO_FIFO_SIZE;
+	else if (ep->bmAttributes == USB_ENDPOINT_XFER_BULK)
+		ep->ep.maxpacket = SW_UDC_EP_FIFO_SIZE;
+	else if (ep->bmAttributes == USB_ENDPOINT_XFER_INT)
+		ep->ep.maxpacket = SW_UDC_EP_FIFO_SIZE;
+	else
+		DMSG_PANIC("[ep_disable] ep type is invalid!\n");
+}
+
+static int sunxi_udc_ep_enable(struct usb_ep *_ep,
+				const struct usb_endpoint_descriptor *desc)
+{
+	struct sunxi_udc	*dev		= NULL;
+	struct sunxi_udc_ep	*ep		= NULL;
+	u32			max		= 0;
+	u32			old_ep_index	= 0;
+	__u32			fifo_addr	= 0;
+	unsigned long		flags		= 0;
+	u32 ep_type   = 0;
+	u32 ts_type   = 0;
+	u32 fifo_size = 0;
+	u8  double_fifo = 0;
+	int i = 0;
+
+	if (_ep == NULL || desc == NULL) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	if (_ep->name == ep0name || desc->bDescriptorType != USB_DT_ENDPOINT) {
+		DMSG_PANIC("PANIC : _ep->name(%s) == ep0name || desc->bDescriptorType(%d) != USB_DT_ENDPOINT\n",
+			_ep->name, desc->bDescriptorType);
+		return -EINVAL;
+	}
+
+	ep = to_sunxi_udc_ep(_ep);
+	if (ep == NULL) {
+		DMSG_PANIC("ERR: usbd_ep_enable, ep = NULL\n");
+		return -EINVAL;
+	}
+
+	if (ep->desc) {
+		DMSG_PANIC("ERR: usbd_ep_enable, ep->desc is not NULL, ep%d(%s)\n",
+			ep->num, _ep->name);
+		return -EINVAL;
+	}
+
+	DMSG_INFO_UDC("ep enable: ep%d(0x%p, %s, %d, %d)\n",
+		ep->num, _ep, _ep->name,
+		(desc->bEndpointAddress & USB_DIR_IN), _ep->maxpacket);
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DMSG_PANIC("PANIC : dev->driver = 0x%p ?= NULL  dev->gadget->speed =%d ?= USB_SPEED_UNKNOWN\n",
+			dev->driver, dev->gadget.speed);
+		return -ESHUTDOWN;
+	}
+
+	max = le16_to_cpu(desc->wMaxPacketSize) & 0x1fff;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	_ep->maxpacket = max & 0x7ff;
+	ep->desc = desc;
+	ep->halted = 0;
+	ep->bEndpointAddress = desc->bEndpointAddress;
+
+	/* ep_type */
+	if ((ep->bEndpointAddress) & USB_DIR_IN) { /* tx */
+		ep_type = USBC_EP_TYPE_TX;
+	} else {	 /* rx */
+		ep_type = USBC_EP_TYPE_RX;
+	}
+
+	/* ts_type */
+	switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		ts_type   = USBC_TS_TYPE_CTRL;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		ts_type   = USBC_TS_TYPE_BULK;
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		ts_type   = USBC_TS_TYPE_ISO;
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		ts_type = USBC_TS_TYPE_INT;
+		break;
+	default:
+		DMSG_PANIC("err: usbd_ep_enable, unknown ep type(%d)\n",
+			(desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK));
+		goto end;
+	}
+
+	/* fifo_addr && fifo_size && double fifo */
+	for (i = 0; i < SW_UDC_ENDPOINTS; i++) {
+		if (!strcmp(_ep->name, ep_fifo[i].name)) {
+			fifo_addr = ep_fifo[i].fifo_addr;
+			fifo_size = ep_fifo[i].fifo_size;
+			double_fifo = ep_fifo[i].double_fifo;
+			break;
+		}
+	}
+
+	DMSG_INFO_UDC("ep enable: ep%d(0x%p, %s, %d, %d), fifo(%d, %d, %d)\n",
+		ep->num,
+		_ep,
+		_ep->name,
+		(desc->bEndpointAddress & USB_DIR_IN),
+		_ep->maxpacket,
+		fifo_addr,
+		fifo_size,
+		double_fifo);
+
+	if (i >= SW_UDC_ENDPOINTS) {
+		DMSG_PANIC("err: usbd_ep_enable, config fifo failed\n");
+		goto end;
+	}
+
+	/* check fifo size */
+	if ((_ep->maxpacket & 0x7ff) > fifo_size) {
+		DMSG_PANIC("err: usbd_ep_enable, fifo size is too small\n");
+		goto end;
+	}
+
+	/* check double fifo */
+	if (double_fifo) {
+		if (((_ep->maxpacket & 0x7ff) * 2) > fifo_size) {
+			DMSG_PANIC("err: usbd_ep_enable, it is double fifo, ");
+			DMSG_PANIC("but fifo size is too small\n");
+			goto end;
+		}
+
+		/* ????FIFO, ????????????? */
+		fifo_size = _ep->maxpacket & 0x7ff;
+	}
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("usbd_ep_enable, usb device is not active\n");
+		goto end;
+	}
+
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, ep->num);
+
+	USBC_Dev_ConfigEp_Default(g_sunxi_udc_io.usb_bsp_hdle, ep_type);
+	USBC_Dev_FlushFifo(g_sunxi_udc_io.usb_bsp_hdle, ep_type);
+
+	/**
+	 * set max packet ,type, direction, address;
+	 * reset fifo counters, enable irq
+	 */
+	USBC_Dev_ConfigEp(g_sunxi_udc_io.usb_bsp_hdle,
+			ts_type, ep_type, double_fifo,
+			(_ep->maxpacket & 0x7ff));
+	USBC_ConfigFifo(g_sunxi_udc_io.usb_bsp_hdle,
+			ep_type, double_fifo, fifo_size,
+			fifo_addr);
+	if (ts_type == USBC_TS_TYPE_ISO)
+		USBC_Dev_IsoUpdateEnable(g_sunxi_udc_io.usb_bsp_hdle);
+
+	USBC_INT_EnableEp(g_sunxi_udc_io.usb_bsp_hdle, ep_type, ep->num);
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+end:
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	sunxi_udc_set_halt(_ep, 0);
+	return 0;
+}
+
+static int sunxi_udc_ep_disable(struct usb_ep *_ep)
+{
+	struct sunxi_udc_ep *ep = NULL;
+	u32 old_ep_index = 0;
+	unsigned long flags = 0;
+
+	if (!_ep) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	ep = to_sunxi_udc_ep(_ep);
+	if (ep == NULL) {
+		DMSG_PANIC("ERR: usbd_ep_disable: ep = NULL\n");
+		return -EINVAL;
+	}
+
+	if (!ep->desc) {
+		DMSG_PANIC("ERR: %s not enabled\n", _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	DMSG_INFO_UDC("ep disable: ep%d(0x%p, %s, %d, %x)\n",
+		ep->num, _ep, _ep->name,
+		(ep->bEndpointAddress & USB_DIR_IN), _ep->maxpacket);
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	DMSG_DBG_UDC("ep_disable: %s\n", _ep->name);
+
+	ep->desc = NULL;
+	ep->halted = 1;
+	sunxi_udc_ep_config_reset(ep);
+
+	sunxi_udc_nuke(ep->dev, ep, -ESHUTDOWN);
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		goto end;
+	}
+
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, ep->num);
+
+	if ((ep->bEndpointAddress) & USB_DIR_IN) { /* tx */
+		USBC_Dev_ConfigEp_Default(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_TX);
+		USBC_INT_DisableEp(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_TX, ep->num);
+	} else { /* rx */
+		USBC_Dev_ConfigEp_Default(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_RX);
+		USBC_INT_DisableEp(g_sunxi_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_RX, ep->num);
+	}
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+end:
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DMSG_DBG_UDC("%s disabled\n", _ep->name);
+	return 0;
+}
+
+static struct usb_request *sunxi_udc_alloc_request(
+		struct usb_ep *_ep,
+		gfp_t mem_flags)
+{
+	struct sunxi_udc_request *req = NULL;
+
+	if (!_ep) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return NULL;
+	}
+
+	req = kzalloc(sizeof(struct sunxi_udc_request), mem_flags | GFP_ATOMIC);
+	if (!req) {
+		DMSG_PANIC("ERR: kzalloc failed\n");
+		return NULL;
+	}
+
+	memset(req, 0, sizeof(struct sunxi_udc_request));
+
+	req->req.dma = DMA_ADDR_INVALID;
+
+	INIT_LIST_HEAD(&req->queue);
+
+	DMSG_INFO_UDC("alloc request: ep(0x%p, %s, %d), req(0x%p)\n",
+		_ep, _ep->name, _ep->maxpacket, req);
+
+	return &req->req;
+}
+
+static void sunxi_udc_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct sunxi_udc_request	*req = NULL;
+
+	if (_ep == NULL || _req == NULL) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return;
+	}
+
+	req = to_sunxi_udc_req(_req);
+	if (req == NULL) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return;
+	}
+
+	DMSG_INFO_UDC("free request: ep(0x%p, %s, %d), req(0x%p)\n",
+		_ep, _ep->name, _ep->maxpacket, req);
+
+	kfree(req);
+}
+
+static int sunxi_udc_queue(struct usb_ep *_ep,
+		struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct sunxi_udc_request *req = NULL;
+	struct sunxi_udc_ep *ep = NULL;
+	struct sunxi_udc *dev = NULL;
+	unsigned long flags = 0;
+	u8 old_ep_index = 0;
+
+	if (_ep == NULL || _req == NULL) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	ep = to_sunxi_udc_ep(_ep);
+	if ((ep == NULL || (!ep->desc && _ep->name != ep0name))) {
+		DMSG_PANIC("ERR: sunxi_udc_queue: inval 2\n");
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DMSG_PANIC("ERR : dev->driver=0x%p, dev->gadget.speed=%x\n",
+			dev->driver, dev->gadget.speed);
+		return -ESHUTDOWN;
+	}
+
+	if (!_req->complete || !_req->buf) {
+		DMSG_PANIC("ERR: usbd_queue: _req is invalid\n");
+		return -EINVAL;
+	}
+
+	req = to_sunxi_udc_req(_req);
+	if (!req) {
+		DMSG_PANIC("ERR: req is NULL\n");
+		return -EINVAL;
+	}
+
+	sunxi_udc_handle_unaligned_buf_start(ep, req);
+	spin_lock_irqsave(&ep->dev->lock, flags);
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	if (is_sunxi_udc_dma_capable(req, ep)) {
+		spin_unlock_irqrestore(&ep->dev->lock, flags);
+		sunxi_udc_map_dma_buffer(req, dev, ep);
+		spin_lock_irqsave(&ep->dev->lock, flags);
+	}
+
+	list_add_tail(&req->queue, &ep->queue);
+
+	if (!is_peripheral_active()) {
+		DMSG_PANIC("warn: peripheral is active\n");
+		goto end;
+	}
+
+	if (g_queue_debug)
+		DMSG_INFO("q:(0x%p,%d,%d)\n", _req, _req->length, _req->actual);
+
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	if (ep->bEndpointAddress)
+		USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle,
+				ep->bEndpointAddress & 0x7F);
+	else
+		USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, 0);
+
+	/* if there is only one in the queue, then execute it */
+	if (!ep->halted && (&req->queue == ep->queue.next)) {
+		if (ep->bEndpointAddress == 0 /* ep0 */) {
+			switch (dev->ep0state) {
+			case EP0_IN_DATA_PHASE:
+				if (!USBC_Dev_IsWriteDataReady(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0)
+				    && sunxi_udc_write_fifo(ep, req)) {
+					dev->ep0state = EP0_IDLE;
+					req = NULL;
+				}
+				break;
+			case EP0_OUT_DATA_PHASE:
+				if ((!_req->length)
+				    || (USBC_Dev_IsReadDataReady(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_EP0)
+				    && sunxi_udc_read_fifo(ep, req))) {
+					dev->ep0state = EP0_IDLE;
+					req = NULL;
+				}
+				break;
+			default:
+				spin_unlock_irqrestore(&ep->dev->lock, flags);
+				return -EL2HLT;
+			}
+		} else if ((ep->bEndpointAddress & USB_DIR_IN) != 0
+				&& !USBC_Dev_IsWriteDataReady(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX)) {
+#if (IS_ENABLED(CONFIG_USB_G_WEBCAM) || IS_ENABLED(CONFIG_USB_CONFIGFS_F_UVC)) \
+	&& IS_ENABLED(CONFIG_SMP)
+			/**
+			 * not execute req when only one in the queue, otherwise
+			 * it will be deadlocked for webcam on SMP.
+			 */
+			if ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+			    == USB_ENDPOINT_XFER_ISOC) {
+				int ret = 0;
+
+				ret = USBC_Dev_WriteDataStatus(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX, 1);
+				if (ret != 0) {
+					DMSG_PANIC("ERR: USBC_Dev_WriteDataStatus, failed\n");
+					req->req.status = -EOVERFLOW;
+					USBC_SelectActiveEp(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						old_ep_index);
+					spin_unlock_irqrestore(&ep->dev->lock,
+						flags);
+					return req->req.status;
+				}
+			} else if (sunxi_udc_write_fifo(ep, req)) {
+				req = NULL;
+			}
+#else
+			if (sunxi_udc_write_fifo(ep, req))
+				req = NULL;
+#endif
+		} else if ((ep->bEndpointAddress & USB_DIR_IN) == 0
+				&& USBC_Dev_IsReadDataReady(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_RX)) {
+			if (sunxi_udc_read_fifo(ep, req))
+				req = NULL;
+		}
+	}
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+end:
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return 0;
+}
+
+static int sunxi_udc_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct sunxi_udc_ep *ep = NULL;
+	struct sunxi_udc *udc = NULL;
+	int retval = -EINVAL;
+	struct sunxi_udc_request *req = NULL;
+	unsigned long flags = 0;
+
+	DMSG_DBG_UDC("(%p,%p)\n", _ep, _req);
+
+	if (!the_controller->driver) {
+		DMSG_PANIC("ERR: sunxi_udc_dequeue: driver is null\n");
+		return -ESHUTDOWN;
+	}
+
+	if (!_ep || !_req) {
+		DMSG_PANIC("ERR: sunxi_udc_dequeue: invalid argment\n");
+		return retval;
+	}
+
+	ep = to_sunxi_udc_ep(_ep);
+	if (ep == NULL) {
+		DMSG_PANIC("ERR: ep == NULL\n");
+		return -EINVAL;
+	}
+
+	udc = to_sunxi_udc(ep->gadget);
+	if (udc == NULL) {
+		DMSG_PANIC("ERR: ep == NULL\n");
+		return -EINVAL;
+	}
+
+	DMSG_INFO_UDC("dequeue: ep(0x%p, %d), _req(0x%p, %d, %d)\n",
+		ep, ep->num,
+			_req, _req->length, _req->actual);
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req) {
+			list_del_init(&req->queue);
+			_req->status = -ECONNRESET;
+			retval = 0;
+			break;
+		}
+	}
+
+	if (retval == 0) {
+		DMSG_DBG_UDC("dequeued req %p from %s, len %d buf %p\n",
+			req, _ep->name, _req->length, _req->buf);
+
+		sunxi_udc_done(ep, req, -ECONNRESET);
+		/*
+		 * If dma is capable, we should disable the dma channel and
+		 * clean dma status, or it would cause dma hang when unexpected
+		 * abort occurs.
+		 */
+#ifdef SW_UDC_DMA_INNER
+		if (is_sunxi_udc_dma_capable(req, ep)) {
+			sunxi_udc_dma_chan_disable((dm_hdl_t)ep->dma_hdle);
+			sunxi_udc_clean_dma_status(ep);
+		}
+#endif
+	}
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return retval;
+}
+
+static int sunxi_udc_set_halt_ex(struct usb_ep *_ep, int value, int is_in)
+{
+	struct sunxi_udc_ep *ep = NULL;
+	u32 idx = 0;
+	__u8 old_ep_index = 0;
+
+	if (_ep == NULL) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	ep = to_sunxi_udc_ep(_ep);
+	if (ep == NULL) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	if (!ep->desc && ep->ep.name != ep0name) {
+		DMSG_PANIC("ERR: !ep->desc && ep->ep.name != ep0name\n");
+		return -EINVAL;
+	}
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	if (idx == 0) {
+		USBC_Dev_EpClearStall(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0);
+	} else {
+		if (is_in) {
+			if (value) {
+				USBC_Dev_EpSendStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX);
+			} else {
+				USBC_Dev_EpClearStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX);
+			}
+		} else {
+			if (value)
+				USBC_Dev_EpSendStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_RX);
+			else
+				USBC_Dev_EpClearStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_RX);
+		}
+	}
+
+	ep->halted = value ? 1 : 0;
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+	return 0;
+}
+
+static int sunxi_udc_set_halt(struct usb_ep *_ep, int value)
+{
+	struct sunxi_udc_ep	*ep = NULL;
+	unsigned long		flags = 0;
+	u32			idx = 0;
+	__u8			old_ep_index = 0;
+
+	if (_ep == NULL) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	ep = to_sunxi_udc_ep(_ep);
+	if (ep == NULL) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	if (!ep->desc && ep->ep.name != ep0name) {
+		DMSG_PANIC("ERR: !ep->desc && ep->ep.name != ep0name\n");
+		return -EINVAL;
+	}
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	old_ep_index = USBC_GetActiveEp(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, idx);
+
+	if (idx == 0) {
+		USBC_Dev_EpClearStall(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_EP0);
+	} else {
+		if ((ep->bEndpointAddress & USB_DIR_IN) != 0) {
+			if (value)
+				USBC_Dev_EpSendStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX);
+			else
+				USBC_Dev_EpClearStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX);
+		} else {
+			if (value)
+				USBC_Dev_EpSendStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_RX);
+			else
+				USBC_Dev_EpClearStall(
+						g_sunxi_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_RX);
+		}
+	}
+
+	ep->halted = value ? 1 : 0;
+
+	USBC_SelectActiveEp(g_sunxi_udc_io.usb_bsp_hdle, old_ep_index);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return 0;
+}
+
+static const struct usb_ep_ops sunxi_udc_ep_ops = {
+	.enable		= sunxi_udc_ep_enable,
+	.disable	= sunxi_udc_ep_disable,
+
+	.alloc_request	= sunxi_udc_alloc_request,
+	.free_request	= sunxi_udc_free_request,
+
+	.queue		= sunxi_udc_queue,
+	.dequeue	= sunxi_udc_dequeue,
+
+	.set_halt	= sunxi_udc_set_halt,
+};
+
+static int sunxi_udc_get_frame(struct usb_gadget *_gadget)
+{
+	int ret = 0;
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	DMSG_INFO_UDC("sunxi_udc_get_frame is no susport\n");
+
+	return ret;
+}
+
+static int sunxi_udc_wakeup(struct usb_gadget *_gadget)
+{
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	return 0;
+}
+
+static int sunxi_udc_set_selfpowered(struct usb_gadget *gadget, int value)
+{
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	return 0;
+}
+
+static void sunxi_udc_disable(struct sunxi_udc *dev);
+static void sunxi_udc_enable(struct sunxi_udc *dev);
+
+static int sunxi_udc_set_pullup(struct sunxi_udc *udc, int is_on)
+{
+	DMSG_DBG_UDC("sunxi_udc_set_pullup\n");
+
+	is_udc_enable = is_on;
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	if (is_on) {
+		sunxi_udc_enable(udc);
+	} else {
+		if (udc->gadget.speed != USB_SPEED_UNKNOWN) {
+			if (udc->driver && udc->driver->disconnect)
+				udc->driver->disconnect(&udc->gadget);
+		}
+
+		sunxi_udc_disable(udc);
+	}
+
+	return 0;
+}
+
+static int sunxi_udc_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct sunxi_udc *udc = to_sunxi_udc(gadget);
+
+	DMSG_DBG_UDC("sunxi_udc_vbus_session\n");
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	udc->vbus = (is_active != 0);
+	sunxi_udc_set_pullup(udc, is_active);
+
+	return 0;
+}
+
+static int sunxi_udc_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct sunxi_udc *udc = to_sunxi_udc(gadget);
+
+	DMSG_INFO_UDC("sunxi_udc_pullup, is_on = %d\n", is_on);
+
+	sunxi_udc_set_pullup(udc, is_on);
+	return 0;
+}
+
+static int sunxi_udc_vbus_draw(struct usb_gadget *_gadget, unsigned ma)
+{
+	if (!is_peripheral_active()) {
+		DMSG_INFO("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	DMSG_DBG_UDC("sunxi_udc_vbus_draw\n");
+
+	cfg_vbus_draw(ma);
+	return 0;
+}
+
+static int sunxi_get_udc_base(struct platform_device *pdev,
+		sunxi_udc_io_t *sunxi_udc_io)
+{
+
+	struct device_node *np = pdev->dev.of_node;
+
+	sunxi_udc_io->usb_vbase  = of_iomap(np, 0);
+	if (sunxi_udc_io->usb_vbase == NULL) {
+		dev_err(&pdev->dev, "can't get usb_vbase resource\n");
+		return -EINVAL;
+	}
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+	sunxi_udc_io->usb_common_phy_config = of_iomap(np, 2);
+	if (sunxi_udc_io->usb_common_phy_config == NULL) {
+		dev_err(&pdev->dev, "can't get common phy resource\n");
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+static int sunxi_get_udc_clock(struct platform_device *pdev,
+		sunxi_udc_io_t *sunxi_udc_io)
+{
+	sunxi_udc_io->clk_bus_otg = devm_clk_get(&pdev->dev, "bus_otg");
+	if (IS_ERR(sunxi_udc_io->clk_bus_otg)) {
+		dev_err(&pdev->dev, "Could not get bus_otg clock\n");
+		return PTR_ERR(sunxi_udc_io->clk_bus_otg);
+	}
+
+#if !defined(CONFIG_ARCH_SUN8IW20) && !defined(CONFIG_ARCH_SUN20IW1) && !defined(CONFIG_ARCH_SUN50IW12)
+	sunxi_udc_io->clk_phy = devm_clk_get(&pdev->dev, "phy");
+	if (IS_ERR(sunxi_udc_io->clk_phy)) {
+		dev_err(&pdev->dev, "Could not get phy clock\n");
+		return PTR_ERR(sunxi_udc_io->clk_phy);
+	}
+#endif
+
+	sunxi_udc_io->reset_otg = devm_reset_control_get(&pdev->dev, "otg");
+	if (IS_ERR(sunxi_udc_io->reset_otg))
+		dev_warn(&pdev->dev, "Could not get otg rst\n");
+
+	sunxi_udc_io->reset_phy = devm_reset_control_get_optional_shared(&pdev->dev, "phy");
+	if (IS_ERR(sunxi_udc_io->reset_phy))
+		dev_warn(&pdev->dev, "Could not get phy rst\n");
+
+	return 0;
+}
+
+/* gadget driver handling */
+static void sunxi_udc_reinit(struct sunxi_udc *dev)
+{
+	u32 i = 0;
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = EP0_IDLE;
+
+	for (i = 0; i < SW_UDC_ENDPOINTS; i++) {
+		struct sunxi_udc_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->dev	 = dev;
+		ep->desc = NULL;
+		ep->halted  = 0;
+		INIT_LIST_HEAD(&ep->queue);
+	}
+}
+
+static void sunxi_udc_enable(struct sunxi_udc *dev)
+{
+	int ret;
+
+	DMSG_DBG_UDC("sunxi_udc_enable called\n");
+
+	if (!IS_ERR_OR_NULL(dev->udc_regulator)) {
+		ret = regulator_enable(dev->udc_regulator);
+		if (ret)
+			DMSG_PANIC("ERR:udc regulator enable failed\n");
+	}
+
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	DMSG_INFO_UDC("CONFIG_USB_GADGET_DUALSPEED: USBC_TS_MODE_HS\n");
+
+	USBC_Dev_ConfigTransferMode(
+				g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_TS_TYPE_BULK,
+				USBC_TS_MODE_HS);
+
+	/* Enable reset and suspend interrupt interrupts */
+	USBC_INT_EnableUsbMiscUint(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_INTUSB_SUSPEND);
+	USBC_INT_EnableUsbMiscUint(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_INTUSB_RESUME);
+	USBC_INT_EnableUsbMiscUint(g_sunxi_udc_io.usb_bsp_hdle,
+				USBC_INTUSB_RESET);
+
+	/* Enable ep0 interrupt */
+	USBC_INT_EnableEp(g_sunxi_udc_io.usb_bsp_hdle,
+			USBC_EP_TYPE_TX, 0);
+
+	cfg_udc_command(SW_UDC_P_ENABLE);
+}
+
+static void sunxi_udc_disable(struct sunxi_udc *dev)
+{
+	DMSG_DBG_UDC("sunxi_udc_disable\n");
+	/* Disable all interrupts */
+	USBC_INT_DisableUsbMiscAll(g_sunxi_udc_io.usb_bsp_hdle);
+	USBC_INT_DisableEpAll(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+	USBC_INT_DisableEpAll(g_sunxi_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+
+	/* Clear the interrupt registers */
+	clear_all_irq();
+	cfg_udc_command(SW_UDC_P_DISABLE);
+
+	/* Set speed to unknown */
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	if (!IS_ERR_OR_NULL(dev->udc_regulator))
+		regulator_disable(dev->udc_regulator);
+}
+
+static s32  usbd_start_work(void)
+{
+	DMSG_INFO_UDC("usbd_start_work\n");
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	USBC_Dev_ConectSwitch(g_sunxi_udc_io.usb_bsp_hdle,
+			USBC_DEVICE_SWITCH_ON);
+	return 0;
+}
+
+static s32  usbd_stop_work(void)
+{
+	DMSG_INFO_UDC("usbd_stop_work\n");
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO_UDC("%s_%d: usb device is not active\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	USBC_Dev_ConectSwitch(g_sunxi_udc_io.usb_bsp_hdle,
+			USBC_DEVICE_SWITCH_OFF); /* default is pulldown */
+	return 0;
+}
+
+static int sunxi_udc_start(struct usb_gadget *g,
+		struct usb_gadget_driver *driver)
+{
+	struct sunxi_udc *udc = the_controller;
+
+	/* Sanity checks */
+	if (!udc) {
+		DMSG_PANIC("ERR: udc is null\n");
+		return -ENODEV;
+	}
+
+	if (udc->driver) {
+		DMSG_PANIC("ERR: udc->driver is not null\n");
+		return -EBUSY;
+	}
+
+	/**
+	 * the struct usb_gadget_driver has a little change
+	 * between linux 3.0 and linux-3.3, speed->max_speed
+	 */
+	if (!driver->setup || driver->max_speed < USB_SPEED_FULL) {
+		DMSG_PANIC("ERR: Invalid setup %p speed %d\n",
+			driver->setup, driver->max_speed);
+		return -EINVAL;
+	}
+
+#if defined(MODULE)
+	if (!driver->unbind) {
+		DMSG_PANIC("Invalid driver: no unbind method\n");
+		return -EINVAL;
+	}
+#endif
+
+	/* Hook the driver */
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+
+	DMSG_INFO_UDC("[%s]: binding gadget driver '%s'\n",
+		gadget_name, driver->driver.name);
+
+	return 0;
+}
+
+static int sunxi_udc_stop(struct usb_gadget *g)
+{
+	struct sunxi_udc *udc = the_controller;
+	struct usb_gadget_driver *driver;
+
+	if (!udc) {
+		DMSG_PANIC("ERR: udc is null\n");
+		return -ENODEV;
+	}
+	driver = udc->driver;
+	if (!driver || driver != udc->driver || !driver->unbind) {
+		DMSG_PANIC("ERR: driver is null\n");
+		return -EINVAL;
+	}
+
+	DMSG_INFO_UDC("[%s]: usb_gadget_unregister_driver() '%s'\n",
+		gadget_name, driver->driver.name);
+
+	udc->gadget.dev.driver = NULL;
+	udc->driver = NULL;
+
+	/* Disable udc */
+	sunxi_udc_disable(udc);
+	return 0;
+}
+
+static const struct usb_gadget_ops sunxi_udc_ops = {
+	.get_frame		= sunxi_udc_get_frame,
+	.wakeup			= sunxi_udc_wakeup,
+	.set_selfpowered	= sunxi_udc_set_selfpowered,
+	.pullup			= sunxi_udc_pullup,
+	.vbus_session		= sunxi_udc_vbus_session,
+	.vbus_draw		= sunxi_udc_vbus_draw,
+	.udc_start		= sunxi_udc_start,
+	.udc_stop		= sunxi_udc_stop,
+};
+
+static struct sunxi_udc sunxi_udc = {
+	.gadget = {
+		.ops		= &sunxi_udc_ops,
+		.ep0		= &sunxi_udc.ep[0].ep,
+		.name		= gadget_name,
+		.dev = {
+			.init_name	= "gadget",
+		},
+	},
+
+	.ep[0] = {
+		.num			= 0,
+		.ep = {
+			.name		= ep0name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= EP0_FIFO_SIZE,
+			.maxpacket_limit = EP0_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL,
+				USB_EP_CAPS_DIR_ALL),
+		},
+		.dev			= &sunxi_udc,
+	},
+
+	.ep[1] = {
+		.num			= 1,
+		.ep = {
+			.name		= ep1in_bulk_name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+			.maxpacket_limit = SW_UDC_EP_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,
+					USB_EP_CAPS_DIR_IN),
+		},
+		.dev		        = &sunxi_udc,
+		.bEndpointAddress   = (USB_DIR_IN | 1),
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[2] = {
+		.num			= 1,
+		.ep = {
+			.name		= ep1out_bulk_name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+			.maxpacket_limit = SW_UDC_EP_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,
+					USB_EP_CAPS_DIR_OUT),
+		},
+		.dev		        = &sunxi_udc,
+		.bEndpointAddress   = (USB_DIR_OUT | 1),
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[3] = {
+		.num			= 2,
+		.ep = {
+			.name		= ep2in_bulk_name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+			.maxpacket_limit = SW_UDC_EP_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,
+					USB_EP_CAPS_DIR_IN),
+		},
+		.dev		        = &sunxi_udc,
+		.bEndpointAddress   = (USB_DIR_IN | 2),
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[4] = {
+		.num			= 2,
+		.ep = {
+			.name		= ep2out_bulk_name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+			.maxpacket_limit = SW_UDC_EP_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,
+					USB_EP_CAPS_DIR_OUT),
+		},
+		.dev		        = &sunxi_udc,
+		.bEndpointAddress   = (USB_DIR_OUT | 2),
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[5] = {
+		.num			= 3,
+		.ep = {
+			.name		= ep3_iso_name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_ISO_FIFO_SIZE,
+			.maxpacket_limit = SW_UDC_EP_ISO_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,
+					USB_EP_CAPS_DIR_ALL),
+		},
+		.dev		        = &sunxi_udc,
+		.bEndpointAddress   = 3,
+		.bmAttributes	    = USB_ENDPOINT_XFER_ISOC,
+	},
+
+	.ep[6] = {
+		.num			= 4,
+		.ep = {
+			.name		= ep4_int_name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+			.maxpacket_limit = SW_UDC_EP_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,
+					USB_EP_CAPS_DIR_ALL),
+		},
+		.dev		        = &sunxi_udc,
+		.bEndpointAddress   = 4,
+		.bmAttributes	    = USB_ENDPOINT_XFER_INT,
+	},
+
+#if defined(CONFIG_ARCH_SUN50IW1) || defined(CONFIG_ARCH_SUN50IW3) \
+	|| defined(CONFIG_ARCH_SUN8IW6) || defined(CONFIG_ARCH_SUN8IW15) \
+	|| defined(CONFIG_ARCH_SUN50IW10) || defined(CONFIG_ARCH_SUN50IW9) \
+	|| defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+	.ep[7] = {
+		.num			= 5,
+		.ep = {
+			.name		= ep5in_bulk_name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+			.maxpacket_limit = SW_UDC_EP_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,
+					USB_EP_CAPS_DIR_IN),
+		},
+		.dev		        = &sunxi_udc,
+		.bEndpointAddress   = (USB_DIR_IN | 5),
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[8] = {
+		.num			= 5,
+		.ep = {
+			.name		= ep5out_bulk_name,
+			.ops		= &sunxi_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+			.maxpacket_limit = SW_UDC_EP_FIFO_SIZE,
+			.caps	= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,
+					USB_EP_CAPS_DIR_OUT),
+		},
+		.dev		        = &sunxi_udc,
+		.bEndpointAddress   = (USB_DIR_OUT | 5),
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+#endif
+
+};
+
+static void sunxi_vbus_det_work(struct work_struct *work)
+{
+	struct sunxi_udc *udc = NULL;
+#if defined(CONFIG_POWER_SUPPLY)
+	struct power_supply *psy = NULL;
+	union power_supply_propval temp;
+#endif
+
+	/* wait for axp vbus detect ready */
+	msleep(100);
+
+	udc = container_of(work, struct sunxi_udc, vbus_det_work);
+
+#if defined(CONFIG_POWER_SUPPLY)
+	if (of_find_property(g_udc_pdev->dev.of_node, "det_vbus_supply", NULL))
+		psy = devm_power_supply_get_by_phandle(&g_udc_pdev->dev,
+						     "det_vbus_supply");
+
+	if (!psy || IS_ERR(psy)) {
+		DMSG_PANIC("%s()%d WARN: get power supply failed\n",
+			   __func__, __LINE__);
+	} else {
+		power_supply_get_property(psy,
+					POWER_SUPPLY_PROP_ONLINE, &temp);
+
+		while (temp.intval) {
+			msleep(1000);
+
+			/* after resume */
+			if (usb_connect)
+				return;
+		}
+	}
+#endif
+	if (udc->driver && udc->driver->disconnect)
+		udc->driver->disconnect(&udc->gadget);
+}
+
+void __iomem *get_otgc_vbase(void)
+{
+	return  g_sunxi_udc_io.usb_vbase;
+
+}
+EXPORT_SYMBOL_GPL(get_otgc_vbase);
+
+int get_dp_dm_status_normal(void)
+{
+	__u32 reg_val = 0;
+	__u32 dp = 0;
+	__u32 dm = 0;
+
+	if (g_sunxi_udc_io.usb_vbase == NULL)
+		return 0;
+	/* USBC_EnableDpDmPullUp */
+	reg_val = USBC_Readl(USBC_REG_ISCR(g_sunxi_udc_io.usb_vbase));
+	reg_val |= (1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
+	USBC_Writel(reg_val, USBC_REG_ISCR(g_sunxi_udc_io.usb_vbase));
+
+	/* USBC_EnableIdPullUp */
+	reg_val = USBC_Readl(USBC_REG_ISCR(g_sunxi_udc_io.usb_vbase));
+	reg_val |= (1 << USBC_BP_ISCR_ID_PULLUP_EN);
+	USBC_Writel(reg_val, USBC_REG_ISCR(g_sunxi_udc_io.usb_vbase));
+
+	msleep(20);
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(g_sunxi_udc_io.usb_vbase));
+	dp = (reg_val >> USBC_BP_ISCR_EXT_DP_STATUS) & 0x01;
+	dm = (reg_val >> USBC_BP_ISCR_EXT_DM_STATUS) & 0x01;
+
+	return ((dp << 1) | dm);
+}
+EXPORT_SYMBOL_GPL(get_dp_dm_status_normal);
+static int sunxi_get_udc_resource(struct platform_device *pdev,
+		sunxi_udc_io_t *sunxi_udc_io);
+
+int sunxi_usb_device_enable(void)
+{
+	struct platform_device *pdev	= g_udc_pdev;
+	struct sunxi_udc	*udc	= &sunxi_udc;
+	int			retval  = 0;
+#if defined(CONFIG_ARCH_SUN50IW10)
+	int val;
+#endif
+
+	DMSG_INFO_UDC("sunxi_usb_device_enable start\n");
+
+	if (pdev == NULL) {
+		DMSG_PANIC("pdev is null\n");
+		return -1;
+	}
+
+	usb_connect	= 0;
+	crq_bRequest	= 0;
+	is_controller_alive = 1;
+
+#if defined(CONFIG_ARCH_SUN8IW6)
+	retval = sunxi_get_udc_resource(pdev, &g_sunxi_udc_io);
+	if (retval != 0) {
+		DMSG_PANIC("ERR: sunxi_get_udc_resource, is fail\n");
+		return -ENODEV;
+	}
+
+	retval = sunxi_udc_io_init(usbd_port_no, &g_sunxi_udc_io);
+	if (retval != 0) {
+		DMSG_PANIC("ERR: sunxi_udc_io_init fail\n");
+		return -1;
+	}
+#endif
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+	/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+	val = USBC_Readl(g_sunxi_udc_io.usb_common_phy_config + SUNXI_HCI_PHY_CTRL);
+	val &= ~(0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+	USBC_Writel(val, g_sunxi_udc_io.usb_common_phy_config + SUNXI_HCI_PHY_CTRL);
+#endif
+
+	retval = sunxi_udc_bsp_init(&g_sunxi_udc_io);
+	if (retval != 0) {
+		DMSG_PANIC("ERR: sunxi_udc_bsp_init failed\n");
+		return -1;
+	}
+
+	sunxi_udc_disable(udc);
+
+	udc->irq_no = platform_get_irq(pdev, 0);
+
+	if (udc->irq_no < 0) {
+		DMSG_PANIC("%s,%d: error to get irq\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	udc->sunxi_udc_io = &g_sunxi_udc_io;
+	udc->usbc_no = usbd_port_no;
+	strcpy((char *)udc->driver_name, gadget_name);
+	udc->pdev	= pdev;
+	udc->controller = &(pdev->dev);
+
+#if IS_ENABLED(CONFIG_OF)
+	udc->controller->dma_mask = &sunxi_udc_mask;
+	udc->controller->coherent_dma_mask = DMA_BIT_MASK(64);
+#endif
+
+	if (is_udc_support_dma()) {
+		retval = sunxi_udc_dma_probe(udc);
+		if (retval != 0) {
+			DMSG_PANIC("ERR: sunxi_udc_dma_probe failef\n");
+			retval = -EBUSY;
+			goto err;
+		}
+	}
+
+
+	if (first_enable) {
+		first_enable = 0;
+		INIT_WORK(&udc->vbus_det_work, sunxi_vbus_det_work);
+#if !defined(SUNXI_USB_FPGA) && defined(CONFIG_POWER_SUPPLY)
+		INIT_WORK(&udc->set_cur_vol_work, sunxi_set_cur_vol_work);
+#endif
+		udc->udc_regulator = devm_regulator_get(&(pdev->dev), "udc");
+
+		if (!IS_ERR_OR_NULL(udc->udc_regulator)) {
+			retval = regulator_enable(udc->udc_regulator);
+			if (retval)
+				DMSG_PANIC("ERR:udc regulator enable failed\n");
+		}
+	}
+
+	retval = request_irq(udc->irq_no, sunxi_udc_irq,
+			0, gadget_name, udc);
+	if (retval != 0) {
+		DMSG_PANIC("ERR: cannot get irq %i, err %d\n",
+			udc->irq_no, retval);
+		retval = -EBUSY;
+		goto err;
+	}
+
+	if (udc->driver && is_udc_enable) {
+		sunxi_udc_enable(udc);
+		cfg_udc_command(SW_UDC_P_ENABLE);
+	}
+
+	DMSG_INFO_UDC("sunxi_usb_device_enable end\n");
+
+	return 0;
+err:
+	if (is_udc_support_dma())
+		sunxi_udc_dma_remove(udc);
+
+	sunxi_udc_bsp_exit(&g_sunxi_udc_io);
+#if defined(CONFIG_ARCH_SUN8IW6)
+	sunxi_udc_io_exit(&g_sunxi_udc_io);
+#endif
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(sunxi_usb_device_enable);
+
+int sunxi_usb_device_disable(void)
+__releases(sunxi_udc.lock)
+__acquires(sunxi_udc.lock)
+{
+	struct platform_device *pdev = g_udc_pdev;
+	struct sunxi_udc *udc = NULL;
+	unsigned long	flags = 0;
+
+	DMSG_INFO_UDC("sunxi_usb_device_disable start\n");
+
+	if (pdev == NULL) {
+		DMSG_PANIC("pdev is null\n");
+		return -1;
+	}
+
+	udc = platform_get_drvdata(pdev);
+	if (udc == NULL) {
+		DMSG_PANIC("udc is null\n");
+		return -1;
+	}
+
+	/* disable usb controller */
+	if (udc->driver && udc->driver->disconnect)
+		udc->driver->disconnect(&udc->gadget);
+
+	if (is_udc_support_dma()) {
+		spin_lock_irqsave(&udc->lock, flags);
+		sunxi_udc_stop_dma_work(udc, 0);
+		spin_unlock_irqrestore(&udc->lock, flags);
+		sunxi_udc_dma_remove(udc);
+	}
+
+	free_irq(udc->irq_no, udc);
+
+	sunxi_udc_bsp_exit(&g_sunxi_udc_io);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	usb_connect	= 0;
+	if (!charger_mode) {
+		__pm_relax(udc->ws);
+		pr_debug("usb_connecting: release wake lock\n");
+	}
+
+	crq_bRequest   = 0;
+	is_controller_alive = 0;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	DMSG_INFO_UDC("sunxi_usb_device_disable end\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_usb_device_disable);
+
+int sunxi_udc_is_enable(struct platform_device *pdev)
+{
+	struct device_node *usbc_np = NULL;
+	int ret = 0;
+	int is_enable = 0;
+
+	const char  *used_status;
+
+	usbc_np = of_find_node_by_type(NULL, SET_USB0);
+	ret = of_property_read_string(usbc_np, "status", &used_status);
+	if (ret) {
+		DMSG_PANIC("get sunxi_udc_is_enable is fail, %d\n", -ret);
+		is_enable = 0;
+	} else if (!strcmp(used_status, "okay")) {
+		is_enable = 1;
+	} else {
+		is_enable = 0;
+	}
+
+	return is_enable;
+}
+
+static int sunxi_get_udc_resource(struct platform_device *pdev,
+		sunxi_udc_io_t *sunxi_udc_io)
+{
+	int retval = 0;
+
+	memset(&g_sunxi_udc_io, 0, sizeof(sunxi_udc_io_t));
+
+	retval = sunxi_get_udc_base(pdev, sunxi_udc_io);
+	if (retval != 0) {
+		dev_err(&pdev->dev, "can't get udc base\n");
+		goto err0;
+	}
+
+	retval = sunxi_get_udc_clock(pdev, sunxi_udc_io);
+	if (retval != 0) {
+		dev_err(&pdev->dev, "can't get udc clock\n");
+		goto err0;
+	}
+
+	charger_mode = of_property_read_bool(pdev->dev.of_node, "charger_mode");
+
+	return 0;
+err0:
+	return retval;
+
+}
+
+static ssize_t
+udc_reg_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	struct resource res;
+
+	of_address_to_resource(sunxi_udc.pdev->dev.of_node, 0, &res);
+	DMSG_INFO("usbc%d, udc, base[0x%08x]:\n",
+		  0, (unsigned int)res.start);
+	print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+		       g_sunxi_udc_io.usb_vbase, 0x98, false);
+
+	DMSG_INFO("usbc%d, udc phy, base[0x%08x]:\n",
+		  0, (unsigned int)(res.start + SUNXI_UDC_TEST_PACKET));
+	print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 4, 4,
+		       (g_sunxi_udc_io.usb_vbase + SUNXI_UDC_TEST_PACKET), 0x200, false);
+	DMSG_INFO("\n");
+
+	return 0;
+}
+
+static ssize_t
+udc_reg_store(struct class *class, struct class_attribute *attr, const char *buf, size_t size)
+{
+	return 0;
+}
+static CLASS_ATTR_RW(udc_reg);
+
+static struct attribute *udc_reg_class_attrs[] = {
+	&class_attr_udc_reg.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(udc_reg_class);
+
+static struct class udc_reg_class = {
+	.name		= "udc_reg",
+	.owner		= THIS_MODULE,
+	.class_groups	= udc_reg_class_groups,
+};
+
+static const struct of_device_id sunxi_udc_match[] = {
+	{.compatible = "allwinner,sunxi-udc", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_udc_match);
+
+static int sunxi_udc_probe_otg(struct platform_device *pdev)
+{
+	struct sunxi_udc *udc = &sunxi_udc;
+	int retval = 0;
+
+	g_udc_pdev = pdev;
+
+	spin_lock_init(&udc->lock);
+
+	if (!sunxi_udc_is_enable(pdev)) {
+		DMSG_INFO("sunxi udc is no enable\n");
+		return -ENODEV;
+	}
+
+	udc->gadget.dev.parent = &pdev->dev;
+
+#if IS_ENABLED(CONFIG_OF)
+	udc->gadget.dev.dma_mask = &sunxi_udc_mask;
+	udc->gadget.dev.coherent_dma_mask = DMA_BIT_MASK(64);
+#endif
+	retval = sunxi_get_udc_resource(pdev, &g_sunxi_udc_io);
+	if (retval != 0) {
+		DMSG_PANIC("ERR: sunxi_get_udc_resource, is fail\n");
+		return -ENODEV;
+	}
+
+	sunxi_udc_io_init(usbd_port_no, &g_sunxi_udc_io);
+
+	sunxi_udc_reinit(udc);
+
+	the_controller = udc;
+
+	platform_set_drvdata(pdev, udc);
+
+	retval = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
+	if (retval != 0) {
+		dev_err(&pdev->dev, "can't usb_add_gadget_udc\n");
+		return retval;
+	}
+
+	udc->gadget.max_speed = USB_SPEED_HIGH;
+
+	retval = class_register(&udc_reg_class);
+	if (retval) {
+		dev_err(&pdev->dev, "register class fialed\n");
+		return retval ;
+	}
+
+	device_create_file(&pdev->dev, &dev_attr_otg_ed_test);
+	device_create_file(&pdev->dev, &dev_attr_otg_phy_range);
+	device_create_file(&pdev->dev, &dev_attr_queue_debug);
+	device_create_file(&pdev->dev, &dev_attr_dma_debug);
+	device_create_file(&pdev->dev, &dev_attr_write_debug);
+	device_create_file(&pdev->dev, &dev_attr_read_debug);
+	device_create_file(&pdev->dev, &dev_attr_irq_debug);
+	device_create_file(&pdev->dev, &dev_attr_msc_read_debug);
+	device_create_file(&pdev->dev, &dev_attr_msc_write_debug);
+
+#if !IS_ENABLED(CONFIG_USB_SUNXI_USB_MANAGER)
+	sunxi_usb_device_enable();
+#endif
+	pr_debug("usb_connecting: init wake lock.\n");
+	if (!charger_mode) {
+		udc->ws = wakeup_source_register(&pdev->dev, "usb_connecting");
+	}
+	return 0;
+
+}
+
+static int sunxi_udc_remove_otg(struct platform_device *pdev)
+{
+	struct sunxi_udc *udc = NULL;
+
+	udc = platform_get_drvdata(pdev);
+
+#if !IS_ENABLED(CONFIG_USB_SUNXI_USB_MANAGER)
+	sunxi_usb_device_disable();
+#endif
+
+	device_remove_file(&pdev->dev, &dev_attr_otg_ed_test);
+	device_remove_file(&pdev->dev, &dev_attr_otg_phy_range);
+	device_remove_file(&pdev->dev, &dev_attr_queue_debug);
+	device_remove_file(&pdev->dev, &dev_attr_dma_debug);
+	device_remove_file(&pdev->dev, &dev_attr_write_debug);
+	device_remove_file(&pdev->dev, &dev_attr_read_debug);
+	device_remove_file(&pdev->dev, &dev_attr_irq_debug);
+	device_remove_file(&pdev->dev, &dev_attr_msc_read_debug);
+	device_remove_file(&pdev->dev, &dev_attr_msc_write_debug);
+
+	if (!charger_mode)
+		wakeup_source_unregister(udc->ws);
+
+	class_unregister(&udc_reg_class);
+
+	g_udc_pdev = NULL;
+
+	usb_del_gadget_udc(&udc->gadget);
+
+	sunxi_udc_io_exit(&g_sunxi_udc_io);
+	memset(&g_sunxi_udc_io, 0, sizeof(sunxi_udc_io_t));
+
+	return 0;
+}
+
+static int sunxi_udc_probe(struct platform_device *pdev)
+{
+	return sunxi_udc_probe_otg(pdev);
+}
+
+static int sunxi_udc_remove(struct platform_device *pdev)
+{
+	return sunxi_udc_remove_otg(pdev);
+}
+
+#if IS_ENABLED(CONFIG_PM)
+static int sunxi_udc_suspend(struct device *dev)
+{
+	struct sunxi_udc *udc = the_controller;
+
+	DMSG_INFO_UDC("sunxi_udc_suspend start\n");
+
+	if (udc == NULL) {
+		DMSG_INFO_UDC("udc is NULL, need not enter to suspend\n");
+		return 0;
+	}
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO("udc is disable, need not enter to suspend\n");
+		return 0;
+	}
+
+	/* soft disconnect */
+	cfg_udc_command(SW_UDC_P_DISABLE);
+
+	/* disable usb controller */
+	sunxi_udc_disable(udc);
+
+	/* close USB clock */
+	close_usb_clock(&g_sunxi_udc_io);
+
+	DMSG_INFO_UDC("sunxi_udc_suspend end\n");
+	return 0;
+}
+
+static int sunxi_udc_resume(struct device *dev)
+{
+	struct sunxi_udc *udc = the_controller;
+#if defined(CONFIG_ARCH_SUN50IW10)
+	int val;
+#endif
+
+	DMSG_INFO_UDC("sunxi_udc_resume start\n");
+
+	if (udc == NULL) {
+		DMSG_INFO_UDC("udc is NULL, need not enter to suspend\n");
+		return 0;
+	}
+
+	if (!is_peripheral_active()) {
+		DMSG_INFO("udc is disable, need not enter to resume\n");
+		return 0;
+	}
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+	/*phy reg, offset:0x10 bit3 set 0, enable siddq*/
+	val = USBC_Readl(g_sunxi_udc_io.usb_common_phy_config + SUNXI_HCI_PHY_CTRL);
+	val &= ~(0x1 << SUNXI_HCI_PHY_CTRL_SIDDQ);
+	USBC_Writel(val, g_sunxi_udc_io.usb_common_phy_config + SUNXI_HCI_PHY_CTRL);
+#endif
+
+	sunxi_udc_bsp_init(&g_sunxi_udc_io);
+	if (is_udc_enable) {
+
+		if (udc->driver && udc->driver->disconnect)
+			udc->driver->disconnect(&udc->gadget);
+
+		/* enable usb controller */
+		sunxi_udc_enable(udc);
+
+		/* soft connect */
+		cfg_udc_command(SW_UDC_P_ENABLE);
+	}
+
+	DMSG_INFO_UDC("sunxi_udc_resume end\n");
+	return 0;
+}
+static const struct dev_pm_ops sunxi_udc_pm_ops = {
+	.suspend = sunxi_udc_suspend,
+	.resume = sunxi_udc_resume,
+};
+
+#define UDC_PM_OPS        (&sunxi_udc_pm_ops)
+
+#else /* !CONFIG_PM */
+
+#define UDC_PM_OPS        NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver sunxi_udc_driver = {
+	.driver		= {
+		.name	= (char *)gadget_name,
+		.pm     = UDC_PM_OPS,
+		.bus	= &platform_bus_type,
+		.owner	= THIS_MODULE,
+		.of_match_table = sunxi_udc_match,
+	},
+
+	.probe		= sunxi_udc_probe,
+	.remove		= sunxi_udc_remove,
+};
+
+static void cfg_udc_command(enum sunxi_udc_cmd_e cmd)
+{
+	struct sunxi_udc *udc = the_controller;
+
+	switch (cmd) {
+	case SW_UDC_P_ENABLE:
+		{
+			if (udc->driver)
+				usbd_start_work();
+			else
+				DMSG_INFO_UDC("udc->driver is null, ");
+				DMSG_INFO_UDC("udc is need not start\n");
+		}
+		break;
+	case SW_UDC_P_DISABLE:
+		{
+			if (udc->driver)
+				usbd_stop_work();
+			else
+				DMSG_INFO_UDC("udc->driver is null, ");
+				DMSG_INFO_UDC("udc is need not stop\n");
+		}
+		break;
+	case SW_UDC_P_RESET:
+		DMSG_PANIC("ERR: reset is not support\n");
+		break;
+	default:
+		DMSG_PANIC("ERR: unknown cmd(%d)\n", cmd);
+		break;
+	}
+}
+
+static void cfg_vbus_draw(unsigned int ma)
+{
+}
+
+static int udc_init(void)
+{
+	int retval = 0;
+	usb_connect = 0;
+
+	/* driver register */
+	retval = platform_driver_register(&sunxi_udc_driver);
+	if (retval) {
+		DMSG_PANIC("ERR: platform_driver_register failed\n");
+		retval = -1;
+		goto err;
+	}
+
+	return 0;
+
+err:
+	return retval;
+}
+
+static void  udc_exit(void)
+{
+	platform_driver_unregister(&sunxi_udc_driver);
+}
+
+fs_initcall(udc_init);
+module_exit(udc_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION("1.0.13");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:softwinner-usbgadget");
diff --git a/drivers/usb/sunxi_usb/udc/sunxi_udc_board.c b/drivers/usb/sunxi_usb/udc/sunxi_udc_board.c
new file mode 100644
index 000000000..6d0cab8a4
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sunxi_udc_board.c
@@ -0,0 +1,255 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sunxi_udc_board.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * usb board config.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/io.h>
+#include  "sunxi_udc_config.h"
+#include  "sunxi_udc_board.h"
+
+#define res_size(_r) (((_r)->end - (_r)->start) + 1)
+
+u32  open_usb_clock(sunxi_udc_io_t *sunxi_udc_io)
+{
+	int ret;
+
+	DMSG_INFO_UDC("open_usb_clock\n");
+
+	/* To fix hardware design issue. */
+#if defined(CONFIG_ARCH_SUN8IW12) || defined(CONFIG_ARCH_SUN50IW3) \
+	|| defined(CONFIG_ARCH_SUN50IW6) || defined(CONFIG_ARCH_SUN8IW15) \
+	|| defined(CONFIG_ARCH_SUN8IW18)
+	usb_otg_phy_txtune(sunxi_udc_io->usb_vbase);
+#endif
+
+	if (!sunxi_udc_io->clk_is_open) {
+		if (sunxi_udc_io->reset_phy) {
+			ret = reset_control_deassert(sunxi_udc_io->reset_phy);
+			if (ret) {
+				DMSG_PANIC("[udc]: reset phy err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (sunxi_udc_io->reset_otg) {
+			ret = reset_control_deassert(sunxi_udc_io->reset_otg);
+			if (ret) {
+				DMSG_PANIC("[udc]: reset otg err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (sunxi_udc_io->clk_bus_otg) {
+			ret = clk_prepare_enable(sunxi_udc_io->clk_bus_otg);
+			if (ret) {
+				DMSG_PANIC("[udc]: enable clk_bus_otg err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+			udelay(10);
+
+		if (sunxi_udc_io->clk_phy) {
+			ret = clk_prepare_enable(sunxi_udc_io->clk_phy);
+			if (ret) {
+				DMSG_PANIC("[udc]: enable clk_phy err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		udelay(10);
+
+		sunxi_udc_io->clk_is_open = 1;
+	}
+
+#if defined(CONFIG_ARCH_SUN50IW10) || defined(CONFIG_ARCH_SUN50IW11)\
+	|| defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)\
+	|| defined(CONFIG_ARCH_SUN5OIW12)
+	USBC_PHY_Clear_Ctl(sunxi_udc_io->usb_vbase, USBC_PHY_CTL_LOOPBACKENB);
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW12) || defined(CONFIG_ARCH_SUN50IW3) \
+	|| defined(CONFIG_ARCH_SUN8IW6) || defined(CONFIG_ARCH_SUN50IW6) \
+	|| defined(CONFIG_ARCH_SUN8IW15) || defined(CONFIG_ARCH_SUN50IW8) \
+	|| defined(CONFIG_ARCH_SUN8IW18) || defined(CONFIG_ARCH_SUN8IW16) \
+	|| defined(CONFIG_ARCH_SUN50IW9) || defined(CONFIG_ARCH_SUN50IW10) \
+	|| defined(CONFIG_ARCH_SUN8IW19) || defined(CONFIG_ARCH_SUN50IW11) \
+	|| defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1) \
+	|| defined(CONFIG_ARCH_SUN50IW12)
+	USBC_PHY_Set_Ctl(sunxi_udc_io->usb_vbase, USBC_PHY_CTL_VBUSVLDEXT);
+	USBC_PHY_Clear_Ctl(sunxi_udc_io->usb_vbase, USBC_PHY_CTL_SIDDQ);
+#else
+	UsbPhyInit(0);
+#endif
+
+#if defined(CONFIG_ARCH_SUN50I) || defined(CONFIG_ARCH_SUN8IW10) \
+	|| defined(CONFIG_ARCH_SUN8IW11) || defined(CONFIG_ARCH_SUN8IW12) \
+	|| defined(CONFIG_ARCH_SUN8IW15) || defined(CONFIG_ARCH_SUN8IW7) \
+	|| defined(CONFIG_ARCH_SUN8IW17) || defined(CONFIG_ARCH_SUN8IW18) \
+	|| defined(CONFIG_ARCH_SUN8IW16) || defined(CONFIG_ARCH_SUN8IW19) \
+	|| defined(CONFIG_ARCH_SUN8IW8) || defined(CONFIG_ARCH_SUN8IW20)\
+	|| defined(CONFIG_ARCH_SUN20IW1) || defined(CONFIG_ARCH_SUN50IW12)
+	/* otg and hci0 Controller Shared phy in SUN50I and SUN8IW10 */
+	USBC_SelectPhyToDevice(sunxi_udc_io->usb_vbase);
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+	usbc_new_phy_init(sunxi_udc_io->usb_vbase);
+#endif
+
+	return 0;
+}
+
+u32 close_usb_clock(sunxi_udc_io_t *sunxi_udc_io)
+{
+	int ret;
+
+	DMSG_INFO_UDC("close_usb_clock\n");
+
+	if (sunxi_udc_io->clk_is_open) {
+		sunxi_udc_io->clk_is_open = 0;
+
+		if (sunxi_udc_io->clk_phy) {
+			ret = clk_prepare_enable(sunxi_udc_io->clk_phy);
+			if (ret) {
+				DMSG_PANIC("[udc]: enable clk_phy err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (sunxi_udc_io->clk_bus_otg) {
+			ret = clk_prepare_enable(sunxi_udc_io->clk_bus_otg);
+			if (ret) {
+				DMSG_PANIC("[udc]: enable clk_bus_otg err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (sunxi_udc_io->reset_otg) {
+			ret = reset_control_deassert(sunxi_udc_io->reset_otg);
+			if (ret) {
+				DMSG_PANIC("[udc]: reset otg err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (sunxi_udc_io->reset_phy) {
+			ret = reset_control_deassert(sunxi_udc_io->reset_phy);
+			if (ret) {
+				DMSG_PANIC("[udc]: reset phy err, return %d\n", ret);
+				return ret;
+			}
+		}
+
+		udelay(10);
+	}
+#if defined(CONFIG_ARCH_SUN8IW12) || defined(CONFIG_ARCH_SUN50IW3) \
+	|| defined(CONFIG_ARCH_SUN8IW6) || defined(CONFIG_ARCH_SUN50IW6) \
+	|| defined(CONFIG_ARCH_SUN8IW15) || defined(CONFIG_ARCH_SUN50IW8) \
+	|| defined(CONFIG_ARCH_SUN8IW18) || defined(CONFIG_ARCH_SUN8IW16) \
+	|| defined(CONFIG_ARCH_SUN50IW9) || defined(CONFIG_ARCH_SUN50IW10) \
+	|| defined(CONFIG_ARCH_SUN8IW19) || defined(CONFIG_ARCH_SUN50IW11)\
+	|| defined(CONFIG_ARCH_SUN8IW20) || defined(CONFIG_ARCH_SUN20IW1)
+	USBC_PHY_Set_Ctl(sunxi_udc_io->usb_vbase, USBC_PHY_CTL_SIDDQ);
+#else
+	UsbPhyInit(0);
+#endif
+
+	return 0;
+}
+
+__s32 sunxi_udc_bsp_init(sunxi_udc_io_t *sunxi_udc_io)
+{
+	spinlock_t lock;
+	unsigned long flags = 0;
+
+	/* open usb lock */
+	open_usb_clock(sunxi_udc_io);
+
+#ifdef SUNXI_USB_FPGA
+	clear_usb_reg(sunxi_udc_io->usb_vbase);
+#endif
+
+	USBC_EnhanceSignal(sunxi_udc_io->usb_bsp_hdle);
+
+	USBC_EnableDpDmPullUp(sunxi_udc_io->usb_bsp_hdle);
+	USBC_EnableIdPullUp(sunxi_udc_io->usb_bsp_hdle);
+	USBC_ForceId(sunxi_udc_io->usb_bsp_hdle, USBC_ID_TYPE_DEVICE);
+	USBC_ForceVbusValid(sunxi_udc_io->usb_bsp_hdle, USBC_VBUS_TYPE_HIGH);
+
+	USBC_SelectBus(sunxi_udc_io->usb_bsp_hdle, USBC_IO_TYPE_PIO, 0, 0);
+
+	USBC_PHY_Clear_Ctl(sunxi_udc_io->usb_vbase, 1);
+
+	/* config usb fifo */
+	spin_lock_init(&lock);
+	spin_lock_irqsave(&lock, flags);
+	USBC_ConfigFIFO_Base(sunxi_udc_io->usb_bsp_hdle, USBC_FIFO_MODE_8K);
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+__s32 sunxi_udc_bsp_exit(sunxi_udc_io_t *sunxi_udc_io)
+{
+	USBC_DisableDpDmPullUp(sunxi_udc_io->usb_bsp_hdle);
+	USBC_DisableIdPullUp(sunxi_udc_io->usb_bsp_hdle);
+	USBC_ForceId(sunxi_udc_io->usb_bsp_hdle, USBC_ID_TYPE_DISABLE);
+	USBC_ForceVbusValid(sunxi_udc_io->usb_bsp_hdle, USBC_VBUS_TYPE_DISABLE);
+
+	close_usb_clock(sunxi_udc_io);
+	return 0;
+}
+
+__s32 sunxi_udc_io_init(__u32 usbc_no, sunxi_udc_io_t *sunxi_udc_io)
+{
+	sunxi_udc_io->usbc.usbc_info.num = usbc_no;
+	sunxi_udc_io->usbc.usbc_info.base = sunxi_udc_io->usb_vbase;
+	sunxi_udc_io->usbc.sram_base = sunxi_udc_io->sram_vbase;
+
+	USBC_init(&sunxi_udc_io->usbc);
+	sunxi_udc_io->usb_bsp_hdle = USBC_open_otg(usbc_no);
+	if (sunxi_udc_io->usb_bsp_hdle == 0) {
+		DMSG_PANIC("ERR: sunxi_udc_init: USBC_open_otg failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+__s32 sunxi_udc_io_exit(sunxi_udc_io_t *sunxi_udc_io)
+{
+	USBC_close_otg(sunxi_udc_io->usb_bsp_hdle);
+	sunxi_udc_io->usb_bsp_hdle = 0;
+	USBC_exit(&sunxi_udc_io->usbc);
+	sunxi_udc_io->usb_vbase  = NULL;
+	sunxi_udc_io->sram_vbase = NULL;
+
+	return 0;
+}
+
diff --git a/drivers/usb/sunxi_usb/udc/sunxi_udc_board.h b/drivers/usb/sunxi_usb/udc/sunxi_udc_board.h
new file mode 100644
index 000000000..0c3769df3
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sunxi_udc_board.h
@@ -0,0 +1,28 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sunxi_udc_board.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-12-20, create this file
+ *
+ * usb board config.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_UDC_BOARD_H__
+#define __SUNXI_UDC_BOARD_H__
+
+u32 open_usb_clock(sunxi_udc_io_t *sunxi_udc_io);
+u32 close_usb_clock(sunxi_udc_io_t *sunxi_udc_io);
+
+__s32 sunxi_udc_io_init(__u32 usbc_no, sunxi_udc_io_t *sunxi_udc_io);
+__s32 sunxi_udc_io_exit(sunxi_udc_io_t *sunxi_udc_io);
+__s32 sunxi_udc_bsp_init(sunxi_udc_io_t *sunxi_udc_io);
+__s32 sunxi_udc_bsp_exit(sunxi_udc_io_t *sunxi_udc_io);
+
+#endif /* __SUNXI_UDC_BOARD_H__ */
+
diff --git a/drivers/usb/sunxi_usb/udc/sunxi_udc_config.h b/drivers/usb/sunxi_usb/udc/sunxi_udc_config.h
new file mode 100644
index 000000000..91bcab266
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sunxi_udc_config.h
@@ -0,0 +1,56 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sunxi_udc_config.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-3-3, create this file
+ *
+ * usb udc config.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_UDC_CONFIG_H__
+#define __SUNXI_UDC_CONFIG_H__
+
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+
+#define  SW_UDC_DOUBLE_FIFO       /* double FIFO          */
+
+/**
+ * we previously deleted the "dma_flag" variable for GKI, which led to the
+ * loss of the flag that distinguishes some gadget modules to use DMA.
+ * Therefore, UDC does not provide DMA transmission.
+ */
+#define  SW_UDC_DMA
+
+/**
+ * only SUN8IW5 and later ic support inner dma,
+ * former ic(eg. SUN8IW1, SUN8IW3, SUN8IW2 etc) use outer dma.
+ */
+#ifdef SW_UDC_DMA
+#define  SW_UDC_DMA_INNER
+#endif
+
+#define  SW_UDC_HS_TO_FS          /* support HS to FS */
+#define  SW_UDC_DEBUG
+
+/* sw udc debug print */
+#if	0
+#define DMSG_DBG_UDC	DMSG_MSG
+#else
+#define DMSG_DBG_UDC(...)
+#endif
+
+#include  "../include/sunxi_usb_config.h"
+
+#endif /* __SUNXI_UDC_CONFIG_H__ */
diff --git a/drivers/usb/sunxi_usb/udc/sunxi_udc_debug.c b/drivers/usb/sunxi_usb/udc/sunxi_udc_debug.c
new file mode 100644
index 000000000..69d164244
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sunxi_udc_debug.c
@@ -0,0 +1,60 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sunxi_udc_debug.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-3-3, create this file
+ *
+ * usb udc debug.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include  "sunxi_udc_config.h"
+#include  "sunxi_udc_board.h"
+#include  "sunxi_udc_debug.h"
+
+void print_list_node(struct sunxi_udc_ep *ep, char *str)
+{
+#ifdef SW_UDC_DEBUG
+	struct sunxi_udc_request	*req = NULL;
+	spinlock_t lock;
+	unsigned long flags = 0;
+
+	spin_lock_init(&lock);
+	spin_lock_irqsave(&lock, flags);
+
+	DMSG_INFO("---------------ep%d: %s-------------\n", ep->num, str);
+	list_for_each_entry(req, &ep->queue, queue) {
+		DMSG_INFO("print_list_node: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d)\n\n",
+			ep, ep->num, req, &(req->req),
+			req->req.length, req->req.actual);
+	}
+	DMSG_INFO("-------------------------------------\n");
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return;
+#endif
+}
+
diff --git a/drivers/usb/sunxi_usb/udc/sunxi_udc_debug.h b/drivers/usb/sunxi_usb/udc/sunxi_udc_debug.h
new file mode 100644
index 000000000..ff6229263
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sunxi_udc_debug.h
@@ -0,0 +1,22 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sunxi_udc_debug.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-3-3, create this file
+ *
+ * usb udc debug.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_UDC_DEBUG_H__
+#define __SUNXI_UDC_DEBUG_H__
+
+void print_list_node(struct sunxi_udc_ep *ep, char *str);
+
+#endif /* __SUNXI_UDC_DEBUG_H__  */
+
diff --git a/drivers/usb/sunxi_usb/udc/sunxi_udc_dma.c b/drivers/usb/sunxi_usb/udc/sunxi_udc_dma.c
new file mode 100644
index 000000000..013b219e7
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sunxi_udc_dma.c
@@ -0,0 +1,622 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sunxi_udc_dma.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-3-3, create this file
+ *
+ * usb udc dma ops
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <asm/cacheflush.h>
+
+#include  "sunxi_udc_config.h"
+#include  "sunxi_udc_board.h"
+#include  "sunxi_udc_dma.h"
+
+dma_channel_t dma_chnl[DMA_CHAN_TOTAL];
+
+/* switch usb bus for dma */
+void sunxi_udc_switch_bus_to_dma(struct sunxi_udc_ep *ep, u32 is_tx)
+{
+}
+
+/* switch usb bus for pio */
+void sunxi_udc_switch_bus_to_pio(struct sunxi_udc_ep *ep, __u32 is_tx)
+{
+}
+
+/* enable dma channel irq */
+void sunxi_udc_enable_dma_channel_irq(struct sunxi_udc_ep *ep)
+{
+	DMSG_DBG_DMA("sunxi_udc_enable_dma_channel_irq\n");
+}
+
+/* disable dma channel irq */
+void sunxi_udc_disable_dma_channel_irq(struct sunxi_udc_ep *ep)
+{
+}
+
+#ifdef SW_UDC_DMA_INNER
+dm_hdl_t sunxi_udc_dma_request(void)
+{
+	int i = 0;
+	dma_channel_t *pchan = NULL;
+
+	/* get a free channel */
+	for (i = 0; i < DMA_CHAN_TOTAL; i++) {
+		pchan = &dma_chnl[i];
+		if (pchan->used == 0) {
+			pchan->used = 1;
+			pchan->channel_num = i;
+			spin_lock_init(&pchan->lock);
+			return (dm_hdl_t)pchan;
+		}
+	}
+
+	return (dm_hdl_t)NULL;
+}
+
+int sunxi_udc_dma_release(dm_hdl_t dma_hdl)
+{
+	dma_channel_t *pchan = NULL;
+	u32 reg_value = 0;
+
+	if (dma_hdl == NULL) {
+		DMSG_PANIC("ERR: sunxi_udc_dma_release failed dma_hdl is NULL\n");
+		return -1;
+	}
+
+	pchan = (dma_channel_t *)dma_hdl;
+	reg_value = USBC_Readw(USBC_REG_DMA_INTE(pchan->reg_base));
+	reg_value &= ~(1 << (pchan->channel_num & 0xff));
+	USBC_Writew(reg_value, USBC_REG_DMA_INTE(pchan->reg_base));
+
+	pchan->used = 0;
+	pchan->channel_num = 0;
+
+	return 0;
+}
+
+int sunxi_udc_dma_chan_disable(dm_hdl_t dma_hdl)
+{
+	dma_channel_t *pchan = NULL;
+	u32 reg_value = 0;
+
+	if (dma_hdl == NULL) {
+		DMSG_PANIC("[sunxi_udc_dma_chan_disable] dma_hdl is NULL\n");
+		return -1;
+	}
+
+	pchan = (dma_channel_t *)dma_hdl;
+	reg_value = USBC_Readl(USBC_REG_DMA_CHAN_CFN(pchan->reg_base,
+					pchan->channel_num));
+	reg_value &= ~(1 << 31);
+	USBC_Writel(reg_value, USBC_REG_DMA_CHAN_CFN(pchan->reg_base,
+					pchan->channel_num));
+
+	pchan->used = 0;
+	pchan->channel_num = 0;
+
+	return 0;
+}
+
+/* config dma */
+void sunxi_dma_set_config(dm_hdl_t dma_hdl, struct dma_config_t *pcfg)
+{
+	u32 reg_value = 0;
+	unsigned long flags;
+	dma_channel_t *pchan = NULL;
+
+	if (dma_hdl == NULL || pcfg == NULL) {
+		DMSG_PANIC("ERR: sunxi_dma_set_config failed dma_hdl or pcfg is NULL\n");
+		return;
+	}
+
+	pchan = (dma_channel_t *)dma_hdl;
+
+	spin_lock_irqsave(&pchan->lock, flags);
+
+	reg_value = USBC_Readl(USBC_REG_DMA_CHAN_CFN(pchan->reg_base,
+				pcfg->dma_num));
+	reg_value &= ~((1 << 4) | (0xf << 0) | (0x7ff << 16));
+
+	/* eplen */
+	reg_value |=  (((pcfg->dma_bst_len) & 0x7ff) << 16);
+
+	/* DIR */
+	reg_value |= ((pcfg->dma_dir & 1) << 4);
+
+	/* ep num */
+	reg_value |=  ((pcfg->dma_for_ep & 0xf) << 0);
+	USBC_Writel(reg_value,
+		USBC_REG_DMA_CHAN_CFN(pchan->reg_base, pcfg->dma_num));
+
+	/* address */
+	USBC_Writel(pcfg->dma_sdram_str_addr,
+		USBC_REG_DMA_SDRAM_ADD(pchan->reg_base, pcfg->dma_num));
+
+	/* transport len */
+	USBC_Writel((pcfg->dma_bc),
+		USBC_REG_DMA_BC(pchan->reg_base, pcfg->dma_num));
+
+	reg_value = USBC_Readw(USBC_REG_DMA_INTE(pchan->reg_base));
+	reg_value |= (1 << (pcfg->dma_num & 0xff));
+	USBC_Writew(reg_value, USBC_REG_DMA_INTE(pchan->reg_base));
+
+	/* start dma */
+	reg_value = USBC_Readl(USBC_REG_DMA_CHAN_CFN(pchan->reg_base,
+						pcfg->dma_num));
+	reg_value |=  (1U << 31);
+	USBC_Writel(reg_value, USBC_REG_DMA_CHAN_CFN(pchan->reg_base,
+						pcfg->dma_num));
+
+	spin_unlock_irqrestore(&pchan->lock, flags);
+}
+
+void sunxi_udc_dma_set_config(struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req, __u32 buff_addr, __u32 len)
+{
+	dm_hdl_t dma_hdl = NULL;
+	dma_channel_t *pchan = NULL;
+	__u32 is_tx = 0;
+	__u32 packet_size = 0;
+
+	struct dma_config_t DmaConfig;
+
+	memset(&DmaConfig, 0, sizeof(DmaConfig));
+
+	is_tx = is_tx_ep(ep);
+	packet_size = ep->ep.maxpacket;
+
+	dma_hdl = sunxi_udc_dma_request();
+	if (dma_hdl == NULL) {
+		DMSG_PANIC("ERR: sunxi_udc_dma_request failed dma_hdl is NULL\n");
+		return;
+	}
+
+	ep->dma_hdle = dma_hdl;
+	pchan = (dma_channel_t *)dma_hdl;
+	if (is_tx)
+		pchan->ep_num = ep_fifo_in[ep->num];
+	else /* rx */
+		pchan->ep_num = ep_fifo_out[ep->num];
+
+	pchan->reg_base = ep->dev->sunxi_udc_io->usb_vbase,
+
+	DmaConfig.dma_bst_len = packet_size;
+	DmaConfig.dma_dir = !is_tx;
+	DmaConfig.dma_for_ep = ep->num;
+	DmaConfig.dma_bc = len;
+	DmaConfig.dma_sdram_str_addr = buff_addr;
+	DmaConfig.dma_num = pchan->channel_num;
+
+	sunxi_dma_set_config(dma_hdl, &DmaConfig);
+}
+
+/* start dma transfer */
+void sunxi_udc_dma_start(struct sunxi_udc_ep *ep,
+		void __iomem  *fifo, __u32 buffer, __u32 len)
+{
+}
+
+/* stop dma transfer */
+void sunxi_udc_dma_stop(struct sunxi_udc_ep *ep)
+{
+}
+
+/* query the length that has been transferred */
+__u32 sunxi_udc_dma_transmit_length(struct sunxi_udc_ep *ep)
+{
+	return ep->dma_transfer_len;
+}
+
+/* check if dma busy */
+__u32 sunxi_udc_dma_is_busy(struct sunxi_udc_ep *ep)
+{
+	return ep->dma_working;
+}
+
+/* dma initialize */
+__s32 sunxi_udc_dma_probe(struct sunxi_udc *dev)
+{
+	return 0;
+}
+
+/* dma remove */
+__s32 sunxi_udc_dma_remove(struct sunxi_udc *dev)
+{
+	return 0;
+}
+
+#else
+
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+static sunxi_udc_dma_parg_t sunxi_udc_dma_para;
+
+static void sunxi_udc_dma_callback1(void *parg)
+{
+	struct sunxi_udc *dev = NULL;
+	struct sunxi_udc_request *req = NULL;
+	struct sunxi_udc_ep *ep = NULL;
+
+	dev = (struct sunxi_udc *)parg;
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: sw_udc_dma_callback failed\n");
+		return;
+	}
+
+	/* find ep */
+	ep = sunxi_udc_dma_para.ep[1];
+	if (sunxi_udc_dma_para.ep[1])
+		sunxi_udc_dma_para.ep[1] = NULL;
+	if (ep) {
+		/* find req */
+		if (likely(!list_empty(&ep->queue)))
+			req = list_entry(ep->queue.next,
+					struct sunxi_udc_request, queue);
+		else
+			req = NULL;
+
+		/* call back */
+		if (req)
+			sunxi_udc_dma_completion(dev, ep, req);
+	} else {
+		DMSG_PANIC("ERR: sw_udc_dma_callback: dma is remove, but dma irq is happened\n");
+	}
+}
+
+static void sunxi_udc_dma_callback2(void *parg)
+{
+	struct sunxi_udc *dev = NULL;
+	struct sunxi_udc_request *req = NULL;
+	struct sunxi_udc_ep *ep = NULL;
+
+	dev = (struct sunxi_udc *)parg;
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: sw_udc_dma_callback failed\n");
+		return;
+	}
+
+	/* find ep */
+	ep = sunxi_udc_dma_para.ep[2];
+	if (sunxi_udc_dma_para.ep[2])
+		sunxi_udc_dma_para.ep[2] = NULL;
+	if (ep) {
+		/* find req */
+		if (likely(!list_empty(&ep->queue)))
+			req = list_entry(ep->queue.next,
+					struct sunxi_udc_request, queue);
+		else
+			req = NULL;
+
+		/* call back */
+		if (req)
+			sunxi_udc_dma_completion(dev, ep, req);
+	} else {
+		DMSG_PANIC("ERR: sw_udc_dma_callback: dma is remove, but dma irq is happened\n");
+	}
+}
+
+static void sunxi_udc_dma_callback3(void *parg)
+{
+	struct sunxi_udc *dev = NULL;
+	struct sunxi_udc_request *req = NULL;
+	struct sunxi_udc_ep *ep = NULL;
+
+	dev = (struct sunxi_udc *)parg;
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: sw_udc_dma_callback failed\n");
+		return;
+	}
+
+	/* find ep */
+	ep = sunxi_udc_dma_para.ep[3];
+	if (sunxi_udc_dma_para.ep[3])
+		sunxi_udc_dma_para.ep[3] = NULL;
+	if (ep) {
+		/* find req */
+		if (likely(!list_empty(&ep->queue)))
+			req = list_entry(ep->queue.next,
+					struct sunxi_udc_request, queue);
+		else
+			req = NULL;
+
+		/* call back */
+		if (req)
+			sunxi_udc_dma_completion(dev, ep, req);
+	} else {
+		DMSG_PANIC("ERR: sw_udc_dma_callback: dma is remove, but dma irq is happened\n");
+	}
+}
+
+static void sunxi_udc_dma_callback4(void *parg)
+{
+	struct sunxi_udc *dev = NULL;
+	struct sunxi_udc_request *req = NULL;
+	struct sunxi_udc_ep *ep = NULL;
+
+	dev = (struct sunxi_udc *)parg;
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: sw_udc_dma_callback failed\n");
+		return;
+	}
+
+	/* find ep */
+	ep = sunxi_udc_dma_para.ep[4];
+	if (sunxi_udc_dma_para.ep[4])
+		sunxi_udc_dma_para.ep[4] = NULL;
+	if (ep) {
+		/* find req */
+		if (likely(!list_empty(&ep->queue)))
+			req = list_entry(ep->queue.next,
+					struct sunxi_udc_request, queue);
+		else
+			req = NULL;
+
+		/* call back */
+		if (req)
+			sunxi_udc_dma_completion(dev, ep, req);
+	} else {
+		DMSG_PANIC("ERR: sw_udc_dma_callback: dma is remove, but dma irq is happened\n");
+	}
+}
+
+static void sunxi_udc_dma_callback5(void *parg)
+{
+	struct sunxi_udc *dev = NULL;
+	struct sunxi_udc_request *req = NULL;
+	struct sunxi_udc_ep *ep = NULL;
+
+	dev = (struct sunxi_udc *)parg;
+	if (dev == NULL) {
+		DMSG_PANIC("ERR: sw_udc_dma_callback failed\n");
+		return;
+	}
+
+	/* find ep */
+	ep = sunxi_udc_dma_para.ep[5];
+	if (sunxi_udc_dma_para.ep[5])
+		sunxi_udc_dma_para.ep[5] = NULL;
+	if (ep) {
+		/* find req */
+		if (likely(!list_empty(&ep->queue)))
+			req = list_entry(ep->queue.next,
+					struct sunxi_udc_request, queue);
+		else
+			req = NULL;
+
+		/* call back */
+		if (req)
+			sunxi_udc_dma_completion(dev, ep, req);
+	} else {
+		DMSG_PANIC("ERR: sw_udc_dma_callback: dma is remove, but dma irq is happened\n");
+	}
+}
+
+dm_hdl_t sunxi_udc_dma_request(void)
+{
+	return (dm_hdl_t)NULL;
+}
+
+int sunxi_udc_dma_release(dm_hdl_t dma_hdl)
+{
+	return 0;
+}
+
+void sunxi_udc_dma_set_config(struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req, __u32 buff_addr, __u32 len)
+{
+	__u32 is_tx = 0;
+	void __iomem	*fifo_addr = NULL;
+	unsigned int usbc_no = 0;
+	struct dma_slave_config slave_config;
+
+	if (ep->dev->sunxi_udc_dma[ep->num].chan ==  NULL) {
+		DMSG_PANIC("udc_dma start error,DMA is NULL.\n");
+		return;
+	}
+
+	memset(&slave_config, 0, sizeof(slave_config));
+	is_tx = is_tx_ep(ep);
+
+	fifo_addr = USBC_REG_EPFIFOx(ep->dev->sunxi_udc_io->usb_vbase, ep->num);
+	printk("%s Please fix me\n", __func__);
+	switch (ep->num) {
+	case 1:
+		//usbc_no = DRQSRC_OTG_EP1;
+		break;
+	case 2:
+		//usbc_no = DRQSRC_OTG_EP2;
+		break;
+	case 3:
+		//usbc_no = DRQSRC_OTG_EP3;
+		break;
+	case 4:
+		//usbc_no = DRQSRC_OTG_EP4;
+		break;
+#if defined(CONFIG_ARCH_SUN50I) || defined(CONFIG_ARCH_SUN8IW6)
+	case 5:
+		//usbc_no = DRQSRC_OTG_EP5;
+		break;
+#endif
+	default:
+		usbc_no = 0;
+	}
+
+	sunxi_udc_dma_para.ep[ep->num] = ep;
+	if (!is_tx) { /* ep in, rx */
+		slave_config.direction = DMA_DEV_TO_MEM;
+		slave_config.src_addr = (phys_addr_t)fifo_addr;
+		slave_config.dst_addr = buff_addr;
+		slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		slave_config.src_maxburst = 1;
+		slave_config.dst_maxburst = 1;
+		printk("%s Please fix me\n", __func__);
+		//slave_config.slave_id = sunxi_slave_id(DRQDST_SDRAM, usbc_no);
+		dmaengine_slave_config(ep->dev->sunxi_udc_dma[ep->num].chan,
+					&slave_config);
+	} else { /* ep out, tx */
+		slave_config.direction = DMA_MEM_TO_DEV;
+		slave_config.src_addr = buff_addr;
+		slave_config.dst_addr = (phys_addr_t)fifo_addr;
+		slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		slave_config.src_maxburst = 1;
+		slave_config.dst_maxburst = 1;
+		printk("%s Please fix me\n", __func__);
+		//slave_config.slave_id = sunxi_slave_id(usbc_no, //DRQSRC_SDRAM);
+		dmaengine_slave_config(ep->dev->sunxi_udc_dma[ep->num].chan,
+					&slave_config);
+	}
+}
+
+void sunxi_udc_dma_start(struct sunxi_udc_ep *ep,
+		void __iomem  *fifo, __u32 buffer, __u32 len)
+{
+	struct dma_async_tx_descriptor *dma_desc = NULL;
+	__u32 is_tx = 0;
+
+	is_tx = is_tx_ep(ep);
+	if (ep->dev->sunxi_udc_dma[ep->num].chan ==  NULL) {
+		DMSG_PANIC("udc_dma start error,DMA is NULL.\n");
+		return;
+	}
+
+	ep->dev->sunxi_udc_dma[ep->num].is_start = 1;
+	if (is_tx) {
+		dma_desc = dmaengine_prep_slave_single(
+					ep->dev->sunxi_udc_dma[ep->num].chan,
+					buffer,
+					len,
+					DMA_MEM_TO_DEV,
+					DMA_PREP_INTERRUPT|DMA_CTRL_ACK);
+		if (!dma_desc) {
+			DMSG_PANIC("[sunxi-udc-%d]dmaengine_prep_slave_sg() failed!\n",
+				ep->num);
+			return;
+		}
+	} else {
+		dma_desc = dmaengine_prep_slave_single(
+					ep->dev->sunxi_udc_dma[ep->num].chan,
+					buffer,
+					len,
+					DMA_DEV_TO_MEM,
+					DMA_PREP_INTERRUPT|DMA_CTRL_ACK);
+		if (!dma_desc) {
+			DMSG_PANIC("[sunxi-udc-%d]dmaengine_prep_slave_sg() failed!\n",
+				ep->num);
+			return;
+		}
+	}
+
+	switch (ep->num) {
+	case 1:
+		dma_desc->callback = sunxi_udc_dma_callback1;
+		break;
+	case 2:
+		dma_desc->callback = sunxi_udc_dma_callback2;
+		break;
+	case 3:
+		dma_desc->callback = sunxi_udc_dma_callback3;
+		break;
+	case 4:
+		dma_desc->callback = sunxi_udc_dma_callback4;
+		break;
+	case 5:
+		dma_desc->callback = sunxi_udc_dma_callback5;
+		break;
+	default:
+		break;
+	}
+
+	dma_desc->callback_param = (void *)ep->dev;
+	dmaengine_submit(dma_desc);
+	dma_async_issue_pending(ep->dev->sunxi_udc_dma[ep->num].chan);
+}
+
+void sunxi_udc_dma_stop(struct sunxi_udc_ep *ep)
+{
+	int ret = 0;
+
+	DMSG_DBG_DMA("line:%d, %s\n", __LINE__, __func__);
+
+	ret = dmaengine_terminate_all(ep->dev->sunxi_udc_dma[ep->num].chan);
+	if (ret != 0) {
+		DMSG_PANIC("ERR: sunxi_dma_ctl stop  failed\n");
+		return;
+	}
+
+	if (sunxi_udc_dma_para.ep[ep->num])
+		sunxi_udc_dma_para.ep[ep->num] = NULL;
+}
+
+__u32 sunxi_udc_dma_transmit_length(struct sunxi_udc_ep *ep)
+{
+	return ep->dma_transfer_len;
+}
+
+__u32 sunxi_udc_dma_is_busy(struct sunxi_udc_ep *ep)
+{
+	return ep->dma_working;
+}
+
+__s32 sunxi_udc_dma_probe(struct sunxi_udc *dev)
+{
+	dma_cap_mask_t mask;
+	int i = 0;
+
+	memset(&sunxi_udc_dma_para, 0, sizeof(sunxi_udc_dma_parg_t));
+	sunxi_udc_dma_para.dev = dev;
+	DMSG_INFO("sunxi_udc_dma_probe version77..\n");
+
+	/* Try to acquire a generic DMA engine slave channel */
+	for (i = 1; i <= (USBC_MAX_EP_NUM - 1); i++) {
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_SLAVE, mask);
+
+		if (dev->sunxi_udc_dma[i].chan == NULL) {
+			dev->sunxi_udc_dma[i].chan =
+					dma_request_channel(mask, NULL, NULL);
+			if (dev->sunxi_udc_dma[i].chan == NULL) {
+				DMSG_PANIC("Request DMA(EP%d) failed!\n", i);
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+__s32 sunxi_udc_dma_remove(struct sunxi_udc *dev)
+{
+	DMSG_DBG_DMA("line:%d, %s\n", __LINE__, __func__);
+
+	memset(&sunxi_udc_dma_para, 0, sizeof(sunxi_udc_dma_parg_t));
+	return 0;
+}
+
+#endif /* SW_UDC_DMA_INNER */
diff --git a/drivers/usb/sunxi_usb/udc/sunxi_udc_dma.h b/drivers/usb/sunxi_usb/udc/sunxi_udc_dma.h
new file mode 100644
index 000000000..88d60573d
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sunxi_udc_dma.h
@@ -0,0 +1,79 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sunxi_udc_dma.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen, 2010-3-3, create this file
+ *
+ * udc dma ops.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_UDC_DMA_H__
+#define __SUNXI_UDC_DMA_H__
+
+#ifdef SW_UDC_DMA
+#define  is_udc_support_dma()		1
+#else
+#define  is_udc_support_dma()		0
+#endif
+
+/* dma channel total */
+#define DMA_CHAN_TOTAL			(8)
+typedef int *dm_hdl_t;
+
+/* define dma channel struct */
+typedef struct {
+	u32		used;		/* 1 used, 0 unuse */
+	u32		channel_num;
+	u32		ep_num;		/* the ep's index in sunxi_udc.ep[] */
+	void __iomem    *reg_base;	/* regs base addr */
+	spinlock_t	lock;		/* dma channel lock */
+} dma_channel_t;
+
+extern dma_channel_t dma_chnl[DMA_CHAN_TOTAL];
+
+/* dma config information */
+struct dma_config_t {
+	spinlock_t	lock;		/* dma channel lock */
+	u32		dma_num;
+	u32		dma_working;
+	u32		dma_en;
+	u32		dma_bst_len;
+	u32		dma_dir;
+	u32		dma_for_ep;
+	u32		dma_sdram_str_addr;
+	u32		dma_bc;
+	u32		dma_residual_bc;
+};
+
+extern int g_dma_debug;
+
+void sunxi_udc_switch_bus_to_dma(struct sunxi_udc_ep *ep, u32 is_tx);
+void sunxi_udc_switch_bus_to_pio(struct sunxi_udc_ep *ep, __u32 is_tx);
+
+void sunxi_udc_enable_dma_channel_irq(struct sunxi_udc_ep *ep);
+void sunxi_udc_disable_dma_channel_irq(struct sunxi_udc_ep *ep);
+void sunxi_dma_set_config(dm_hdl_t dma_hdl, struct dma_config_t *pcfg);
+dm_hdl_t sunxi_udc_dma_request(void);
+int sunxi_udc_dma_release(dm_hdl_t dma_hdl);
+int sunxi_udc_dma_chan_disable(dm_hdl_t dma_hdl);
+void sunxi_udc_dma_set_config(struct sunxi_udc_ep *ep,
+		struct sunxi_udc_request *req, __u32 buff_addr, __u32 len);
+void sunxi_udc_dma_start(struct sunxi_udc_ep *ep,
+		void __iomem  *fifo, __u32 buffer, __u32 len);
+void sunxi_udc_dma_stop(struct sunxi_udc_ep *ep);
+__u32 sunxi_udc_dma_transmit_length(struct sunxi_udc_ep *ep);
+__u32 sunxi_udc_dma_is_busy(struct sunxi_udc_ep *ep);
+void sunxi_udc_dma_completion(struct sunxi_udc *dev,
+		struct sunxi_udc_ep *ep, struct sunxi_udc_request *req);
+
+__s32 sunxi_udc_dma_probe(struct sunxi_udc *dev);
+__s32 sunxi_udc_dma_remove(struct sunxi_udc *dev);
+
+#endif /* __SUNXI_UDC_DMA_H__ */
+
diff --git a/drivers/usb/sunxi_usb/usbc/usbc.c b/drivers/usb/sunxi_usb/usbc/usbc.c
new file mode 100644
index 000000000..0b4c257f8
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc.c
@@ -0,0 +1,1450 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel, 2009.09.01
+ *
+ * usb common ops.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include  "usbc_i.h"
+
+static void __iomem *usbc_base_address;       /* usb base address */
+/* usbc internal use, in charge of USB port */
+static __usbc_otg_t usbc_otg_array[USBC_MAX_OPEN_NUM];
+static __fifo_info_t usbc_info_g;
+
+/**
+ * get vbus current state
+ * @hUSB: handle return by USBC_open_otg, include the key data which USBC need
+ *
+ * return the current VBUS state
+ */
+__u32 USBC_GetVbusStatus(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u8 reg_val = 0;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	reg_val = USBC_Readb(USBC_REG_DEVCTL(usbc_otg->base_addr));
+	reg_val = reg_val >> USBC_BP_DEVCTL_VBUS;
+	switch (reg_val & 0x03) {
+	case 0x00:
+		return USBC_VBUS_STATUS_BELOW_SESSIONEND;
+	case 0x01:
+		return USBC_VBUS_STATUS_ABOVE_SESSIONEND_BELOW_AVALID;
+	case 0x02:
+		return USBC_VBUS_STATUS_ABOVE_AVALID_BELOW_VBUSVALID;
+	case 0x03:
+		return USBC_VBUS_STATUS_ABOVE_VBUSVALID;
+	default:
+		return USBC_VBUS_STATUS_BELOW_SESSIONEND;
+	}
+}
+EXPORT_SYMBOL(USBC_GetVbusStatus);
+
+/**
+ * select the function type, now is for host, or device
+ * @hUSB: handle return by USBC_open_otg, include the key data which USBC need
+ *
+ */
+void USBC_OTG_SelectMode(__hdle hUSB, __u32 mode)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+}
+EXPORT_SYMBOL(USBC_OTG_SelectMode);
+
+/**
+ * get the length of data that can be read from current FIFO
+ * @hUSB:     handle return by USBC_open_otg,
+ *            include the key data which USBC need
+ * @ep_type:  ep type, tx or rx
+ *
+ * return the data length that can be current read
+ */
+__u32 USBC_ReadLenFromFifo(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		return USBC_Readw(USBC_REG_COUNT0(usbc_otg->base_addr));
+	case USBC_EP_TYPE_TX:
+		return 0;
+	case USBC_EP_TYPE_RX:
+		return USBC_Readw(USBC_REG_RXCOUNT(usbc_otg->base_addr));
+	default:
+		return 0;
+	}
+}
+EXPORT_SYMBOL(USBC_ReadLenFromFifo);
+
+/**
+ * write data packet to fifo
+ * @hUSB: handle return by USBC_open_otg,
+ *        include the key data which USBC need
+ * @fifo: fifo address
+ * @cnt:  data length
+ * @buff: store the data to be written
+ *
+ * return the length that successfully written
+ */
+__u32 USBC_WritePacket(__hdle hUSB, void __iomem *fifo, __u32 cnt, void *buff)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 len = 0;
+	__u32 i32 = 0;
+	__u32 i8  = 0;
+	__u8  *buf8  = NULL;
+	__u32 *buf32 = NULL;
+
+	if (usbc_otg == NULL || buff == NULL)
+		return 0;
+
+	/* --<1>-- adjust data */
+	buf32 = buff;
+	len   = cnt;
+
+	i32 = len >> 2;
+	i8  = len & 0x03;
+
+	/* --<2>-- deal with 4byte part */
+	while (i32--)
+		USBC_Writel(*buf32++, fifo);
+
+	/* --<3>-- deal with no 4byte part */
+	buf8 = (__u8 *)buf32;
+	while (i8--)
+		USBC_Writeb(*buf8++, fifo);
+
+	return len;
+}
+EXPORT_SYMBOL(USBC_WritePacket);
+
+/**
+ * read data from fifo
+ * @hUSB: handle return by USBC_open_otg,
+ *        include the key data which USBC need
+ * @fifo: fifo address
+ * @cnt:  data length
+ * @buff: store the data that will be read
+ *
+ * return the length that successfully read
+ */
+__u32 USBC_ReadPacket(__hdle hUSB, void __iomem *fifo, __u32 cnt, void *buff)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 len = 0;
+	__u32 i32 = 0;
+	__u32 i8  = 0;
+	__u8  *buf8  = NULL;
+	__u32 *buf32 = NULL;
+
+	if (usbc_otg == NULL || buff == NULL)
+		return 0;
+
+	/* --<1>-- adjust data */
+	buf32 = buff;
+	len   = cnt;
+
+	i32 = len >> 2;
+	i8  = len & 0x03;
+
+	/* --<2>-- deal with 4byte part */
+	while (i32--)
+		*buf32++ = USBC_Readl(fifo);
+
+	/* --<3>-- deal with no 4byte part */
+	buf8 = (__u8 *)buf32;
+	while (i8--)
+		*buf8++ = USBC_Readb(fifo);
+
+	return len;
+}
+EXPORT_SYMBOL(USBC_ReadPacket);
+
+void USBC_ConfigFIFO_Base(__hdle hUSB, __u32 fifo_mode)
+{
+	__fifo_info_t *usbc_info = &usbc_info_g;
+
+	usbc_info->port0_fifo_addr = 0x00;
+	usbc_info->port0_fifo_size = fifo_mode;	/* 8k */
+}
+EXPORT_SYMBOL(USBC_ConfigFIFO_Base);
+
+/* get port fifo's start address */
+void __iomem *USBC_GetPortFifoStartAddr(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	if (usbc_otg->port_num == 0)
+		return usbc_info_g.port0_fifo_addr;
+	else if (usbc_otg->port_num == 1)
+		return usbc_info_g.port1_fifo_addr;
+	else
+		return usbc_info_g.port2_fifo_addr;
+}
+EXPORT_SYMBOL(USBC_GetPortFifoStartAddr);
+
+/* get port fifo's size */
+__u32 USBC_GetPortFifoSize(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	if (usbc_otg->port_num == 0)
+		return usbc_info_g.port0_fifo_size;
+	else
+		return usbc_info_g.port1_fifo_size;
+}
+EXPORT_SYMBOL(USBC_GetPortFifoSize);
+
+void __iomem *USBC_SelectFIFO(__hdle hUSB, __u32 ep_index)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	return USBC_REG_EPFIFOx(usbc_otg->base_addr, ep_index);
+}
+EXPORT_SYMBOL(USBC_SelectFIFO);
+
+static void __USBC_ConfigFifo_TxEp_Default(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(0x00, USBC_REG_TXFIFOAD(usbc_base_addr));
+	USBC_Writeb(0x00, USBC_REG_TXFIFOSZ(usbc_base_addr));
+}
+
+/**
+ * set tx ep's fifo address and size
+ * @hUSB:           handle return by USBC_open_otg,
+ *                  include the key data which USBC need
+ * @is_double_fifo: if use hardware double fifo
+ * @fifo_size:      fifo size = 2 ^ fifo_size
+ * @fifo_addr:      fifo start addr = fifo_addr * 8
+ *
+ */
+static void __USBC_ConfigFifo_TxEp(void __iomem *usbc_base_addr,
+		__u32 is_double_fifo, __u32 fifo_size, __u32 fifo_addr)
+{
+	__u32 temp = 0;
+	__u32 size = 0;   /* fifo_size = 2^ (size + 3) */
+	__u32 addr = 0;   /* fifo_addr = addr * 8 */
+
+	/* --<1>-- 512 align */
+	temp = fifo_size + 511;
+	temp &= ~511;
+	temp >>= 3;
+	temp >>= 1;
+	while (temp) {
+		size++;
+		temp >>= 1;
+	}
+
+	/* --<2>-- calculate addr */
+	addr = fifo_addr >> 3;
+
+	/* --<3>--config fifo addr */
+	USBC_Writew(addr, USBC_REG_TXFIFOAD(usbc_base_addr));
+
+	/* --<4>--config fifo size */
+	USBC_Writeb((size & 0x0f), USBC_REG_TXFIFOSZ(usbc_base_addr));
+	if (is_double_fifo)
+		USBC_REG_set_bit_b(USBC_BP_TXFIFOSZ_DPB,
+				USBC_REG_TXFIFOSZ(usbc_base_addr));
+}
+
+static void __USBC_ConfigFifo_RxEp_Default(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(0x00, USBC_REG_RXFIFOAD(usbc_base_addr));
+	USBC_Writeb(0x00, USBC_REG_RXFIFOSZ(usbc_base_addr));
+}
+
+/**
+ * set rx ep's fifo address and size
+ * @hUSB:           handle return by USBC_open_otg,
+ *                  include the key data which USBC need
+ * @is_double_fifo: if use hardware double fifo
+ * @fifo_size:      fifo size = 2 ^ fifo_size
+ * @fifo_addr:      fifo start addr = fifo_addr * 8
+ *
+ */
+static void __USBC_ConfigFifo_RxEp(void __iomem *usbc_base_addr,
+		__u32 is_double_fifo, __u32 fifo_size, __u32 fifo_addr)
+{
+	__u32 temp = 0;
+	__u32 size = 0;   /* fifo_size = 2 ^ (size + 3) */
+	__u32 addr = 0;   /* fifo_addr = addr * 8 */
+
+	/* --<1>-- 512 align */
+	temp = fifo_size + 511;
+	temp &= ~511;
+	temp >>= 3;
+	temp >>= 1;
+	while (temp) {
+		size++;
+		temp >>= 1;
+	}
+
+	/* --<2>--calculate addr */
+	addr = fifo_addr >> 3;
+
+	/* --<3>--config fifo addr */
+	USBC_Writew(addr, USBC_REG_RXFIFOAD(usbc_base_addr));
+
+	/* --<2>--config fifo size */
+	USBC_Writeb((size & 0x0f), USBC_REG_RXFIFOSZ(usbc_base_addr));
+	if (is_double_fifo)
+		USBC_REG_set_bit_b(USBC_BP_RXFIFOSZ_DPB,
+				USBC_REG_RXFIFOSZ(usbc_base_addr));
+}
+
+/**
+ * config ep's fifo addr and size
+ * @hUSB:     handle return by USBC_open_otg,
+ *            include the key data which USBC need
+ * @ep_type:  ep type
+ *
+ */
+void USBC_ConfigFifo_Default(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		/* not support */
+		break;
+	case USBC_EP_TYPE_TX:
+		__USBC_ConfigFifo_TxEp_Default(usbc_otg->base_addr);
+		break;
+	case USBC_EP_TYPE_RX:
+		__USBC_ConfigFifo_RxEp_Default(usbc_otg->base_addr);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(USBC_ConfigFifo_Default);
+
+/**
+ * config ep's fifo addr and size
+ * @hUSB:           handle return by USBC_open_otg,
+ *                  include the key data which USBC need
+ * @ep_type:        ep type
+ * @is_double_fifo: if use hardware double fifo
+ * @fifo_size:      fifo size = 2 ^ fifo_size
+ * @fifo_addr:      fifo start addr = fifo_addr * 8
+ *
+ */
+void USBC_ConfigFifo(__hdle hUSB, __u32 ep_type,
+		__u32 is_double_fifo, __u32 fifo_size, __u32 fifo_addr)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		/* not support */
+		break;
+	case USBC_EP_TYPE_TX:
+		__USBC_ConfigFifo_TxEp(usbc_otg->base_addr,
+				is_double_fifo, fifo_size, fifo_addr);
+		break;
+	case USBC_EP_TYPE_RX:
+		__USBC_ConfigFifo_RxEp(usbc_otg->base_addr,
+				is_double_fifo, fifo_size, fifo_addr);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(USBC_ConfigFifo);
+
+/**
+ * get the last frma number
+ * @hUSB: handle return by USBC_open_otg,
+ *        include the key data which USBC need
+ *
+ */
+__u32 USBC_GetLastFrameNumber(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	return USBC_Readl(USBC_REG_FRNUM(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_GetLastFrameNumber);
+
+/**
+ * get status of DP
+ * @hUSB: handle return by USBC_open_otg,
+ *        include the key data which USBC need
+ *
+ */
+__u32 USBC_GetStatus_Dp(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 temp = 0;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	temp = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	temp = (temp >> USBC_BP_ISCR_EXT_DP_STATUS) & 0x01;
+
+	return temp;
+}
+EXPORT_SYMBOL(USBC_GetStatus_Dp);
+
+/**
+ * get status of DM
+ * @hUSB: handle return by USBC_open_otg,
+ *        include the key data which USBC need
+ *
+ */
+__u32 USBC_GetStatus_Dm(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 temp = 0;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	temp = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	temp = (temp >> USBC_BP_ISCR_EXT_DM_STATUS) & 0x01;
+
+	return temp;
+}
+EXPORT_SYMBOL(USBC_GetStatus_Dm);
+
+/**
+ * get status of DpDm
+ * @hUSB: handle return by USBC_open_otg,
+ *        include the key data which USBC need
+ *
+ */
+__u32 USBC_GetStatus_DpDm(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 temp = 0;
+	__u32 dp = 0;
+	__u32 dm = 0;
+
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	temp = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	dp = (temp >> USBC_BP_ISCR_EXT_DP_STATUS) & 0x01;
+	dm = (temp >> USBC_BP_ISCR_EXT_DM_STATUS) & 0x01;
+	return ((dp << 1) | dm);
+
+}
+EXPORT_SYMBOL(USBC_GetStatus_DpDm);
+
+/**
+ * get current OTG mode from vendor0's id
+ * @hUSB: handle return by USBC_open_otg,
+ *        include the key data which USBC need
+ *
+ * return USBC_OTG_DEVICE / USBC_OTG_HOST
+ */
+__u32 USBC_GetOtgMode_Form_ID(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 mode = 0;
+
+	if (usbc_otg == NULL)
+		return USBC_OTG_DEVICE;
+
+	mode = USBC_REG_test_bit_l(USBC_BP_ISCR_MERGED_ID_STATUS,
+				USBC_REG_ISCR(usbc_otg->base_addr));
+	if (mode)
+		return USBC_OTG_DEVICE;
+	else
+		return USBC_OTG_HOST;
+}
+EXPORT_SYMBOL(USBC_GetOtgMode_Form_ID);
+
+/**
+ * get current OTG mode from OTG Device's B-Device
+ * @hUSB: handle return by USBC_open_otg,
+ *        include the key data which USBC need
+ *
+ * return USBC_OTG_DEVICE / USBC_OTG_HOST
+ */
+__u32 USBC_GetOtgMode_Form_BDevice(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 mode = 0;
+
+	if (usbc_otg == NULL)
+		return USBC_OTG_DEVICE;
+
+	mode = USBC_REG_test_bit_b(USBC_BP_DEVCTL_B_DEVICE,
+				USBC_REG_DEVCTL(usbc_otg->base_addr));
+	if (mode)
+		return USBC_OTG_DEVICE;
+	else
+		return USBC_OTG_HOST;
+}
+EXPORT_SYMBOL(USBC_GetOtgMode_Form_BDevice);
+
+/**
+ * otg and hci0 Controller Shared phy in SUN50I
+ * select 1:to device,0:hci
+ */
+void USBC_SelectPhyToDevice(void __iomem *usbc_base_addr)
+{
+	int reg_value = 0;
+
+	reg_value = USBC_Readl(usbc_base_addr + 0x420);
+	reg_value |= (0x01);
+	USBC_Writel(reg_value, (usbc_base_addr + 0x420));
+}
+
+/**
+ * select the bus way for data transfer
+ * @hUSB:     handle return by USBC_open_otg,
+ *            include the key data which USBC need
+ * @io_type:  bus type, pio or dma
+ * @ep_type:  ep type, rx or tx
+ * @ep_index: ep index
+ *
+ */
+void USBC_SelectBus(__hdle hUSB, __u32 io_type, __u32 ep_type, __u32 ep_index)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	if (usbc_otg == NULL)
+		return;
+
+	reg_val = USBC_Readb(USBC_REG_VEND0(usbc_otg->base_addr));
+	if (io_type == USBC_IO_TYPE_DMA) {
+		if (ep_type == USBC_EP_TYPE_TX) {
+			reg_val |= ((ep_index - 0x01) << 1)
+					<< USBC_BP_VEND0_DRQ_SEL; /* drq_sel */
+			reg_val |= 0x1<<USBC_BP_VEND0_BUS_SEL; /* io_dma */
+		} else {
+			reg_val |= ((ep_index << 1) - 0x01)
+					<< USBC_BP_VEND0_DRQ_SEL;
+			reg_val |= 0x1<<USBC_BP_VEND0_BUS_SEL;
+		}
+	} else {
+#if !defined(CONFIG_ARCH_SUN8IW6) && !defined(CONFIG_ARCH_SUN8IW8)
+		reg_val &= 0x00; /* clear drq_sel, select pio */
+#endif
+	}
+
+	/**
+	 * in SUN8IW5 SUN8IW6 and later ic, FIFO_BUS_SEL bit(bit24 of reg0x40
+	 * for host/device) is fixed to 1, the hw guarantee that it's ok for
+	 * cpu/inner_dma/outer_dma transfer.
+	 */
+
+	reg_val |= 0x1<<USBC_BP_VEND0_BUS_SEL;
+
+	USBC_Writeb(reg_val, USBC_REG_VEND0(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_SelectBus);
+
+/* get tx ep's interrupt flag */
+static __u32 __USBC_INT_TxPending(void __iomem *usbc_base_addr)
+{
+	return USBC_Readw(USBC_REG_INTTx(usbc_base_addr));
+}
+
+/* clear tx ep's interrupt flag */
+static void __USBC_INT_ClearTxPending(void __iomem *usbc_base_addr,
+			__u8 ep_index)
+{
+	USBC_Writew((1 << ep_index), USBC_REG_INTTx(usbc_base_addr));
+}
+
+/* clear all the tx ep's interrupt flag */
+static void __USBC_INT_ClearTxPendingAll(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(0xffff, USBC_REG_INTTx(usbc_base_addr));
+}
+
+/* get rx ep's interrupt flag */
+static __u32 __USBC_INT_RxPending(void __iomem *usbc_base_addr)
+{
+	return USBC_Readw(USBC_REG_INTRx(usbc_base_addr));
+}
+
+/* clear rx ep's interrupt flag */
+static void __USBC_INT_ClearRxPending(void __iomem *usbc_base_addr,
+		__u8 ep_index)
+{
+	USBC_Writew((1 << ep_index), USBC_REG_INTRx(usbc_base_addr));
+}
+
+/* clear all the rx ep's interrupt flag */
+static void __USBC_INT_ClearRxPendingAll(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(0xffff, USBC_REG_INTRx(usbc_base_addr));
+}
+
+/* open a tx ep's interrupt */
+static void __USBC_INT_EnableTxEp(void __iomem *usbc_base_addr, __u8 ep_index)
+{
+	USBC_REG_set_bit_w(ep_index, USBC_REG_INTTxE(usbc_base_addr));
+}
+
+/* open a rx ep's interrupt */
+static void __USBC_INT_EnableRxEp(void __iomem *usbc_base_addr, __u8 ep_index)
+{
+	USBC_REG_set_bit_w(ep_index, USBC_REG_INTRxE(usbc_base_addr));
+}
+
+/* close a tx ep's interrupt */
+static void __USBC_INT_DisableTxEp(void __iomem *usbc_base_addr, __u8 ep_index)
+{
+	USBC_REG_clear_bit_w(ep_index, USBC_REG_INTTxE(usbc_base_addr));
+}
+
+/* close a rx ep's interrupt */
+static void __USBC_INT_DisableRxEp(void __iomem *usbc_base_addr, __u8 ep_index)
+{
+	USBC_REG_clear_bit_w(ep_index, USBC_REG_INTRxE(usbc_base_addr));
+}
+
+/* close all tx ep's interrupt */
+static void __USBC_INT_DisableTxAll(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(0, USBC_REG_INTTxE(usbc_base_addr));
+}
+
+/* close all rx ep's interrupt */
+static void __USBC_INT_DisableRxAll(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(0, USBC_REG_INTRxE(usbc_base_addr));
+}
+
+/* get ep's interrupt flag */
+__u32 USBC_INT_EpPending(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+	case USBC_EP_TYPE_TX:
+		return __USBC_INT_TxPending(usbc_otg->base_addr);
+
+	case USBC_EP_TYPE_RX:
+		return __USBC_INT_RxPending(usbc_otg->base_addr);
+
+	default:
+		return 0;
+	}
+}
+EXPORT_SYMBOL(USBC_INT_EpPending);
+
+/* clear ep's interrupt flag */
+void USBC_INT_ClearEpPending(__hdle hUSB, __u32 ep_type, __u8 ep_index)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+	case USBC_EP_TYPE_TX:
+		__USBC_INT_ClearTxPending(usbc_otg->base_addr, ep_index);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_INT_ClearRxPending(usbc_otg->base_addr, ep_index);
+		break;
+
+	default:
+		break;
+	}
+
+}
+EXPORT_SYMBOL(USBC_INT_ClearEpPending);
+
+/* clear ep's interrupt flag */
+void USBC_INT_ClearEpPendingAll(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+	case USBC_EP_TYPE_TX:
+		__USBC_INT_ClearTxPendingAll(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_INT_ClearRxPendingAll(usbc_otg->base_addr);
+		break;
+
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(USBC_INT_ClearEpPendingAll);
+
+/* get usb misc's interrupt flag */
+__u32 USBC_INT_MiscPending(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	return USBC_Readb(USBC_REG_INTUSB(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_INT_MiscPending);
+
+/* clear usb misc's interrupt flag */
+void USBC_INT_ClearMiscPending(__hdle hUSB, __u32 mask)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_Writeb(mask, USBC_REG_INTUSB(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_INT_ClearMiscPending);
+
+/* clear all the usb misc's interrupt flag */
+void USBC_INT_ClearMiscPendingAll(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_Writeb(0xff, USBC_REG_INTUSB(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_INT_ClearMiscPendingAll);
+
+/* open a ep's interrupt */
+void USBC_INT_EnableEp(__hdle hUSB, __u32 ep_type, __u8 ep_index)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_TX:
+		__USBC_INT_EnableTxEp(usbc_otg->base_addr, ep_index);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_INT_EnableRxEp(usbc_otg->base_addr, ep_index);
+		break;
+
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(USBC_INT_EnableEp);
+
+/* open a usb misc's interrupt */
+void USBC_INT_EnableUsbMiscUint(__hdle hUSB, __u32 mask)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	if (usbc_otg == NULL)
+		return;
+
+	reg_val = USBC_Readb(USBC_REG_INTUSBE(usbc_otg->base_addr));
+	reg_val |= mask;
+	USBC_Writeb(reg_val, USBC_REG_INTUSBE(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_INT_EnableUsbMiscUint);
+
+/* close a ep's interrupt */
+void USBC_INT_DisableEp(__hdle hUSB, __u32 ep_type, __u8 ep_index)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_TX:
+		__USBC_INT_DisableTxEp(usbc_otg->base_addr, ep_index);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_INT_DisableRxEp(usbc_otg->base_addr, ep_index);
+		break;
+
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(USBC_INT_DisableEp);
+
+/* close a usb misc's interrupt */
+void USBC_INT_DisableUsbMiscUint(__hdle hUSB, __u32 mask)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	if (usbc_otg == NULL)
+		return;
+
+	reg_val = USBC_Readb(USBC_REG_INTUSBE(usbc_otg->base_addr));
+	reg_val &= ~mask;
+	USBC_Writeb(reg_val, USBC_REG_INTUSBE(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_INT_DisableUsbMiscUint);
+
+/* close all ep's interrupt */
+void USBC_INT_DisableEpAll(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_TX:
+		__USBC_INT_DisableTxAll(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_INT_DisableRxAll(usbc_otg->base_addr);
+		break;
+
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(USBC_INT_DisableEpAll);
+
+/* close all usb misc's interrupt */
+void USBC_INT_DisableUsbMiscAll(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_Writeb(0, USBC_REG_INTUSBE(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_INT_DisableUsbMiscAll);
+
+/* get current active ep */
+__u32 USBC_GetActiveEp(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	return USBC_Readb(USBC_REG_EPIND(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_GetActiveEp);
+
+/* set the active ep */
+void USBC_SelectActiveEp(__hdle hUSB, __u8 ep_index)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_Writeb(ep_index, USBC_REG_EPIND(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_SelectActiveEp);
+
+/* enhance usb transfer signal */
+void USBC_EnhanceSignal(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+}
+EXPORT_SYMBOL(USBC_EnhanceSignal);
+
+/* enter TestPacket mode */
+void USBC_EnterMode_TestPacket(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_REG_set_bit_b(USBC_BP_TMCTL_TEST_PACKET,
+			USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnterMode_TestPacket);
+
+/* enter Test_K mode */
+void USBC_EnterMode_Test_K(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_REG_set_bit_b(USBC_BP_TMCTL_TEST_K,
+			USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnterMode_Test_K);
+
+/* enter Test_J mode */
+void USBC_EnterMode_Test_J(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_REG_set_bit_b(USBC_BP_TMCTL_TEST_J,
+			USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnterMode_Test_J);
+
+/* enter Test_SE0_NAK mode */
+void USBC_EnterMode_Test_SE0_NAK(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_REG_set_bit_b(USBC_BP_TMCTL_TEST_SE0_NAK,
+			USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnterMode_Test_SE0_NAK);
+
+/* clear all test mode */
+void USBC_EnterMode_Idle(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_REG_clear_bit_b(USBC_BP_TMCTL_TEST_PACKET,
+			USBC_REG_TMCTL(usbc_otg->base_addr));
+	USBC_REG_clear_bit_b(USBC_BP_TMCTL_TEST_K,
+			USBC_REG_TMCTL(usbc_otg->base_addr));
+	USBC_REG_clear_bit_b(USBC_BP_TMCTL_TEST_J,
+			USBC_REG_TMCTL(usbc_otg->base_addr));
+	USBC_REG_clear_bit_b(USBC_BP_TMCTL_TEST_SE0_NAK,
+			USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnterMode_Idle);
+
+/**
+ * vbus, id, dpdm, these bit is set 1 to clear,
+ * so we clear these bit when operate other bits
+ */
+static __u32 __USBC_WakeUp_ClearChangeDetect(__u32 reg_val)
+{
+	__u32 temp = reg_val;
+
+	temp &= ~(1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT);
+	temp &= ~(1 << USBC_BP_ISCR_ID_CHANGE_DETECT);
+	temp &= ~(1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT);
+
+	return temp;
+}
+
+void USBC_SetWakeUp_Default(__hdle hUSB)
+{
+}
+EXPORT_SYMBOL(USBC_SetWakeUp_Default);
+
+void USBC_EnableIdPullUp(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	/**
+	 * vbus, id, dpdm, these bit is set 1 to clear,
+	 * so we clear these bit when operate other bits
+	 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= (1 << USBC_BP_ISCR_ID_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnableIdPullUp);
+
+void USBC_DisableIdPullUp(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	/**
+	 * vbus, id, dpdm, these bit is set 1 to clear,
+	 * so we clear these bit when operate other bits
+	 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_ID_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_DisableIdPullUp);
+
+void USBC_EnableDpDmPullUp(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	/**
+	 * vbus, id, dpdm, these bit is set 1 to clear,
+	 * so we clear these bit when operate other bits
+	 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= (1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnableDpDmPullUp);
+
+void USBC_DisableDpDmPullUp(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	/**
+	 * vbus, id, dpdm, these bit is set 1 to clear,
+	 * so we clear these bit when operate other bits
+	 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_DisableDpDmPullUp);
+
+static void __USBC_ForceIdDisable(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	/**
+	 * vbus, id, dpdm, these bit is set 1 to clear,
+	 * so we clear these bit when operate other bits
+	 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+static void __USBC_ForceIdToLow(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	/* first write 00, then write 10 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val |= (0x02 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+static void __USBC_ForceIdToHigh(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	/* first write 00, then write 10 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val |= (0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+/* force id to (id_type) */
+void USBC_ForceId(__hdle hUSB, __u32 id_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	switch (id_type) {
+	case USBC_ID_TYPE_HOST:
+		__USBC_ForceIdToLow(usbc_otg->base_addr);
+		break;
+
+	case USBC_ID_TYPE_DEVICE:
+		__USBC_ForceIdToHigh(usbc_otg->base_addr);
+		break;
+
+	default:
+		__USBC_ForceIdDisable(usbc_otg->base_addr);
+	}
+}
+EXPORT_SYMBOL(USBC_ForceId);
+
+static void __USBC_ForceVbusValidDisable(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	/* first write 00, then write 10 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+static void __USBC_ForceVbusValidToLow(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	/* first write 00, then write 10 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val |= (0x02 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+static void __USBC_ForceVbusValidToHigh(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	/* first write 00, then write 11 */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val |= (0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+/* force vbus valid to (id_type) */
+void USBC_ForceVbusValid(__hdle hUSB, __u32 vbus_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (vbus_type) {
+	case USBC_VBUS_TYPE_LOW:
+		__USBC_ForceVbusValidToLow(usbc_otg->base_addr);
+		break;
+
+	case USBC_VBUS_TYPE_HIGH:
+		__USBC_ForceVbusValidToHigh(usbc_otg->base_addr);
+		break;
+
+	default:
+		__USBC_ForceVbusValidDisable(usbc_otg->base_addr);
+	}
+}
+EXPORT_SYMBOL(USBC_ForceVbusValid);
+
+void USBC_A_valid_InputSelect(__hdle hUSB, __u32 source)
+{
+}
+EXPORT_SYMBOL(USBC_A_valid_InputSelect);
+
+void USBC_EnableUsbLineStateBypass(__hdle hUSB)
+{
+}
+EXPORT_SYMBOL(USBC_EnableUsbLineStateBypass);
+
+void USBC_DisableUsbLineStateBypass(__hdle hUSB)
+{
+}
+EXPORT_SYMBOL(USBC_DisableUsbLineStateBypass);
+
+void USBC_EnableHosc(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= 1 << USBC_BP_ISCR_HOSC_EN;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnableHosc);
+
+/* forbidde Hosc */
+void USBC_DisableHosc(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_HOSC_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_DisableHosc);
+
+/* check if vbus irq occur */
+__u32 USBC_IsVbusChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+	__u32 temp = 0;
+
+	/* when read the volatile bit, write 1 clear it synchronously. */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+
+	temp = reg_val & (1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT);
+
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	reg_val |= 1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT;
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+
+	return temp;
+}
+EXPORT_SYMBOL(USBC_IsVbusChange);
+
+/* check if id irq occur */
+__u32 USBC_IsIdChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+	__u32 temp = 0;
+
+	/* when read the volatile bit, write 1 clear it synchronously. */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+
+	temp = reg_val & (1 << USBC_BP_ISCR_ID_CHANGE_DETECT);
+
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	reg_val |= 1 << USBC_BP_ISCR_ID_CHANGE_DETECT;
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+
+	return temp;
+}
+EXPORT_SYMBOL(USBC_IsIdChange);
+
+/* check if dpdm irq occur */
+__u32 USBC_IsDpDmChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+	__u32 temp = 0;
+
+	/* when read the volatile bit, write 1 clear it synchronously. */
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+
+	temp = reg_val & (1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT);
+
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	reg_val |= 1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT;
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+
+	return temp;
+}
+EXPORT_SYMBOL(USBC_IsDpDmChange);
+
+/* disable wake irq */
+void USBC_DisableWakeIrq(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_IRQ_ENABLE);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_DisableWakeIrq);
+
+/* disable vbus irq */
+void USBC_DisableVbusChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_DisableVbusChange);
+
+/* disable id irq */
+void USBC_DisableIdChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_ID_CHANGE_DETECT_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_DisableIdChange);
+
+/* disable dpdm irq */
+void USBC_DisableDpDmChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_DisableDpDmChange);
+
+/* enable wake irq */
+void USBC_EnableWakeIrq(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= 1 << USBC_BP_ISCR_IRQ_ENABLE;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnableWakeIrq);
+
+/* enable vbus irq */
+void USBC_EnableVbusChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= 1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT_EN;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnableVbusChange);
+
+/* enable id irq */
+void USBC_EnableIdChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= 1 << USBC_BP_ISCR_ID_CHANGE_DETECT_EN;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnableIdChange);
+
+/* enable dmdp irq */
+void USBC_EnableDpDmChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= 1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT_EN;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_EnableDpDmChange);
+
+/* test mode, get the reg value */
+__u32 USBC_TestMode_ReadReg(__hdle hUSB, __u32 offset, __u32 reg_width)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	if (usbc_otg == NULL)
+		return reg_val;
+
+	if (reg_width == 8)
+		reg_val = USBC_Readb(usbc_otg->base_addr + offset);
+	else if (reg_width == 16)
+		reg_val = USBC_Readw(usbc_otg->base_addr + offset);
+	else if (reg_width == 32)
+		reg_val = USBC_Readl(usbc_otg->base_addr + offset);
+	else
+		reg_val = 0;
+
+	return reg_val;
+}
+EXPORT_SYMBOL(USBC_TestMode_ReadReg);
+
+__hdle USBC_open_otg(__u32 otg_no)
+{
+	__usbc_otg_t *usbc_otg = usbc_otg_array;
+
+	usbc_otg->used      = 1;
+	usbc_otg->no        = otg_no;
+	usbc_otg->port_num  = otg_no;
+	usbc_otg->base_addr = usbc_base_address;
+
+	return (__hdle)(usbc_otg);
+}
+EXPORT_SYMBOL(USBC_open_otg);
+
+/**
+ * release otg's usage
+ * @hUSB: handle return by USBC_open_otg, include the key data which USBC need
+ *
+ * return 0 on success, !0 otherwise.
+ */
+__s32  USBC_close_otg(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	memset(usbc_otg, 0, sizeof(__usbc_otg_t));
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_close_otg);
+
+__s32 USBC_init(bsp_usbc_t *usbc)
+{
+	if (usbc->usbc_info.base)
+		usbc_base_address = usbc->usbc_info.base;
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_init);
+
+__s32 USBC_exit(bsp_usbc_t *usbc)
+{
+	__usbc_otg_t *usbc_otg = usbc_otg_array;
+
+	memset(&usbc_info_g, 0, sizeof(__fifo_info_t));
+	memset(usbc_otg, 0, (USBC_MAX_OPEN_NUM * sizeof(__usbc_otg_t)));
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_exit);
diff --git a/drivers/usb/sunxi_usb/usbc/usbc_dev.c b/drivers/usb/sunxi_usb/usbc/usbc_dev.c
new file mode 100644
index 000000000..ac1c2b5bd
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc_dev.c
@@ -0,0 +1,1325 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc_dev.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel, 2009.09.01
+ *
+ * usb register ops.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include  "usbc_i.h"
+
+/**
+ * select the usb transfer type, eg control/iso/interrupt/bulk transfer
+ */
+
+static void __USBC_Dev_TsType_default(void __iomem *usbc_base_addr)
+{
+	/* disable all transfer type */
+	USBC_REG_clear_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN,
+			USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsType_Ctrl(void __iomem *usbc_base_addr)
+{
+	/* --<1>--disable other transfer type */
+	USBC_REG_clear_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN,
+			USBC_REG_PCTL(usbc_base_addr));
+
+	/* --<2>--select Ctrl type */
+	/* do not need config */
+}
+
+static void __USBC_Dev_TsType_Iso(void __iomem *usbc_base_addr)
+{
+	/* --<1>--disable other transfer type */
+	/* do not need config */
+
+	/* --<2>--select Ctrl type */
+	USBC_REG_set_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN,
+			USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsType_Int(void __iomem *usbc_base_addr)
+{
+	/* --<1>--disable other transfer type */
+	USBC_REG_clear_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN,
+			USBC_REG_PCTL(usbc_base_addr));
+
+	/* --<2>--select Ctrl type */
+	/* donot need config */
+}
+
+static void __USBC_Dev_TsType_Bulk(void __iomem *usbc_base_addr)
+{
+	/* --<1>--disable other transfer type */
+	USBC_REG_clear_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN,
+			USBC_REG_PCTL(usbc_base_addr));
+
+	/* --<2>--select Ctrl type */
+	/* donot need config */
+}
+
+/**
+ * select the usb speed type, eg high/full/low
+ */
+
+static void __USBC_Dev_TsMode_default(void __iomem *usbc_base_addr)
+{
+	USBC_REG_clear_bit_b(USBC_BP_POWER_D_HIGH_SPEED_EN,
+			USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsMode_Hs(void __iomem *usbc_base_addr)
+{
+	USBC_REG_set_bit_b(USBC_BP_POWER_D_HIGH_SPEED_EN,
+			USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsMode_Fs(void __iomem *usbc_base_addr)
+{
+	USBC_REG_clear_bit_b(USBC_BP_POWER_D_HIGH_SPEED_EN,
+			USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsMode_Ls(void __iomem *usbc_base_addr)
+{
+	/* hw not support ls, so default select fs */
+	__USBC_Dev_TsMode_Fs(usbc_base_addr);
+}
+
+static void __USBC_Dev_ep0_ConfigEp0_Default(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(1<<USBC_BP_CSR0_D_FLUSH_FIFO,
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ConfigEp0(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(1<<USBC_BP_CSR0_D_FLUSH_FIFO,
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_ep0_IsReadDataReady(void __iomem *usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_CSR0_D_RX_PKT_READY,
+				USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_ep0_IsWriteDataReady(void __iomem *usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_CSR0_D_TX_PKT_READY,
+				USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ReadDataHalf(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(1<<USBC_BP_CSR0_D_SERVICED_RX_PKT_READY,
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ReadDataComplete(void __iomem *usbc_base_addr)
+{
+	USBC_Writew((1<<USBC_BP_CSR0_D_SERVICED_RX_PKT_READY)
+			| (1<<USBC_BP_CSR0_D_DATA_END),
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_WriteDataHalf(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(1<<USBC_BP_CSR0_D_TX_PKT_READY,
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_WriteDataComplete(void __iomem *usbc_base_addr)
+{
+	USBC_Writew((1<<USBC_BP_CSR0_D_TX_PKT_READY)
+			| (1<<USBC_BP_CSR0_D_DATA_END),
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_ep0_IsEpStall(void __iomem *usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_CSR0_D_SENT_STALL,
+				USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_SendStall(void __iomem *usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_CSR0_D_SEND_STALL,
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ClearStall(void __iomem *usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_CSR0_D_SEND_STALL,
+			USBC_REG_CSR0(usbc_base_addr));
+	USBC_REG_clear_bit_w(USBC_BP_CSR0_D_SENT_STALL,
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_ep0_IsSetupEnd(void __iomem *usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_CSR0_D_SETUP_END,
+				USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ClearSetupEnd(void __iomem *usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_CSR0_D_SERVICED_SETUP_END,
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_EnableIsoEp(void __iomem *usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_TXCSR_D_ISO,
+			USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_EnableIntEp(void __iomem *usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_TXCSR_D_ISO,
+			USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_EnableBulkEp(void __iomem *usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_TXCSR_D_ISO,
+			USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_ConfigEp_Default(void __iomem *usbc_base_addr)
+{
+	/* --<1>--clear tx csr */
+	USBC_Writew(0x00, USBC_REG_TXCSR(usbc_base_addr));
+
+	/* --<2>--clear tx ep max packet */
+	USBC_Writew(0x00, USBC_REG_TXMAXP(usbc_base_addr));
+
+	/* --<3>--config ep transfer type */
+}
+
+static void __USBC_Dev_Tx_ConfigEp(void __iomem *usbc_base_addr,
+		__u32 ts_type, __u32 is_double_fifo, __u32 ep_MaxPkt)
+{
+	__u16 reg_val = 0;
+	__u16 temp = 0;
+
+	/* --<1>--config tx csr */
+	reg_val = (1 << USBC_BP_TXCSR_D_MODE);
+	reg_val |= (1 << USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE);
+	reg_val |= (1 << USBC_BP_TXCSR_D_FLUSH_FIFO);
+	USBC_Writew(reg_val, USBC_REG_TXCSR(usbc_base_addr));
+
+	if (is_double_fifo)
+		USBC_Writew(reg_val, USBC_REG_TXCSR(usbc_base_addr));
+
+	/* --<2>--config tx ep max packet */
+	reg_val = USBC_Readw(USBC_REG_TXMAXP(usbc_base_addr));
+	temp    = ep_MaxPkt & ((1 << USBC_BP_TXMAXP_PACKET_COUNT) - 1);
+	reg_val |= temp;
+	USBC_Writew(reg_val, USBC_REG_TXMAXP(usbc_base_addr));
+
+	/* --<3>--config ep transfer type */
+	switch (ts_type) {
+	case USBC_TS_TYPE_ISO:
+		__USBC_Dev_Tx_EnableIsoEp(usbc_base_addr);
+		break;
+
+	case USBC_TS_TYPE_INT:
+		__USBC_Dev_Tx_EnableIntEp(usbc_base_addr);
+		break;
+
+	case USBC_TS_TYPE_BULK:
+		__USBC_Dev_Tx_EnableBulkEp(usbc_base_addr);
+		break;
+
+	default:
+		__USBC_Dev_Tx_EnableBulkEp(usbc_base_addr);
+	}
+}
+
+static void __USBC_Dev_Tx_ConfigEpDma(void __iomem *usbc_base_addr)
+{
+	__u16 ep_csr = 0;
+
+	/* auto_set, tx_mode, dma_tx_en, mode1 */
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr |= (1 << USBC_BP_TXCSR_D_AUTOSET) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_D_MODE) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_D_DMA_REQ_EN) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_D_DMA_REQ_MODE) >> 8;
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+}
+
+static void __USBC_Dev_Tx_ClearEpDma(void __iomem *usbc_base_addr)
+{
+	__u16 ep_csr = 0;
+
+	/* auto_set, dma_tx_en, mode1 */
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_D_AUTOSET) >> 8);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_D_DMA_REQ_EN) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+
+	/* DMA_REQ_EN and DMA_REQ_MODE cannot be cleared in the same cycle */
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_D_DMA_REQ_MODE) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+}
+
+static __u32 __USBC_Dev_Tx_IsWriteDataReady(void __iomem *usbc_base_addr)
+{
+	__u32 temp = 0;
+
+	temp = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	temp &= (1 << USBC_BP_TXCSR_D_TX_READY);
+
+	return temp;
+}
+
+static __u32 __USBC_Dev_Tx_IsWriteDataReady_FifoEmpty(
+		void __iomem *usbc_base_addr)
+{
+	__u32 temp = 0;
+
+	temp = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	temp &= (1 << USBC_BP_TXCSR_D_TX_READY)
+			| (1 << USBC_BP_TXCSR_D_FIFO_NOT_EMPTY);
+
+	return temp;
+}
+
+
+static void __USBC_Dev_Tx_WriteDataHalf(void __iomem *usbc_base_addr)
+{
+	__u16 ep_csr = 0;
+
+	ep_csr = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	ep_csr |= 1 << USBC_BP_TXCSR_D_TX_READY;
+	ep_csr &= ~(1 << USBC_BP_TXCSR_D_UNDER_RUN);
+	USBC_Writew(ep_csr, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_WriteDataComplete(void __iomem *usbc_base_addr)
+{
+	__u16 ep_csr = 0;
+
+	ep_csr = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	ep_csr |= 1 << USBC_BP_TXCSR_D_TX_READY;
+	ep_csr &= ~(1 << USBC_BP_TXCSR_D_UNDER_RUN);
+	USBC_Writew(ep_csr, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_SendStall(void __iomem *usbc_base_addr)
+{
+	/* send stall, and fifo is flushed automatically */
+	USBC_REG_set_bit_w(USBC_BP_TXCSR_D_SEND_STALL,
+			USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_Tx_IsEpStall(void __iomem *usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_TXCSR_D_SENT_STALL,
+				USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_ClearStall(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val;
+
+	reg_val = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	reg_val &= ~((1 << USBC_BP_TXCSR_D_SENT_STALL)
+				|(1 << USBC_BP_TXCSR_D_SEND_STALL));
+	USBC_Writew(reg_val, USBC_REG_TXCSR(usbc_base_addr));
+
+	/* clear data toggle */
+	USBC_REG_set_bit_w(USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_EnableIsoEp(void __iomem *usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_RXCSR_D_ISO,
+			USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_EnableIntEp(void __iomem *usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_RXCSR_D_ISO,
+			USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_EnableBulkEp(void __iomem *usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_RXCSR_D_ISO,
+			USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_ConfigEp_Default(void __iomem *usbc_base_addr)
+{
+	/* --<1>--clear tx csr */
+	USBC_Writew(0x00, USBC_REG_RXCSR(usbc_base_addr));
+
+	/* --<2>--clear tx ep max packet */
+	USBC_Writew(0x00, USBC_REG_RXMAXP(usbc_base_addr));
+
+	/* --<3>--config ep transfer type */
+}
+
+static void __USBC_Dev_Rx_ConfigEp(void __iomem *usbc_base_addr,
+		__u32 ts_type, __u32 is_double_fifo, __u32 ep_MaxPkt)
+{
+	__u16 reg_val = 0;
+	__u16 temp = 0;
+
+	/* --<1>--config tx csr */
+	USBC_Writew((1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE)
+			| (1 << USBC_BP_RXCSR_D_FLUSH_FIFO),
+	USBC_REG_RXCSR(usbc_base_addr));
+
+	if (is_double_fifo) {
+		USBC_Writew((1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE)
+				| (1 << USBC_BP_RXCSR_D_FLUSH_FIFO),
+		USBC_REG_RXCSR(usbc_base_addr));
+	}
+
+	if (ts_type == USBC_TS_TYPE_INT)
+		USBC_Writew(1 << USBC_BP_RXCSR_D_DISABLE_NYET,
+		USBC_REG_RXCSR(usbc_base_addr));
+
+	/* --<2>--config tx ep max packet */
+	reg_val = USBC_Readw(USBC_REG_RXMAXP(usbc_base_addr));
+	temp    = ep_MaxPkt & ((1 << USBC_BP_RXMAXP_PACKET_COUNT) - 1);
+	reg_val |= temp;
+	USBC_Writew(reg_val, USBC_REG_RXMAXP(usbc_base_addr));
+
+	/* --<3>--config ep transfer type */
+	switch (ts_type) {
+	case USBC_TS_TYPE_ISO:
+		__USBC_Dev_Rx_EnableIsoEp(usbc_base_addr);
+		break;
+
+	case USBC_TS_TYPE_INT:
+		__USBC_Dev_Rx_EnableIntEp(usbc_base_addr);
+		break;
+
+	case USBC_TS_TYPE_BULK:
+		__USBC_Dev_Rx_EnableBulkEp(usbc_base_addr);
+		break;
+
+	default:
+		__USBC_Dev_Rx_EnableBulkEp(usbc_base_addr);
+	}
+}
+
+static void __USBC_Dev_Rx_ConfigEpDma(void __iomem *usbc_base_addr)
+{
+	__u16 ep_csr = 0;
+
+	/* auto_clear, dma_rx_en, mode0 */
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+	ep_csr |= ((1 << USBC_BP_RXCSR_D_DMA_REQ_MODE) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+	ep_csr |= ((1 << USBC_BP_RXCSR_D_AUTO_CLEAR) >> 8);
+	ep_csr |= ((1 << USBC_BP_RXCSR_D_DMA_REQ_EN) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_D_DMA_REQ_MODE) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+	ep_csr |= ((1 << USBC_BP_RXCSR_D_DMA_REQ_MODE) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+}
+
+static void __USBC_Dev_Rx_ClearEpDma(void __iomem *usbc_base_addr)
+{
+	__u16 ep_csr = 0;
+
+	/* auto_clear, dma_rx_en, mode0 */
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+
+	ep_csr &= ~((1 << USBC_BP_RXCSR_D_AUTO_CLEAR) >> 8);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_D_DMA_REQ_MODE) >> 8);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_D_DMA_REQ_EN) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+}
+
+static __u32 __USBC_Dev_Rx_IsReadDataReady(void __iomem *usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_RXCSR_D_RX_PKT_READY,
+				USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_ReadDataHalf(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	/* overrun, dataerr is used in iso transfer */
+	reg_val = USBC_Readw(USBC_REG_RXCSR(usbc_base_addr));
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_RX_PKT_READY);
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_OVERRUN);
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_DATA_ERROR);
+	USBC_Writew(reg_val, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_ReadDataComplete(void __iomem *usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	/* overrun, dataerr is used in iso transfer */
+	reg_val = USBC_Readw(USBC_REG_RXCSR(usbc_base_addr));
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_RX_PKT_READY);
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_OVERRUN);
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_DATA_ERROR);
+	USBC_Writew(reg_val, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_SendStall(void __iomem *usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_RXCSR_D_SEND_STALL,
+			USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_Rx_IsEpStall(void __iomem *usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_RXCSR_D_SENT_STALL,
+			USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_ClearStall(void __iomem *usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_RXCSR_D_SEND_STALL,
+			USBC_REG_RXCSR(usbc_base_addr));
+	USBC_REG_clear_bit_w(USBC_BP_RXCSR_D_SENT_STALL,
+			USBC_REG_RXCSR(usbc_base_addr));
+
+	/* clear data toggle */
+	USBC_REG_set_bit_w(USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_ClearDma_Trans(void __iomem *usbc_base_addr)
+{
+	/**
+	 * in SUN8IW5, SUN8IW6 and later ic, this bit is fix to 1, set when
+	 * drv initialize;
+	 * in SUN8IW5, SUN8IW6 former ic, we donot use inner dma, so this bit
+	 * should be 0.
+	 */
+}
+
+static void __USBC_Dev_ConfigDma_Trans(void __iomem *usbc_base_addr)
+{
+	/**
+	 * in SUN8IW5 and later ic, this bit is fix to 1, set when drv
+	 * initialize, so donot set here;
+	 * in SUN8IW5 former ic(eg SUN8IW3), we donot use inner dma(use cpu
+	 * or outer dma), this bit should be 0, so cannot set here.
+	 */
+}
+
+/**
+ * clear the address allocated by host for device
+ * @hUSB: handle return by USBC_open_otg, include the key data which USBC need
+ */
+void USBC_Dev_SetAddress_default(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_Writeb(0x00, USBC_REG_FADDR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_Dev_SetAddress_default);
+
+/**
+ * set the address
+ * @hUSB: handle return by USBC_open_otg, include the key data which USBC need
+ */
+void USBC_Dev_SetAddress(__hdle hUSB, __u8 address)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	USBC_Writeb(address, USBC_REG_FADDR(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_Dev_SetAddress);
+
+__u32 USBC_Dev_QueryTransferMode(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return USBC_TS_MODE_UNKNOWN;
+
+	if (USBC_REG_test_bit_b(USBC_BP_POWER_D_HIGH_SPEED_FLAG,
+			USBC_REG_PCTL(usbc_otg->base_addr)))
+		return USBC_TS_MODE_HS;
+	else
+		return USBC_TS_MODE_FS;
+}
+EXPORT_SYMBOL(USBC_Dev_QueryTransferMode);
+
+/**
+ * config the device's transfer type and speed mode
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ts_type:    transfer type
+ * @speed_mode: speed mode
+ */
+void USBC_Dev_ConfigTransferMode(__hdle hUSB, __u8 ts_type, __u8 speed_mode)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	/* --<1>--select the transfer type */
+	/* default bulk transfer */
+	switch (ts_type) {
+	case USBC_TS_TYPE_CTRL:
+		__USBC_Dev_TsType_Ctrl(usbc_otg->base_addr);
+		break;
+
+	case USBC_TS_TYPE_ISO:
+		__USBC_Dev_TsType_Iso(usbc_otg->base_addr);
+		break;
+
+	case USBC_TS_TYPE_INT:
+		__USBC_Dev_TsType_Int(usbc_otg->base_addr);
+		break;
+
+	case USBC_TS_TYPE_BULK:
+		__USBC_Dev_TsType_Bulk(usbc_otg->base_addr);
+		break;
+
+	default:
+		__USBC_Dev_TsType_default(usbc_otg->base_addr);
+	}
+
+	/* --<2>--select the transfer speed */
+	switch (speed_mode) {
+	case USBC_TS_MODE_HS:
+		__USBC_Dev_TsMode_Hs(usbc_otg->base_addr);
+		break;
+
+	case USBC_TS_MODE_FS:
+		__USBC_Dev_TsMode_Fs(usbc_otg->base_addr);
+		break;
+
+	case USBC_TS_MODE_LS:
+		__USBC_Dev_TsMode_Ls(usbc_otg->base_addr);
+		break;
+
+	default:
+		__USBC_Dev_TsMode_default(usbc_otg->base_addr);
+	}
+}
+EXPORT_SYMBOL(USBC_Dev_ConfigTransferMode);
+
+/**
+ * the switch to communicate with PC
+ * @hUSB:     handle return by USBC_open_otg,
+ *            include the key data which USBC need
+ * @is_on:    1 - open the switch, 0 - close the switch
+ *
+ */
+void USBC_Dev_ConectSwitch(__hdle hUSB, __u32 is_on)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	if (is_on == USBC_DEVICE_SWITCH_ON)
+		USBC_REG_set_bit_b(USBC_BP_POWER_D_SOFT_CONNECT,
+				USBC_REG_PCTL(usbc_otg->base_addr));
+	else
+		USBC_REG_clear_bit_b(USBC_BP_POWER_D_SOFT_CONNECT,
+				USBC_REG_PCTL(usbc_otg->base_addr));
+}
+EXPORT_SYMBOL(USBC_Dev_ConectSwitch);
+
+/**
+ * query current device's status, eg reset, resume, suspend, etc.
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ *
+ */
+__u32 USBC_Dev_QueryPowerStatus(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	return (USBC_Readb(USBC_REG_PCTL(usbc_otg->base_addr)) & 0x0f);
+}
+EXPORT_SYMBOL(USBC_Dev_QueryPowerStatus);
+
+/**
+ * config EP, include double fifo, max packet size, etc.
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    transfer type
+ * @is_double_fifo: speed mode
+ * @ep_MaxPkt:  max packet size
+ *
+ */
+__s32 USBC_Dev_ConfigEp(__hdle hUSB,
+		__u32 ts_type, __u32 ep_type,
+		__u32 is_double_fifo, __u32 ep_MaxPkt)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_ConfigEp0(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_ConfigEp(usbc_otg->base_addr,
+				ts_type, is_double_fifo,  ep_MaxPkt);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_ConfigEp(usbc_otg->base_addr,
+				ts_type, is_double_fifo, ep_MaxPkt);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_ConfigEp);
+
+/**
+ * release all Ep resources, excpet irq
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ *
+ * return: 0 - success, !0 - failed
+ */
+__s32 USBC_Dev_ConfigEp_Default(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_ConfigEp0_Default(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_ConfigEp_Default(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_ConfigEp_Default(usbc_otg->base_addr);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_ConfigEp_Default);
+
+/**
+ * config  Ep's dma
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ *
+ * return: 0 - success, !0 - failed
+ */
+__s32 USBC_Dev_ConfigEpDma(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		/* not support */
+		return -1;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_ConfigEpDma(usbc_otg->base_addr);
+		__USBC_Dev_ConfigDma_Trans(usbc_otg->base_addr);
+	break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_ConfigEpDma(usbc_otg->base_addr);
+		__USBC_Dev_ConfigDma_Trans(usbc_otg->base_addr);
+	break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_ConfigEpDma);
+
+/**
+ * clear  Ep's dma configuration
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ *
+ * return: 0 - success, !0 - failed
+ */
+__s32 USBC_Dev_ClearEpDma(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		/* not support */
+		return -1;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_ClearEpDma(usbc_otg->base_addr);
+		__USBC_Dev_ClearDma_Trans(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_ClearEpDma(usbc_otg->base_addr);
+		__USBC_Dev_ClearDma_Trans(usbc_otg->base_addr);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_ClearEpDma);
+
+/**
+ * check if ep is stalled
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ *
+ * return: 0 - success, !0 - failed
+ */
+__s32 USBC_Dev_IsEpStall(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_IsEpStall(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_IsEpStall(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_IsEpStall(usbc_otg->base_addr);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_IsEpStall);
+
+/**
+ * let ep enter stall status
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ *
+ * return: 0 - success, !0 - failed
+ */
+__s32 USBC_Dev_EpSendStall(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_SendStall(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_SendStall(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_SendStall(usbc_otg->base_addr);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_EpSendStall);
+
+/**
+ * clear the ep's stall status
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ *
+ * return: 0 - success, !0 - failed
+ */
+__s32 USBC_Dev_EpClearStall(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_ClearStall(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_ClearStall(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_ClearStall(usbc_otg->base_addr);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_EpClearStall);
+
+/**
+ * check if ep0 is SetupEnd
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ *
+ */
+__u32 USBC_Dev_Ctrl_IsSetupEnd(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	return __USBC_Dev_ep0_IsSetupEnd(usbc_otg->base_addr);
+}
+EXPORT_SYMBOL(USBC_Dev_Ctrl_IsSetupEnd);
+
+/**
+ * clear the ep0's SetupEnd status
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ *
+ */
+void USBC_Dev_Ctrl_ClearSetupEnd(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	__USBC_Dev_ep0_ClearSetupEnd(usbc_otg->base_addr);
+}
+EXPORT_SYMBOL(USBC_Dev_Ctrl_ClearSetupEnd);
+
+static __s32 __USBC_Dev_WriteDataHalf(void __iomem *usbc_base_addr,
+		__u32 ep_type)
+{
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_WriteDataHalf(usbc_base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_WriteDataHalf(usbc_base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		/* not support */
+		return -1;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+static __s32 __USBC_Dev_WriteDataComplete(void __iomem *usbc_base_addr,
+		__u32 ep_type)
+{
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_WriteDataComplete(usbc_base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_WriteDataComplete(usbc_base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		/* not support */
+		return -1;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+static __s32 __USBC_Dev_ReadDataHalf(void __iomem *usbc_base_addr,
+		__u32 ep_type)
+{
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_ReadDataHalf(usbc_base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		/* not support */
+		return -1;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_ReadDataHalf(usbc_base_addr);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+static __s32 __USBC_Dev_ReadDataComplete(void __iomem *usbc_base_addr,
+		__u32 ep_type)
+{
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_ReadDataComplete(usbc_base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		/* not support */
+		return -1;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_ReadDataComplete(usbc_base_addr);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * get the write status, eg write over or not
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ * @complete:   if all data has been written over.
+ *
+ * return: 0 - success, !0 - failed
+ */
+__s32 USBC_Dev_WriteDataStatus(__hdle hUSB,
+		__u32 ep_type, __u32 complete)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	if (complete)
+		return __USBC_Dev_WriteDataComplete(
+				usbc_otg->base_addr, ep_type);
+	else
+		return __USBC_Dev_WriteDataHalf(
+				usbc_otg->base_addr, ep_type);
+}
+EXPORT_SYMBOL(USBC_Dev_WriteDataStatus);
+
+/**
+ * get the read status, eg write over or not
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ * @complete:   if all data has been read over.
+ *
+ * return: 0 - success, !0 - failed
+ */
+__s32 USBC_Dev_ReadDataStatus(__hdle hUSB,
+		__u32 ep_type, __u32 complete)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	if (complete)
+		return __USBC_Dev_ReadDataComplete(
+					usbc_otg->base_addr, ep_type);
+	else
+		return __USBC_Dev_ReadDataHalf(
+					usbc_otg->base_addr, ep_type);
+}
+EXPORT_SYMBOL(USBC_Dev_ReadDataStatus);
+
+/**
+ * check if the data ready for reading
+ * @hUSB:       handle return by USBC_open_otg,
+ *              include the key data which USBC need
+ * @ep_type:    ep type
+ *
+ */
+__u32 USBC_Dev_IsReadDataReady(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		return __USBC_Dev_ep0_IsReadDataReady(usbc_otg->base_addr);
+
+	case USBC_EP_TYPE_TX:
+		/* not support */
+		break;
+
+	case USBC_EP_TYPE_RX:
+		return __USBC_Dev_Rx_IsReadDataReady(usbc_otg->base_addr);
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_IsReadDataReady);
+
+/**
+ * check if the data ready for writing
+ * @hUSB:       handle return by USBC_open_otg,
+ * include the key data which USBC need
+ * @ep_type:    ep type
+ *
+ */
+__u32 USBC_Dev_IsWriteDataReady(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		return __USBC_Dev_ep0_IsWriteDataReady(usbc_otg->base_addr);
+
+	case USBC_EP_TYPE_TX:
+		return __USBC_Dev_Tx_IsWriteDataReady(usbc_otg->base_addr);
+
+	case USBC_EP_TYPE_RX:
+		/* not support */
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_IsWriteDataReady);
+
+__u32 USBC_Dev_IsWriteDataReady_FifoEmpty(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return 0;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		return __USBC_Dev_ep0_IsWriteDataReady(usbc_otg->base_addr);
+
+	case USBC_EP_TYPE_TX:
+		return __USBC_Dev_Tx_IsWriteDataReady_FifoEmpty(
+						usbc_otg->base_addr);
+
+	case USBC_EP_TYPE_RX:
+		/* not support */
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+
+
+/**
+ * configure the device's transfer type and speed mode.
+ * @hUSB:       handle return by USBC_open_otg,
+ * include the key data which USBC need
+ *
+ */
+__s32 USBC_Dev_IsoUpdateEnable(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return -1;
+
+	__USBC_Dev_TsType_Iso(usbc_otg->base_addr);
+	return 0;
+}
+EXPORT_SYMBOL(USBC_Dev_IsoUpdateEnable);
+
+static void __USBC_Dev_ep0_FlushFifo(void __iomem *usbc_base_addr)
+{
+	USBC_Writew(1 << USBC_BP_CSR0_D_FLUSH_FIFO,
+			USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_FlushFifo(void __iomem *usbc_base_addr)
+{
+	USBC_Writew((1 << USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE)
+			| (1 << USBC_BP_TXCSR_D_FLUSH_FIFO),
+	USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_FlushFifo(void __iomem *usbc_base_addr)
+{
+	USBC_Writew((1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE)
+			| (1 << USBC_BP_RXCSR_D_FLUSH_FIFO),
+			USBC_REG_RXCSR(usbc_base_addr));
+}
+
+void USBC_Dev_FlushFifo(__hdle hUSB, __u32 ep_type)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	switch (ep_type) {
+	case USBC_EP_TYPE_EP0:
+		__USBC_Dev_ep0_FlushFifo(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_TX:
+		__USBC_Dev_Tx_FlushFifo(usbc_otg->base_addr);
+		break;
+
+	case USBC_EP_TYPE_RX:
+		__USBC_Dev_Rx_FlushFifo(usbc_otg->base_addr);
+		break;
+
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(USBC_Dev_FlushFifo);
+
+__u32 USBC_Phyx_Read(__hdle hUSB)
+{
+	__u32 reg_value = 0;
+	__u32 temp = 0;
+	__u32 ptmp = 0;
+	__u32 ret = 0;
+
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL) {
+		DMSG_PANIC("ERR: usbc_otg is null!");
+		return -1;
+	}
+
+	reg_value = USBC_Readl(usbc_otg->base_addr + USBC_REG_o_PHYTUNE);
+	reg_value &= 0xf3f;
+	ptmp = reg_value;
+
+	temp = reg_value >> 8;
+	ptmp &= ~((0xf << 8) | (0xf << 4));
+	ptmp <<= 6;
+	reg_value &= ~((0xf << 8) | (0xf << 0));
+	ret = reg_value | ptmp | temp;
+	DMSG_INFO("bit[3:0]VREF = 0x%x; bit[5:4]RISE = 0x%x; bit[7:6]PREEMPAMP = 0x%x; bit[9:8]RES = 0x%x\n",
+			temp, reg_value >> 4, (ptmp >> 6) & 0x3,
+			((ptmp >> 6)  & 0xc) >> 2);
+
+	return ret;
+}
+EXPORT_SYMBOL(USBC_Phyx_Read);
+
+
+void USBC_Phyx_Write(__hdle hUSB, __u32 data)
+{
+	__u32 reg_value = 0;
+	__u32 temp = 0;
+	__u32 dtmp = 0;
+
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (usbc_otg == NULL)
+		return;
+
+	temp = dtmp  = data;
+	reg_value = USBC_Readl(usbc_otg->base_addr + USBC_REG_o_PHYTUNE);
+	/*TXVREFTUNE + TXRISETUNE + TXPREEMPAMPTUNE + TXRESTUNE*/
+	reg_value &= ~((0xf << 8) | (0x3 << 4) | (0xf << 0));
+	temp &= ~((0xf << 4) | (0x3 << 8) | (0x1 << 10));
+	reg_value |= temp << 8;
+	dtmp &= ~((0xf << 6) | (0xf << 0) | (0x1 << 10));
+	reg_value |= dtmp;
+	data &= ~((0x3 << 4) | (0xf << 0) | (0x1 << 10));
+	reg_value |= data >> 6;
+
+	USBC_Writel(reg_value, (usbc_otg->base_addr + USBC_REG_o_PHYTUNE));
+}
+EXPORT_SYMBOL(USBC_Phyx_Write);
diff --git a/drivers/usb/sunxi_usb/usbc/usbc_i.h b/drivers/usb/sunxi_usb/usbc/usbc_i.h
new file mode 100644
index 000000000..15f9d9c7b
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc_i.h
@@ -0,0 +1,57 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc_i.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel, 2009.09.15
+ *
+ * usb common ops.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __USBC_I_H__
+#define __USBC_I_H__
+
+#include "../include/sunxi_usb_config.h"
+
+#define  USBC_MAX_OPEN_NUM    1
+
+void __iomem *get_otgc_vbase(void);
+
+/* record USB common info */
+typedef struct __fifo_info {
+	void __iomem *port0_fifo_addr;
+	__u32 port0_fifo_size;
+
+	void __iomem *port1_fifo_addr;
+	__u32 port1_fifo_size;
+
+	void __iomem *port2_fifo_addr;
+	__u32 port2_fifo_size;
+} __fifo_info_t;
+
+/* record current USB port's all hardware info */
+typedef struct __usbc_otg {
+	__u32 port_num;
+	void __iomem *base_addr;	/* usb base address */
+
+	__u32 used;			/* is used or not */
+	__u32 no;			/* index in manager table */
+} __usbc_otg_t;
+
+
+/* PHYS EFUSE offest */
+#define EFUSE_OFFSET					0x18		//esuse offset
+#define SUNXI_USB_PHY_EFUSE_ADJUST      0x10000     //bit16
+#define SUNXI_USB_PHY_EFUSE_MODE        0x20000     //bit17
+#define SUNXI_USB_PHY_EFUSE_RES         0x3C0000    //bit18-21
+#define SUNXI_USB_PHY_EFUSE_COM         0x1C00000   //bit22-24
+#define SUNXI_USB_PHY_EFUSE_USB0TX      0x1C00000   //bit22-24
+#define SUNXI_USB_PHY_EFUSE_USB1TX		0xE000000   //bit25-27
+
+#endif /* __USBC_I_H__ */
+
diff --git a/drivers/usb/sunxi_usb/usbc/usbc_phy.c b/drivers/usb/sunxi_usb/usbc/usbc_phy.c
new file mode 100644
index 000000000..6a0c9e1fc
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc_phy.c
@@ -0,0 +1,408 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc_phy.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel, 2009.10.21
+ *
+ * usb common ops.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include  "usbc_i.h"
+#include "linux/sunxi-sid.h"
+
+/**
+ * define USB PHY controller reg bit
+ */
+
+/* Common Control Bits for Both PHYs */
+#define  USBC_PHY_PLL_BW			0x03
+#define  USBC_PHY_RES45_CAL_EN			0x0c
+
+/* Private Control Bits for Each PHY */
+#define  USBC_PHY_TX_AMPLITUDE_TUNE		0x20
+#define  USBC_PHY_TX_SLEWRATE_TUNE		0x22
+#define  USBC_PHY_VBUSVALID_TH_SEL		0x25
+#define  USBC_PHY_PULLUP_RES_SEL		0x27
+#define  USBC_PHY_OTG_FUNC_EN			0x28
+#define  USBC_PHY_VBUS_DET_EN			0x29
+#define  USBC_PHY_DISCON_TH_SEL			0x2a
+
+/* usb PHY common set, initialize */
+void USBC_PHY_SetCommonConfig(void)
+{
+}
+
+/**
+ * usb PHY specific set
+ * @hUSB: handle returned by USBC_open_otg,
+ *        include some key data that the USBC need.
+ *
+ */
+void USBC_PHY_SetPrivateConfig(__hdle hUSB)
+{
+}
+
+/**
+ * get PHY's common setting. for debug, to see if PHY is set correctly.
+ *
+ * return the 32bit usb PHY common setting value.
+ */
+__u32 USBC_PHY_GetCommonConfig(void)
+{
+	__u32 reg_val = 0;
+
+	return reg_val;
+}
+
+/**
+ * write usb PHY0's phy reg setting. mainly for phy0 standby.
+ *
+ * return the data wrote
+ */
+static __u32 usb_phy0_write(__u32 addr,
+		__u32 data, __u32 dmask, void __iomem *usbc_base_addr)
+{
+	__u32 i = 0;
+
+	data = data & 0x0f;
+	addr = addr & 0x0f;
+	dmask = dmask & 0x0f;
+
+	USBC_Writeb((dmask<<4)|data, usbc_base_addr + 0x404 + 2);
+	USBC_Writeb(addr|0x10, usbc_base_addr + 0x404);
+	for (i = 0; i < 5 ; i++)
+		;
+	USBC_Writeb(addr|0x30, usbc_base_addr + 0x404);
+	for (i = 0 ; i < 5 ; i++)
+		;
+	USBC_Writeb(addr|0x10, usbc_base_addr + 0x404);
+	for (i = 0 ; i < 5 ; i++)
+		;
+
+	return (USBC_Readb(usbc_base_addr + 0x404 + 3) & 0x0f);
+}
+
+/**
+ * Standby the usb phy with the input usb phy index number
+ * @phy_index: usb phy index number, which used to select the phy to standby
+ *
+ */
+void USBC_phy_Standby(__hdle hUSB, __u32 phy_index)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if (phy_index == 0) {
+		usb_phy0_write(0xB, 0x8, 0xf, usbc_otg->base_addr);
+		usb_phy0_write(0x7, 0xf, 0xf, usbc_otg->base_addr);
+		usb_phy0_write(0x1, 0xf, 0xf, usbc_otg->base_addr);
+		usb_phy0_write(0x2, 0xf, 0xf, usbc_otg->base_addr);
+	}
+}
+
+/**
+ * Recover the standby phy with the input index number
+ * @phy_index: usb phy index number
+ *
+ */
+void USBC_Phy_Standby_Recover(__hdle hUSB, __u32 phy_index)
+{
+	__u32 i;
+
+	if (phy_index == 0) {
+		for (i = 0; i < 0x10; i++)
+			;
+	}
+}
+
+static __u32 USBC_Phy_TpWrite(__u32 usbc_no, __u32 addr, __u32 data, __u32 len)
+{
+	void __iomem *otgc_base = NULL;
+	void __iomem *phyctl_val = NULL;
+	__u32 temp = 0, dtmp = 0;
+	__u32 j = 0;
+
+	otgc_base = get_otgc_vbase();
+	if (otgc_base == NULL)
+		return 0;
+
+	phyctl_val = otgc_base + USBPHYC_REG_o_PHYCTL;
+
+	dtmp = data;
+	for (j = 0; j < len; j++) {
+		/* set the bit address to be write */
+		temp = USBC_Readl(phyctl_val);
+		temp &= ~(0xff << 8);
+		temp |= ((addr + j) << 8);
+		USBC_Writel(temp, phyctl_val);
+
+		temp = USBC_Readb(phyctl_val);
+		temp &= ~(0x1 << 7);
+		temp |= (dtmp & 0x1) << 7;
+		temp &= ~(0x1 << (usbc_no << 1));
+		USBC_Writeb(temp, phyctl_val);
+
+		temp = USBC_Readb(phyctl_val);
+		temp |= (0x1 << (usbc_no << 1));
+		USBC_Writeb(temp, phyctl_val);
+
+		temp = USBC_Readb(phyctl_val);
+		temp &= ~(0x1 << (usbc_no << 1));
+		USBC_Writeb(temp, phyctl_val);
+		dtmp >>= 1;
+	}
+
+	return data;
+}
+
+static __u32 USBC_Phy_Write(__u32 usbc_no, __u32 addr, __u32 data, __u32 len)
+{
+	return USBC_Phy_TpWrite(usbc_no, addr, data, len);
+}
+
+void UsbPhyCtl(void __iomem *regs)
+{
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(regs + USBPHYC_REG_o_PHYCTL);
+	reg_val |= (0x01 << USBC_PHY_CTL_VBUSVLDEXT);
+	USBC_Writel(reg_val, (regs + USBPHYC_REG_o_PHYCTL));
+}
+
+void USBC_PHY_Set_Ctl(void __iomem *regs, __u32 mask)
+{
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(regs + USBPHYC_REG_o_PHYCTL);
+	reg_val |= (0x01 << mask);
+	USBC_Writel(reg_val, (regs + USBPHYC_REG_o_PHYCTL));
+}
+
+void USBC_PHY_Clear_Ctl(void __iomem *regs, __u32 mask)
+{
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(regs + USBPHYC_REG_o_PHYCTL);
+	reg_val &= ~(0x01 << mask);
+	USBC_Writel(reg_val, (regs + USBPHYC_REG_o_PHYCTL));
+}
+
+void UsbPhyInit(__u32 usbc_no)
+{
+
+	/* adjust the 45 ohm resistor */
+	if (usbc_no == 0)
+		USBC_Phy_Write(usbc_no, 0x0c, 0x01, 1);
+
+	/* adjust USB0 PHY range and rate */
+	USBC_Phy_Write(usbc_no, 0x20, 0x14, 5);
+
+	/* adjust disconnect threshold */
+	USBC_Phy_Write(usbc_no, 0x2a, 3, 2);
+	/* by wangjx */
+}
+
+void UsbPhyEndReset(__u32 usbc_no)
+{
+	int i;
+
+	if (usbc_no == 0) {
+		/**
+		 * Disable Sequelch Detect for a while
+		 * before Release USB Reset.
+		 */
+		USBC_Phy_Write(usbc_no, 0x3c, 0x2, 2);
+		for (i = 0; i < 0x100; i++)
+			;
+		USBC_Phy_Write(usbc_no, 0x3c, 0x0, 2);
+	}
+}
+
+void usb_otg_phy_txtune(void __iomem *regs)
+{
+	__u32 reg_val = 0;
+
+	reg_val = USBC_Readl(regs + USBC_REG_o_PHYTUNE);
+#if defined(CONFIG_ARCH_SUN8IW18)
+	reg_val |= (0x01 << 1);
+#else
+	reg_val |= 0x03 << 2;	/* TXRESTUNE */
+#endif
+	reg_val &= ~(0xf << 8);
+	reg_val |= 0xc << 8;	/* TXVREFTUNE */
+	USBC_Writel(reg_val, (regs + USBC_REG_o_PHYTUNE));
+}
+
+/*for new phy*/
+static int usbc_new_phyx_tp_write(void __iomem *regs,
+		int addr, int data, int len)
+{
+	int temp = 0;
+	int j = 0;
+	int dtmp = 0;
+
+	/*device: 0x410(phy_ctl)*/
+	dtmp = data;
+
+	for (j = 0; j < len; j++) {
+
+		temp = USBC_Readb(regs + USBPHYC_REG_o_PHYCTL);
+		temp |= (0x1 << 1);
+		USBC_Writeb(temp, regs + USBPHYC_REG_o_PHYCTL);
+
+		USBC_Writeb(addr + j, regs + USBPHYC_REG_o_PHYCTL + 1);
+
+		temp = USBC_Readb(regs + USBPHYC_REG_o_PHYCTL);
+		temp &= ~(0x1 << 0);
+		USBC_Writeb(temp, regs + USBPHYC_REG_o_PHYCTL);
+
+		temp = USBC_Readb(regs + USBPHYC_REG_o_PHYCTL);
+		temp &= ~(0x1 << 7);
+		temp |= (dtmp & 0x1) << 7;
+		USBC_Writeb(temp, regs + USBPHYC_REG_o_PHYCTL);
+
+		temp |= (0x1 << 0);
+		USBC_Writeb(temp, regs + USBPHYC_REG_o_PHYCTL);
+
+		temp &= ~(0x1 << 0);
+		USBC_Writeb(temp, regs + USBPHYC_REG_o_PHYCTL);
+
+		temp = USBC_Readb(regs + USBPHYC_REG_o_PHYCTL);
+		temp &= ~(0x1 << 1);
+		USBC_Writeb(temp, regs + USBPHYC_REG_o_PHYCTL);
+
+		dtmp >>= 1;
+	}
+
+	return 0;
+}
+
+static int usbc_new_phyx_tp_read(void __iomem *regs, int addr, int len)
+{
+	int temp = 0;
+	int i = 0;
+	int j = 0;
+	int ret = 0;
+
+	temp = USBC_Readb(regs + USBPHYC_REG_o_PHYCTL);
+	temp |= (0x1 << 1);
+	USBC_Writeb(temp, regs + USBPHYC_REG_o_PHYCTL);
+
+	for (j = len; j > 0; j--) {
+		USBC_Writeb((addr + j - 1), regs + USBPHYC_REG_o_PHYCTL + 1);
+
+		for (i = 0; i < 0x4; i++)
+			;
+
+		temp = USBC_Readb(regs + USBC_REG_o_PHYSTATUS);
+		ret <<= 1;
+		ret |= (temp & 0x1);
+	}
+
+	temp = USBC_Readb(regs + USBPHYC_REG_o_PHYCTL);
+	temp &= ~(0x1 << 1);
+	USBC_Writeb(temp, regs + USBPHYC_REG_o_PHYCTL);
+
+	return ret;
+}
+
+
+void usbc_new_phy_init(void __iomem *regs)
+{
+	int value = 0;
+	u32 efuse_val  = 0;
+
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x03, 0x06,
+			usbc_new_phyx_tp_read(regs, 0x03, 0x06));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x16, 0x03,
+			usbc_new_phyx_tp_read(regs, 0x16, 0x03));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x0b, 0x08,
+			usbc_new_phyx_tp_read(regs, 0x0b, 0x08));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x09, 0x03,
+			usbc_new_phyx_tp_read(regs, 0x09, 0x03));
+
+	sunxi_get_module_param_from_sid(&efuse_val, EFUSE_OFFSET, 4);
+	pr_debug("efuse_val:0x%x\n", efuse_val);
+
+	usbc_new_phyx_tp_write(regs, 0x1c, 0x0, 0x03);
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x1c, 0x03,
+			usbc_new_phyx_tp_read(regs, 0x1c, 0x03));
+
+	if (efuse_val & SUNXI_USB_PHY_EFUSE_ADJUST) {
+		if (efuse_val & SUNXI_USB_PHY_EFUSE_MODE) {
+			/* iref mode */
+			usbc_new_phyx_tp_write(regs, 0x60, 0x1, 0x01);
+
+			/* usbc-0 */
+			value = (efuse_val & SUNXI_USB_PHY_EFUSE_USB0TX) >> 22;
+			usbc_new_phyx_tp_write(regs, 0x61, value, 0x03);
+
+			value = (efuse_val & SUNXI_USB_PHY_EFUSE_RES) >> 18;
+			usbc_new_phyx_tp_write(regs, 0x44, value, 0x04);
+
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x60, 0x01,
+				usbc_new_phyx_tp_read(regs, 0x60, 0x01));
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x61, 0x03,
+				usbc_new_phyx_tp_read(regs, 0x61, 0x03));
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x44, 0x04,
+				usbc_new_phyx_tp_read(regs, 0x44, 0x04));
+		} else {
+			/* verf mode */
+			usbc_new_phyx_tp_write(regs, 0x60, 0x0, 0x01);
+
+			value = (efuse_val & SUNXI_USB_PHY_EFUSE_RES) >> 18;
+			usbc_new_phyx_tp_write(regs, 0x44, value, 0x04);
+
+			value = (efuse_val & SUNXI_USB_PHY_EFUSE_COM) >> 22;
+			usbc_new_phyx_tp_write(regs, 0x36, value, 0x03);
+
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x60, 0x01,
+				usbc_new_phyx_tp_read(regs, 0x60, 0x01));
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x44, 0x04,
+				usbc_new_phyx_tp_read(regs, 0x44, 0x04));
+			pr_debug("addr:%x,len:%x,value:%x\n", 0x36, 0x03,
+				usbc_new_phyx_tp_read(regs, 0x36, 0x03));
+		}
+	}
+
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x03, 0x06,
+			usbc_new_phyx_tp_read(regs, 0x03, 0x06));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x16, 0x03,
+			usbc_new_phyx_tp_read(regs, 0x16, 0x03));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x0b, 0x08,
+			usbc_new_phyx_tp_read(regs, 0x0b, 0x08));
+	pr_debug("addr:%x,len:%x,value:%x\n", 0x09, 0x03,
+			usbc_new_phyx_tp_read(regs, 0x09, 0x03));
+}
+
+void usbc_new_phy_res_cal(void __iomem *regs)
+{
+	int value;
+
+	/*clear software res cail*/
+	usbc_new_phyx_tp_write(regs, 0x43, 0x0, 0x01);
+	usbc_new_phyx_tp_write(regs, 0x41, 0x0, 0x01);
+	usbc_new_phyx_tp_write(regs, 0x40, 0x0, 0x01);
+	/*res cail*/
+	usbc_new_phyx_tp_write(regs, 0x40, 0x01, 0x01);
+	mdelay(1);
+	usbc_new_phyx_tp_write(regs, 0x41, 0x01, 0x01);
+
+	while (1) {
+		if (usbc_new_phyx_tp_read(regs, 0x42, 0x01))
+			break;
+	}
+
+	/*set res*/
+	value = usbc_new_phyx_tp_read(regs, 0x49, 0x04);
+	pr_debug("addr:%x,,value:%x\n", 0x49, value);
+	usbc_new_phyx_tp_write(regs, 0x44, value, 0x04);
+	usbc_new_phyx_tp_write(regs, 0x41, 0x0, 0x01);
+	usbc_new_phyx_tp_write(regs, 0x40, 0x0, 0x01);
+	usbc_new_phyx_tp_write(regs, 0x43, 0x01, 0x01);
+}
+
diff --git a/drivers/usb/typec/class.c b/drivers/usb/typec/class.c
index a400b65cf..91d62276b 100644
--- a/drivers/usb/typec/class.c
+++ b/drivers/usb/typec/class.c
@@ -53,6 +53,7 @@ struct typec_port {
 	struct typec_mux		*mux;
 
 	const struct typec_capability	*cap;
+	const struct typec_operations   *ops;
 };
 
 #define to_typec_port(_dev_) container_of(_dev_, struct typec_port, dev)
@@ -955,7 +956,7 @@ preferred_role_store(struct device *dev, struct device_attribute *attr,
 		return -EOPNOTSUPP;
 	}
 
-	if (!port->cap->try_role) {
+	if (!port->ops || !port->ops->try_role) {
 		dev_dbg(dev, "Setting preferred role not supported\n");
 		return -EOPNOTSUPP;
 	}
@@ -968,7 +969,7 @@ preferred_role_store(struct device *dev, struct device_attribute *attr,
 			return -EINVAL;
 	}
 
-	ret = port->cap->try_role(port->cap, role);
+	ret = port->ops->try_role(port, role);
 	if (ret)
 		return ret;
 
@@ -999,7 +1000,7 @@ static ssize_t data_role_store(struct device *dev,
 	struct typec_port *port = to_typec_port(dev);
 	int ret;
 
-	if (!port->cap->dr_set) {
+	if (!port->ops || !port->ops->dr_set) {
 		dev_dbg(dev, "data role swapping not supported\n");
 		return -EOPNOTSUPP;
 	}
@@ -1014,7 +1015,7 @@ static ssize_t data_role_store(struct device *dev,
 		goto unlock_and_ret;
 	}
 
-	ret = port->cap->dr_set(port->cap, ret);
+	ret = port->ops->dr_set(port, ret);
 	if (ret)
 		goto unlock_and_ret;
 
@@ -1049,7 +1050,7 @@ static ssize_t power_role_store(struct device *dev,
 		return -EOPNOTSUPP;
 	}
 
-	if (!port->cap->pr_set) {
+	if (!port->ops || !port->ops->pr_set) {
 		dev_dbg(dev, "power role swapping not supported\n");
 		return -EOPNOTSUPP;
 	}
@@ -1071,7 +1072,7 @@ static ssize_t power_role_store(struct device *dev,
 		goto unlock_and_ret;
 	}
 
-	ret = port->cap->pr_set(port->cap, ret);
+	ret = port->ops->pr_set(port, ret);
 	if (ret)
 		goto unlock_and_ret;
 
@@ -1102,7 +1103,8 @@ port_type_store(struct device *dev, struct device_attribute *attr,
 	int ret;
 	enum typec_port_type type;
 
-	if (!port->cap->port_type_set || port->cap->type != TYPEC_PORT_DRP) {
+	if (port->cap->type != TYPEC_PORT_DRP ||
+	    !port->ops || !port->ops->port_type_set) {
 		dev_dbg(dev, "changing port type not supported\n");
 		return -EOPNOTSUPP;
 	}
@@ -1119,7 +1121,7 @@ port_type_store(struct device *dev, struct device_attribute *attr,
 		goto unlock_and_ret;
 	}
 
-	ret = port->cap->port_type_set(port->cap, type);
+	ret = port->ops->port_type_set(port, type);
 	if (ret)
 		goto unlock_and_ret;
 
@@ -1175,7 +1177,7 @@ static ssize_t vconn_source_store(struct device *dev,
 		return -EOPNOTSUPP;
 	}
 
-	if (!port->cap->vconn_set) {
+	if (!port->ops || !port->ops->vconn_set) {
 		dev_dbg(dev, "VCONN swapping not supported\n");
 		return -EOPNOTSUPP;
 	}
@@ -1184,7 +1186,7 @@ static ssize_t vconn_source_store(struct device *dev,
 	if (ret)
 		return ret;
 
-	ret = port->cap->vconn_set(port->cap, (enum typec_role)source);
+	ret = port->ops->vconn_set(port, (enum typec_role)source);
 	if (ret)
 		return ret;
 
@@ -1278,6 +1280,7 @@ static void typec_release(struct device *dev)
 	ida_destroy(&port->mode_ids);
 	typec_switch_put(port->sw);
 	typec_mux_put(port->mux);
+	kfree(port->cap);
 	kfree(port);
 }
 
@@ -1486,6 +1489,16 @@ EXPORT_SYMBOL_GPL(typec_set_mode);
 
 /* --------------------------------------- */
 
+/**
+ * typec_get_drvdata - Return private driver data pointer
+ * @port: USB Type-C port
+ */
+void *typec_get_drvdata(struct typec_port *port)
+{
+	return dev_get_drvdata(&port->dev);
+}
+EXPORT_SYMBOL_GPL(typec_get_drvdata);
+
 /**
  * typec_port_register_altmode - Register USB Type-C Port Alternate Mode
  * @port: USB Type-C Port that supports the alternate mode
@@ -1579,7 +1592,7 @@ struct typec_port *typec_register_port(struct device *parent,
 	mutex_init(&port->port_type_lock);
 
 	port->id = id;
-	port->cap = cap;
+	port->ops = cap->ops;
 	port->port_type = cap->type;
 	port->prefer_role = cap->prefer_role;
 
@@ -1589,6 +1602,13 @@ struct typec_port *typec_register_port(struct device *parent,
 	port->dev.fwnode = cap->fwnode;
 	port->dev.type = &typec_port_dev_type;
 	dev_set_name(&port->dev, "port%d", id);
+	dev_set_drvdata(&port->dev, cap->driver_data);
+
+	port->cap = kmemdup(cap, sizeof(*cap), GFP_KERNEL);
+	if (!port->cap) {
+		put_device(&port->dev);
+		return ERR_PTR(-ENOMEM);
+	}
 
 	port->sw = typec_switch_get(&port->dev);
 	if (IS_ERR(port->sw)) {
diff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c
index 355a2c7fa..70f749a6a 100644
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -390,12 +390,6 @@ static enum tcpm_state tcpm_default_state(struct tcpm_port *port)
 	return SRC_UNATTACHED;
 }
 
-static inline
-struct tcpm_port *typec_cap_to_tcpm(const struct typec_capability *cap)
-{
-	return container_of(cap, struct tcpm_port, typec_caps);
-}
-
 static bool tcpm_port_is_disconnected(struct tcpm_port *port)
 {
 	return (!port->attached && port->cc1 == TYPEC_CC_OPEN &&
@@ -3996,10 +3990,9 @@ void tcpm_pd_hard_reset(struct tcpm_port *port)
 }
 EXPORT_SYMBOL_GPL(tcpm_pd_hard_reset);
 
-static int tcpm_dr_set(const struct typec_capability *cap,
-		       enum typec_data_role data)
+static int tcpm_dr_set(struct typec_port *p, enum typec_data_role data)
 {
-	struct tcpm_port *port = typec_cap_to_tcpm(cap);
+	struct tcpm_port *port = typec_get_drvdata(p);
 	int ret;
 
 	mutex_lock(&port->swap_lock);
@@ -4064,10 +4057,9 @@ static int tcpm_dr_set(const struct typec_capability *cap,
 	return ret;
 }
 
-static int tcpm_pr_set(const struct typec_capability *cap,
-		       enum typec_role role)
+static int tcpm_pr_set(struct typec_port *p, enum typec_role role)
 {
-	struct tcpm_port *port = typec_cap_to_tcpm(cap);
+	struct tcpm_port *port = typec_get_drvdata(p);
 	int ret;
 
 	mutex_lock(&port->swap_lock);
@@ -4108,10 +4100,9 @@ static int tcpm_pr_set(const struct typec_capability *cap,
 	return ret;
 }
 
-static int tcpm_vconn_set(const struct typec_capability *cap,
-			  enum typec_role role)
+static int tcpm_vconn_set(struct typec_port *p, enum typec_role role)
 {
-	struct tcpm_port *port = typec_cap_to_tcpm(cap);
+	struct tcpm_port *port = typec_get_drvdata(p);
 	int ret;
 
 	mutex_lock(&port->swap_lock);
@@ -4148,9 +4139,9 @@ static int tcpm_vconn_set(const struct typec_capability *cap,
 	return ret;
 }
 
-static int tcpm_try_role(const struct typec_capability *cap, int role)
+static int tcpm_try_role(struct typec_port *p, int role)
 {
-	struct tcpm_port *port = typec_cap_to_tcpm(cap);
+	struct tcpm_port *port = typec_get_drvdata(p);
 	struct tcpc_dev	*tcpc = port->tcpc;
 	int ret = 0;
 
@@ -4357,10 +4348,9 @@ static void tcpm_init(struct tcpm_port *port)
 	tcpm_set_state(port, PORT_RESET, 0);
 }
 
-static int tcpm_port_type_set(const struct typec_capability *cap,
-			      enum typec_port_type type)
+static int tcpm_port_type_set(struct typec_port *p, enum typec_port_type type)
 {
-	struct tcpm_port *port = typec_cap_to_tcpm(cap);
+	struct tcpm_port *port = typec_get_drvdata(p);
 
 	mutex_lock(&port->lock);
 	if (type == port->port_type)
@@ -4385,6 +4375,14 @@ static int tcpm_port_type_set(const struct typec_capability *cap,
 	return 0;
 }
 
+static const struct typec_operations tcpm_ops = {
+	.try_role = tcpm_try_role,
+	.dr_set = tcpm_dr_set,
+	.pr_set = tcpm_pr_set,
+	.vconn_set = tcpm_vconn_set,
+	.port_type_set = tcpm_port_type_set
+};
+
 void tcpm_tcpc_reset(struct tcpm_port *port)
 {
 	mutex_lock(&port->lock);
@@ -4798,11 +4796,8 @@ struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc)
 	port->typec_caps.fwnode = tcpc->fwnode;
 	port->typec_caps.revision = 0x0120;	/* Type-C spec release 1.2 */
 	port->typec_caps.pd_revision = 0x0300;	/* USB-PD spec release 3.0 */
-	port->typec_caps.dr_set = tcpm_dr_set;
-	port->typec_caps.pr_set = tcpm_pr_set;
-	port->typec_caps.vconn_set = tcpm_vconn_set;
-	port->typec_caps.try_role = tcpm_try_role;
-	port->typec_caps.port_type_set = tcpm_port_type_set;
+	port->typec_caps.driver_data = port;
+	port->typec_caps.ops = &tcpm_ops;
 
 	port->partner_desc.identity = &port->partner_ident;
 	port->port_type = port->typec_caps.type;
diff --git a/drivers/usb/typec/tps6598x.c b/drivers/usb/typec/tps6598x.c
index a38d1409f..0698addd1 100644
--- a/drivers/usb/typec/tps6598x.c
+++ b/drivers/usb/typec/tps6598x.c
@@ -94,7 +94,6 @@ struct tps6598x {
 	struct typec_port *port;
 	struct typec_partner *partner;
 	struct usb_pd_identity partner_identity;
-	struct typec_capability typec_cap;
 };
 
 /*
@@ -307,11 +306,10 @@ static int tps6598x_exec_cmd(struct tps6598x *tps, const char *cmd,
 	return 0;
 }
 
-static int
-tps6598x_dr_set(const struct typec_capability *cap, enum typec_data_role role)
+static int tps6598x_dr_set(struct typec_port *port, enum typec_data_role role)
 {
-	struct tps6598x *tps = container_of(cap, struct tps6598x, typec_cap);
 	const char *cmd = (role == TYPEC_DEVICE) ? "SWUF" : "SWDF";
+	struct tps6598x *tps = typec_get_drvdata(port);
 	u32 status;
 	int ret;
 
@@ -338,11 +336,10 @@ tps6598x_dr_set(const struct typec_capability *cap, enum typec_data_role role)
 	return ret;
 }
 
-static int
-tps6598x_pr_set(const struct typec_capability *cap, enum typec_role role)
+static int tps6598x_pr_set(struct typec_port *port, enum typec_role role)
 {
-	struct tps6598x *tps = container_of(cap, struct tps6598x, typec_cap);
 	const char *cmd = (role == TYPEC_SINK) ? "SWSk" : "SWSr";
+	struct tps6598x *tps = typec_get_drvdata(port);
 	u32 status;
 	int ret;
 
@@ -369,6 +366,11 @@ tps6598x_pr_set(const struct typec_capability *cap, enum typec_role role)
 	return ret;
 }
 
+static const struct typec_operations tps6598x_ops = {
+	.dr_set = tps6598x_dr_set,
+	.pr_set = tps6598x_pr_set,
+};
+
 static irqreturn_t tps6598x_interrupt(int irq, void *data)
 {
 	struct tps6598x *tps = data;
@@ -448,6 +450,7 @@ static const struct regmap_config tps6598x_regmap_config = {
 
 static int tps6598x_probe(struct i2c_client *client)
 {
+	struct typec_capability typec_cap = { };
 	struct tps6598x *tps;
 	u32 status;
 	u32 conf;
@@ -492,40 +495,40 @@ static int tps6598x_probe(struct i2c_client *client)
 	if (ret < 0)
 		return ret;
 
-	tps->typec_cap.revision = USB_TYPEC_REV_1_2;
-	tps->typec_cap.pd_revision = 0x200;
-	tps->typec_cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;
-	tps->typec_cap.pr_set = tps6598x_pr_set;
-	tps->typec_cap.dr_set = tps6598x_dr_set;
+	typec_cap.revision = USB_TYPEC_REV_1_2;
+	typec_cap.pd_revision = 0x200;
+	typec_cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;
+	typec_cap.driver_data = tps;
+	typec_cap.ops = &tps6598x_ops;
 
 	switch (TPS_SYSCONF_PORTINFO(conf)) {
 	case TPS_PORTINFO_SINK_ACCESSORY:
 	case TPS_PORTINFO_SINK:
-		tps->typec_cap.type = TYPEC_PORT_SNK;
-		tps->typec_cap.data = TYPEC_PORT_UFP;
+		typec_cap.type = TYPEC_PORT_SNK;
+		typec_cap.data = TYPEC_PORT_UFP;
 		break;
 	case TPS_PORTINFO_DRP_UFP_DRD:
 	case TPS_PORTINFO_DRP_DFP_DRD:
-		tps->typec_cap.type = TYPEC_PORT_DRP;
-		tps->typec_cap.data = TYPEC_PORT_DRD;
+		typec_cap.type = TYPEC_PORT_DRP;
+		typec_cap.data = TYPEC_PORT_DRD;
 		break;
 	case TPS_PORTINFO_DRP_UFP:
-		tps->typec_cap.type = TYPEC_PORT_DRP;
-		tps->typec_cap.data = TYPEC_PORT_UFP;
+		typec_cap.type = TYPEC_PORT_DRP;
+		typec_cap.data = TYPEC_PORT_UFP;
 		break;
 	case TPS_PORTINFO_DRP_DFP:
-		tps->typec_cap.type = TYPEC_PORT_DRP;
-		tps->typec_cap.data = TYPEC_PORT_DFP;
+		typec_cap.type = TYPEC_PORT_DRP;
+		typec_cap.data = TYPEC_PORT_DFP;
 		break;
 	case TPS_PORTINFO_SOURCE:
-		tps->typec_cap.type = TYPEC_PORT_SRC;
-		tps->typec_cap.data = TYPEC_PORT_DFP;
+		typec_cap.type = TYPEC_PORT_SRC;
+		typec_cap.data = TYPEC_PORT_DFP;
 		break;
 	default:
 		return -ENODEV;
 	}
 
-	tps->port = typec_register_port(&client->dev, &tps->typec_cap);
+	tps->port = typec_register_port(&client->dev, &typec_cap);
 	if (IS_ERR(tps->port))
 		return PTR_ERR(tps->port);
 
diff --git a/drivers/usb/typec/ucsi/ucsi.c b/drivers/usb/typec/ucsi/ucsi.c
index ba288b964..edd722fb8 100644
--- a/drivers/usb/typec/ucsi/ucsi.c
+++ b/drivers/usb/typec/ucsi/ucsi.c
@@ -17,9 +17,6 @@
 #include "ucsi.h"
 #include "trace.h"
 
-#define to_ucsi_connector(_cap_) container_of(_cap_, struct ucsi_connector, \
-					      typec_cap)
-
 /*
  * UCSI_TIMEOUT_MS - PPM communication timeout
  *
@@ -713,10 +710,9 @@ static int ucsi_role_cmd(struct ucsi_connector *con, struct ucsi_control *ctrl)
 	return ret;
 }
 
-static int
-ucsi_dr_swap(const struct typec_capability *cap, enum typec_data_role role)
+static int ucsi_dr_swap(struct typec_port *port, enum typec_data_role role)
 {
-	struct ucsi_connector *con = to_ucsi_connector(cap);
+	struct ucsi_connector *con = typec_get_drvdata(port);
 	struct ucsi_control ctrl;
 	int ret = 0;
 
@@ -748,10 +744,9 @@ ucsi_dr_swap(const struct typec_capability *cap, enum typec_data_role role)
 	return ret < 0 ? ret : 0;
 }
 
-static int
-ucsi_pr_swap(const struct typec_capability *cap, enum typec_role role)
+static int ucsi_pr_swap(struct typec_port *port, enum typec_role role)
 {
-	struct ucsi_connector *con = to_ucsi_connector(cap);
+	struct ucsi_connector *con = typec_get_drvdata(port);
 	struct ucsi_control ctrl;
 	int ret = 0;
 
@@ -788,6 +783,11 @@ ucsi_pr_swap(const struct typec_capability *cap, enum typec_role role)
 	return ret;
 }
 
+static const struct typec_operations ucsi_ops = {
+	.dr_set = ucsi_dr_swap,
+	.pr_set = ucsi_pr_swap
+};
+
 static struct fwnode_handle *ucsi_find_fwnode(struct ucsi_connector *con)
 {
 	struct fwnode_handle *fwnode;
@@ -843,8 +843,8 @@ static int ucsi_register_port(struct ucsi *ucsi, int index)
 		*accessory = TYPEC_ACCESSORY_DEBUG;
 
 	cap->fwnode = ucsi_find_fwnode(con);
-	cap->dr_set = ucsi_dr_swap;
-	cap->pr_set = ucsi_pr_swap;
+	cap->driver_data = con;
+	cap->ops = &ucsi_ops;
 
 	/* Register the connector */
 	con->port = typec_register_port(ucsi->dev, cap);
-- 
2.17.1

