From d2314365d82ab4d8d8310b81b8d0ce2e22b169ab Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 16:51:10 +0800
Subject: [PATCH 27/93] add sunxi cpufreq support

---
 drivers/cpufreq/Kconfig                |  22 +-
 drivers/cpufreq/Kconfig.riscv          |  16 +
 drivers/cpufreq/Makefile               |  12 +-
 drivers/cpufreq/cpufreq-dt-platdev.c   |  11 +-
 drivers/cpufreq/cpufreq.c              |  24 +-
 drivers/cpufreq/cpufreq_conservative.c |   2 +-
 drivers/cpufreq/cpufreq_ondemand.c     |   2 +-
 drivers/cpufreq/cpufreq_performance.c  |   2 +-
 drivers/cpufreq/cpufreq_powersave.c    |   2 +-
 drivers/cpufreq/cpufreq_times.c        | 211 ++++++++++++
 drivers/cpufreq/cpufreq_userspace.c    |   2 +-
 drivers/cpufreq/dummy-cpufreq.c        |  60 ++++
 drivers/cpufreq/qcom-cpufreq-hw.c      |   2 +-
 drivers/cpufreq/sun50i-cpufreq-nvmem.c | 432 +++++++++++++++++++++----
 14 files changed, 732 insertions(+), 68 deletions(-)
 create mode 100644 drivers/cpufreq/Kconfig.riscv
 create mode 100644 drivers/cpufreq/cpufreq_times.c
 create mode 100644 drivers/cpufreq/dummy-cpufreq.c

diff --git a/drivers/cpufreq/Kconfig b/drivers/cpufreq/Kconfig
index bff529501..274c8733e 100644
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -34,6 +34,13 @@ config CPU_FREQ_STAT
 
 	  If in doubt, say N.
 
+config CPU_FREQ_TIMES
+       bool "CPU frequency time-in-state statistics"
+       help
+         Export CPU time-in-state information through procfs.
+
+         If in doubt, say N.
+
 choice
 	prompt "Default CPUFreq governor"
 	default CPU_FREQ_DEFAULT_GOV_USERSPACE if ARM_SA1100_CPUFREQ || ARM_SA1110_CPUFREQ
@@ -214,7 +221,7 @@ config CPUFREQ_DT
 	  If in doubt, say N.
 
 config CPUFREQ_DT_PLATDEV
-	bool
+	tristate
 	help
 	  This adds a generic DT based cpufreq platdev driver for frequency
 	  management.  This creates a 'cpufreq-dt' platform device, on the
@@ -222,6 +229,15 @@ config CPUFREQ_DT_PLATDEV
 
 	  If in doubt, say N.
 
+config CPUFREQ_DUMMY
+	tristate "Dummy CPU frequency driver"
+	help
+	  This option adds a generic dummy CPUfreq driver, which sets a fake
+	  2-frequency table when initializing each policy and otherwise does
+	  nothing.
+
+	  If in doubt, say N
+
 if X86
 source "drivers/cpufreq/Kconfig.x86"
 endif
@@ -234,6 +250,10 @@ if PPC32 || PPC64
 source "drivers/cpufreq/Kconfig.powerpc"
 endif
 
+if RISCV
+source "drivers/cpufreq/Kconfig.riscv"
+endif
+
 if IA64
 config IA64_ACPI_CPUFREQ
 	tristate "ACPI Processor P-States driver"
diff --git a/drivers/cpufreq/Kconfig.riscv b/drivers/cpufreq/Kconfig.riscv
new file mode 100644
index 000000000..e1544d6df
--- /dev/null
+++ b/drivers/cpufreq/Kconfig.riscv
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# RISC-V CPU Frequency scaling drivers
+#
+
+config RISCV_ALLWINNER_SUN50I_CPUFREQ_NVMEM
+	tristate "ARCH RISCV Allwinner nvmem based SUN50I CPUFreq driver"
+	depends on ARCH_SUNXI
+	depends on NVMEM_SUNXI_SID
+	select PM_OPP
+	help
+	  This adds the nvmem based CPUFreq driver for Allwinner
+	  h6 SoC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sun50i-cpufreq-nvmem.
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 9a9f5ccd1..a94cb55a7 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -5,7 +5,10 @@ obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o freq_table.o
 # CPUfreq stats
 obj-$(CONFIG_CPU_FREQ_STAT)             += cpufreq_stats.o
 
-# CPUfreq governors 
+# CPUfreq times
+obj-$(CONFIG_CPU_FREQ_TIMES)		+= cpufreq_times.o
+
+# CPUfreq governors
 obj-$(CONFIG_CPU_FREQ_GOV_PERFORMANCE)	+= cpufreq_performance.o
 obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
@@ -17,6 +20,8 @@ obj-$(CONFIG_CPU_FREQ_GOV_ATTR_SET)	+= cpufreq_governor_attr_set.o
 obj-$(CONFIG_CPUFREQ_DT)		+= cpufreq-dt.o
 obj-$(CONFIG_CPUFREQ_DT_PLATDEV)	+= cpufreq-dt-platdev.o
 
+obj-$(CONFIG_CPUFREQ_DUMMY)		+= dummy-cpufreq.o
+
 ##################################################################################
 # x86 drivers.
 # Link order matters. K8 is preferred to ACPI because of firmware bugs in early
@@ -101,6 +106,11 @@ obj-$(CONFIG_CPU_FREQ_PMAC64)		+= pmac64-cpufreq.o
 obj-$(CONFIG_PPC_PASEMI_CPUFREQ)	+= pasemi-cpufreq.o
 obj-$(CONFIG_POWERNV_CPUFREQ)		+= powernv-cpufreq.o
 
+
+##################################################################################
+# RISCV platform drivers
+obj-$(CONFIG_RISCV_ALLWINNER_SUN50I_CPUFREQ_NVMEM) += sun50i-cpufreq-nvmem.o
+
 ##################################################################################
 # Other platform drivers
 obj-$(CONFIG_BMIPS_CPUFREQ)		+= bmips-cpufreq.o
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index bca8d1f47..fff011272 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -8,6 +8,7 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
+#include <linux/module.h>
 
 #include "cpufreq-dt.h"
 
@@ -26,6 +27,7 @@ static const struct of_device_id whitelist[] __initconst = {
 	{ .compatible = "allwinner,sun8i-a23", },
 	{ .compatible = "allwinner,sun8i-a83t", },
 	{ .compatible = "allwinner,sun8i-h3", },
+	{ .compatible = "allwinner,sun8iw20p1", },
 
 	{ .compatible = "apm,xgene-shadowcat", },
 
@@ -103,6 +105,11 @@ static const struct of_device_id whitelist[] __initconst = {
 static const struct of_device_id blacklist[] __initconst = {
 	{ .compatible = "allwinner,sun50i-h6", },
 
+	{ .compatible = "arm,sun50iw9p1", },
+	{ .compatible = "arm,sun50iw10p1", },
+	{ .compatible = "arm,sun8iw20p1", },
+	{ .compatible = "arm,sun20iw1p1", },
+
 	{ .compatible = "calxeda,highbank", },
 	{ .compatible = "calxeda,ecx-2000", },
 
@@ -180,4 +187,6 @@ static int __init cpufreq_dt_platdev_init(void)
 			       -1, data,
 			       sizeof(struct cpufreq_dt_platform_data)));
 }
-device_initcall(cpufreq_dt_platdev_init);
+
+module_init(cpufreq_dt_platdev_init);
+MODULE_LICENSE("GPL");
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 194a6587a..8e78d0dd3 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -16,6 +16,7 @@
 
 #include <linux/cpu.h>
 #include <linux/cpufreq.h>
+#include <linux/cpufreq_times.h>
 #include <linux/cpu_cooling.h>
 #include <linux/delay.h>
 #include <linux/device.h>
@@ -105,6 +106,8 @@ bool have_governor_per_policy(void)
 }
 EXPORT_SYMBOL_GPL(have_governor_per_policy);
 
+static struct kobject *cpufreq_global_kobject;
+
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy)
 {
 	if (have_governor_per_policy())
@@ -155,6 +158,12 @@ __weak void arch_set_freq_scale(struct cpumask *cpus, unsigned long cur_freq,
 }
 EXPORT_SYMBOL_GPL(arch_set_freq_scale);
 
+__weak void arch_set_max_freq_scale(struct cpumask *cpus,
+				    unsigned long policy_max_freq)
+{
+}
+EXPORT_SYMBOL_GPL(arch_set_max_freq_scale);
+
 /*
  * This is a generic cpufreq init() routine which can be used by cpufreq
  * drivers of SMP systems. It will do following:
@@ -382,6 +391,7 @@ static void cpufreq_notify_transition(struct cpufreq_policy *policy,
 					 CPUFREQ_POSTCHANGE, freqs);
 
 		cpufreq_stats_record_transition(policy, freqs->new);
+		cpufreq_times_record_transition(policy, freqs->new);
 		policy->cur = freqs->new;
 	}
 }
@@ -1473,6 +1483,7 @@ static int cpufreq_online(unsigned int cpu)
 			goto out_destroy_policy;
 
 		cpufreq_stats_create_table(policy);
+		cpufreq_times_create_policy(policy);
 
 		write_lock_irqsave(&cpufreq_driver_lock, flags);
 		list_add(&policy->policy_list, &cpufreq_policy_list);
@@ -2033,9 +2044,15 @@ EXPORT_SYMBOL(cpufreq_unregister_notifier);
 unsigned int cpufreq_driver_fast_switch(struct cpufreq_policy *policy,
 					unsigned int target_freq)
 {
+	int ret;
+
 	target_freq = clamp_val(target_freq, policy->min, policy->max);
 
-	return cpufreq_driver->fast_switch(policy, target_freq);
+	ret = cpufreq_driver->fast_switch(policy, target_freq);
+	if (ret)
+		cpufreq_times_record_transition(policy, ret);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(cpufreq_driver_fast_switch);
 
@@ -2413,6 +2430,8 @@ static int cpufreq_set_policy(struct cpufreq_policy *policy,
 	policy->max = new_data.max;
 	trace_cpu_frequency_limits(policy);
 
+	arch_set_max_freq_scale(policy->cpus, policy->max);
+
 	policy->cached_target_freq = UINT_MAX;
 
 	pr_debug("new min and max freqs are %u - %u kHz\n",
@@ -2760,9 +2779,6 @@ int cpufreq_unregister_driver(struct cpufreq_driver *driver)
 }
 EXPORT_SYMBOL_GPL(cpufreq_unregister_driver);
 
-struct kobject *cpufreq_global_kobject;
-EXPORT_SYMBOL(cpufreq_global_kobject);
-
 static int __init cpufreq_core_init(void)
 {
 	if (cpufreq_disabled())
diff --git a/drivers/cpufreq/cpufreq_conservative.c b/drivers/cpufreq/cpufreq_conservative.c
index b66e81c06..737ff3b9c 100644
--- a/drivers/cpufreq/cpufreq_conservative.c
+++ b/drivers/cpufreq/cpufreq_conservative.c
@@ -346,7 +346,7 @@ struct cpufreq_governor *cpufreq_default_governor(void)
 	return CPU_FREQ_GOV_CONSERVATIVE;
 }
 
-fs_initcall(cpufreq_gov_dbs_init);
+core_initcall(cpufreq_gov_dbs_init);
 #else
 module_init(cpufreq_gov_dbs_init);
 #endif
diff --git a/drivers/cpufreq/cpufreq_ondemand.c b/drivers/cpufreq/cpufreq_ondemand.c
index dced03387..82a4d37dd 100644
--- a/drivers/cpufreq/cpufreq_ondemand.c
+++ b/drivers/cpufreq/cpufreq_ondemand.c
@@ -483,7 +483,7 @@ struct cpufreq_governor *cpufreq_default_governor(void)
 	return CPU_FREQ_GOV_ONDEMAND;
 }
 
-fs_initcall(cpufreq_gov_dbs_init);
+core_initcall(cpufreq_gov_dbs_init);
 #else
 module_init(cpufreq_gov_dbs_init);
 #endif
diff --git a/drivers/cpufreq/cpufreq_performance.c b/drivers/cpufreq/cpufreq_performance.c
index aaa04dfca..def9afe0f 100644
--- a/drivers/cpufreq/cpufreq_performance.c
+++ b/drivers/cpufreq/cpufreq_performance.c
@@ -50,5 +50,5 @@ MODULE_AUTHOR("Dominik Brodowski <linux@brodo.de>");
 MODULE_DESCRIPTION("CPUfreq policy governor 'performance'");
 MODULE_LICENSE("GPL");
 
-fs_initcall(cpufreq_gov_performance_init);
+core_initcall(cpufreq_gov_performance_init);
 module_exit(cpufreq_gov_performance_exit);
diff --git a/drivers/cpufreq/cpufreq_powersave.c b/drivers/cpufreq/cpufreq_powersave.c
index c143dc237..1ae66019e 100644
--- a/drivers/cpufreq/cpufreq_powersave.c
+++ b/drivers/cpufreq/cpufreq_powersave.c
@@ -43,7 +43,7 @@ struct cpufreq_governor *cpufreq_default_governor(void)
 	return &cpufreq_gov_powersave;
 }
 
-fs_initcall(cpufreq_gov_powersave_init);
+core_initcall(cpufreq_gov_powersave_init);
 #else
 module_init(cpufreq_gov_powersave_init);
 #endif
diff --git a/drivers/cpufreq/cpufreq_times.c b/drivers/cpufreq/cpufreq_times.c
new file mode 100644
index 000000000..4df55b323
--- /dev/null
+++ b/drivers/cpufreq/cpufreq_times.c
@@ -0,0 +1,211 @@
+/* drivers/cpufreq/cpufreq_times.c
+ *
+ * Copyright (C) 2018 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/cpufreq.h>
+#include <linux/cpufreq_times.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/threads.h>
+
+static DEFINE_SPINLOCK(task_time_in_state_lock); /* task->time_in_state */
+
+/**
+ * struct cpu_freqs - per-cpu frequency information
+ * @offset: start of these freqs' stats in task time_in_state array
+ * @max_state: number of entries in freq_table
+ * @last_index: index in freq_table of last frequency switched to
+ * @freq_table: list of available frequencies
+ */
+struct cpu_freqs {
+	unsigned int offset;
+	unsigned int max_state;
+	unsigned int last_index;
+	unsigned int freq_table[0];
+};
+
+static struct cpu_freqs *all_freqs[NR_CPUS];
+
+static unsigned int next_offset;
+
+void cpufreq_task_times_init(struct task_struct *p)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&task_time_in_state_lock, flags);
+	p->time_in_state = NULL;
+	spin_unlock_irqrestore(&task_time_in_state_lock, flags);
+	p->max_state = 0;
+}
+
+void cpufreq_task_times_alloc(struct task_struct *p)
+{
+	void *temp;
+	unsigned long flags;
+	unsigned int max_state = READ_ONCE(next_offset);
+
+	/* We use one array to avoid multiple allocs per task */
+	temp = kcalloc(max_state, sizeof(p->time_in_state[0]), GFP_ATOMIC);
+	if (!temp)
+		return;
+
+	spin_lock_irqsave(&task_time_in_state_lock, flags);
+	p->time_in_state = temp;
+	spin_unlock_irqrestore(&task_time_in_state_lock, flags);
+	p->max_state = max_state;
+}
+
+/* Caller must hold task_time_in_state_lock */
+static int cpufreq_task_times_realloc_locked(struct task_struct *p)
+{
+	void *temp;
+	unsigned int max_state = READ_ONCE(next_offset);
+
+	temp = krealloc(p->time_in_state, max_state * sizeof(u64), GFP_ATOMIC);
+	if (!temp)
+		return -ENOMEM;
+	p->time_in_state = temp;
+	memset(p->time_in_state + p->max_state, 0,
+	       (max_state - p->max_state) * sizeof(u64));
+	p->max_state = max_state;
+	return 0;
+}
+
+void cpufreq_task_times_exit(struct task_struct *p)
+{
+	unsigned long flags;
+	void *temp;
+
+	if (!p->time_in_state)
+		return;
+
+	spin_lock_irqsave(&task_time_in_state_lock, flags);
+	temp = p->time_in_state;
+	p->time_in_state = NULL;
+	spin_unlock_irqrestore(&task_time_in_state_lock, flags);
+	kfree(temp);
+}
+
+int proc_time_in_state_show(struct seq_file *m, struct pid_namespace *ns,
+	struct pid *pid, struct task_struct *p)
+{
+	unsigned int cpu, i;
+	u64 cputime;
+	unsigned long flags;
+	struct cpu_freqs *freqs;
+	struct cpu_freqs *last_freqs = NULL;
+
+	spin_lock_irqsave(&task_time_in_state_lock, flags);
+	for_each_possible_cpu(cpu) {
+		freqs = all_freqs[cpu];
+		if (!freqs || freqs == last_freqs)
+			continue;
+		last_freqs = freqs;
+
+		seq_printf(m, "cpu%u\n", cpu);
+		for (i = 0; i < freqs->max_state; i++) {
+			cputime = 0;
+			if (freqs->offset + i < p->max_state &&
+			    p->time_in_state)
+				cputime = p->time_in_state[freqs->offset + i];
+			seq_printf(m, "%u %lu\n", freqs->freq_table[i],
+				   (unsigned long)nsec_to_clock_t(cputime));
+		}
+	}
+	spin_unlock_irqrestore(&task_time_in_state_lock, flags);
+	return 0;
+}
+
+void cpufreq_acct_update_power(struct task_struct *p, u64 cputime)
+{
+	unsigned long flags;
+	unsigned int state;
+	struct cpu_freqs *freqs = all_freqs[task_cpu(p)];
+
+	if (!freqs || is_idle_task(p) || p->flags & PF_EXITING)
+		return;
+
+	state = freqs->offset + READ_ONCE(freqs->last_index);
+
+	spin_lock_irqsave(&task_time_in_state_lock, flags);
+	if ((state < p->max_state || !cpufreq_task_times_realloc_locked(p)) &&
+	    p->time_in_state)
+		p->time_in_state[state] += cputime;
+	spin_unlock_irqrestore(&task_time_in_state_lock, flags);
+}
+
+static int cpufreq_times_get_index(struct cpu_freqs *freqs, unsigned int freq)
+{
+	int index;
+        for (index = 0; index < freqs->max_state; ++index) {
+		if (freqs->freq_table[index] == freq)
+			return index;
+        }
+	return -1;
+}
+
+void cpufreq_times_create_policy(struct cpufreq_policy *policy)
+{
+	int cpu, index = 0;
+	unsigned int count = 0;
+	struct cpufreq_frequency_table *pos, *table;
+	struct cpu_freqs *freqs;
+	void *tmp;
+
+	if (all_freqs[policy->cpu])
+		return;
+
+	table = policy->freq_table;
+	if (!table)
+		return;
+
+	cpufreq_for_each_valid_entry(pos, table)
+		count++;
+
+	tmp =  kzalloc(sizeof(*freqs) + sizeof(freqs->freq_table[0]) * count,
+		       GFP_KERNEL);
+	if (!tmp)
+		return;
+
+	freqs = tmp;
+	freqs->max_state = count;
+
+	cpufreq_for_each_valid_entry(pos, table)
+		freqs->freq_table[index++] = pos->frequency;
+
+	index = cpufreq_times_get_index(freqs, policy->cur);
+	if (index >= 0)
+		WRITE_ONCE(freqs->last_index, index);
+
+	freqs->offset = next_offset;
+	WRITE_ONCE(next_offset, freqs->offset + count);
+	for_each_cpu(cpu, policy->related_cpus)
+		all_freqs[cpu] = freqs;
+}
+
+void cpufreq_times_record_transition(struct cpufreq_policy *policy,
+	unsigned int new_freq)
+{
+	int index;
+	struct cpu_freqs *freqs = all_freqs[policy->cpu];
+	if (!freqs)
+		return;
+
+	index = cpufreq_times_get_index(freqs, new_freq);
+	if (index >= 0)
+		WRITE_ONCE(freqs->last_index, index);
+}
diff --git a/drivers/cpufreq/cpufreq_userspace.c b/drivers/cpufreq/cpufreq_userspace.c
index cbd81c58c..b43e7cd50 100644
--- a/drivers/cpufreq/cpufreq_userspace.c
+++ b/drivers/cpufreq/cpufreq_userspace.c
@@ -147,7 +147,7 @@ struct cpufreq_governor *cpufreq_default_governor(void)
 	return &cpufreq_gov_userspace;
 }
 
-fs_initcall(cpufreq_gov_userspace_init);
+core_initcall(cpufreq_gov_userspace_init);
 #else
 module_init(cpufreq_gov_userspace_init);
 #endif
diff --git a/drivers/cpufreq/dummy-cpufreq.c b/drivers/cpufreq/dummy-cpufreq.c
new file mode 100644
index 000000000..f1e5ac7ab
--- /dev/null
+++ b/drivers/cpufreq/dummy-cpufreq.c
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Google, Inc.
+ */
+#include <linux/cpufreq.h>
+#include <linux/module.h>
+
+static struct cpufreq_frequency_table freq_table[] = {
+	{ .frequency = 1 },
+	{ .frequency = 2 },
+	{ .frequency = CPUFREQ_TABLE_END },
+};
+
+static int dummy_cpufreq_target_index(struct cpufreq_policy *policy,
+				   unsigned int index)
+{
+	return 0;
+}
+
+static int dummy_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+	policy->freq_table = freq_table;
+	return 0;
+}
+
+static unsigned int dummy_cpufreq_get(unsigned int cpu)
+{
+	return 1;
+}
+
+static int dummy_cpufreq_verify(struct cpufreq_policy_data *policy)
+{
+	return 0;
+}
+
+static struct cpufreq_driver dummy_cpufreq_driver = {
+	.name = "dummy",
+	.target_index = dummy_cpufreq_target_index,
+	.init = dummy_cpufreq_driver_init,
+	.get = dummy_cpufreq_get,
+	.verify = dummy_cpufreq_verify,
+	.attr = cpufreq_generic_attr,
+};
+
+static int __init dummy_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&dummy_cpufreq_driver);
+}
+
+static void __exit dummy_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&dummy_cpufreq_driver);
+}
+
+module_init(dummy_cpufreq_init);
+module_exit(dummy_cpufreq_exit);
+
+MODULE_AUTHOR("Connor O'Brien <connoro@google.com>");
+MODULE_DESCRIPTION("dummy cpufreq driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/cpufreq/qcom-cpufreq-hw.c b/drivers/cpufreq/qcom-cpufreq-hw.c
index a9ae2f84a..fc92a8842 100644
--- a/drivers/cpufreq/qcom-cpufreq-hw.c
+++ b/drivers/cpufreq/qcom-cpufreq-hw.c
@@ -334,7 +334,7 @@ static int __init qcom_cpufreq_hw_init(void)
 {
 	return platform_driver_register(&qcom_cpufreq_hw_driver);
 }
-device_initcall(qcom_cpufreq_hw_init);
+postcore_initcall(qcom_cpufreq_hw_init);
 
 static void __exit qcom_cpufreq_hw_exit(void)
 {
diff --git a/drivers/cpufreq/sun50i-cpufreq-nvmem.c b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
index 9907a1651..ab955a2c4 100644
--- a/drivers/cpufreq/sun50i-cpufreq-nvmem.c
+++ b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
@@ -1,11 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Allwinner CPUFreq nvmem based driver
- *
  * The sun50i-cpufreq-nvmem driver reads the efuse value from the SoC to
  * provide the OPP framework with required information.
  *
- * Copyright (C) 2019 Yangtao Li <tiny.windzz@gmail.com>
+ * Copyright (C) 2020 frank@allwinnertech.com
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -16,28 +14,42 @@
 #include <linux/platform_device.h>
 #include <linux/pm_opp.h>
 #include <linux/slab.h>
+#include <linux/sunxi-sid.h>
 
-#define MAX_NAME_LEN	7
+#define MAX_NAME_LEN    3
 
-#define NVMEM_MASK	0x7
-#define NVMEM_SHIFT	5
+#define SUN50IW9_ICPU_MASK     GENMASK(9, 0)
 
 static struct platform_device *cpufreq_dt_pdev, *sun50i_cpufreq_pdev;
 
-/**
- * sun50i_cpufreq_get_efuse() - Determine speed grade from efuse value
- * @versions: Set to the value parsed from efuse
- *
- * Returns 0 if success.
- */
-static int sun50i_cpufreq_get_efuse(u32 *versions)
+struct cpufreq_nvmem_data {
+	u32 nv_speed;
+	u32 nv_Icpu;
+	u32 nv_bin;
+	u32 nv_bin_ext;
+	u32 version;
+	char name[MAX_NAME_LEN];
+};
+
+static struct cpufreq_nvmem_data ver_data;
+
+struct cpufreq_soc_data {
+	void (*nvmem_xlate)(u32 *versions, char *name);
+	bool has_nvmem_Icpu;
+	bool has_nvmem_bin;
+	bool has_nvmem_extend_bin;
+};
+
+static int sun50i_nvmem_get_data(char *cell_name, u32 *data)
 {
-	struct nvmem_cell *speedbin_nvmem;
+	struct nvmem_cell *cell_nvmem;
+	size_t len;
+	u8 *cell_value;
+	u32 tmp_data = 0;
+	u32 i;
 	struct device_node *np;
 	struct device *cpu_dev;
-	u32 *speedbin, efuse_value;
-	size_t len;
-	int ret;
+	int ret = 0;
 
 	cpu_dev = get_cpu_device(0);
 	if (!cpu_dev)
@@ -48,48 +60,326 @@ static int sun50i_cpufreq_get_efuse(u32 *versions)
 		return -ENOENT;
 
 	ret = of_device_is_compatible(np,
-				      "allwinner,sun50i-h6-operating-points");
+				      "allwinner,sun50i-operating-points");
 	if (!ret) {
 		of_node_put(np);
 		return -ENOENT;
 	}
 
-	speedbin_nvmem = of_nvmem_cell_get(np, NULL);
+	cell_nvmem = of_nvmem_cell_get(np, cell_name);
 	of_node_put(np);
-	if (IS_ERR(speedbin_nvmem)) {
-		if (PTR_ERR(speedbin_nvmem) != -EPROBE_DEFER)
+	if (IS_ERR(cell_nvmem)) {
+		if (PTR_ERR(cell_nvmem) != -EPROBE_DEFER)
 			pr_err("Could not get nvmem cell: %ld\n",
-			       PTR_ERR(speedbin_nvmem));
-		return PTR_ERR(speedbin_nvmem);
+			       PTR_ERR(cell_nvmem));
+		return PTR_ERR(cell_nvmem);
 	}
 
-	speedbin = nvmem_cell_read(speedbin_nvmem, &len);
-	nvmem_cell_put(speedbin_nvmem);
-	if (IS_ERR(speedbin))
-		return PTR_ERR(speedbin);
+	cell_value = nvmem_cell_read(cell_nvmem, &len);
+	nvmem_cell_put(cell_nvmem);
+	if (IS_ERR(cell_value))
+		return PTR_ERR(cell_value);
+
+	if (len > 4) {
+		pr_err("Invalid nvmem cell length\n");
+		ret = -EINVAL;
+	} else {
+		for (i = 0; i < len; i++)
+			tmp_data |= ((u32)cell_value[i] << (i * 8));
+		*data = tmp_data;
+	}
 
-	efuse_value = (*speedbin >> NVMEM_SHIFT) & NVMEM_MASK;
+	kfree(cell_value);
+
+	return 0;
+}
+
+static void sun50iw9_icpu_xlate(char *prop_name, char *name, u32 i_data)
+{
+	int value = 0;
+
+	i_data &= SUN50IW9_ICPU_MASK;
+
+	if ((i_data >= 0) && (i_data < 93))
+		value = 0;
+	/* 150 is temp munber */
+	else if ((i_data >= 93) && (i_data < 150))
+		value = 1;
+	else if ((i_data >= 150) && (i_data < 271))
+		value = 2;
+
+	snprintf(name, MAX_NAME_LEN, "%s%d", prop_name, value);
+}
 
-	/*
-	 * We treat unexpected efuse values as if the SoC was from
-	 * the slowest bin. Expected efuse values are 1-3, slowest
-	 * to fastest.
-	 */
-	if (efuse_value >= 1 && efuse_value <= 3)
-		*versions = efuse_value - 1;
+static void sun50iw9_nvmem_xlate(u32 *versions, char *name)
+{
+	switch (ver_data.nv_speed) {
+	case 0x2400:
+	case 0x7400:
+		sun50iw9_icpu_xlate("a", name, ver_data.nv_Icpu);
+		break;
+	case 0x2c00:
+	case 0x7c00:
+		sun50iw9_icpu_xlate("b", name, ver_data.nv_Icpu);
+		break;
+	case 0x5000:
+	case 0x5400:
+	case 0x6c00:
+		*versions = 0b0001;
+		break;
+	case 0x5c00:
+	default:
+		*versions = 0b0010;
+	}
+}
+
+static struct cpufreq_soc_data sun50iw9_soc_data = {
+	.nvmem_xlate = sun50iw9_nvmem_xlate,
+	.has_nvmem_Icpu = true,
+};
+
+static void sun50iw10_bin_xlate(bool high_speed, char *name, u32 bin)
+{
+	int value = 0;
+	bool version_before_f;
+	unsigned int ver_bits = sunxi_get_soc_ver() & 0x7;
+	u32 bin_ext = ver_data.nv_bin_ext;
+
+	bin >>= 12;
+	bin_ext >>= 31;
+
+	if (ver_bits == 0 || ver_bits == 3 || ver_bits == 4)
+		version_before_f = true;
 	else
-		*versions = 0;
+		version_before_f = false;
+
+	if (high_speed) {
+		switch (bin) {
+		case 0b100:
+			if (version_before_f) {
+				/* ic version A-E */
+				value = 1;
+			} else {
+				/* ic version F and later version */
+				value = 3;
+			}
+			break;
+		default:
+			if (version_before_f) {
+				/* ic version A-E */
+				value = 0;
+			} else {
+				/* ic version F and later version */
+				value = 2;
+			}
+		}
+
+		snprintf(name, MAX_NAME_LEN, "b%d", value);
+	} else {
+		if (bin_ext && (!version_before_f)) {
+			value = 6;
+		} else {
+			switch (bin) {
+			case 0b100:
+				if (version_before_f) {
+					/* ic version A-E */
+					value = 2;
+				} else {
+					/* ic version F and later version */
+					value = 5;
+				}
+				break;
+			case 0b010:
+				if (version_before_f) {
+					/* ic version A-E */
+					value = 1;
+				} else {
+					/* ic version F and later version */
+					value = 4;
+				}
+				break;
+			default:
+				if (version_before_f) {
+					/* ic version A-E */
+					value = 0;
+				} else {
+					/* ic version F and later version */
+					value = 3;
+				}
+			}
+		}
+		snprintf(name, MAX_NAME_LEN, "a%d", value);
+	}
+}
+
+static void sun50iw10_nvmem_xlate(u32 *versions, char *name)
+{
+	unsigned int ver_bits = sunxi_get_soc_ver() & 0x7;
+
+	switch (ver_data.nv_speed) {
+	case 0x0200:
+	case 0x0600:
+	case 0x0620:
+	case 0x0640:
+	case 0x0800:
+	case 0x1000:
+	case 0x1400:
+	case 0x2000:
+	case 0x4000:
+		if (ver_bits == 0 || ver_bits == 3 || ver_bits == 4) {
+			/* ic version A-E */
+			*versions = 0b0100;
+		} else {
+			/* ic version F and later version */
+			*versions = 0b0010;
+		}
+		sun50iw10_bin_xlate(true, name, ver_data.nv_bin);
+		break;
+	case 0x0400:
+	default:
+		*versions = 0b0001;
+		sun50iw10_bin_xlate(false, name, ver_data.nv_bin);
+	}
+}
+
+static struct cpufreq_soc_data sun50iw10_soc_data = {
+	.nvmem_xlate = sun50iw10_nvmem_xlate,
+	.has_nvmem_bin = true,
+	.has_nvmem_extend_bin = true,
+};
+
+static void sun8iw20_bin_xlate(bool bin_select, char *name, u32 nv_bin)
+{
+	int value = 0;
+	u32 bin = (nv_bin >> 12) & 0xf;
+
+	if (bin_select) {
+		if (bin <= 1)
+			value = 1;
+		else
+			value = 0;
+		/*BGA use axx in VF table*/
+		snprintf(name, MAX_NAME_LEN, "a%d", value);
+	} else {
+		value = 0;
+		/*QFN use bxx in VF table*/
+		snprintf(name, MAX_NAME_LEN, "b%d", value);
+	}
+}
+
+static void sun8iw20_nvmem_xlate(u32 *versions, char *name)
+{
+	switch (ver_data.nv_speed) {
+	case 0x6000:
+		sun8iw20_bin_xlate(false, name, ver_data.nv_bin);
+		*versions = 0b0010;
+		break;
+	case 0x6400:
+	case 0x7000:
+	case 0x7c00:
+	default:
+		sun8iw20_bin_xlate(true, name, ver_data.nv_bin);
+		*versions = 0b0001;
+		break;
+	}
+	pr_debug("sun8iw20 match vf:%s, mark:0x%x\n", name, ver_data.nv_speed);
+}
+
+static struct cpufreq_soc_data sun8iw20_soc_data = {
+	.nvmem_xlate = sun8iw20_nvmem_xlate,
+	.has_nvmem_bin = true,
+};
+
+static void sun20iw1_bin_xlate(bool bin_select, bool high_speed, char *name, u32 nv_bin)
+{
+	int value = 0;
+	u32 bin = (nv_bin >> 12) & 0xf;
+
+	if (bin_select) {
+		if (bin <= 1)
+			value = 1;
+		else
+			value = 0;
+		/*BGA use axx in VF table*/
+		snprintf(name, MAX_NAME_LEN, "a%d", value);
+	} else {
+		if (high_speed)
+			value = 1;
+		else
+			value = 0;
+		/*QFN use bxx in VF table*/
+		snprintf(name, MAX_NAME_LEN, "b%d", value);
+	}
+}
+
+static void sun20iw1_nvmem_xlate(u32 *versions, char *name)
+{
+	switch (ver_data.nv_speed) {
+	case 0x5e00:
+		sun20iw1_bin_xlate(false, false, name, ver_data.nv_bin);
+		*versions = 0b0010;
+		break;
+	case 0x5c00:
+	case 0x7400:
+		sun20iw1_bin_xlate(false, true, name, ver_data.nv_bin);
+		*versions = 0b0001;
+		break;
+	case 0x5000:
+	default:
+		sun20iw1_bin_xlate(true, true, name, ver_data.nv_bin);
+		*versions = 0b0001;
+	}
+	pr_debug("sun20iw1 match vf:%s, mark:0x%x\n", name, ver_data.nv_speed);
+}
+
+static struct cpufreq_soc_data sun20iw1_soc_data = {
+	.nvmem_xlate = sun20iw1_nvmem_xlate,
+	.has_nvmem_bin = true,
+};
+
+/**
+ * sun50i_cpufreq_get_efuse() - Determine speed grade from efuse value
+ * @versions: Set to the value parsed from efuse
+ *
+ * Returns 0 if success.
+ */
+static int sun50i_cpufreq_get_efuse(const struct cpufreq_soc_data *soc_data,
+				    u32 *versions, char *name)
+{
+	int ret;
+
+	ret = sun50i_nvmem_get_data("speed", &ver_data.nv_speed);
+	if (ret)
+		return ret;
+
+	if (soc_data->has_nvmem_Icpu) {
+		ret = sun50i_nvmem_get_data("Icpu", &ver_data.nv_Icpu);
+		if (ret)
+			return ret;
+	}
+
+	if (soc_data->has_nvmem_bin) {
+		ret = sun50i_nvmem_get_data("bin", &ver_data.nv_bin);
+		if (ret)
+			return ret;
+	}
+
+	if (soc_data->has_nvmem_extend_bin) {
+		ret = sun50i_nvmem_get_data("bin_ext", &ver_data.nv_bin_ext);
+		if (ret)
+			return ret;
+	}
+
+	soc_data->nvmem_xlate(versions, name);
 
-	kfree(speedbin);
 	return 0;
 };
 
 static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *match;
 	struct opp_table **opp_tables;
-	char name[MAX_NAME_LEN];
 	unsigned int cpu;
-	u32 speed = 0;
 	int ret;
 
 	opp_tables = kcalloc(num_possible_cpus(), sizeof(*opp_tables),
@@ -97,12 +387,15 @@ static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 	if (!opp_tables)
 		return -ENOMEM;
 
-	ret = sun50i_cpufreq_get_efuse(&speed);
+	match = dev_get_platdata(&pdev->dev);
+	if (!match)
+		return -EINVAL;
+
+	ret = sun50i_cpufreq_get_efuse(match->data,
+				       &ver_data.version, ver_data.name);
 	if (ret)
 		return ret;
 
-	snprintf(name, MAX_NAME_LEN, "speed%d", speed);
-
 	for_each_possible_cpu(cpu) {
 		struct device *cpu_dev = get_cpu_device(cpu);
 
@@ -111,11 +404,24 @@ static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 			goto free_opp;
 		}
 
-		opp_tables[cpu] = dev_pm_opp_set_prop_name(cpu_dev, name);
-		if (IS_ERR(opp_tables[cpu])) {
-			ret = PTR_ERR(opp_tables[cpu]);
-			pr_err("Failed to set prop name\n");
-			goto free_opp;
+		if (strlen(ver_data.name)) {
+			opp_tables[cpu] = dev_pm_opp_set_prop_name(cpu_dev,
+								   ver_data.name);
+			if (IS_ERR(opp_tables[cpu])) {
+				ret = PTR_ERR(opp_tables[cpu]);
+				pr_err("Failed to set prop name\n");
+				goto free_opp;
+			}
+		}
+
+		if (ver_data.version) {
+			opp_tables[cpu] = dev_pm_opp_set_supported_hw(cpu_dev,
+							  &ver_data.version, 1);
+			if (IS_ERR(opp_tables[cpu])) {
+				ret = PTR_ERR(opp_tables[cpu]);
+				pr_err("Failed to set hw\n");
+				goto free_opp;
+			}
 		}
 	}
 
@@ -133,7 +439,12 @@ static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 	for_each_possible_cpu(cpu) {
 		if (IS_ERR_OR_NULL(opp_tables[cpu]))
 			break;
-		dev_pm_opp_put_prop_name(opp_tables[cpu]);
+
+		if (strlen(ver_data.name))
+			dev_pm_opp_put_prop_name(opp_tables[cpu]);
+
+		if (ver_data.version)
+			dev_pm_opp_put_supported_hw(opp_tables[cpu]);
 	}
 	kfree(opp_tables);
 
@@ -147,9 +458,16 @@ static int sun50i_cpufreq_nvmem_remove(struct platform_device *pdev)
 
 	platform_device_unregister(cpufreq_dt_pdev);
 
-	for_each_possible_cpu(cpu)
-		dev_pm_opp_put_prop_name(opp_tables[cpu]);
+	for_each_possible_cpu(cpu) {
+		if (IS_ERR_OR_NULL(opp_tables[cpu]))
+			break;
+
+		if (strlen(ver_data.name))
+			dev_pm_opp_put_prop_name(opp_tables[cpu]);
 
+		if (ver_data.version)
+			dev_pm_opp_put_supported_hw(opp_tables[cpu]);
+	}
 	kfree(opp_tables);
 
 	return 0;
@@ -164,7 +482,10 @@ static struct platform_driver sun50i_cpufreq_driver = {
 };
 
 static const struct of_device_id sun50i_cpufreq_match_list[] = {
-	{ .compatible = "allwinner,sun50i-h6" },
+	{ .compatible = "arm,sun50iw9p1", .data = &sun50iw9_soc_data, },
+	{ .compatible = "arm,sun50iw10p1", .data = &sun50iw10_soc_data, },
+	{ .compatible = "arm,sun8iw20p1", .data = &sun8iw20_soc_data, },
+	{ .compatible = "arm,sun20iw1p1", .data = &sun20iw1_soc_data, },
 	{}
 };
 
@@ -198,9 +519,10 @@ static int __init sun50i_cpufreq_init(void)
 	if (unlikely(ret < 0))
 		return ret;
 
-	sun50i_cpufreq_pdev =
-		platform_device_register_simple("sun50i-cpufreq-nvmem",
-						-1, NULL, 0);
+	sun50i_cpufreq_pdev = platform_device_register_data(NULL,
+							    "sun50i-cpufreq-nvmem",
+							    -1, match,
+							    sizeof(*match));
 	ret = PTR_ERR_OR_ZERO(sun50i_cpufreq_pdev);
 	if (ret == 0)
 		return 0;
@@ -217,5 +539,5 @@ static void __exit sun50i_cpufreq_exit(void)
 }
 module_exit(sun50i_cpufreq_exit);
 
-MODULE_DESCRIPTION("Sun50i-h6 cpufreq driver");
+MODULE_DESCRIPTION("Sun50i cpufreq driver");
 MODULE_LICENSE("GPL v2");
-- 
2.17.1

