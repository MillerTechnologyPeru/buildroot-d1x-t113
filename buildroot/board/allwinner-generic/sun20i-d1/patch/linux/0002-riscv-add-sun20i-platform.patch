From 24aa890a8c4123d83bd4af2fb06546641269d75a Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 16:33:32 +0800
Subject: [PATCH 02/93] riscv: add sun20i platform

---
 arch/riscv/Kconfig                          |   66 +-
 arch/riscv/Kconfig.socs                     |   76 +
 arch/riscv/Makefile                         |   19 +-
 arch/riscv/boot/dts/Makefile                |    1 +
 arch/riscv/boot/dts/sunxi/Makefile          |    2 +
 arch/riscv/boot/dts/sunxi/sun20iw1p1.dtsi   | 1879 +++++++++++++++++++
 arch/riscv/configs/sun20iw1p1_d1_defconfig  |  177 ++
 arch/riscv/configs/sun20iw1p1_defconfig     |  190 ++
 arch/riscv/configs/sun20iw1p1_min_defconfig |   68 +
 arch/riscv/include/asm/asid.h               |   77 +
 arch/riscv/include/asm/cache.h              |    1 +
 arch/riscv/include/asm/cacheflush.h         |    9 +
 arch/riscv/include/asm/cpuidle.h            |    7 +
 arch/riscv/include/asm/csr.h                |   18 +
 arch/riscv/include/asm/device.h             |   17 +
 arch/riscv/include/asm/elf.h                |    5 +
 arch/riscv/include/asm/io.h                 |   15 +-
 arch/riscv/include/asm/kexec.h              |   99 +
 arch/riscv/include/asm/mmu.h                |    1 +
 arch/riscv/include/asm/mmu_context.h        |   17 +-
 arch/riscv/include/asm/perf_event.h         |    4 +-
 arch/riscv/include/asm/pgtable-64.h         |    2 +-
 arch/riscv/include/asm/pgtable-bits.h       |   12 +-
 arch/riscv/include/asm/pgtable.h            |   45 +-
 arch/riscv/include/asm/proc-fns.h           |    8 +
 arch/riscv/include/asm/processor.h          |    1 +
 arch/riscv/include/asm/ptrace.h             |   69 +-
 arch/riscv/include/asm/sbi.h                |   60 +
 arch/riscv/include/asm/switch_to.h          |   48 +
 arch/riscv/include/asm/tlbflush.h           |    9 +-
 arch/riscv/include/uapi/asm/elf.h           |    2 +
 arch/riscv/include/uapi/asm/hwcap.h         |    1 +
 arch/riscv/include/uapi/asm/ptrace.h        |    9 +
 arch/riscv/include/uapi/asm/sigcontext.h    |    1 +
 arch/riscv/kernel/Makefile                  |    6 +
 arch/riscv/kernel/asm-offsets.c             |  190 ++
 arch/riscv/kernel/cpu-reset.S               |   23 +
 arch/riscv/kernel/cpu-reset.h               |   58 +
 arch/riscv/kernel/cpu.c                     |    2 +-
 arch/riscv/kernel/cpufeature.c              |   13 +-
 arch/riscv/kernel/cpuidle.c                 |   10 +
 arch/riscv/kernel/crash_dump.c              |   69 +
 arch/riscv/kernel/entry.S                   |    2 +-
 arch/riscv/kernel/head.S                    |    2 +-
 arch/riscv/kernel/irq.c                     |    7 +
 arch/riscv/kernel/machine_kexec.c           |  163 ++
 arch/riscv/kernel/module.c                  |    2 +-
 arch/riscv/kernel/perf_event.c              |    2 +-
 arch/riscv/kernel/process.c                 |    6 +
 arch/riscv/kernel/ptrace.c                  |   41 +
 arch/riscv/kernel/relocate_kernel.S         |   32 +
 arch/riscv/kernel/reset.c                   |   13 +
 arch/riscv/kernel/setup.c                   |    2 +
 arch/riscv/kernel/signal.c                  |   41 +
 arch/riscv/kernel/smpboot.c                 |    1 +
 arch/riscv/kernel/time.c                    |    4 +
 arch/riscv/kernel/vector.S                  |   84 +
 arch/riscv/mm/Makefile                      |    3 +
 arch/riscv/mm/asid.c                        |  189 ++
 arch/riscv/mm/cacheflush.c                  |   93 +
 arch/riscv/mm/context.c                     |   43 +-
 arch/riscv/mm/dma-mapping.c                 |   81 +
 arch/riscv/mm/fault.c                       |    4 +-
 arch/riscv/mm/init.c                        |  174 +-
 arch/riscv/mm/ioremap.c                     |   40 +-
 arch/riscv/mm/tlbflush.c                    |   51 +
 66 files changed, 4371 insertions(+), 95 deletions(-)
 create mode 100644 arch/riscv/boot/dts/sunxi/Makefile
 create mode 100644 arch/riscv/boot/dts/sunxi/sun20iw1p1.dtsi
 create mode 100644 arch/riscv/configs/sun20iw1p1_d1_defconfig
 create mode 100644 arch/riscv/configs/sun20iw1p1_defconfig
 create mode 100644 arch/riscv/configs/sun20iw1p1_min_defconfig
 create mode 100644 arch/riscv/include/asm/asid.h
 create mode 100644 arch/riscv/include/asm/cpuidle.h
 create mode 100644 arch/riscv/include/asm/device.h
 create mode 100644 arch/riscv/include/asm/kexec.h
 create mode 100644 arch/riscv/include/asm/proc-fns.h
 create mode 100644 arch/riscv/kernel/cpu-reset.S
 create mode 100644 arch/riscv/kernel/cpu-reset.h
 create mode 100644 arch/riscv/kernel/cpuidle.c
 create mode 100644 arch/riscv/kernel/crash_dump.c
 create mode 100644 arch/riscv/kernel/machine_kexec.c
 create mode 100644 arch/riscv/kernel/relocate_kernel.S
 create mode 100644 arch/riscv/kernel/vector.S
 create mode 100644 arch/riscv/mm/asid.c
 create mode 100644 arch/riscv/mm/dma-mapping.c

diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index a0fa4be94..52d85bf13 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -30,9 +30,11 @@ config RISCV
 	select GENERIC_STRNLEN_USER
 	select GENERIC_SMP_IDLE_THREAD
 	select GENERIC_ATOMIC64 if !64BIT
+	select GENERIC_ALLOCATOR
 	select HAVE_ARCH_AUDITSYSCALL
 	select HAVE_ASM_MODVERSIONS
 	select HAVE_MEMBLOCK_NODE_MAP
+	select DMA_DIRECT_REMAP
 	select HAVE_DMA_CONTIGUOUS
 	select HAVE_FUTEX_CMPXCHG if FUTEX
 	select HAVE_PERF_EVENTS
@@ -54,6 +56,11 @@ config RISCV
 	select GENERIC_ARCH_TOPOLOGY if SMP
 	select ARCH_HAS_PTE_SPECIAL
 	select ARCH_HAS_MMIOWB
+	select ARCH_HAS_DMA_PREP_COHERENT
+	select ARCH_HAS_SYNC_DMA_FOR_CPU
+	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
+	select ARCH_HAS_DMA_WRITE_COMBINE
+	select ARCH_HAS_DMA_MMAP_PGPROT
 	select HAVE_EBPF_JIT if 64BIT
 	select EDAC_SUPPORT
 	select ARCH_HAS_GIGANTIC_PAGE
@@ -62,6 +69,11 @@ config RISCV
 	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT if MMU
 	select HAVE_ARCH_MMAP_RND_BITS
 	select HAVE_COPY_THREAD_TLS
+	select ARCH_HAS_SETUP_DMA_OPS
+	select GENERIC_CLOCKEVENTS_BROADCAST
+	select ARCH_HAS_DMA_COHERENT_TO_PFN
+	select CPU_PM if (SUSPEND || CPU_IDLE)
+	select ARCH_KEEP_MEMBLOCK if FLATMEM
 
 config ARCH_MMAP_RND_BITS_MIN
 	default 18 if 64BIT
@@ -144,6 +156,12 @@ config PGTABLE_LEVELS
 	default 3 if 64BIT
 	default 2
 
+config SUNXI_SOC_NAME
+	string "The name of Sunxi SoC"
+	default ""
+	help
+	  Used for /proc/cpuinfo and /sys/.../sysinfo.
+
 source "arch/riscv/Kconfig.socs"
 
 menu "Platform type"
@@ -172,7 +190,6 @@ config ARCH_RV64I
 	select HAVE_FTRACE_MCOUNT_RECORD
 	select HAVE_DYNAMIC_FTRACE
 	select HAVE_DYNAMIC_FTRACE_WITH_REGS
-	select SWIOTLB
 
 endchoice
 
@@ -268,12 +285,41 @@ config FPU
 
 	  If you don't know what to do here, say Y.
 
+config VECTOR
+	bool "VECTOR support"
+	default n
+	help
+	  Say N here if you want to disable all vector related procedure
+	  in the kernel.
+
+	  If you don't know what to do here, say Y.
+
 endmenu
 
 menu "Kernel features"
 
 source "kernel/Kconfig.hz"
 
+config KEXEC
+	select KEXEC_CORE
+	bool "kexec system call"
+	---help---
+	  kexec is a system call that implements the ability to shutdown your
+	  current kernel, and to start another kernel.  It is like a reboot
+	  but it is independent of the system firmware.   And like a reboot
+	  you can start any kernel with it, not just Linux.
+
+config CRASH_DUMP
+	bool "Build kdump crash kernel"
+	help
+	  Generate crash dump after being started by kexec. This should
+	  be normally only set in special crash dump kernels which are
+	  loaded in the main kernel with kexec-tools into a specially
+	  reserved region and then later executed after a crash by
+	  kdump/kexec.
+
+	  For more details see Documentation/kdump/kdump.txt
+
 endmenu
 
 menu "Boot options"
@@ -323,8 +369,26 @@ endchoice
 
 endmenu
 
+menu "CPU Power Management"
+
+source "drivers/cpuidle/Kconfig"
+
+source "drivers/cpufreq/Kconfig"
+endmenu
+
 menu "Power management options"
 
 source "kernel/power/Kconfig"
 
+config ARCH_HIBERNATION_POSSIBLE
+	def_bool y
+	depends on CPU_PM
+
+config ARCH_HIBERNATION_HEADER
+	def_bool y
+	depends on HIBERNATION
+
+config ARCH_SUSPEND_POSSIBLE
+	def_bool y
+
 endmenu
diff --git a/arch/riscv/Kconfig.socs b/arch/riscv/Kconfig.socs
index 536c0ef4a..209979c36 100644
--- a/arch/riscv/Kconfig.socs
+++ b/arch/riscv/Kconfig.socs
@@ -10,4 +10,80 @@ config SOC_SIFIVE
        help
          This enables support for SiFive SoC platform hardware.
 
+config RISCV_SUNXI
+       bool
+
+config ARCH_SUNXI
+       bool "Allwinner RISC-V SoC Family"
+       select RISCV_SUNXI
+       help
+         This enables support for SUNXI SoC platform hardware.
+
+# Select the board between FPGA and EVB
+
+choice
+      prompt "Allwinner development Board"
+      depends on ARCH_SUNXI
+      default FPGA_V4_PLATFORM
+
+config FPGA_V4_PLATFORM
+       bool "FPGAv4 board"
+       help
+         Support for Allwinner's FPGAv4 board
+
+config FPGA_V7_PLATFORM
+       bool "FPGAv7 board"
+       help
+         Support for Allwinner's FPGAv4 board
+
+config EVB_PLATFORM
+       bool "EVB board"
+       help
+         Support for Allwinner's EVB board
+endchoice
+
+if ARCH_SUNXI
+choice
+	prompt "Select the architecture of SoC"
+	default ARCH_SUN20I
+	help
+	  Select the architecture for SoC
+	  sunxi
+	  `-- sun20i ----- C906 based Family SoCs
+
+	config ARCH_SUN20I
+	bool "Allwinner SUN20I"
+endchoice
+
+if ARCH_SUN20I
+choice
+	prompt "Select the wafer with arch sun20i"
+	default ARCH_SUN20IW1
+	help
+	  Select the wafer with arch sun20i
+
+config ARCH_SUN20IW1
+	bool "Allwinner SUN20IW1 SoCs"
+	help
+	  Support for Allwinner SUN20IW1 SoC family
+
+endchoice
+endif
+
+if ARCH_SUN20IW1
+choice
+	prompt "Select the wafer with arch sun20iw1"
+	default ARCH_SUN20IW1P1
+	help
+	  Select the wafer with arch sun20iw1
+
+config ARCH_SUN20IW1P1
+	bool "Allwinner SUN20IW1P1 SoCs"
+	help
+	  Support for Allwinner SUN20IW1P1 SoC family
+
+endchoice
+endif
+endif
+
 endmenu
diff --git a/arch/riscv/Makefile b/arch/riscv/Makefile
index f5e914210..972fe3492 100644
--- a/arch/riscv/Makefile
+++ b/arch/riscv/Makefile
@@ -35,12 +35,19 @@ else
 endif
 
 # ISA string setting
-riscv-march-$(CONFIG_ARCH_RV32I)	:= rv32ima
-riscv-march-$(CONFIG_ARCH_RV64I)	:= rv64ima
-riscv-march-$(CONFIG_FPU)		:= $(riscv-march-y)fd
-riscv-march-$(CONFIG_RISCV_ISA_C)	:= $(riscv-march-y)c
-KBUILD_CFLAGS += -march=$(subst fd,,$(riscv-march-y))
-KBUILD_AFLAGS += -march=$(riscv-march-y)
+riscv-march-cflags-$(CONFIG_ARCH_RV32I)		:= rv32ima
+riscv-march-cflags-$(CONFIG_ARCH_RV64I)		:= rv64ima
+riscv-march-cflags-$(CONFIG_RISCV_ISA_C)	:= $(riscv-march-cflags-y)c
+
+riscv-march-aflags-$(CONFIG_ARCH_RV32I)		:= rv32ima
+riscv-march-aflags-$(CONFIG_ARCH_RV64I)		:= rv64ima
+riscv-march-aflags-$(CONFIG_FPU)		:= $(riscv-march-aflags-y)fd
+riscv-march-aflags-$(CONFIG_RISCV_ISA_C)	:= $(riscv-march-aflags-y)c
+riscv-march-aflags-$(CONFIG_VECTOR)		:= $(riscv-march-aflags-y)v
+riscv-march-aflags-$(CONFIG_RISCV_ISA_THEAD)	:= $(riscv-march-aflags-y)xthead
+
+KBUILD_CFLAGS += -march=$(riscv-march-cflags-y) -Wa,-march=$(riscv-march-aflags-y)
+KBUILD_AFLAGS += -march=$(riscv-march-aflags-y)
 
 KBUILD_CFLAGS += -mno-save-restore
 KBUILD_CFLAGS += -DCONFIG_PAGE_OFFSET=$(CONFIG_PAGE_OFFSET)
diff --git a/arch/riscv/boot/dts/Makefile b/arch/riscv/boot/dts/Makefile
index dcc3ada78..1f76c4ab7 100644
--- a/arch/riscv/boot/dts/Makefile
+++ b/arch/riscv/boot/dts/Makefile
@@ -1,2 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0
 subdir-y += sifive
+subdir-y += sunxi
diff --git a/arch/riscv/boot/dts/sunxi/Makefile b/arch/riscv/boot/dts/sunxi/Makefile
new file mode 100644
index 000000000..7a7c38bb7
--- /dev/null
+++ b/arch/riscv/boot/dts/sunxi/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_SUNXI) += board.dtb
diff --git a/arch/riscv/boot/dts/sunxi/sun20iw1p1.dtsi b/arch/riscv/boot/dts/sunxi/sun20iw1p1.dtsi
new file mode 100644
index 000000000..b78311876
--- /dev/null
+++ b/arch/riscv/boot/dts/sunxi/sun20iw1p1.dtsi
@@ -0,0 +1,1879 @@
+/*
+ * Allwinner Technology CO., Ltd. sun20iw1p1 platform.
+ *
+ */
+
+/memreserve/ 0x41fc0000 0x020000;  /* opensbi */
+
+#include <dt-bindings/clock/sun8iw20-ccu.h>
+#include <dt-bindings/clock/sun8iw20-r-ccu.h>
+#include <dt-bindings/clock/sun8iw20-rtc.h>
+#include <dt-bindings/reset/sun8iw20-ccu.h>
+#include <dt-bindings/reset/sun8iw20-r-ccu.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/gpio/sun4i-gpio.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	model = "sun20iw1p1";
+	compatible = "allwinner,sun20iw1p1";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+		serial5 = &uart5;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		twi0 = &twi0;
+		twi1 = &twi1;
+		twi2 = &twi2;
+		twi3 = &twi3;
+		mmc2 = &sdc2;
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		pwm2 = &pwm2;
+		pwm3 = &pwm3;
+		pwm4 = &pwm4;
+		pwm5 = &pwm5;
+		pwm6 = &pwm6;
+		pwm7 = &pwm7;
+		ir0 = &s_cir0;
+		ir1 = &ir1;
+		mmc0 = &sdc0;
+		ve0 = &ve;
+		tvd = &tvd;
+		tvd0 = &tvd0;
+	} ;
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8 debug loglevel=7,initcall_debug=1 init=/init earlycon=sbi";
+		stdout-path = "serial0:115200n8";
+		linux,initrd-start = <0x42000000>;
+		linux,initrd-end   = <0x43000000>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <24000000>;
+
+		idle-states {
+			CPU_SLEEP: cpu-sleep {
+				compatible = "riscv,idle-state";
+				local-timer-stop;
+				entry-latency-us = <59>;
+				exit-latency-us = <59>;
+				min-residency-us = <5000>;
+			};
+		};
+
+		CPU0: cpu@0 {
+			device_type = "cpu";
+			reg = <0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+		/*	riscv,priv-major = <1>;*/
+		/*	riscv,priv-minor = <10>;*/
+			mmu-type = "riscv,sv39";
+			clocks = <&ccu CLK_RISCV>;
+			clock-frequency = <24000000>;
+			operating-points-v2 = <&cpu_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP>;
+			#cooling-cells = <2>;
+	/*		d-cache-size = <0x8000>;*/
+	/*		d-cache-line-size = <32>;*/
+			CPU0_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+			};
+		};
+	};
+
+	dram: dram {
+		device_type = "dram";
+		compatible = "allwinner,dram";
+		clocks = <&ccu CLK_PLL_DDR0>;
+		clock-names = "pll_ddr";
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0x0 0x8000000>;
+	};
+
+	dump_reg: dump_reg@20000 {
+		compatible = "allwinner,sunxi-dump-reg";
+		reg = <0x0 0x00020000 0x0 0x0004>;
+		/* 0x00020000: dump_reg test addr, 0x0004: dump_reg test size */
+	};
+
+	cpu_opp_table: cpu-opp-table {
+		compatible = "allwinner,sun50i-operating-points";
+		nvmem-cells = <&speedbin_efuse>, <&cpubin_efuse>;
+		nvmem-cell-names = "speed", "bin";
+		opp-shared;
+
+		opp@1008000000 {
+			opp-hz = /bits/ 64 <1008000000>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-microvolt-a0 = <1100000>;
+			opp-microvolt-a1 = <950000>;
+
+			opp-microvolt-b1 = <950000>;
+			opp-supported-hw = <0x1>;
+		};
+	};
+
+	dcxo24M: dcxo24M_clk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "dcxo24M";
+	};
+
+	rc_16m: rc16m_clk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <16000000>;
+		clock-accuracy = <300000000>;
+		clock-output-names = "rc-16m";
+	};
+
+	ext_32k: ext32k_clk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <32768>;
+		clock-output-names = "ext-32k";
+	};
+
+	reg_pio1_8: pio-18 {
+		compatible = "regulator-fixed";
+		regulator-name = "pio-18";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	reg_pio3_3: pio-33 {
+		compatible = "regulator-fixed";
+		regulator-name = "pio-33";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	thermal-zones {
+		cpu_thermal_zone {
+			polling-delay-passive = <500>;
+			polling-delay = <1000>;
+			thermal-sensors = <&ths 0>;
+			sustainable-power = <1200>;
+
+			cpu_trips: trips {
+				cpu_threshold: trip-point@0 {
+					temperature = <70000>;
+					type = "passive";
+					hysteresis = <0>;
+				};
+				cpu_target: trip-point@1 {
+					temperature = <90000>;
+					type = "passive";
+					hysteresis = <0>;
+				};
+				cpu_crit: cpu_crit@0 {
+					temperature = <110000>;
+					type = "critical";
+					hysteresis = <0>;
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_target>;
+					cooling-device = <&CPU0
+					THERMAL_NO_LIMIT
+					THERMAL_NO_LIMIT>;
+					contribution = <1024>;
+				};
+			};
+		};
+	};
+
+	mmu_aw: iommu@2010000 {
+		compatible = "allwinner,sunxi-iommu";
+		reg = <0x0 0x02010000 0x0 0x1000>;
+		interrupts-extended = <&plic0 80 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "iommu-irq";
+		clocks = <&ccu CLK_BUS_IOMMU>;
+		clock-names = "iommu";
+		#iommu-cells = <2>;
+		status = "okay";
+	};
+
+	soc: soc@3000000 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		sram_ctrl: sram_ctrl@3000000 {
+			compatible = "allwinner,sram_ctrl";
+			reg = <0x0 0x3000000 0 0x16C>;
+			soc_ver {
+				offset = <0x24>;
+				mask = <0x7>;
+				shift = <0>;
+				ver_a = <0x18590000>;
+				ver_b = <0x18590002>;
+				ver_d = <0x18590003>;
+			};
+
+			soc_id {
+				offset = <0x200>;
+				mask = <0x1>;
+				shift = <22>;
+			};
+
+			soc_bin {
+				offset = <0x0>;
+				mask = <0x3ff>;
+				shift = <0x0>;
+			};
+
+		};
+
+		rtc_ccu: rtc_ccu@7090000 {
+			compatible = "allwinner,sun20iw1-rtc-ccu";
+			device_type = "rtc-ccu";
+			reg = <0x0 0x07090000 0x0 0x320>;  /* The same as rtc */
+			#clock-cells = <1>;
+		};
+
+		ccu: clock@2001000 {
+			compatible = "allwinner,sun20iw1-ccu";
+			reg = <0x0 0x02001000 0x0 0x1000>;
+			clocks = <&dcxo24M>, <&rtc_ccu CLK_OSC32K>, <&rtc_ccu CLK_IOSC>;
+			clock-names = "hosc", "losc", "iosc";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		r_ccu: clock@7010000 {
+			compatible = "allwinner,sun20iw1-r-ccu";
+			reg = <0x0 0x07010000 0x0 0x240>;
+			clocks = <&dcxo24M>, <&rtc_ccu CLK_OSC32K>, <&rtc_ccu CLK_IOSC>,
+				 <&ccu CLK_PLL_PERIPH0>;
+			clock-names = "hosc", "losc", "iosc", "pll-periph0";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+
+		plic0: interrupt-controller@10000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <2>;
+			#interrupt-cells = <2>;
+			interrupt-controller;
+			reg = <0x0 0x10000000 0x0 0x4000000>;
+			interrupts-extended = <&CPU0_intc 0xffffffff &CPU0_intc 9>;
+			reg-names = "control";
+			riscv,max-priority = <7>;
+			riscv,ndev=<200>;
+		};
+
+		uart0: uart@2500000 {
+			compatible = "allwinner,sun20i-uart";
+			device_type = "uart0";
+			reg = <0x0 0x02500000 0x0 0x400>;
+			interrupts-extended = <&plic0 18 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_UART0>;
+			clock-names = "uart0";
+			resets = <&ccu RST_BUS_UART0>;
+			sunxi,uart-fifosize = <64>;
+			uart0_port = <0>;
+			uart0_type = <2>;
+			status = "okay";
+		};
+
+		uart1: uart@2500400 {
+			compatible = "allwinner,sun20i-uart";
+			device_type = "uart1";
+			reg = <0x0 0x02500400 0x0 0x400>;
+			interrupts-extended = <&plic0 19 IRQ_TYPE_LEVEL_HIGH>;
+			sunxi,uart-fifosize = <256>;
+			clocks = <&ccu CLK_BUS_UART1>;
+			clock-names = "uart1";
+			resets = <&ccu RST_BUS_UART1>;
+			uart1_port = <1>;
+			uart1_type = <4>;
+			status = "disabled";
+		};
+
+		uart2: uart@2500800 {
+			compatible = "allwinner,sun20i-uart";
+			device_type = "uart2";
+			reg = <0x0 0x02500800 0x0 0x400>;
+			interrupts-extended = <&plic0 20 IRQ_TYPE_LEVEL_HIGH>;
+			sunxi,uart-fifosize = <256>;
+			clocks = <&ccu CLK_BUS_UART2>;
+			clock-names = "uart2";
+			resets = <&ccu RST_BUS_UART2>;
+			uart2_port = <2>;
+			uart2_type = <4>;
+			status = "disabled";
+		};
+
+		uart3: uart@2500c00 {
+			compatible = "allwinner,sun20i-uart";
+			device_type = "uart3";
+			reg = <0x0 0x02500c00 0x0 0x400>;
+			interrupts-extended = <&plic0 21 IRQ_TYPE_LEVEL_HIGH>;
+			sunxi,uart-fifosize = <256>;
+			clocks = <&ccu CLK_BUS_UART3>;
+			clock-names = "uart3";
+			resets = <&ccu RST_BUS_UART3>;
+			uart3_port = <3>;
+			uart3_type = <4>;
+			status = "disabled";
+		};
+
+		uart4: uart@2501000 {
+			compatible = "allwinner,sun20i-uart";
+			device_type = "uart4";
+			reg = <0x0 0x02501000 0x0 0x400>;
+			interrupts-extended = <&plic0 22 IRQ_TYPE_LEVEL_HIGH>;
+			sunxi,uart-fifosize = <256>;
+			clocks = <&ccu CLK_BUS_UART4>;
+			clock-names = "uart4";
+			resets = <&ccu RST_BUS_UART4>;
+			uart4_port = <4>;
+			uart4_type = <2>;
+			status = "disabled";
+		};
+
+		uart5: uart@2501400 {
+			compatible = "allwinner,sun20i-uart";
+			device_type = "uart5";
+			reg = <0x0 0x02501400 0x0 0x400>;
+			interrupts-extended = <&plic0 23 IRQ_TYPE_LEVEL_HIGH>;
+			sunxi,uart-fifosize = <256>;
+			clocks = <&ccu CLK_BUS_UART5>;
+			clock-names = "uart5";
+			resets = <&ccu RST_BUS_UART5>;
+			uart5_port = <5>;
+			uart5_type = <2>;
+			status = "disabled";
+		};
+		cryptoengine: ce@03040000 {
+			compatible = "allwinner,sunxi-ce";
+			device_name = "ce";
+			reg = <0x0 0x03040000 0x0 0xa0>, /* non-secure space */
+			      <0x0 0x03040800 0x0 0xa0>; /* secure space */
+			interrupts-extended = <&plic0 68 IRQ_TYPE_EDGE_RISING>, /*non-secure*/
+				   <&plic0 69 IRQ_TYPE_EDGE_RISING>; /* secure*/
+			clock-frequency = <400000000>; /* 400MHz */
+			clocks = <&ccu CLK_BUS_CE>, <&ccu CLK_CE>, <&ccu CLK_MBUS_CE>,
+					<&ccu CLK_PLL_PERIPH0_2X>;
+			clock-names = "bus_ce", "ce_clk", "mbus_ce", "pll_periph0_2x";
+			resets = <&ccu RST_BUS_CE>;
+			status = "okay";
+		};
+
+		s_cir0: s_cir@7040000 {
+			compatible = "allwinner,s_cir";
+			reg = <0x0 0x07040000 0x0 0x400>;
+			interrupts-extended = <&plic0 167 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&r_ccu CLK_R_APB0_BUS_IRRX>, <&dcxo24M>, <&r_ccu CLK_R_APB0_IRRX>;
+			clock-names = "bus", "pclk", "mclk";
+			resets = <&r_ccu RST_R_APB0_BUS_IRRX>;
+			supply = "";
+			supply_vol = "";
+			status = "disabled";
+		};
+
+		ir1: ir@2003000 {
+			compatible = "allwinner,irtx";
+			reg = <0x0 0x02003000 0x0 0x400>;
+			interrupts-extended = <&plic0 35 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_IR_TX>, <&dcxo24M>, <&ccu CLK_IR_TX>;
+			clock-names = "bus", "pclk", "mclk";
+			resets = <&ccu RST_BUS_IR_TX>;
+			status = "disabled";
+		};
+
+		di: deinterlace@5400000 {
+			compatible = "allwinner,sunxi-deinterlace";
+			reg = <0x0 0x05400000 0x0 0x0000ffff>;
+			interrupts-extended = <&plic0 104 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_DI>,
+				 <&ccu CLK_BUS_DI>,
+				 <&ccu CLK_PLL_PERIPH0_2X>;
+			clock-names = "clk_di",
+				      "pll_periph",
+				      "clk_bus_di";
+			resets = <&ccu RST_BUS_DI>;
+			reset-names = "rst_bus_di";
+
+			assigned-clocks = <&ccu CLK_DI>;
+			assigned-clock-parents = <&ccu CLK_PLL_PERIPH0_2X>;
+			assigned-clock-rates = <300000000>;
+
+			iommus = <&mmu_aw 4 1>;
+			status = "okay";
+		};
+
+		gmac0: eth@4500000 {
+			compatible = "allwinner,sunxi-gmac";
+			reg = <0x0 0x04500000 0x0 0x10000>,
+			      <0x0 0x03000030 0x0 0x4>;
+			interrupts-extended = <&plic0 62 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "gmacirq";
+			clocks = <&ccu CLK_BUS_EMAC0>, <&ccu CLK_EMAC0_25M>;
+			clock-names = "gmac", "ephy";
+			resets = <&ccu RST_BUS_EMAC0>;
+			device_type = "gmac0";
+			pinctrl-0 = <&gmac_pins_a>;
+			pinctrl-1 = <&gmac_pins_b>;
+			pinctrl-names = "default", "sleep";
+			phy-mode = "rgmii";
+			use_ephy25m = <1>;
+			tx-delay = <7>;
+			rx-delay = <31>;
+			phy-rst = <&pio PA 14 GPIO_ACTIVE_LOW>;
+			gmac-power0;
+			gmac-power1;
+			gmac-power2;
+			status = "disabled";
+		};
+
+		rtc: rtc@7090000 {
+			compatible = "allwinner,sun20iw1-rtc";
+			device_type = "rtc";
+			wakeup-source;
+			interrupts-extended = <&plic0 160 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x07090000 0x0 0x320>;
+			clocks = <&r_ccu CLK_R_AHB_BUS_RTC>, <&rtc_ccu CLK_RTC_SPI>, <&rtc_ccu CLK_RTC_1K>;
+			clock-names = "r-ahb-rtc", "rtc-spi", "rtc-1k";
+			resets = <&r_ccu RST_R_AHB_BUS_RTC>;
+			gpr_cur_pos = <6>;
+		};
+
+		dma: dma-controller@3002000 {
+			compatible = "allwinner,sun8i-riscv-dma";
+			reg = <0x0 0x03002000 0x0 0x1000>;
+			interrupts-extended = <&plic0 66 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_DMA>, <&ccu CLK_MBUS_DMA>;
+			clock-names = "bus", "mbus";
+			resets = <&ccu RST_BUS_DMA>;
+			dma-channels = <8>;
+			dma-requests = <48>;
+			#dma-cells = <1>;
+			status = "okay";
+		};
+
+		soc_timer0: timer@2050000 {
+			compatible = "allwinner,sun4i-a10-timer";
+			device_type = "soc_timer";
+			reg = <0x0 0x02050000 0x0 0xA0>;
+			interrupts-extended = <&plic0 75 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&dcxo24M>;
+			status = "okay";
+		};
+
+		wdt: watchdog@6011000 {
+			compatible = "allwinner,sun20i-wdt";
+			reg = <0x0 0x06011000 0x0 0x20>;
+			interrupts-extended = <&plic0 147 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		mbus0:mbus-comtroller@3102000 {
+			compatible = "allwinner,sun8i-mbus";
+			reg = <0x0 0x03102000 0x0 0x1000>;
+			#mbus-cells = <1>;
+		};
+
+		pmu: pmu {
+			compatible = "riscv,c910_pmu";
+		};
+
+		ilde: idle {
+			compatible = "riscv,idle";
+		};
+
+		pio: pinctrl@2000000 {
+			compatible = "allwinner,sun20iw1-pinctrl";
+			reg = <0x0 0x02000000 0x0 0x500>;
+			interrupts-extended = <&plic0 85 IRQ_TYPE_LEVEL_HIGH>,
+				     <&plic0 87 IRQ_TYPE_LEVEL_HIGH>,
+				     <&plic0 89 IRQ_TYPE_LEVEL_HIGH>,
+				     <&plic0 91 IRQ_TYPE_LEVEL_HIGH>,
+				     <&plic0 93 IRQ_TYPE_LEVEL_HIGH>,
+				     <&plic0 95 IRQ_TYPE_LEVEL_HIGH>;
+			device_type = "pio";
+			clocks = <&ccu CLK_APB0>, <&dcxo24M>, <&rtc_ccu CLK_OSC32K>;
+			clock-names = "apb", "hosc", "losc";
+			gpio-controller;
+			#gpio-cells = <3>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			#size-cells = <0>;
+			vcc-pf-supply = <&reg_pio1_8>;
+			vcc-pfo-supply = <&reg_pio3_3>;
+
+			test_pins_a: test_pins@0 {
+				allwinner,pins = "PB0", "PB1";
+				allwinner,function = "test";
+				allwinner,muxsel = <0x7>;
+				allwinner,drive = <1>;
+				allwinner,pull = <1>;
+			};
+			test_pins_b: test_pins@1 {
+				pins = "PB0", "PB1";
+				function = "io_disabled";
+				allwinner,muxsel = <0xF>;
+				allwinner,drive = <1>;
+				allwinner,pull = <1>;
+			};
+
+			gmac_pins_a: gmac@0 {
+				pins = "PA0", "PA1", "PA2", "PA3",
+						 "PA4", "PA5", "PA6", "PA7",
+						 "PA8", "PA10", "PA11", "PA12",
+						 "PA13", "PA17", "PA18", "PA28",
+						 "PA29", "PA30", "PA31";
+				function = "gmac0";
+				drive-strength = <10>;
+			};
+
+			gmac_pins_b: gmac@1 {
+				pins = "PA0", "PA1", "PA2", "PA3",
+						 "PA4", "PA5", "PA6", "PA7",
+						 "PA8", "PA10", "PA11", "PA12",
+						 "PA13", "PA17", "PA18", "PA28",
+						 "PA29", "PA30", "PA31";
+				function = "gpio_in";
+				drive-strength = <10>;
+			};
+
+			ir1_pins_a: ir1@0 {  /* For FPGA board */
+				pins = "PG11";
+				function = "ir1";
+				drive-strength = <10>;
+			};
+
+			csi_mclk0_pins_a: csi_mclk0@0 {
+				pins = "PE3";
+				function = "csi0";
+				drive-strength = <10>;
+			};
+			csi_mclk0_pins_b: csi_mclk0@1 {
+				pins = "PE3";
+				function = "gpio_in";
+			};
+			csi0_pins_a: csi0@0 {
+				pins = "PE2", "PE0", "PE1", "PE4", "PE5",
+						 "PE6", "PE7", "PE8", "PE9", "PE10", "PE11";
+				function = "ncsi0";
+				drive-strength = <10>;
+			};
+			csi0_pins_b: csi0@1 {
+				pins = "PE2", "PE0", "PE1", "PE4", "PE5",
+						 "PE6", "PE7", "PE8", "PE9", "PE10", "PE11";
+				function = "io_disabled";
+				drive-strength = <10>;
+			};
+
+			lvds0_pins_a: lvds0@0 {
+				pins  = "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9";
+				function = "lvds0";
+				drive-strength = <30>;
+				bias-disable;
+			};
+
+			lvds0_pins_b: lvds0@1 {
+				pins  = "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9";
+				function = "io_disabled";
+				drive-strength = <30>;
+				bias-disable;
+			};
+
+			rgb24_pins_a: rgb24@0 {
+				pins = "PB2", "PB3", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", \
+					"PB4", "PB5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", \
+					"PB6", "PB7", "PD12", "PD13", "PD14", "PD15", "PD16", "PD17", \
+					"PD18", "PD19", "PD20", "PD21";
+				function = "lcd0";
+				drive-strength = <30>;
+				bias-disable;
+			};
+
+			rgb24_pins_b: rgb24@1 {
+				pins = "PB2", "PB3", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", \
+					"PB4", "PB5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", \
+					"PB6", "PB7", "PD12", "PD13", "PD14", "PD15", "PD16", "PD17", \
+					"PD18", "PD19", "PD20", "PD21";
+				function = "io_disabled";
+				bias-disable;
+			};
+
+			rgb18_pins_a: rgb18@0 {
+				pins = "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", \
+					"PD6", "PD7", "PD8", "PD9", "PD10", "PD11", \
+					"PD12", "PD13", "PD14", "PD15", "PD16", "PD17", \
+					"PD18", "PD19", "PD20", "PD21";
+				function = "lcd0";
+				drive-strength = <30>;
+				bias-disable;
+			};
+
+			rgb18_pins_b: rgb18@1 {
+				pins = "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", \
+					"PD6", "PD7", "PD8", "PD9", "PD10", "PD11", \
+					"PD12", "PD13", "PD14", "PD15", "PD16", "PD17", \
+					"PD18", "PD19", "PD20", "PD21";
+				function = "io_disabled";
+				bias-disable;
+			};
+
+			dsi2lane_pins_a: dsi2lane@0 {
+				pins = "PD0", "PD1", "PD2", "PD3", "PD4", "PD5";
+				function = "dsi";
+				drive-strength = <30>;
+				bias-disable;
+			};
+
+			dsi2lane_pins_b: dsi2lane@1 {
+				pins = "PD0", "PD1", "PD2", "PD3", "PD4", "PD5";
+				function = "io_disabled";
+				bias-disable;
+			};
+
+			dsi4lane_pins_a: dsi4lane@0 {
+				pins = "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9";
+				function = "dsi";
+				drive-strength = <30>;
+				bias-disable;
+			};
+
+			dsi4lane_pins_b: dsi4lane@1 {
+				pins = "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9";
+				function = "io_disabled";
+				bias-disable;
+			};
+
+		};
+
+		spi0: spi@4025000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "allwinner,sun20i-spi";
+			device_type = "spi0";
+			reg = <0x0 0x04025000 0x0 0x300>;
+			interrupts-extended = <&plic0 31 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_PLL_PERIPH0>, <&ccu CLK_SPI0>, <&ccu CLK_BUS_SPI0>;
+			clock-names = "pll", "mod", "bus";
+			resets = <&ccu RST_BUS_SPI0>;
+			clock-frequency = <100000000>;
+			pinctrl-names = "default", "sleep";
+			spi0_cs_number = <1>;
+			spi0_cs_bitmap = <1>;
+			dmas = <&dma 22>, <&dma 22>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		spi1: spi@4026000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "allwinner,sun20i-spi";
+			reg = <0x0 0x04026000 0x0 0x1000>;
+			interrupts-extended = <&plic0 32 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_PLL_PERIPH0>, <&ccu CLK_SPI1>, <&ccu CLK_BUS_SPI1>;
+			clock-names = "pll", "mod", "bus";
+			resets = <&ccu RST_BUS_SPI1>;
+			clock-frequency = <100000000>;
+			spi1_cs_number = <1>;
+			spi1_cs_bitmap = <1>;
+			dmas = <&dma 23>, <&dma 23>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		twi0: twi@2502000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "allwinner,sun20i-twi";
+			device_type = "twi0";
+			reg = <0x0 0x02502000 0x0 0x400>;
+			interrupts-extended= <&plic0 25 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C0>;
+			resets = <&ccu RST_BUS_I2C0>;
+			clock-names = "bus";
+			clock-frequency = <400000>;
+			dmas = <&dma 43>, <&dma 43>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		twi1: twi@2502400 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "allwinner,sun20i-twi";
+			device_type = "twi1";
+			reg = <0x0 0x02502400 0x0 0x400>;
+			interrupts-extended= <&plic0 26 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C1>;
+			resets = <&ccu RST_BUS_I2C1>;
+			clock-names = "bus";
+			clock-frequency = <200000>;
+			dmas = <&dma 44>, <&dma 44>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		twi2: twi@2502800 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "allwinner,sun20i-twi";
+			device_type = "twi2";
+			reg = <0x0 0x02502800 0x0 0x400>;
+			interrupts-extended = <&plic0 27 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C2>;
+			resets = <&ccu RST_BUS_I2C2>;
+			clock-names = "bus";
+			clock-frequency = <100000>;
+			dmas = <&dma 45>, <&dma 45>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		twi3: twi@2502c00 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "allwinner,sun20i-twi";
+			device_type = "twi3";
+			reg = <0x0 0x02502c00 0x0 0x400>;
+			interrupts-extended = <&plic0 28 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C3>;
+			resets = <&ccu RST_BUS_I2C3>;
+			clock-names = "bus";
+			clock-frequency = <100000>;
+			dmas = <&dma 46>, <&dma 46>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		ledc: ledc@2008000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "allwinner,sunxi-leds";
+			reg = <0x0 0x02008000 0x0 0x400>;
+			interrupts-extended = <&plic0 36 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "ledcirq";
+			clocks = <&ccu CLK_LEDC>, <&ccu CLK_BUS_LEDC>;
+			clock-names = "clk_ledc", "clk_cpuapb";
+			dmas = <&dma 42>, <&dma 42>;
+			dma-names = "rx", "tx";
+			resets = <&ccu RST_BUS_LEDC>;
+			reset-names = "ledc_reset";
+			status = "disable";
+		};
+
+		pwm: pwm@2000c00 {
+			#pwm-cells = <0x3>;
+			compatible = "allwinner,sunxi-pwm";
+			reg = <0x0 0x02000c00 0x0 0x3ff>;
+			clocks = <&ccu CLK_BUS_PWM>;
+			resets = <&ccu RST_BUS_PWM>;
+			pwm-number = <8>;
+			pwm-base = <0x0>;
+			sunxi-pwms = <&pwm0>, <&pwm1>, <&pwm2>, <&pwm3>, <&pwm4>,
+				<&pwm5>, <&pwm6>, <&pwm7>;
+
+		};
+
+		keyboard0: keyboard@2009800 {
+			compatible = "allwinner,keyboard_1350mv";
+			reg = <0x0 0x02009800 0x0 0x400>;
+			interrupts-extended = <&plic0 77 IRQ_TYPE_EDGE_RISING>;
+			clocks = <&ccu CLK_BUS_LRADC>;
+			resets = <&ccu RST_BUS_LRADC>;
+			key_cnt = <5>;
+			key0 = <210 115>;
+			key1 = <410 114>;
+			key2 = <590 139>;
+			key3 = <750 28>;
+			key4 = <880 172>;
+			status = "disabled";
+		};
+
+		sid@3006000 {
+			compatible = "allwinner,sun20iw1p1-sid", "allwinner,sunxi-sid";
+			reg = <0x0 0x03006000 0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			chipid {
+				reg = <0x0 0>;
+				offset = <0x200>;
+				size = <0x10>;
+			};
+
+			oem {
+				reg = <0x0 0>;
+				offset = <0x238>;
+				size = <0x8>;
+			};
+
+			secure_status {
+				reg = <0x0 0>;
+				offset = <0x210>;
+				size = <0x4>;
+			};
+
+			speedbin_efuse: speedbin@00 {
+				reg = <0x00 2>;
+			};
+
+			cpubin_efuse: cpubin@28 {
+				reg = <0x28 2>;
+			};
+
+			ths_calib: calib@14 {
+				reg = <0x14 8>;
+			};
+		};
+
+		gpadc: gpadc@2009000 {
+		       compatible = "allwinner,sunxi-gpadc";
+		       reg = <0x0 0x02009000 0x0 0x400>;
+		       interrupts-extended = <&plic0 73 IRQ_TYPE_LEVEL_HIGH>;
+		       clocks = <&ccu CLK_BUS_GPADC>;
+		       clock-names = "bus";
+		       resets = <&ccu RST_BUS_GPADC>;
+		       status = "okay";
+		};
+
+		ths: ths@02009400 {
+			compatible = "allwinner,sun20iw1p1-ths";
+			reg = <0x0 0x02009400 0x0 0x400>;
+			clocks = <&ccu CLK_BUS_THS>;
+			clock-names = "bus";
+			resets = <&ccu RST_BUS_THS>;
+			nvmem-cells = <&ths_calib>;
+			nvmem-cell-names = "calibration";
+			#thermal-sensor-cells = <1>;
+		};
+
+		tpadc: tpadc@2009c00 {
+			compatible = "allwinner,tp_key";
+			reg = <0x0 0x02009c00 0x0 0x400>;
+			interrupts-extended = <&plic0 78 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_TPADC>, <&ccu CLK_BUS_TPADC>;
+			clock-names = "mod", "bus";
+			clock-frequency = <1000000>;
+			resets = <&ccu RST_BUS_TPADC>;
+			status = "disabled";
+		};
+
+		rtp:rtp@2009c00 {
+			compatible = "allwinner,sun8i-ts";
+			reg = <0x0 0x02009c00 0x0 0x400>;
+			clocks = <&ccu CLK_TPADC>, <&ccu CLK_BUS_TPADC>;
+			clock-names = "mod", "bus";
+			clock-frequency = <1000000>;
+			resets = <&ccu RST_BUS_TPADC>;
+			interrupts-extended = <&plic0 78 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		/* codec addr: 0x02030000, the others is invalid to avoid build warining */
+		codec:codec@2030000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-internal-codec";
+			reg = <0x0 0x02030000 0x0 0x34c>;
+			clocks = <&ccu CLK_PLL_AUDIO0>,
+				 <&ccu CLK_PLL_AUDIO1_DIV5>,
+				 <&ccu CLK_AUDIO_DAC>,
+				 <&ccu CLK_AUDIO_ADC>,
+				 <&ccu CLK_BUS_AUDIO_CODEC>;
+			clock-names = "pll_audio0", "pll_audio1_div5",
+				      "audio_clk_dac", "audio_clk_adc",
+				      "audio_clk_bus";
+			resets = <&ccu RST_BUS_AUDIO_CODEC>;
+			rx_sync_en  = <0x00>;
+			device_type = "codec";
+			status = "disabled";
+		};
+
+		dummy_cpudai:dummy_cpudai@203034c {
+			compatible = "allwinner,sunxi-dummy-cpudai";
+			reg = <0x0 0x0203034c 0x0 0x4>;
+			tx_fifo_size    = <128>;
+			rx_fifo_size    = <256>;
+			dac_txdata      = <0x02030020>;
+			adc_txdata      = <0x02030040>;
+			playback_cma    = <128>;
+			capture_cma     = <256>;
+			device_type = "cpudai";
+			dmas = <&dma 7>, <&dma 7>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		sndcodec:sound@2030340 {
+			compatible = "allwinner,sunxi-codec-machine";
+			reg = <0x0 0x02030340 0x0 0x4>;
+			interrupts-extended = <&plic0 41 IRQ_TYPE_LEVEL_HIGH>;
+			sunxi,audio-codec = <&codec>;
+			sunxi,cpudai-controller = <&dummy_cpudai>;
+			device_type = "sndcodec";
+			status = "disabled";
+		};
+
+		sunxi_rpaf_dsp0:rpaf-dsp@203034c {
+			compatible = "allwinner,rpaf-dsp0";
+			device_type = "sunxi_rpaf_dsp0";
+			dsp_id = <0x0>;
+			status = "okay";
+		};
+
+		/* dmic addr: 0x02031000, the others is invalid to avoid build warining */
+		dmic:dmic@2031000{
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-dmic";
+			reg = <0x0 0x02031000 0x0 0x50>;
+			clocks = <&ccu CLK_PLL_AUDIO0>,
+				 <&ccu CLK_DMIC>,
+				 <&ccu CLK_BUS_DMIC>;
+			clock-names = "pll_audio", "dmic", "dmic_bus";
+			resets = <&ccu RST_BUS_DMIC>;
+			dmas		= <&dma 8>;
+			dma-names	= "rx";
+			interrupts-extended = <&plic0 40 IRQ_TYPE_LEVEL_HIGH>;
+			clk_parent	= <0x1>;
+			capture_cma	= <256>;
+			data_vol	= <0xB0>;
+			rx_chmap	= <0x76543210>;
+			rx_sync_en      = <0x00>;
+			device_type = "dmic";
+			status = "disabled";
+		};
+
+		dmic_codec:sound@2031050{
+			#sound-dai-cells = <0>;
+			compatible = "dmic-codec";
+			reg = <0x0 0x02031050 0x0 0x4>;
+			num-channels = <8>;
+			status = "disabled";
+		};
+
+		sounddmic:sounddmic@2031060 {
+			reg = <0x0 0x02031060 0x0 0x4>;
+			compatible = "sunxi,simple-audio-card";
+			simple-audio-card,name = "snddmic";
+			simple-audio-card,capture_only;
+			status = "disabled";
+			/* simple-audio-card,format = "i2s"; */
+			simple-audio-card,cpu {
+				sound-dai = <&dmic>;
+			};
+			simple-audio-card,codec {
+				sound-dai = <&dmic_codec>;
+			};
+		};
+
+		/* daudio0 addr: 0x02032000, the others is invalid to avoid build warining */
+		daudio0:daudio@2032000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-daudio";
+			reg = <0x0 0x02032000 0x0 0xa0>;
+			clocks = <&ccu CLK_PLL_AUDIO0>,
+				 <&ccu CLK_I2S0>,
+				 <&ccu CLK_BUS_I2S0>;
+			clock-names = "pll_audio", "i2s0", "i2s0_bus";
+			resets = <&ccu RST_BUS_I2S0>;
+			dmas		= <&dma 3>, <&dma 3>;
+			dma-names	= "tx", "rx";
+			interrupts-extended = <&plic0 42 IRQ_TYPE_LEVEL_HIGH>;
+			sign_extend		= <0x00>;
+			tx_data_mode		= <0x00>;
+			rx_data_mode		= <0x00>;
+			msb_lsb_first		= <0x00>;
+			pcm_lrck_period		= <0x80>;
+			slot_width_select	= <0x20>;
+			frametype		= <0x00>;
+			tdm_config		= <0x01>;
+			tdm_num			= <0x00>;
+			mclk_div		= <0x00>;
+			clk_parent		= <0x01>;
+			capture_cma		= <128>;
+			playback_cma		= <128>;
+			tx_num			= <4>;
+			tx_chmap1		= <0x76543210>;
+			tx_chmap0		= <0xFEDCBA98>;
+			rx_num			= <4>;
+			rx_chmap3		= <0x03020100>;
+			rx_chmap2		= <0x07060504>;
+			rx_chmap1		= <0x0B0A0908>;
+			rx_chmap0		= <0x0F0E0D0C>;
+			asrc_function_en	= <0x00>;
+			rx_sync_en              = <0x00>;
+			device_type = "daudio0";
+			status = "disabled";
+		};
+
+		sounddaudio0: sounddaudio0@20320a0 {
+			reg = <0x0 0x020320a0 0x0 0x4>;
+			compatible = "sunxi,simple-audio-card";
+			simple-audio-card,name = "snddaudio0";
+			simple-audio-card,format = "i2s";
+			status = "disabled";
+			/* simple-audio-card,frame-master = <&daudio0_master>; */
+			/* simple-audio-card,bitclock-master = <&daudio0_master>; */
+			/* simple-audio-card,bitclock-inversion; */
+			/* simple-audio-card,frame-inversion; */
+			simple-audio-card,cpu {
+				sound-dai = <&daudio0>;
+			};
+		};
+
+		/* daudio1 addr: 0x02033000, the others is invalid to avoid build warining */
+		daudio1:daudio@2033000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-daudio";
+			reg = <0x0 0x02033000 0x0 0xa0>;
+			clocks = <&ccu CLK_PLL_AUDIO0>,
+				 <&ccu CLK_I2S1>,
+				 <&ccu CLK_BUS_I2S1>;
+			clock-names = "pll_audio", "i2s1", "i2s1_bus";
+			resets = <&ccu RST_BUS_I2S1>;
+			dmas		= <&dma 4>, <&dma 4>;
+			dma-names	= "tx", "rx";
+			interrupts-extended = <&plic0 43 IRQ_TYPE_LEVEL_HIGH>;
+			sign_extend		= <0x00>;
+			tx_data_mode		= <0x00>;
+			rx_data_mode		= <0x00>;
+			msb_lsb_first		= <0x00>;
+			pcm_lrck_period		= <0x80>;
+			slot_width_select	= <0x20>;
+			frametype		= <0x00>;
+			tdm_config		= <0x01>;
+			tdm_num			= <0x01>;
+			mclk_div		= <0x00>;
+			clk_parent		= <0x01>;
+			capture_cma		= <128>;
+			playback_cma		= <128>;
+			tx_num			= <4>;
+			tx_chmap1		= <0x76543210>;
+			tx_chmap0		= <0xFEDCBA98>;
+			rx_num			= <4>;
+			rx_chmap3		= <0x03020100>;
+			rx_chmap2		= <0x07060504>;
+			rx_chmap1		= <0x0B0A0908>;
+			rx_chmap0		= <0x0F0E0D0C>;
+			asrc_function_en	= <0x00>;
+			rx_sync_en              = <0x00>;
+			device_type = "daudio1";
+			status = "disabled";
+		};
+
+		sounddaudio1: sounddaudio1@20330a0 {
+			reg = <0x0 0x020330a0 0x0 0x4>;
+			compatible = "sunxi,simple-audio-card";
+			simple-audio-card,name = "snddaudio1";
+			simple-audio-card,format = "i2s";
+			status = "disabled";
+			simple-audio-card,cpu {
+				sound-dai = <&daudio1>;
+			};
+		};
+
+		/* daudio2 addr: 0x02034000, the others is invalid to avoid build warining */
+		daudio2:daudio@2034000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-daudio";
+			reg = <0x0 0x02034000 0x0 0xa0>;
+			clocks = <&ccu CLK_PLL_AUDIO0>,
+				 <&ccu CLK_I2S2>,
+				 <&ccu CLK_BUS_I2S2>,
+				 <&ccu CLK_PLL_AUDIO0_4X>,
+				 <&ccu CLK_I2S2_ASRC>;
+			resets = <&ccu RST_BUS_I2S2>;
+			dmas		= <&dma 5>, <&dma 5>;
+			dma-names	= "tx", "rx";
+			interrupts-extended = <&plic0 44 IRQ_TYPE_LEVEL_HIGH>;
+			sign_extend		= <0x00>;
+			tx_data_mode		= <0x00>;
+			rx_data_mode		= <0x00>;
+			msb_lsb_first		= <0x00>;
+			pcm_lrck_period		= <0x80>;
+			slot_width_select	= <0x20>;
+			frametype		= <0x00>;
+			tdm_config		= <0x01>;
+			tdm_num			= <0x02>;
+			mclk_div		= <0x01>;
+			clk_parent		= <0x01>;
+			capture_cma		= <128>;
+			playback_cma		= <128>;
+			tx_num			= <4>;
+			tx_chmap1		= <0x76543210>;
+			tx_chmap0		= <0xFEDCBA98>;
+			rx_num			= <4>;
+			rx_chmap3		= <0x03020100>;
+			rx_chmap2		= <0x07060504>;
+			rx_chmap1		= <0x0B0A0908>;
+			rx_chmap0		= <0x0F0E0D0C>;
+			asrc_function_en	= <0x00>;
+			rx_sync_en              = <0x00>;
+			device_type = "daudio2";
+			status = "disabled";
+		};
+
+		sounddaudio2: sounddaudio2@20340a0 {
+			reg = <0x0 0x020340a0 0x0 0x4>;
+			compatible = "sunxi,simple-audio-card";
+			simple-audio-card,name = "snddaudio2";
+			simple-audio-card,format = "i2s";
+			status = "disabled";
+			simple-audio-card,cpu {
+				sound-dai = <&daudio2>;
+			};
+		};
+
+		hdmiaudio: hdmiaudio@20340a4 {
+			#sound-dai-cells = <0>;
+			reg = <0x0 0x020340a4 0x0 0x4>;
+			compatible = "allwinner,sunxi-hdmiaudio";
+			status = "disabled";
+		};
+
+		/* spdif addr: 0x02036000, the others is invalid to avoid build warining */
+		spdif:spdif@2036000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-spdif";
+			reg = <0x0 0x02036000 0x0 0x58>;
+			clocks = <&ccu CLK_PLL_AUDIO0_4X>,
+				 <&ccu CLK_SPDIF_TX>,
+				 <&ccu CLK_BUS_SPDIF>,
+				 <&ccu CLK_PLL_AUDIO1>,
+				 <&ccu CLK_PLL_AUDIO1_DIV5>,
+				 <&ccu CLK_PLL_PERIPH0>,
+				 <&ccu CLK_SPDIF_RX>;
+			clock-names = "pll_audio0", "spdif", "spdif_bus",
+				      "pll_audio1", "pll_audio1_div5",
+				      "pll_periph","spdif_rx";
+			resets = <&ccu RST_BUS_SPDIF>;
+			dmas		= <&dma 2>, <&dma 2>;
+			dma-names	= "tx", "rx";
+			interrupts-extended = <&plic0 41 IRQ_TYPE_LEVEL_HIGH>;
+			clk_parent	= <0x1>;
+			playback_cma	= <128>;
+			capture_cma	= <128>;
+			rx_sync_en      = <0>;
+			device_type = "spdif";
+			status = "disabled";
+		};
+
+		soundspdif:soundspdif@2036040 {
+			reg = <0x0 0x02036040 0x0 0x4>;
+			compatible = "sunxi,simple-audio-card";
+			simple-audio-card,name = "sndspdif";
+			status = "disabled";
+			 /* simple-audio-card,format = "i2s"; */
+			 simple-audio-card,cpu {
+				 sound-dai = <&spdif>;
+			 };
+			 simple-audio-card,codec {
+				 /*snd-soc-dummy*/
+			 };
+		};
+
+		g2d: g2d@5410000 {
+			compatible = "allwinner,sunxi-g2d";
+			reg = <0x0 0x05410000 0x0 0x3ffff>;
+/*			interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;*/
+			interrupts-extended = <&plic0 105 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_G2D>, <&ccu CLK_G2D>, <&ccu CLK_MBUS_G2D>;
+			clock-names = "bus", "g2d", "mbus_g2d";
+			resets = <&ccu RST_BUS_G2D>;
+			iommus = <&mmu_aw 3 1>;
+			status = "okay";
+		};
+
+		disp: disp@5000000 {
+			compatible = "allwinner,sunxi-disp";
+			reg = <0x0 0x05000000 0x0 0x3fffff>,	/* de0 */
+			      <0x0 0x05460000 0x0 0xfff>,	/*display_if_top*/
+			      <0x0 0x05461000 0x0 0xfff>,	/* tcon-lcd0 */
+			      <0x0 0x05470000 0x0 0xfff>,	/* tcon-tv */
+			      <0x0 0x05450000 0x0 0x1fff>;	/* dsi0*/
+/*			interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>,tcon-lcd0
+				     <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>,tcon-tv
+				     <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;dsi*/
+			interrupts-extended = <&plic0 106 IRQ_TYPE_LEVEL_HIGH>,
+					      <&plic0 107 IRQ_TYPE_LEVEL_HIGH>,
+					      <&plic0 108 IRQ_TYPE_LEVEL_HIGH>;
+
+			clocks = <&ccu CLK_DE0>,
+				 <&ccu CLK_DE0>,
+				 <&ccu CLK_BUS_DE0>,
+				 <&ccu CLK_BUS_DE0>,
+				 <&ccu CLK_BUS_DPSS_TOP0>,
+				 <&ccu CLK_BUS_DPSS_TOP0>,
+				 <&ccu CLK_MIPI_DSI>,
+				 <&ccu CLK_BUS_MIPI_DSI>,
+				 <&ccu CLK_TCON_LCD0>,
+				 <&ccu CLK_TCON_TV>,
+				 <&ccu CLK_BUS_TCON_LCD0>,
+				 <&ccu CLK_BUS_TCON_TV>,
+				 <&ccu CLK_MIPI_DSI>,
+				 <&ccu CLK_BUS_MIPI_DSI>;
+			clock-names = "clk_de0",
+					"clk_de1",
+					"clk_bus_de0",
+					"clk_bus_de1",
+					"clk_bus_dpss_top0",
+					"clk_bus_dpss_top1",
+					"clk_mipi_dsi0",
+					"clk_bus_mipi_dsi0",
+					"clk_tcon0",
+					"clk_tcon1",/*tcon-tv actually*/
+					"clk_bus_tcon0",
+					"clk_bus_tcon1",/*tcon-tv actually*/
+					"clk_mipi_dsi0",
+					"clk_bus_mipi_dsi0";
+			resets = <&ccu RST_BUS_DE0>,
+				 <&ccu RST_BUS_DE0>,
+				 <&ccu RST_BUS_DPSS_TOP0>,
+				 <&ccu RST_BUS_DPSS_TOP0>,
+				 <&ccu RST_BUS_MIPI_DSI>,
+				 <&ccu RST_BUS_TCON_LCD0>,
+				 <&ccu RST_BUS_TCON_TV>,
+				 <&ccu RST_BUS_LVDS0>;
+			reset-names = "rst_bus_de0",
+					"rst_bus_de1",
+					"rst_bus_dpss_top0",
+					"rst_bus_dpss_top1",
+					"rst_bus_mipi_dsi0",
+					"rst_bus_tcon0",
+					"rst_bus_tcon1",
+					"rst_bus_lvds0";
+
+			assigned-clocks = <&ccu CLK_DE0>,
+			<&ccu CLK_MIPI_DSI>,
+			<&ccu CLK_TCON_LCD0>,
+			<&ccu CLK_TCON_TV>;
+			assigned-clock-parents = <&ccu CLK_PLL_PERIPH0_2X>,
+			<&ccu CLK_PLL_PERIPH0>,
+			<&ccu CLK_PLL_VIDEO0_4X>,
+			<&ccu CLK_PLL_VIDEO1_4X>;
+			assigned-clock-rates = <300000000>,
+			<150000000>,
+			<0>,
+			<0>;
+
+			boot_disp = <0>;
+			boot_disp1 = <0>;
+			boot_disp2 = <0>;
+			fb_base = <0>;
+			iommus = <&mmu_aw 2 0>;
+			status = "okay";
+		};
+
+             ve: ve@1c0e000 {
+                   compatible = "allwinner,sunxi-cedar-ve";
+                   reg = <0x0 0x01c0e000 0x0 0x1000>,
+                         <0x0 0x03000000 0x0 0x10>,
+                         <0x0 0x03001000 0x0 0x1000>;
+                   interrupts-extended = <&plic0 82 IRQ_TYPE_LEVEL_HIGH>;
+                   clocks = <&ccu CLK_BUS_VE>, <&ccu CLK_VE>, <&ccu CLK_MBUS_VE>;
+                   clock-names = "bus_ve", "ve", "mbus_ve";
+                   resets = <&ccu RST_BUS_VE>;
+                   iommus = <&mmu_aw 0 1>;
+                   status = "okay";
+             };
+
+		msgbox: msgbox@0601f000 {
+			compatible = "sunxi,msgbox-amp";
+			reg = <0x0 0x03003000 0x0 0x1000>,
+			      <0x0 0x01701000 0x0 0x1000>,
+			      <0x0 0x0601f000 0x0 0x1000>;
+			interrupts-extended = <&plic0 144 IRQ_TYPE_LEVEL_HIGH>,
+					<&plic0 102 IRQ_TYPE_LEVEL_HIGH>,
+					<&plic0 140 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_MSGBOX2>;
+			rpmsg_id = "sunxi,dsp-msgbox","sunxi,dsp-power-msgbox";
+			resets = <&ccu RST_BUS_MSGBOX2>;
+			reset-names = "rst";
+			msgbox_amp_counts = <3>;
+			msgbox_amp_local = <2>;
+			rpmsg_amp_remote-0 = <1>;
+			rpmsg_read_channel-0 = <2>;
+			rpmsg_write_channel-0 = <2>;
+			rpmsg_amp_remote-1 = <1>;
+			rpmsg_read_channel-1 = <0>;
+			rpmsg_write_channel-1 = <0>;
+		};
+
+		lcd0: lcd0@1c0c000 {
+			compatible = "allwinner,sunxi-lcd0";
+			reg = <0x0 0x1c0c000 0x0 0x0>;  /* Fake registers to avoid dtc compiling warnings */
+			pinctrl-names = "active","sleep";
+			status = "okay";
+		};
+
+
+		sdc2: sdmmc@4022000 {
+			compatible = "allwinner,sunxi-mmc-v4p6x";
+			device_type = "sdc2";
+			reg = <0x0 0x04022000 0x0 0x1000>;
+			interrupts-extended = <&plic0 58 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&dcxo24M>,
+				 <&ccu CLK_PLL_PERIPH0_2X>,
+				 <&ccu CLK_MMC2>,
+				 <&ccu CLK_BUS_MMC2>;
+			clock-names = "osc24m","pll_periph","mmc","ahb";
+			resets = <&ccu RST_BUS_MMC2>;
+			reset-names = "rst";
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&sdc2_pins_a>;
+			pinctrl-1 = <&sdc2_pins_b>;
+			bus-width = <4>;
+			req-page-count = <2>;
+			cap-mmc-highspeed;
+			cap-cmd23;
+			mmc-cache-ctrl;
+			non-removable;
+			/*max-frequency = <200000000>;*/
+			max-frequency = <50000000>;
+			cap-erase;
+			mmc-high-capacity-erase-size;
+			no-sdio;
+			no-sd;
+			/*-- speed mode --*/
+			/*sm0: DS26_SDR12*/
+			/*sm1: HSSDR52_SDR25*/
+			/*sm2: HSDDR52_DDR50*/
+			/*sm3: HS200_SDR104*/
+			/*sm4: HS400*/
+			/*-- frequency point --*/
+			/*f0: CLK_400K*/
+			/*f1: CLK_25M*/
+			/*f2: CLK_50M*/
+			/*f3: CLK_100M*/
+			/*f4: CLK_150M*/
+			/*f5: CLK_200M*/
+
+			sdc_tm4_sm0_freq0 = <0>;
+			sdc_tm4_sm0_freq1 = <0>;
+			sdc_tm4_sm1_freq0 = <0x00000000>;
+			sdc_tm4_sm1_freq1 = <0>;
+			sdc_tm4_sm2_freq0 = <0x00000000>;
+			sdc_tm4_sm2_freq1 = <0>;
+			sdc_tm4_sm3_freq0 = <0x05000000>;
+			sdc_tm4_sm3_freq1 = <0x00000005>;
+			sdc_tm4_sm4_freq0 = <0x00050000>;
+			sdc_tm4_sm4_freq1 = <0x00000004>;
+			sdc_tm4_sm4_freq0_cmd = <0>;
+			sdc_tm4_sm4_freq1_cmd = <0>;
+
+			/*vmmc-supply = <&reg_3p3v>;*/
+			/*vqmc-supply = <&reg_3p3v>;*/
+			/*vdmc-supply = <&reg_3p3v>;*/
+			/*vmmc = "vcc-card";*/
+			/*vqmc = "";*/
+			/*vdmc = "";*/
+			/*sunxi-power-save-mode;*/
+		};
+
+		sdc0: sdmmc@4020000 {
+			compatible = "allwinner,sunxi-mmc-v5p3x";
+			device_type = "sdc0";
+			reg = <0x0 0x04020000 0x0 0x1000>;
+			interrupts-extended = <&plic0 56 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&dcxo24M>,
+				 <&ccu CLK_PLL_PERIPH0_2X>,
+				 <&ccu CLK_MMC0>,
+				 <&ccu CLK_BUS_MMC0>;
+			clock-names = "osc24m","pll_periph","mmc","ahb";
+			resets = <&ccu RST_BUS_MMC0>;
+			reset-names = "rst";
+			pinctrl-names = "default","mmc_1v8","sleep","uart_jtag";
+			pinctrl-0 = <&sdc0_pins_a>;
+			pinctrl-1 = <&sdc0_pins_b>;
+			pinctrl-2 = <&sdc0_pins_c>;
+			pinctrl-3 = <&sdc0_pins_d &sdc0_pins_e>;
+			max-frequency = <50000000>;
+			bus-width = <4>;
+			req-page-count = <2>;
+			/*non-removable;*/
+			/*broken-cd;*/
+			/*cd-inverted*/
+			/*cd-gpios = <&pio PF 6 GPIO_ACTIVE_LOW>;*/
+			/* vmmc-supply = <&reg_3p3v>;*/
+			/* vqmc-supply = <&reg_3p3v>;*/
+			/* vdmc-supply = <&reg_3p3v>;*/
+			/*vmmc = "vcc-card";*/
+			/*vqmc = "";*/
+			/*vdmc = "";*/
+			cap-sd-highspeed;
+			cap-wait-while-busy;
+			no-sdio;
+			no-mmc;
+			/*sd-uhs-sdr50;*/
+			/*sd-uhs-ddr50;*/
+			/*cap-sdio-irq;*/
+			/*keep-power-in-suspend;*/
+			/*ignore-pm-notify;*/
+			/*sunxi-power-save-mode;*/
+			/*sunxi-dly-400k = <1 0 0 0>; */
+			/*sunxi-dly-26M  = <1 0 0 0>;*/
+			/*sunxi-dly-52M  = <1 0 0 0>;*/
+			/*sunxi-dly-52M-ddr4  = <1 0 0 0>;*/
+			/*sunxi-dly-52M-ddr8  = <1 0 0 0>;*/
+			/*sunxi-dly-104M  = <1 0 0 0>;*/
+			/*sunxi-dly-208M  = <1 0 0 0>;*/
+			/*sunxi-dly-104M-ddr  = <1 0 0 0>;*/
+			/*sunxi-dly-208M-ddr  = <1 0 0 0>;*/
+
+			status = "okay";
+		};
+
+
+
+		sdc1: sdmmc@4021000 {
+			compatible = "allwinner,sunxi-mmc-v5p3x";
+			device_type = "sdc1";
+			reg = <0x0 0x04021000 0x0 0x1000>;
+			interrupts-extended = <&plic0 57 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&dcxo24M>,
+				 <&ccu CLK_PLL_PERIPH0_2X>,
+				 <&ccu CLK_MMC1>,
+				 <&ccu CLK_BUS_MMC1>;
+			clock-names = "osc24m","pll_periph","mmc","ahb";
+			resets = <&ccu RST_BUS_MMC1>;
+			reset-names = "rst";
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&sdc1_pins_a>;
+			pinctrl-1 = <&sdc1_pins_b>;
+			max-frequency = <50000000>;
+			bus-width = <4>;
+			/*broken-cd;*/
+			/*cd-inverted*/
+			/*cd-gpios = <&pio PG 6 6 1 2 0>;*/
+			/* vmmc-supply = <&reg_3p3v>;*/
+			/* vqmc-supply = <&reg_3p3v>;*/
+			/* vdmc-supply = <&reg_3p3v>;*/
+			/*vmmc = "vcc-card";*/
+			/*vqmc = "";*/
+			/*vdmc = "";*/
+			cap-sd-highspeed;
+			no-mmc;
+			/*sd-uhs-sdr50;*/
+			/*sd-uhs-ddr50;*/
+			/*sd-uhs-sdr104;*/
+			/*cap-sdio-irq;*/
+			keep-power-in-suspend;
+			/*ignore-pm-notify;*/
+			/*sunxi-power-save-mode;*/
+			/*sunxi-dly-400k = <1 0 0 0 0>; */
+			/*sunxi-dly-26M  = <1 0 0 0 0>;*/
+			/*sunxi-dly-52M  = <1 0 0 0 0>;*/
+			sunxi-dly-52M-ddr4  = <1 0 0 0 2>;
+			/*sunxi-dly-52M-ddr8  = <1 0 0 0 0>;*/
+			sunxi-dly-104M  = <1 0 0 0 1>;
+			/*sunxi-dly-208M  = <1 1 0 0 0>;*/
+			sunxi-dly-208M  = <1 0 0 0 1>;
+			/*sunxi-dly-104M-ddr  = <1 0 0 0 0>;*/
+			/*sunxi-dly-208M-ddr  = <1 0 0 0 0>;*/
+
+			status = "disabled";
+		};
+
+		hdmi: hdmi@5500000 {
+			compatible = "allwinner,sunxi-hdmi";
+			reg = <0x0 0x05500000 0x0 0xfffff>;
+			interrupts-extended = <&plic0 93 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_HDMI>,
+				<&ccu CLK_HDMI_24M>,
+				<&ccu CLK_HDMI_CEC>,
+				<&ccu CLK_TCON_TV>;
+			clock-names = "clk_bus_hdmi",
+					"clk_ddc",
+					"clk_cec",
+					"clk_tcon_tv";
+			resets = <&ccu RST_BUS_HDMI_SUB>,
+				<&ccu RST_BUS_HDMI_MAIN>;
+			reset-names = "rst_bus_sub",
+				      "rst_bus_main";
+			assigned-clocks = <&ccu CLK_HDMI_CEC>;
+			assigned-clock-parents = <&ccu CLK_HDMI_CEC_32K>;
+			assigned-clock-rates = <0>;
+			status = "okay";
+		};
+
+		usbc0:usbc0@0 {
+			device_type = "usbc0";
+			compatible = "allwinner,sunxi-otg-manager";
+			usb_port_type = <2>;
+			usb_detect_type = <1>;
+			usb_id_gpio;
+			usb_det_vbus_gpio;
+			usb_regulator_io = "nocare";
+			usb_wakeup_suspend = <0>;
+			usb_luns = <3>;
+			usb_serial_unique = <0>;
+			usb_serial_number = "20080411";
+			rndis_wceis = <1>;
+			status = "okay";
+		};
+
+		udc:udc-controller@0x04100000 {
+			compatible = "allwinner,sunxi-udc";
+			reg = <0x0 0x04100000 0x0 0x1000>, /*udc base*/
+			      <0x0 0x00000000 0x0 0x100>; /*sram base*/
+			interrupts-extended = <&plic0 45 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OTG>;
+			clock-names = "bus_otg";
+			resets = <&ccu RST_BUS_OTG>, <&ccu RST_USB_PHY0>;
+			reset-names = "otg", "phy";
+			status = "okay";
+		};
+
+		ehci0:ehci0-controller@0x04101000 {
+			compatible = "allwinner,sunxi-ehci0";
+			reg = <0x0 0x04101000 0x0 0xFFF>, /*hci0 base*/
+			      <0x0 0x00000000 0x0 0x100>, /*sram base*/
+			      <0x0 0x04100000 0x0 0x1000>; /*otg base*/
+			interrupts-extended = <&plic0 46 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_EHCI0>;
+			clock-names = "bus_hci";
+			resets = <&ccu RST_BUS_EHCI0>, <&ccu RST_USB_PHY0>;
+			reset-names = "hci", "phy";
+			hci_ctrl_no = <0>;
+			status = "okay";
+		};
+
+		ohci0:ohci0-controller@0x04101400 {
+			compatible = "allwinner,sunxi-ohci0";
+			reg = <0x0 0x04101400 0x0 0xFFF>, /*hci0 base*/
+			      <0x0 0x00000000 0x0 0x100>, /*sram base*/
+			      <0x0 0x04100000 0x0 0x1000>; /*otg base*/
+			interrupts-extended = <&plic0 47 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI0>, <&ccu CLK_USB_OHCI0>;
+			clock-names = "bus_hci", "ohci";
+			resets = <&ccu RST_BUS_OHCI0>, <&ccu RST_USB_PHY0>;
+			reset-names = "hci", "phy";
+			hci_ctrl_no = <0>;
+			status = "okay";
+		};
+
+		usbc1:usbc1@0 {
+			device_type = "usbc1";
+			usb_regulator_io = "nocare";
+			usb_wakeup_suspend = <0>;
+			status = "disable";
+		};
+
+		ehci1:ehci1-controller@0x04200000 {
+			compatible = "allwinner,sunxi-ehci1";
+			reg = <0x0 0x04200000 0x0 0xFFF>, /*ehci1 base*/
+			      <0x0 0x00000000 0x0 0x100>, /*sram base*/
+			      <0x0 0x04100000 0x0 0x1000>; /*otg base*/
+			interrupts-extended = <&plic0 49 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_EHCI1>;
+			clock-names = "bus_hci";
+			resets = <&ccu RST_BUS_EHCI1>, <&ccu RST_USB_PHY1>;
+			reset-names = "hci", "phy";
+			hci_ctrl_no = <1>;
+			status = "disable";
+		};
+
+		ohci1:ohci1-controller@0x04200400 {
+			compatible = "allwinner,sunxi-ohci1";
+			reg = <0x0 0x04200400 0x0 0xFFF>, /*ohci1 base*/
+			      <0x0 0x00000000 0x0 0x100>, /*sram base*/
+			      <0x0 0x04100000 0x0 0x1000>; /*otg base*/
+			interrupts-extended = <&plic0 50 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI1>, <&ccu CLK_USB_OHCI1>;
+			clock-names = "bus_hci", "ohci";
+			resets = <&ccu RST_BUS_OHCI1>, <&ccu RST_USB_PHY1>;
+			reset-names = "hci", "phy";
+			hci_ctrl_no = <1>;
+			status = "disable";
+		};
+
+		pwm0: pwm0@2000c10 {
+			compatible = "allwinner,sunxi-pwm0";
+			reg = <0x0 0x02000c10 0x0 0x4>;
+			reg_base = <0x02000c00>;
+		};
+
+		pwm1: pwm1@2000c11 {
+			compatible = "allwinner,sunxi-pwm1";
+			reg = <0x0 0x02000c11 0x0 0x4>;
+			reg_base = <0x02000c00>;
+		};
+
+		pwm2: pwm2@2000c12 {
+			compatible = "allwinner,sunxi-pwm2";
+			reg = <0x0 0x02000c12 0x0 0x4>;
+			reg_base = <0x02000c00>;
+		};
+
+		pwm3: pwm3@2000c13 {
+			compatible = "allwinner,sunxi-pwm3";
+			reg = <0x0 0x02000c13 0x0 0x4>;
+			reg_base = <0x02000c00>;
+		};
+
+		pwm4: pwm4@2000c14 {
+			compatible = "allwinner,sunxi-pwm4";
+			reg = <0x0 0x02000c14 0x0 0x4>;
+			reg_base = <0x02000c00>;
+		};
+
+		pwm5: pwm5@2000c15 {
+			compatible = "allwinner,sunxi-pwm5";
+			reg = <0x0 0x02000c15 0x0 0x4>;
+			reg_base = <0x02000c00>;
+		};
+
+		pwm6: pwm6@2000c16 {
+			compatible = "allwinner,sunxi-pwm6";
+			reg = <0x0 0x02000c16 0x0 0x4>;
+			reg_base = <0x02000c00>;
+		};
+
+		pwm7: pwm7@2000c17 {
+			compatible = "allwinner,sunxi-pwm7";
+			reg = <0x0 0x02000c17 0x0 0x4>;
+			reg_base = <0x02000c00>;
+		};
+
+		lcd_fb0: lcd_fb0@0 {
+			compatible = "allwinner,sunxi-lcd_fb0";
+			pinctrl-names = "active","sleep";
+			status = "disabled";
+		};
+
+		vind0: vind@5800800 {
+			compatible = "allwinner,sunxi-vin-media", "simple-bus";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			device_id = <0>;
+			csi_top = <336000000>;
+			csi_isp = <327000000>;
+			reg = <0x0 0x05800800 0x0 0x200>,
+				<0x0 0x05800000 0x0 0x800>;
+			clocks = <&ccu CLK_CSI_TOP>, <&ccu CLK_PLL_VIDEO1_2X>,
+				<&ccu CLK_CSI0_MCLK>, <&dcxo24M>, <&ccu CLK_PLL_VIDEO1>,
+				<&ccu CLK_BUS_CSI>, <&ccu CLK_MBUS_CSI>;
+			clock-names = "csi_top", "csi_top_src",
+					"csi_mclk0", "csi_mclk0_24m", "csi_mclk0_pll",
+					"csi_bus", "csi_mbus";
+			resets = <&ccu RST_BUS_CSI>;
+			reset-names = "csi_ret";
+			pinctrl-names = "mclk0-default", "mclk0-sleep";
+			pinctrl-0 = <&csi_mclk0_pins_a>;
+			pinctrl-1 = <&csi_mclk0_pins_b>;
+			status = "okay";
+
+			csi0: csi@5801000{
+				compatible = "allwinner,sunxi-csi";
+				reg = <0x0 0x05801000 0x0 0x1000>;
+				interrupts-extended = <&plic0 116 IRQ_TYPE_LEVEL_HIGH>;
+				pinctrl-names = "default","sleep";
+				pinctrl-0 = <&csi0_pins_a>;
+				pinctrl-1 = <&csi0_pins_b>;
+				device_id = <0>;
+				iommus = <&mmu_aw 1 1>;
+				status = "okay";
+			};
+			isp0: isp@5809410 {
+				compatible = "allwinner,sunxi-isp";
+				reg = <0x0 0x05809410 0x0 0x10>;
+				device_id = <0xfe>;
+
+				status = "okay";
+			};
+			isp1: isp@5809420 {
+				compatible = "allwinner,sunxi-isp";
+				reg = <0x0 0x05809420 0x0 0x10>;
+				device_id = <0xff>;
+				status = "okay";
+			};
+			scaler0: scaler@5809430 {
+				compatible = "allwinner,sunxi-scaler";
+				reg = <0x0 0x05809430 0x0 0x10>;
+				device_id = <0xfe>;
+				status = "okay";
+			};
+			scaler1: scaler@5809440 {
+				compatible = "allwinner,sunxi-scaler";
+				reg = <0x0 0x05809440 0x0 0x10>;
+				device_id = <0xff>;
+				status = "okay";
+			};
+			actuator0: actuator@5809450 {
+				compatible = "allwinner,sunxi-actuator";
+				device_type = "actuator0";
+				reg = <0x0 0x05809450 0x0 0x10>;
+				actuator0_name = "ad5820_act";
+				actuator0_slave = <0x18>;
+				actuator0_af_pwdn = <>;
+				actuator0_afvdd = "afvcc-csi";
+				actuator0_afvdd_vol = <2800000>;
+				status = "disabled";
+			};
+			flash0: flash@5809460 {
+				device_type = "flash0";
+				compatible = "allwinner,sunxi-flash";
+				reg = <0x0 0x05809460 0x0 0x10>;
+				flash0_type = <2>;
+				flash0_en = <>;
+				flash0_mode = <>;
+				flash0_flvdd = "";
+				flash0_flvdd_vol = <>;
+				device_id = <0>;
+				status = "disabled";
+			};
+			sensor0: sensor@5809470 {
+				reg = <0x0 0x05809470 0x0 0x10>;
+				device_type = "sensor0";
+				compatible = "allwinner,sunxi-sensor";
+				sensor0_mname = "ov5640";
+				sensor0_twi_cci_id = <2>;
+				sensor0_twi_addr = <0x78>;
+				sensor0_mclk_id = <0>;
+				sensor0_pos = "rear";
+				sensor0_isp_used = <0>;
+				sensor0_fmt = <0>;
+				sensor0_stby_mode = <0>;
+				sensor0_vflip = <0>;
+				sensor0_hflip = <0>;
+				sensor0_iovdd-supply = <>;
+				sensor0_iovdd_vol = <>;
+				sensor0_avdd-supply = <>;
+				sensor0_avdd_vol = <>;
+				sensor0_dvdd-supply = <>;
+				sensor0_dvdd_vol = <>;
+				sensor0_power_en = <>;
+				sensor0_reset = <&pio PE 9 GPIO_ACTIVE_LOW>;
+				sensor0_pwdn = <&pio PE 8 GPIO_ACTIVE_LOW>;
+				sensor0_sm_vs = <>;
+				flash_handle = <&flash0>;
+				act_handle = <&actuator0>;
+				device_id = <0>;
+				status	= "okay";
+			};
+			sensor1: sensor@5809480 {
+				reg = <0x0 0x05809480 0x0 0x10>;
+				device_type = "sensor1";
+				compatible = "allwinner,sunxi-sensor";
+				sensor1_mname = "ov5647";
+				sensor1_twi_cci_id = <3>;
+				sensor1_twi_addr = <0x6c>;
+				sensor1_mclk_id = <1>;
+				sensor1_pos = "front";
+				sensor1_isp_used = <0>;
+				sensor1_fmt = <0>;
+				sensor1_stby_mode = <0>;
+				sensor1_vflip = <0>;
+				sensor1_hflip = <0>;
+				sensor1_iovdd-supply = <>;
+				sensor1_iovdd_vol = <>;
+				sensor1_avdd-supply = <>;
+				sensor1_avdd_vol = <>;
+				sensor1_dvdd-supply = <>;
+				sensor1_dvdd_vol = <>;
+				sensor1_power_en = <>;
+				sensor1_reset = <&pio PE 7 GPIO_ACTIVE_LOW>;
+				sensor1_pwdn = <&pio PE 6 GPIO_ACTIVE_LOW>;
+				sensor1_sm_vs = <>;
+				flash_handle = <>;
+				act_handle = <>;
+				device_id = <1>;
+				status	= "okay";
+			};
+			vinc0: vinc@5809000 {
+				compatible = "allwinner,sunxi-vin-core";
+				device_type = "vinc0";
+				reg = <0x0 0x05809000 0x0 0x200>;
+				interrupts-extended = <&plic0 111 IRQ_TYPE_LEVEL_HIGH>;
+				vinc0_csi_sel = <0>;
+				vinc0_mipi_sel = <0xff>;
+				vinc0_isp_sel = <0>;
+				vinc0_tdm_rx_sel = <0xff>;
+				vinc0_rear_sensor_sel = <0>;
+				vinc0_front_sensor_sel = <0>;
+				vinc0_sensor_list = <0>;
+				device_id = <0>;
+				iommus = <&mmu_aw 1 1>;
+				status = "okay";
+			};
+			vinc1: vinc@5809200 {
+				device_type = "vinc1";
+				compatible = "allwinner,sunxi-vin-core";
+				reg = <0x0 0x05809200 0x0 0x200>;
+				interrupts-extended = <&plic0 112 IRQ_TYPE_LEVEL_HIGH>;
+				vinc1_csi_sel = <0>;
+				vinc1_mipi_sel = <0xff>;
+				vinc1_isp_sel = <1>;
+				vinc1_tdm_rx_sel = <0xff>;
+				vinc1_rear_sensor_sel = <0>;
+				vinc1_front_sensor_sel = <0>;
+				vinc1_sensor_list = <0>;
+				device_id = <1>;
+				iommus = <&mmu_aw 1 1>;
+				status = "okay";
+			};
+
+		};
+		tvd: tvd@05c00000 {
+			compatible = "allwinner,sunxi-tvd";
+			reg = <0x0 0x05c00000 0x0 0x00010000>;/*tvd_top*/
+			interrupts-extended = <&plic0 123 IRQ_TYPE_LEVEL_HIGH>;
+
+			clocks = <&ccu CLK_BUS_TVD_TOP>,
+			<&ccu CLK_MBUS_TVIN>;
+			clock-names = "clk_bus_tvd_top",
+			"clk_mbus_tvd";
+
+			resets = <&ccu RST_BUS_TVD_TOP>;
+			reset-names = "rst_bus_tvd_top";
+
+			tvd-number = <1>;
+			tvds = <&tvd0>;
+			status = "okay";
+		};
+
+		tvd0: tvd0@05c01000 {
+			compatible = "allwinner,sunxi-tvd0";
+			reg = <0x0 0x05c01000 0x0 0x00010000>;
+			interrupts-extended = <&plic0 123 IRQ_TYPE_LEVEL_HIGH>;
+
+			clocks = <&ccu CLK_TVD>,
+			<&ccu CLK_BUS_TVD>;
+			clock-names = "clk_tvd0","clk_bus_tvd0";
+
+			resets = <&ccu RST_BUS_TVD>;
+			reset-names = "rst_bus_tvd0";
+
+			assigned-clocks = <&ccu CLK_TVD>;
+			assigned-clock-parents = <&ccu CLK_PLL_VIDEO1>;
+
+			tvd_used = <1>;
+			tvd_if = <0>;
+			status = "okay";
+		};
+	};
+
+};
diff --git a/arch/riscv/configs/sun20iw1p1_d1_defconfig b/arch/riscv/configs/sun20iw1p1_d1_defconfig
new file mode 100644
index 000000000..105530215
--- /dev/null
+++ b/arch/riscv/configs/sun20iw1p1_d1_defconfig
@@ -0,0 +1,177 @@
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_EXPERT=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_ARCH_SUNXI=y
+CONFIG_EVB_PLATFORM=y
+CONFIG_VECTOR=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_TIMES=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_RISCV_ALLWINNER_SUN50I_CPUFREQ_NVMEM=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_CAN=y
+CONFIG_CAN_SUN4I=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_SUNXI_MBUS=y
+CONFIG_MTD=y
+CONFIG_AW_MTD_SPINAND=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NETDEVICES=y
+CONFIG_SUNXI_GMAC=y
+# CONFIG_INPUT_SENSORINIT is not set
+CONFIG_KEYBOARD_SUNXI=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_SENSOR=y
+CONFIG_SUNXI_GPADC=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_VIRTIO_CONSOLE=m
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_SUNXI=y
+CONFIG_SPI=y
+CONFIG_SPI_SUNXI=y
+CONFIG_PINCTRL=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_STATISTICS=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_SUNXI_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_SUNXI_WATCHDOG=y
+CONFIG_MFD_SUN6I_PRCM=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_SUNXI_REGULATOR_PWM=y
+CONFIG_RC_CORE=y
+CONFIG_RC_DECODERS=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_RX_SUNXI=y
+CONFIG_IR_TX_SUNXI=y
+CONFIG_FB=y
+CONFIG_DISP2_SUNXI=y
+CONFIG_HDMI2_DISP2_SUNXI=y
+CONFIG_DISP2_SUNXI_DEBUG=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_SUNXI=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_SUNXI=y
+CONFIG_USB_SUNXI_HCD=y
+CONFIG_USB_SUNXI_HCI=y
+CONFIG_USB_SUNXI_EHCI0=y
+CONFIG_USB_SUNXI_EHCI1=y
+CONFIG_USB_SUNXI_OHCI0=y
+CONFIG_USB_SUNXI_OHCI1=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_UAS=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_SUNXI_UDC0=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_UEVENT=y
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_SUNXI_USB=y
+CONFIG_USB_SUNXI_USB_MANAGER=y
+CONFIG_USB_SUNXI_USB_DEBUG=y
+CONFIG_USB_SUNXI_USB_ADB=y
+CONFIG_USB_ROLE_SWITCH=y
+CONFIG_MMC=y
+CONFIG_MMC_SUNXI=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUNXI=y
+CONFIG_DMADEVICES=y
+CONFIG_DMA_SUN6I=y
+CONFIG_SYNC_FILE=y
+# CONFIG_VIRTIO_MENU is not set
+CONFIG_STAGING=y
+CONFIG_ION=y
+CONFIG_ION_SYSTEM_HEAP=y
+CONFIG_ION_CMA_HEAP=y
+# CONFIG_COMMON_CLK_DEBUG is not set
+# CONFIG_CLK_SUNXI is not set
+CONFIG_SUN8IW20_CCU=y
+CONFIG_SUN8IW20_R_CCU=y
+CONFIG_SUNXI_IOMMU=y
+CONFIG_SUNXI_IOMMU_DEBUG=y
+CONFIG_SUNXI_IOMMU_TESTS=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_SUNXI_SID=y
+CONFIG_SUNXI_RISCV_SUSPEND=y
+CONFIG_PWM=y
+CONFIG_PWM_SUNXI_GROUP=y
+CONFIG_SIFIVE_PLIC=y
+CONFIG_ANDROID=y
+CONFIG_NVMEM_SUNXI_SID=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_UBIFS_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+CONFIG_CRYPTO_DEV_SUNXI=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_XZ_DEC=y
+CONFIG_DMA_CMA=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_FS=y
diff --git a/arch/riscv/configs/sun20iw1p1_defconfig b/arch/riscv/configs/sun20iw1p1_defconfig
new file mode 100644
index 000000000..f8dc938ee
--- /dev/null
+++ b/arch/riscv/configs/sun20iw1p1_defconfig
@@ -0,0 +1,190 @@
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_EXPERT=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_SUNXI_SOC_NAME="sun20iw1"
+CONFIG_ARCH_SUNXI=y
+CONFIG_EVB_PLATFORM=y
+CONFIG_VECTOR=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_TIMES=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_RISCV_ALLWINNER_SUN50I_CPUFREQ_NVMEM=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_CAN=y
+CONFIG_CAN_SUN4I=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_SUNXI_MBUS=y
+CONFIG_MTD=y
+CONFIG_AW_MTD_SPINAND=y
+CONFIG_MTD_UBI_BLOCK=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NETDEVICES=y
+CONFIG_SUNXI_GMAC=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_SENSORINIT is not set
+CONFIG_KEYBOARD_SUNXI=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_SUN4I=y
+# CONFIG_TOUCHSCREEN_GSLX680NEW is not set
+CONFIG_INPUT_SENSOR=y
+CONFIG_SUNXI_GPADC=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_VIRTIO_CONSOLE=m
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_SUNXI=y
+CONFIG_SPI=y
+CONFIG_SPI_SUNXI=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PINCTRL=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_WATCHDOG=y
+CONFIG_SUNXI_WATCHDOG=y
+CONFIG_MFD_SUN6I_PRCM=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_SUNXI_REGULATOR_PWM=y
+CONFIG_RC_CORE=y
+CONFIG_RC_DECODERS=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_RX_SUNXI=y
+CONFIG_IR_TX_SUNXI=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_FB=y
+CONFIG_DISP2_SUNXI=y
+CONFIG_HDMI2_DISP2_SUNXI=y
+CONFIG_HDMI2_HDCP_SUNXI=y
+CONFIG_DISP2_SUNXI_DEBUG=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_HCD_SUNXI=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_SUNXI=y
+CONFIG_USB_SUNXI_HCD=y
+CONFIG_USB_SUNXI_HCI=y
+CONFIG_USB_SUNXI_EHCI0=y
+CONFIG_USB_SUNXI_EHCI1=y
+CONFIG_USB_SUNXI_OHCI0=y
+CONFIG_USB_SUNXI_OHCI1=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_UAS=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_SUNXI_UDC0=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_UEVENT=y
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_SUNXI_USB=y
+CONFIG_USB_SUNXI_USB_MANAGER=y
+CONFIG_USB_SUNXI_USB_DEBUG=y
+CONFIG_USB_SUNXI_USB_ADB=y
+CONFIG_USB_ROLE_SWITCH=y
+CONFIG_MMC=y
+CONFIG_MMC_SUNXI=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_SUNXI=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUNXI=y
+CONFIG_SUNXI_REBOOT_FLAG=y
+CONFIG_SUNXI_RTC_BOOTCOUNT=y
+CONFIG_SUNXI_RTC_POWEROFF_ALARM=y
+CONFIG_DMADEVICES=y
+CONFIG_DMA_SUN6I=y
+CONFIG_SYNC_FILE=y
+# CONFIG_VIRTIO_MENU is not set
+CONFIG_STAGING=y
+CONFIG_ION=y
+CONFIG_ION_SYSTEM_HEAP=y
+CONFIG_ION_CMA_HEAP=y
+# CONFIG_COMMON_CLK_DEBUG is not set
+# CONFIG_CLK_SUNXI is not set
+CONFIG_SUN8IW20_CCU=y
+CONFIG_SUN8IW20_R_CCU=y
+CONFIG_SUN4I_TIMER=y
+CONFIG_SUNXI_IOMMU=y
+CONFIG_SUNXI_IOMMU_DEBUG=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_SUNXI_SID=y
+CONFIG_SUNXI_RISCV_SUSPEND=y
+CONFIG_PWM=y
+CONFIG_PWM_SUNXI_GROUP=y
+CONFIG_SIFIVE_PLIC=y
+CONFIG_ANDROID=y
+CONFIG_NVMEM_SUNXI_SID=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_UBIFS_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+CONFIG_CRYPTO_DEV_SUNXI=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_XZ_DEC=y
+CONFIG_DMA_CMA=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_FS=y
diff --git a/arch/riscv/configs/sun20iw1p1_min_defconfig b/arch/riscv/configs/sun20iw1p1_min_defconfig
new file mode 100644
index 000000000..aebc08885
--- /dev/null
+++ b/arch/riscv/configs/sun20iw1p1_min_defconfig
@@ -0,0 +1,68 @@
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_ARCH_SUNXI=y
+CONFIG_EVB_PLATFORM=y
+CONFIG_VECTOR=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_VIRTIO_BLK=y
+# CONFIG_INPUT_SENSORINIT is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_VIRTIO_CONSOLE=m
+# CONFIG_HW_RANDOM is not set
+CONFIG_PINCTRL=y
+# CONFIG_HWMON is not set
+CONFIG_MFD_SUN6I_PRCM=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_USB_SUPPORT is not set
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUNXI=y
+CONFIG_SYNC_FILE=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_COMMON_CLK_DEBUG is not set
+# CONFIG_CLK_SUNXI is not set
+CONFIG_SUN8IW20_CCU=y
+CONFIG_SUN8IW20_R_CCU=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_RPMSG_VIRTIO=y
+# CONFIG_SUNXI_SRAM is not set
+CONFIG_SUNXI_RISCV_SUSPEND=y
+CONFIG_SIFIVE_PLIC=y
+CONFIG_ANDROID=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_FS=y
diff --git a/arch/riscv/include/asm/asid.h b/arch/riscv/include/asm/asid.h
new file mode 100644
index 000000000..f8a3e8ac7
--- /dev/null
+++ b/arch/riscv/include/asm/asid.h
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ASM_ASM_ASID_H
+#define __ASM_ASM_ASID_H
+
+#include <linux/atomic.h>
+#include <linux/compiler.h>
+#include <linux/cpumask.h>
+#include <linux/percpu.h>
+#include <linux/spinlock.h>
+
+struct asid_info {
+	atomic64_t	generation;
+	unsigned long	*map;
+	atomic64_t __percpu	*active;
+	u64 __percpu		*reserved;
+	u32			bits;
+	/* Lock protecting the structure */
+	raw_spinlock_t		lock;
+	/* Which CPU requires context flush on next call */
+	cpumask_t		flush_pending;
+	/* Number of ASID allocated by context (shift value) */
+	unsigned int		ctxt_shift;
+	/* Callback to locally flush the context. */
+	void			(*flush_cpu_ctxt_cb)(void);
+};
+
+#define NUM_ASIDS(info)			(1UL << ((info)->bits))
+#define NUM_CTXT_ASIDS(info)		(NUM_ASIDS(info) >> (info)->ctxt_shift)
+
+#define active_asid(info, cpu)	(*per_cpu_ptr((info)->active, cpu))
+
+void asid_new_context(struct asid_info *info, atomic64_t *pasid,
+		      unsigned int cpu, struct mm_struct *mm);
+
+/*
+ * Check the ASID is still valid for the context. If not generate a new ASID.
+ *
+ * @pasid: Pointer to the current ASID batch
+ * @cpu: current CPU ID. Must have been acquired throught get_cpu()
+ */
+static inline void asid_check_context(struct asid_info *info,
+				      atomic64_t *pasid, unsigned int cpu,
+				      struct mm_struct *mm)
+{
+	u64 asid, old_active_asid;
+
+	asid = atomic64_read(pasid);
+
+	/*
+	 * The memory ordering here is subtle.
+	 * If our active_asid is non-zero and the ASID matches the current
+	 * generation, then we update the active_asid entry with a relaxed
+	 * cmpxchg. Racing with a concurrent rollover means that either:
+	 *
+	 * - We get a zero back from the cmpxchg and end up waiting on the
+	 *   lock. Taking the lock synchronises with the rollover and so
+	 *   we are forced to see the updated generation.
+	 *
+	 * - We get a valid ASID back from the cmpxchg, which means the
+	 *   relaxed xchg in flush_context will treat us as reserved
+	 *   because atomic RmWs are totally ordered for a given location.
+	 */
+	old_active_asid = atomic64_read(&active_asid(info, cpu));
+	if (old_active_asid &&
+	    !((asid ^ atomic64_read(&info->generation)) >> info->bits) &&
+	    atomic64_cmpxchg_relaxed(&active_asid(info, cpu),
+				     old_active_asid, asid))
+		return;
+
+	asid_new_context(info, pasid, cpu, mm);
+}
+
+int asid_allocator_init(struct asid_info *info,
+			u32 bits, unsigned int asid_per_ctxt,
+			void (*flush_cpu_ctxt_cb)(void));
+
+#endif
diff --git a/arch/riscv/include/asm/cache.h b/arch/riscv/include/asm/cache.h
index bfd523e8f..c7cf3ac80 100644
--- a/arch/riscv/include/asm/cache.h
+++ b/arch/riscv/include/asm/cache.h
@@ -10,5 +10,6 @@
 #define L1_CACHE_SHIFT		6
 
 #define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
+#define ARCH_DMA_MINALIGN	L1_CACHE_BYTES
 
 #endif /* _ASM_RISCV_CACHE_H */
diff --git a/arch/riscv/include/asm/cacheflush.h b/arch/riscv/include/asm/cacheflush.h
index 555b20b11..c53092f25 100644
--- a/arch/riscv/include/asm/cacheflush.h
+++ b/arch/riscv/include/asm/cacheflush.h
@@ -99,6 +99,15 @@ void flush_icache_mm(struct mm_struct *mm, bool local);
 
 #endif /* CONFIG_SMP */
 
+void dma_wbinv_range(unsigned long start, unsigned long end);
+void dma_wb_range(unsigned long start, unsigned long end);
+void dma_usr_va_wb_range(void *user_addr, unsigned long len);
+void dma_usr_va_inv_range(void *user_addr, unsigned long len);
+void dma_va_wb_range(void *kernel_addr, unsigned long len);
+void dma_va_inv_range(void *kernel_addr, unsigned long len);
+void dma_va_wbinv_range(void *kernel_addr, unsigned long len);
+void dma_clean_dcache_all(void);
+
 /*
  * Bits in sys_riscv_flush_icache()'s flags argument.
  */
diff --git a/arch/riscv/include/asm/cpuidle.h b/arch/riscv/include/asm/cpuidle.h
new file mode 100644
index 000000000..5fc6395f6
--- /dev/null
+++ b/arch/riscv/include/asm/cpuidle.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ASM_CPUIDLE_H
+#define __ASM_CPUIDLE_H
+
+#include <asm/proc-fns.h>
+
+#endif
diff --git a/arch/riscv/include/asm/csr.h b/arch/riscv/include/asm/csr.h
index a18923fa2..edd432e7d 100644
--- a/arch/riscv/include/asm/csr.h
+++ b/arch/riscv/include/asm/csr.h
@@ -21,6 +21,12 @@
 #define SR_FS_CLEAN	_AC(0x00004000, UL)
 #define SR_FS_DIRTY	_AC(0x00006000, UL)
 
+#define SR_VS		_AC(0x01800000, UL) /* Vector Status */
+#define SR_VS_OFF	_AC(0x00000000, UL)
+#define SR_VS_INITIAL	_AC(0x00800000, UL)
+#define SR_VS_CLEAN	_AC(0x01000000, UL)
+#define SR_VS_DIRTY	_AC(0x01800000, UL)
+
 #define SR_XS		_AC(0x00018000, UL) /* Extension Status */
 #define SR_XS_OFF	_AC(0x00000000, UL)
 #define SR_XS_INITIAL	_AC(0x00008000, UL)
@@ -42,6 +48,9 @@
 #define SATP_PPN	_AC(0x00000FFFFFFFFFFF, UL)
 #define SATP_MODE_39	_AC(0x8000000000000000, UL)
 #define SATP_MODE	SATP_MODE_39
+#define SATP_ASID_BITS	16
+#define SATP_ASID_SHIFT	44
+#define SATP_ASID_MASK	_AC(0xFFFF, UL)
 #endif
 
 /* SCAUSE */
@@ -56,6 +65,7 @@
 #define IRQ_U_EXT		8
 #define IRQ_S_EXT		9
 #define IRQ_M_EXT		11
+#define IRQ_S_PMU		17
 
 #define EXC_INST_MISALIGNED	0
 #define EXC_INST_ACCESS		1
@@ -67,10 +77,18 @@
 #define EXC_LOAD_PAGE_FAULT	13
 #define EXC_STORE_PAGE_FAULT	15
 
+#define CSR_VSTART		0x8
+#define CSR_VXSAT		0x9
+#define CSR_VXRM		0xa
+#define CSR_VL			0xc20
+#define CSR_VTYPE		0xc21
+#define CSR_VLENB		0xc22
+
 /* SIE (Interrupt Enable) and SIP (Interrupt Pending) flags */
 #define SIE_SSIE		(_AC(0x1, UL) << IRQ_S_SOFT)
 #define SIE_STIE		(_AC(0x1, UL) << IRQ_S_TIMER)
 #define SIE_SEIE		(_AC(0x1, UL) << IRQ_S_EXT)
+#define SIE_SMIE		(_AC(0x1, UL) << IRQ_S_PMU)
 
 #define CSR_CYCLE		0xc00
 #define CSR_TIME		0xc01
diff --git a/arch/riscv/include/asm/device.h b/arch/riscv/include/asm/device.h
new file mode 100644
index 000000000..fc73485d3
--- /dev/null
+++ b/arch/riscv/include/asm/device.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ */
+#ifndef __ASM_DEVICE_H
+#define __ASM_DEVICE_H
+
+struct dev_archdata {
+#ifdef CONFIG_IOMMU_API
+	void *iommu;			/* private IOMMU data */
+#endif
+};
+
+struct pdev_archdata {
+};
+
+#endif
diff --git a/arch/riscv/include/asm/elf.h b/arch/riscv/include/asm/elf.h
index ef04084bf..e40ef7feb 100644
--- a/arch/riscv/include/asm/elf.h
+++ b/arch/riscv/include/asm/elf.h
@@ -49,6 +49,11 @@
 #define ELF_HWCAP	(elf_hwcap)
 extern unsigned long elf_hwcap;
 
+#define ELF_CORE_COPY_REGS(dest, regs)                           \
+do {								 \
+	*(struct user_regs_struct *)&(dest) = (regs)->user_regs; \
+} while (0);
+
 /*
  * This yields a string that ld.so will use to load implementation
  * specific libraries for optimization.  This is more specific in
diff --git a/arch/riscv/include/asm/io.h b/arch/riscv/include/asm/io.h
index 3ba4d9372..78919a410 100644
--- a/arch/riscv/include/asm/io.h
+++ b/arch/riscv/include/asm/io.h
@@ -15,16 +15,13 @@
 #include <asm/mmiowb.h>
 #include <asm/pgtable.h>
 
-extern void __iomem *ioremap(phys_addr_t offset, unsigned long size);
+extern void __iomem *ioremap_cache(phys_addr_t addr, size_t size);
+extern void __iomem *__ioremap(phys_addr_t addr, size_t size, pgprot_t prot);
 
-/*
- * The RISC-V ISA doesn't yet specify how to query or modify PMAs, so we can't
- * change the properties of memory regions.  This should be fixed by the
- * upcoming platform spec.
- */
-#define ioremap_nocache(addr, size) ioremap((addr), (size))
-#define ioremap_wc(addr, size) ioremap((addr), (size))
-#define ioremap_wt(addr, size) ioremap((addr), (size))
+#define ioremap(addr, size)		__ioremap((addr), (size), pgprot_noncached(PAGE_KERNEL))
+#define ioremap_wc(addr, size)		__ioremap((addr), (size), pgprot_writecombine(PAGE_KERNEL))
+#define ioremap_nocache(addr, size)	ioremap((addr), (size))
+#define ioremap_cache			ioremap_cache
 
 extern void iounmap(volatile void __iomem *addr);
 
diff --git a/arch/riscv/include/asm/kexec.h b/arch/riscv/include/asm/kexec.h
new file mode 100644
index 000000000..bfaca0d4a
--- /dev/null
+++ b/arch/riscv/include/asm/kexec.h
@@ -0,0 +1,99 @@
+/*
+ * kexec for riscv
+ *
+ * Copyright (C) 2020-2025 Alibaba Group Holding Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _RISCV_KEXEC_H
+#define _RISCV_KEXEC_H
+
+/* Maximum physical address we can use pages from */
+
+#define KEXEC_SOURCE_MEMORY_LIMIT (-1UL)
+
+/* Maximum address we can reach in physical address mode */
+
+#define KEXEC_DESTINATION_MEMORY_LIMIT (-1UL)
+
+/* Maximum address we can use for the control code buffer */
+
+#define KEXEC_CONTROL_MEMORY_LIMIT (-1UL)
+
+#define KEXEC_CONTROL_PAGE_SIZE 4096
+
+#define KEXEC_ARCH KEXEC_ARCH_RISCV
+
+#ifndef __ASSEMBLY__
+
+/**
+ * crash_setup_regs() - save registers for the panic kernel
+ *
+ * @newregs: registers are saved here
+ * @oldregs: registers to be saved (may be %NULL)
+ */
+static inline void crash_setup_regs(struct pt_regs *newregs,
+				    struct pt_regs *oldregs)
+{
+	if (oldregs) {
+		memcpy(newregs, oldregs, sizeof(*newregs));
+	} else {
+		u64 tmp1, tmp2;
+
+		__asm__ __volatile__ (
+			"sd	ra, 8(%2)\n"
+			"sd	gp, 24(%2)\n"
+			"sd	t0, 40(%2)\n"
+			"sd	t1, 48(%2)\n"
+			"sd	t2, 56(%2)\n"
+			"sd	s0, 64(%2)\n"
+			"sd	s1, 72(%2)\n"
+			"sd	a0, 80(%2)\n"
+			"sd	a1, 88(%2)\n"
+			"sd	a2, 96(%2)\n"
+			"sd	a3, 104(%2)\n"
+			"sd	a4, 112(%2)\n"
+			"sd	a5, 120(%2)\n"
+			"sd	a6, 128(%2)\n"
+			"sd	a7, 136(%2)\n"
+			"sd	s2, 144(%2)\n"
+			"sd	s3, 152(%2)\n"
+			"sd	s4, 160(%2)\n"
+			"sd	s5, 168(%2)\n"
+			"sd	s6, 176(%2)\n"
+			"sd	s7, 184(%2)\n"
+			"sd	s8, 192(%2)\n"
+			"sd	s9, 200(%2)\n"
+			"sd	s10, 208(%2)\n"
+			"sd	s11, 216(%2)\n"
+			"sd	t3, 224(%2)\n"
+			"sd	t4, 232(%2)\n"
+			"sd	t5, 240(%2)\n"
+			"sd	t6, 248(%2)\n"
+			"auipc	%0, 0\n"
+			"sd	%0, 0(%2)\n"
+			"csrr	%0, sstatus\n"
+			"sd	%0, 256(%2)\n"
+			"csrr	%0, stval\n"
+			"sd	%0, 264(%2)\n"
+			"csrr	%0, scause\n"
+			"sd	%0, 272(%2)\n"
+			"sd tp, 32(%2)\n"
+			"sd	sp, 16(%2)\n"
+			: "=&r" (tmp1), "=&r" (tmp2)
+			: "r" (newregs)
+			: "memory"
+		);
+	}
+}
+
+static inline bool crash_is_nosave(unsigned long pfn) {return false; }
+static inline void crash_prepare_suspend(void) {}
+static inline void crash_post_resume(void) {}
+
+#endif /* __ASSEMBLY__ */
+
+#endif
diff --git a/arch/riscv/include/asm/mmu.h b/arch/riscv/include/asm/mmu.h
index 151476fb5..2c0679c7c 100644
--- a/arch/riscv/include/asm/mmu.h
+++ b/arch/riscv/include/asm/mmu.h
@@ -11,6 +11,7 @@
 
 typedef struct {
 	void *vdso;
+	atomic64_t asid;
 #ifdef CONFIG_SMP
 	/* A local icache flush is needed before user execution can resume. */
 	cpumask_t icache_stale_mask;
diff --git a/arch/riscv/include/asm/mmu_context.h b/arch/riscv/include/asm/mmu_context.h
index 67c463812..9b55a8e65 100644
--- a/arch/riscv/include/asm/mmu_context.h
+++ b/arch/riscv/include/asm/mmu_context.h
@@ -12,19 +12,20 @@
 
 #include <linux/mm.h>
 #include <linux/sched.h>
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+#include <asm/asid.h>
+
+#define ASID_MASK		((1 << SATP_ASID_BITS) - 1)
+#define cpu_asid(mm)		(atomic64_read(&mm->context.asid) & ASID_MASK)
+
+#define init_new_context(tsk, mm)	({ atomic64_set(&(mm)->context.asid, 0); 0; })
 
 static inline void enter_lazy_tlb(struct mm_struct *mm,
 	struct task_struct *task)
 {
 }
 
-/* Initialize context-related info for a new mm_struct */
-static inline int init_new_context(struct task_struct *task,
-	struct mm_struct *mm)
-{
-	return 0;
-}
-
 static inline void destroy_context(struct mm_struct *mm)
 {
 }
@@ -32,6 +33,8 @@ static inline void destroy_context(struct mm_struct *mm)
 void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	struct task_struct *task);
 
+void check_and_switch_context(struct mm_struct *mm, unsigned int cpu);
+
 static inline void activate_mm(struct mm_struct *prev,
 			       struct mm_struct *next)
 {
diff --git a/arch/riscv/include/asm/perf_event.h b/arch/riscv/include/asm/perf_event.h
index aefbfaa6a..4de9810a9 100644
--- a/arch/riscv/include/asm/perf_event.h
+++ b/arch/riscv/include/asm/perf_event.h
@@ -18,8 +18,8 @@
  * The RISCV_MAX_COUNTERS parameter should be specified.
  */
 
-#ifdef CONFIG_RISCV_BASE_PMU
-#define RISCV_MAX_COUNTERS	2
+#if defined(CONFIG_RISCV_BASE_PMU) || defined(CONFIG_THEAD_XT_V1_PMU)
+#define RISCV_MAX_COUNTERS	32
 #endif
 
 #ifndef RISCV_MAX_COUNTERS
diff --git a/arch/riscv/include/asm/pgtable-64.h b/arch/riscv/include/asm/pgtable-64.h
index 746309890..832b1fc1c 100644
--- a/arch/riscv/include/asm/pgtable-64.h
+++ b/arch/riscv/include/asm/pgtable-64.h
@@ -55,7 +55,7 @@ static inline void pud_clear(pud_t *pudp)
 
 static inline unsigned long pud_page_vaddr(pud_t pud)
 {
-	return (unsigned long)pfn_to_virt(pud_val(pud) >> _PAGE_PFN_SHIFT);
+	return (unsigned long)pfn_to_virt((pud_val(pud) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 #define pmd_index(addr) (((addr) >> PMD_SHIFT) & (PTRS_PER_PMD - 1))
diff --git a/arch/riscv/include/asm/pgtable-bits.h b/arch/riscv/include/asm/pgtable-bits.h
index bbaeb5d35..a6d239255 100644
--- a/arch/riscv/include/asm/pgtable-bits.h
+++ b/arch/riscv/include/asm/pgtable-bits.h
@@ -24,6 +24,13 @@
 #define _PAGE_DIRTY     (1 << 7)    /* Set by hardware on any write */
 #define _PAGE_SOFT      (1 << 8)    /* Reserved for software */
 
+/* C-SKY extend */
+#define _PAGE_SEC	(1UL << 59)   /* Security */
+#define _PAGE_SHARE	(1UL << 60)   /* Shareable */
+#define _PAGE_BUF	(1UL << 61)   /* Bufferable */
+#define _PAGE_CACHE	(1UL << 62)   /* Cacheable */
+#define _PAGE_SO	(1UL << 63)   /* Strong Order */
+
 #define _PAGE_SPECIAL   _PAGE_SOFT
 #define _PAGE_TABLE     _PAGE_PRESENT
 
@@ -38,6 +45,9 @@
 /* Set of bits to preserve across pte_modify() */
 #define _PAGE_CHG_MASK  (~(unsigned long)(_PAGE_PRESENT | _PAGE_READ |	\
 					  _PAGE_WRITE | _PAGE_EXEC |	\
-					  _PAGE_USER | _PAGE_GLOBAL))
+					  _PAGE_USER | _PAGE_GLOBAL |	\
+					  _PAGE_SEC | _PAGE_SHARE |	\
+					  _PAGE_BUF | _PAGE_CACHE |	\
+					  _PAGE_SO))
 
 #endif /* _ASM_RISCV_PGTABLE_BITS_H */
diff --git a/arch/riscv/include/asm/pgtable.h b/arch/riscv/include/asm/pgtable.h
index d32210171..37e4219b0 100644
--- a/arch/riscv/include/asm/pgtable.h
+++ b/arch/riscv/include/asm/pgtable.h
@@ -35,9 +35,11 @@
 #define FIRST_USER_ADDRESS  0
 
 /* Page protection bits */
-#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_USER)
+#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_USER | \
+			 _PAGE_SHARE | _PAGE_CACHE | _PAGE_BUF)
 
-#define PAGE_NONE		__pgprot(_PAGE_PROT_NONE)
+#define PAGE_NONE		__pgprot(_PAGE_PROT_NONE | _PAGE_CACHE | \
+					 _PAGE_BUF | _PAGE_SHARE | _PAGE_SHARE)
 #define PAGE_READ		__pgprot(_PAGE_BASE | _PAGE_READ)
 #define PAGE_WRITE		__pgprot(_PAGE_BASE | _PAGE_READ | _PAGE_WRITE)
 #define PAGE_EXEC		__pgprot(_PAGE_BASE | _PAGE_EXEC)
@@ -55,10 +57,15 @@
 				| _PAGE_WRITE \
 				| _PAGE_PRESENT \
 				| _PAGE_ACCESSED \
-				| _PAGE_DIRTY)
+				| _PAGE_DIRTY \
+				| _PAGE_CACHE \
+				| _PAGE_SHARE \
+				| _PAGE_BUF)
 
 #define PAGE_KERNEL		__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_EXEC	__pgprot(_PAGE_KERNEL | _PAGE_EXEC)
+#define PAGE_KERNEL_SO		__pgprot((_PAGE_KERNEL | _PAGE_SO) & \
+					~(_PAGE_CACHE | _PAGE_BUF))
 
 #define PAGE_TABLE		__pgprot(_PAGE_TABLE)
 
@@ -167,18 +174,18 @@ static inline pgd_t *pgd_offset(const struct mm_struct *mm, unsigned long addr)
 
 static inline struct page *pmd_page(pmd_t pmd)
 {
-	return pfn_to_page(pmd_val(pmd) >> _PAGE_PFN_SHIFT);
+	return pfn_to_page((pmd_val(pmd) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 static inline unsigned long pmd_page_vaddr(pmd_t pmd)
 {
-	return (unsigned long)pfn_to_virt(pmd_val(pmd) >> _PAGE_PFN_SHIFT);
+	return (unsigned long)pfn_to_virt((pmd_val(pmd) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 /* Yields the page frame number (PFN) of a page table entry */
 static inline unsigned long pte_pfn(pte_t pte)
 {
-	return (pte_val(pte) >> _PAGE_PFN_SHIFT);
+	return ((pte_val(pte) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 #define pte_page(x)     pfn_to_page(pte_pfn(x))
@@ -405,6 +412,32 @@ static inline int ptep_clear_flush_young(struct vm_area_struct *vma,
 	return ptep_test_and_clear_young(vma, address, ptep);
 }
 
+#define __HAVE_PHYS_MEM_ACCESS_PROT
+struct file;
+extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+				     unsigned long size, pgprot_t vma_prot);
+
+#define pgprot_noncached pgprot_noncached
+static inline pgprot_t pgprot_noncached(pgprot_t _prot)
+{
+	unsigned long prot = pgprot_val(_prot);
+
+	prot &= ~(_PAGE_CACHE | _PAGE_BUF);
+	prot |= _PAGE_SO;
+
+	return __pgprot(prot);
+}
+
+#define pgprot_writecombine pgprot_writecombine
+static inline pgprot_t pgprot_writecombine(pgprot_t _prot)
+{
+	unsigned long prot = pgprot_val(_prot);
+
+	prot &= ~(_PAGE_CACHE | _PAGE_BUF);
+
+	return __pgprot(prot);
+}
+
 /*
  * Encode and decode a swap entry
  *
diff --git a/arch/riscv/include/asm/proc-fns.h b/arch/riscv/include/asm/proc-fns.h
new file mode 100644
index 000000000..813b41921
--- /dev/null
+++ b/arch/riscv/include/asm/proc-fns.h
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __RISCV_PROCFNS_H__
+#define __RISCV_PROCFNS_H__
+
+extern void cpu_do_idle(void);
+
+#endif /* __RISCV_PROCFNS_H__ */
diff --git a/arch/riscv/include/asm/processor.h b/arch/riscv/include/asm/processor.h
index f539149d0..fe601f356 100644
--- a/arch/riscv/include/asm/processor.h
+++ b/arch/riscv/include/asm/processor.h
@@ -32,6 +32,7 @@ struct thread_struct {
 	unsigned long sp;	/* Kernel mode stack */
 	unsigned long s[12];	/* s[0]: frame pointer */
 	struct __riscv_d_ext_state fstate;
+	struct __riscv_v_state vstate;
 };
 
 #define INIT_THREAD {					\
diff --git a/arch/riscv/include/asm/ptrace.h b/arch/riscv/include/asm/ptrace.h
index d48d1e139..1ce740809 100644
--- a/arch/riscv/include/asm/ptrace.h
+++ b/arch/riscv/include/asm/ptrace.h
@@ -12,38 +12,43 @@
 #ifndef __ASSEMBLY__
 
 struct pt_regs {
-	unsigned long sepc;
-	unsigned long ra;
-	unsigned long sp;
-	unsigned long gp;
-	unsigned long tp;
-	unsigned long t0;
-	unsigned long t1;
-	unsigned long t2;
-	unsigned long s0;
-	unsigned long s1;
-	unsigned long a0;
-	unsigned long a1;
-	unsigned long a2;
-	unsigned long a3;
-	unsigned long a4;
-	unsigned long a5;
-	unsigned long a6;
-	unsigned long a7;
-	unsigned long s2;
-	unsigned long s3;
-	unsigned long s4;
-	unsigned long s5;
-	unsigned long s6;
-	unsigned long s7;
-	unsigned long s8;
-	unsigned long s9;
-	unsigned long s10;
-	unsigned long s11;
-	unsigned long t3;
-	unsigned long t4;
-	unsigned long t5;
-	unsigned long t6;
+	union {
+		struct user_regs_struct user_regs;
+		struct {
+			unsigned long sepc;
+			unsigned long ra;
+			unsigned long sp;
+			unsigned long gp;
+			unsigned long tp;
+			unsigned long t0;
+			unsigned long t1;
+			unsigned long t2;
+			unsigned long s0;
+			unsigned long s1;
+			unsigned long a0;
+			unsigned long a1;
+			unsigned long a2;
+			unsigned long a3;
+			unsigned long a4;
+			unsigned long a5;
+			unsigned long a6;
+			unsigned long a7;
+			unsigned long s2;
+			unsigned long s3;
+			unsigned long s4;
+			unsigned long s5;
+			unsigned long s6;
+			unsigned long s7;
+			unsigned long s8;
+			unsigned long s9;
+			unsigned long s10;
+			unsigned long s11;
+			unsigned long t3;
+			unsigned long t4;
+			unsigned long t5;
+			unsigned long t6;
+		};
+	};
 	/* Supervisor CSRs */
 	unsigned long sstatus;
 	unsigned long sbadaddr;
diff --git a/arch/riscv/include/asm/sbi.h b/arch/riscv/include/asm/sbi.h
index 21134b3ef..1e74c190c 100644
--- a/arch/riscv/include/asm/sbi.h
+++ b/arch/riscv/include/asm/sbi.h
@@ -7,6 +7,7 @@
 #define _ASM_RISCV_SBI_H
 
 #include <linux/types.h>
+#include <linux/reboot.h>
 
 #define SBI_SET_TIMER 0
 #define SBI_CONSOLE_PUTCHAR 1
@@ -17,6 +18,26 @@
 #define SBI_REMOTE_SFENCE_VMA 6
 #define SBI_REMOTE_SFENCE_VMA_ASID 7
 #define SBI_SHUTDOWN 8
+#define SBI_PMU 0x09000001
+#define SBI_SYSPEND 0x09000007
+#define SBI_WAKEUP 0x09000008
+#define SBI_EXT_SRST 0x53525354
+
+enum sbi_ext_srst_fid {
+	SBI_EXT_SRST_RESET = 0,
+};
+
+enum sbi_srst_reset_type {
+	SBI_SRST_RESET_TYPE_SHUTDOWN = 0,
+	SBI_SRST_RESET_TYPE_COLD_REBOOT,
+	SBI_SRST_RESET_TYPE_WARM_REBOOT,
+};
+
+enum sbi_srst_reset_reason {
+	SBI_SRST_RESET_REASON_NONE = 0,
+	SBI_SRST_RESET_REASON_SYS_FAILURE,
+};
+
 
 #define SBI_CALL(which, arg0, arg1, arg2, arg3) ({		\
 	register uintptr_t a0 asm ("a0") = (uintptr_t)(arg0);	\
@@ -94,4 +115,43 @@ static inline void sbi_remote_sfence_vma_asid(const unsigned long *hart_mask,
 	SBI_CALL_4(SBI_REMOTE_SFENCE_VMA_ASID, hart_mask, start, size, asid);
 }
 
+static inline void sbi_set_pmu(int start)
+{
+	SBI_CALL_1(SBI_PMU, start);
+}
+
+static inline void sbi_suspend(int state)
+{
+	SBI_CALL_1(SBI_SYSPEND, state);
+}
+
+static inline void sbi_set_wakeup(unsigned long irq, unsigned int enable)
+{
+	SBI_CALL_2(SBI_WAKEUP, irq, enable);
+}
+
+static inline void sbi_srst_reset(unsigned long type, unsigned long reason)
+{
+	SBI_CALL_3(SBI_EXT_SRST, SBI_EXT_SRST_RESET, type, reason);
+	pr_warn("%s: type=0x%lx reason=0x%lx failed\n",
+		__func__, type, reason);
+}
+
+static inline int sbi_srst_reboot(struct notifier_block *this,
+			   unsigned long mode, void *cmd)
+{
+	sbi_srst_reset((mode == REBOOT_WARM || mode == REBOOT_SOFT) ?
+		       SBI_SRST_RESET_TYPE_WARM_REBOOT :
+		       SBI_SRST_RESET_TYPE_COLD_REBOOT,
+		       SBI_SRST_RESET_REASON_NONE);
+	return NOTIFY_DONE;
+}
+
+static inline void sbi_srst_power_off(void)
+{
+	sbi_srst_reset(SBI_SRST_RESET_TYPE_SHUTDOWN,
+		       SBI_SRST_RESET_REASON_NONE);
+}
+
+void sbi_init(void);
 #endif
diff --git a/arch/riscv/include/asm/switch_to.h b/arch/riscv/include/asm/switch_to.h
index ee4f0ac62..68d8eb020 100644
--- a/arch/riscv/include/asm/switch_to.h
+++ b/arch/riscv/include/asm/switch_to.h
@@ -63,6 +63,52 @@ extern bool has_fpu;
 #define __switch_to_aux(__prev, __next) do { } while (0)
 #endif
 
+#ifdef CONFIG_VECTOR
+extern void __vstate_save(struct task_struct *save_to);
+extern void __vstate_restore(struct task_struct *restore_from);
+
+static inline void __vstate_clean(struct pt_regs *regs)
+{
+	regs->sstatus |= (regs->sstatus & ~(SR_VS)) | SR_VS_CLEAN;
+}
+
+static inline void vstate_save(struct task_struct *task,
+			       struct pt_regs *regs)
+{
+	if ((regs->sstatus & SR_VS) == SR_VS_DIRTY) {
+		__vstate_save(task);
+		__vstate_clean(regs);
+	}
+}
+
+static inline void vstate_restore(struct task_struct *task,
+				  struct pt_regs *regs)
+{
+	if ((regs->sstatus & SR_VS) != SR_VS_OFF) {
+		__vstate_restore(task);
+		__vstate_clean(regs);
+	}
+}
+
+static inline void __switch_to_vector(struct task_struct *prev,
+				   struct task_struct *next)
+{
+	struct pt_regs *regs;
+
+	regs = task_pt_regs(prev);
+	if (unlikely(regs->sstatus & SR_SD))
+		vstate_save(prev, regs);
+	vstate_restore(next, task_pt_regs(next));
+}
+
+extern bool has_vector;
+#else
+#define has_vector false
+#define vstate_save(task, regs) do { } while (0)
+#define vstate_restore(task, regs) do { } while (0)
+#define __switch_to_vector(__prev, __next) do { } while (0)
+#endif
+
 extern struct task_struct *__switch_to(struct task_struct *,
 				       struct task_struct *);
 
@@ -72,6 +118,8 @@ do {							\
 	struct task_struct *__next = (next);		\
 	if (has_fpu)					\
 		__switch_to_aux(__prev, __next);	\
+	if (has_vector)					\
+		__switch_to_vector(__prev, __next);	\
 	((last) = __switch_to(__prev, __next));		\
 } while (0)
 
diff --git a/arch/riscv/include/asm/tlbflush.h b/arch/riscv/include/asm/tlbflush.h
index f02188a5b..7b554146e 100644
--- a/arch/riscv/include/asm/tlbflush.h
+++ b/arch/riscv/include/asm/tlbflush.h
@@ -44,7 +44,14 @@ static inline void flush_tlb_range(struct vm_area_struct *vma,
 static inline void flush_tlb_kernel_range(unsigned long start,
 	unsigned long end)
 {
-	flush_tlb_all();
+	start &= PAGE_MASK;
+	end   += PAGE_SIZE - 1;
+	end   &= PAGE_MASK;
+
+	while (start < end) {
+		__asm__ __volatile__ ("sfence.vma %0" : : "r" (start) : "memory");
+		start += PAGE_SIZE;
+	}
 }
 
 #endif /* _ASM_RISCV_TLBFLUSH_H */
diff --git a/arch/riscv/include/uapi/asm/elf.h b/arch/riscv/include/uapi/asm/elf.h
index 644a00ce6..6a9c20e9e 100644
--- a/arch/riscv/include/uapi/asm/elf.h
+++ b/arch/riscv/include/uapi/asm/elf.h
@@ -24,6 +24,8 @@ typedef __u64 elf_fpreg_t;
 typedef union __riscv_fp_state elf_fpregset_t;
 #define ELF_NFPREG (sizeof(struct __riscv_d_ext_state) / sizeof(elf_fpreg_t))
 
+#define ELF_NVREG  (sizeof(struct __riscv_v_state) / sizeof(elf_greg_t))
+
 #if __riscv_xlen == 64
 #define ELF_RISCV_R_SYM(r_info)		ELF64_R_SYM(r_info)
 #define ELF_RISCV_R_TYPE(r_info)	ELF64_R_TYPE(r_info)
diff --git a/arch/riscv/include/uapi/asm/hwcap.h b/arch/riscv/include/uapi/asm/hwcap.h
index 4e7646077..e87e5e497 100644
--- a/arch/riscv/include/uapi/asm/hwcap.h
+++ b/arch/riscv/include/uapi/asm/hwcap.h
@@ -21,5 +21,6 @@
 #define COMPAT_HWCAP_ISA_F	(1 << ('F' - 'A'))
 #define COMPAT_HWCAP_ISA_D	(1 << ('D' - 'A'))
 #define COMPAT_HWCAP_ISA_C	(1 << ('C' - 'A'))
+#define COMPAT_HWCAP_ISA_V	(1 << ('V' - 'A'))
 
 #endif
diff --git a/arch/riscv/include/uapi/asm/ptrace.h b/arch/riscv/include/uapi/asm/ptrace.h
index 882547f6b..857a93910 100644
--- a/arch/riscv/include/uapi/asm/ptrace.h
+++ b/arch/riscv/include/uapi/asm/ptrace.h
@@ -77,6 +77,15 @@ union __riscv_fp_state {
 	struct __riscv_q_ext_state q;
 };
 
+struct __riscv_v_state {
+	__uint128_t v[32];
+	unsigned long vstart;
+	unsigned long vxsat;
+	unsigned long vxrm;
+	unsigned long vl;
+	unsigned long vtype;
+};
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _UAPI_ASM_RISCV_PTRACE_H */
diff --git a/arch/riscv/include/uapi/asm/sigcontext.h b/arch/riscv/include/uapi/asm/sigcontext.h
index 84f2dfcfd..f74b3c814 100644
--- a/arch/riscv/include/uapi/asm/sigcontext.h
+++ b/arch/riscv/include/uapi/asm/sigcontext.h
@@ -17,6 +17,7 @@
 struct sigcontext {
 	struct user_regs_struct sc_regs;
 	union __riscv_fp_state sc_fpregs;
+	struct __riscv_v_state sc_vregs;
 };
 
 #endif /* _UAPI_ASM_RISCV_SIGCONTEXT_H */
diff --git a/arch/riscv/kernel/Makefile b/arch/riscv/kernel/Makefile
index 696020ff7..9af47acf8 100644
--- a/arch/riscv/kernel/Makefile
+++ b/arch/riscv/kernel/Makefile
@@ -28,8 +28,10 @@ obj-y	+= stacktrace.o
 obj-y	+= vdso.o
 obj-y	+= cacheinfo.o
 obj-y	+= vdso/
+obj-y	+= cpuidle.o
 
 obj-$(CONFIG_FPU)		+= fpu.o
+obj-$(CONFIG_VECTOR)		+= vector.o
 obj-$(CONFIG_SMP)		+= smpboot.o
 obj-$(CONFIG_SMP)		+= smp.o
 obj-$(CONFIG_MODULES)		+= module.o
@@ -42,4 +44,8 @@ obj-$(CONFIG_PERF_EVENTS)	+= perf_event.o
 obj-$(CONFIG_PERF_EVENTS)	+= perf_callchain.o
 obj-$(CONFIG_HAVE_PERF_REGS)	+= perf_regs.o
 
+obj-$(CONFIG_KEXEC_CORE)        += machine_kexec.o relocate_kernel.o    \
+						cpu-reset.o
+obj-$(CONFIG_CRASH_DUMP)        += crash_dump.o
+
 clean:
diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.c
index 9f5628c38..a6010c399 100644
--- a/arch/riscv/kernel/asm-offsets.c
+++ b/arch/riscv/kernel/asm-offsets.c
@@ -70,6 +70,45 @@ void asm_offsets(void)
 	OFFSET(TASK_THREAD_F31, task_struct, thread.fstate.f[31]);
 	OFFSET(TASK_THREAD_FCSR, task_struct, thread.fstate.fcsr);
 
+	OFFSET(TASK_THREAD_V0,  task_struct, thread.vstate.v[0]);
+	OFFSET(TASK_THREAD_V1,  task_struct, thread.vstate.v[1]);
+	OFFSET(TASK_THREAD_V2,  task_struct, thread.vstate.v[2]);
+	OFFSET(TASK_THREAD_V3,  task_struct, thread.vstate.v[3]);
+	OFFSET(TASK_THREAD_V4,  task_struct, thread.vstate.v[4]);
+	OFFSET(TASK_THREAD_V5,  task_struct, thread.vstate.v[5]);
+	OFFSET(TASK_THREAD_V6,  task_struct, thread.vstate.v[6]);
+	OFFSET(TASK_THREAD_V7,  task_struct, thread.vstate.v[7]);
+	OFFSET(TASK_THREAD_V8,  task_struct, thread.vstate.v[8]);
+	OFFSET(TASK_THREAD_V9,  task_struct, thread.vstate.v[9]);
+	OFFSET(TASK_THREAD_V10, task_struct, thread.vstate.v[10]);
+	OFFSET(TASK_THREAD_V11, task_struct, thread.vstate.v[11]);
+	OFFSET(TASK_THREAD_V12, task_struct, thread.vstate.v[12]);
+	OFFSET(TASK_THREAD_V13, task_struct, thread.vstate.v[13]);
+	OFFSET(TASK_THREAD_V14, task_struct, thread.vstate.v[14]);
+	OFFSET(TASK_THREAD_V15, task_struct, thread.vstate.v[15]);
+	OFFSET(TASK_THREAD_V16, task_struct, thread.vstate.v[16]);
+	OFFSET(TASK_THREAD_V17, task_struct, thread.vstate.v[17]);
+	OFFSET(TASK_THREAD_V18, task_struct, thread.vstate.v[18]);
+	OFFSET(TASK_THREAD_V19, task_struct, thread.vstate.v[19]);
+	OFFSET(TASK_THREAD_V20, task_struct, thread.vstate.v[20]);
+	OFFSET(TASK_THREAD_V21, task_struct, thread.vstate.v[21]);
+	OFFSET(TASK_THREAD_V22, task_struct, thread.vstate.v[22]);
+	OFFSET(TASK_THREAD_V23, task_struct, thread.vstate.v[23]);
+	OFFSET(TASK_THREAD_V24, task_struct, thread.vstate.v[24]);
+	OFFSET(TASK_THREAD_V25, task_struct, thread.vstate.v[25]);
+	OFFSET(TASK_THREAD_V26, task_struct, thread.vstate.v[26]);
+	OFFSET(TASK_THREAD_V27, task_struct, thread.vstate.v[27]);
+	OFFSET(TASK_THREAD_V28, task_struct, thread.vstate.v[28]);
+	OFFSET(TASK_THREAD_V29, task_struct, thread.vstate.v[29]);
+	OFFSET(TASK_THREAD_V30, task_struct, thread.vstate.v[30]);
+	OFFSET(TASK_THREAD_V31, task_struct, thread.vstate.v[31]);
+	OFFSET(TASK_THREAD_VSTART, task_struct, thread.vstate.vstart);
+	OFFSET(TASK_THREAD_VXSAT, task_struct, thread.vstate.vxsat);
+	OFFSET(TASK_THREAD_VXRM, task_struct, thread.vstate.vxrm);
+	OFFSET(TASK_THREAD_VL, task_struct, thread.vstate.vl);
+	OFFSET(TASK_THREAD_VTYPE, task_struct, thread.vstate.vtype);
+	DEFINE(RISCV_VECTOR_VLENB, sizeof(__uint128_t));
+
 	DEFINE(PT_SIZE, sizeof(struct pt_regs));
 	OFFSET(PT_SEPC, pt_regs, sepc);
 	OFFSET(PT_RA, pt_regs, ra);
@@ -171,6 +210,7 @@ void asm_offsets(void)
 		- offsetof(struct task_struct, thread.ra)
 	);
 
+	/* Float Point */
 	DEFINE(TASK_THREAD_F0_F0,
 		  offsetof(struct task_struct, thread.fstate.f[0])
 		- offsetof(struct task_struct, thread.fstate.f[0])
@@ -304,6 +344,156 @@ void asm_offsets(void)
 		- offsetof(struct task_struct, thread.fstate.f[0])
 	);
 
+	/* Vector */
+	DEFINE(TASK_THREAD_V0_V0,
+		  offsetof(struct task_struct, thread.vstate.v[0])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V1_V0,
+		  offsetof(struct task_struct, thread.vstate.v[1])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V2_V0,
+		  offsetof(struct task_struct, thread.vstate.v[2])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V3_V0,
+		  offsetof(struct task_struct, thread.vstate.v[3])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V4_V0,
+		  offsetof(struct task_struct, thread.vstate.v[4])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V5_V0,
+		  offsetof(struct task_struct, thread.vstate.v[5])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V6_V0,
+		  offsetof(struct task_struct, thread.vstate.v[6])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V7_V0,
+		  offsetof(struct task_struct, thread.vstate.v[7])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V8_V0,
+		  offsetof(struct task_struct, thread.vstate.v[8])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V9_V0,
+		  offsetof(struct task_struct, thread.vstate.v[9])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V10_V0,
+		  offsetof(struct task_struct, thread.vstate.v[10])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V11_V0,
+		  offsetof(struct task_struct, thread.vstate.v[11])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V12_V0,
+		  offsetof(struct task_struct, thread.vstate.v[12])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V13_V0,
+		  offsetof(struct task_struct, thread.vstate.v[13])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V14_V0,
+		  offsetof(struct task_struct, thread.vstate.v[14])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V15_V0,
+		  offsetof(struct task_struct, thread.vstate.v[15])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V16_V0,
+		  offsetof(struct task_struct, thread.vstate.v[16])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V17_V0,
+		  offsetof(struct task_struct, thread.vstate.v[17])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V18_V0,
+		  offsetof(struct task_struct, thread.vstate.v[18])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V19_V0,
+		  offsetof(struct task_struct, thread.vstate.v[19])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V20_V0,
+		  offsetof(struct task_struct, thread.vstate.v[20])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V21_V0,
+		  offsetof(struct task_struct, thread.vstate.v[21])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V22_V0,
+		  offsetof(struct task_struct, thread.vstate.v[22])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V23_V0,
+		  offsetof(struct task_struct, thread.vstate.v[23])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V24_V0,
+		  offsetof(struct task_struct, thread.vstate.v[24])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V25_V0,
+		  offsetof(struct task_struct, thread.vstate.v[25])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V26_V0,
+		  offsetof(struct task_struct, thread.vstate.v[26])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V27_V0,
+		  offsetof(struct task_struct, thread.vstate.v[27])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V28_V0,
+		  offsetof(struct task_struct, thread.vstate.v[28])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V29_V0,
+		  offsetof(struct task_struct, thread.vstate.v[29])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V30_V0,
+		  offsetof(struct task_struct, thread.vstate.v[30])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V31_V0,
+		  offsetof(struct task_struct, thread.vstate.v[31])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VSTART_V0,
+		  offsetof(struct task_struct, thread.vstate.vstart)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VXSAT_V0,
+		  offsetof(struct task_struct, thread.vstate.vxsat)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VXRM_V0,
+		  offsetof(struct task_struct, thread.vstate.vxrm)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VL_V0,
+		  offsetof(struct task_struct, thread.vstate.vl)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VTYPE_V0,
+		  offsetof(struct task_struct, thread.vstate.vtype)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+
 	/*
 	 * We allocate a pt_regs on the stack when entering the kernel.  This
 	 * ensures the alignment is sane.
diff --git a/arch/riscv/kernel/cpu-reset.S b/arch/riscv/kernel/cpu-reset.S
new file mode 100644
index 000000000..51d67ce1d
--- /dev/null
+++ b/arch/riscv/kernel/cpu-reset.S
@@ -0,0 +1,23 @@
+/*
+ * CPU reset routines
+ *
+ * Copyright (C) 2020-2025 Alibaba Group Holding Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/linkage.h>
+
+ENTRY(__cpu_soft_restart)
+		fence
+		fence.i
+		sfence.vma
+		mv	s1, a0		//entry
+		mv	a0, a1		//arg0
+		mv	a1, a2		//arg1
+		mv	a2, a3		//arg2
+		jr s1
+		ebreak
+ENDPROC(__cpu_soft_restart)
diff --git a/arch/riscv/kernel/cpu-reset.h b/arch/riscv/kernel/cpu-reset.h
new file mode 100644
index 000000000..81eb43efe
--- /dev/null
+++ b/arch/riscv/kernel/cpu-reset.h
@@ -0,0 +1,58 @@
+/*
+ * CPU reset routines
+ *
+ * Copyright (C) 2020-2025 Alibaba Group Holding Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _RISCV_CPU_RESET_H
+#define _RISCV_CPU_RESET_H
+
+extern struct resource *standard_resources;
+void __cpu_soft_restart(unsigned long entry, unsigned long arg0, unsigned long arg1,
+								unsigned long arg2);
+
+__attribute__ ((optimize("-O0"))) static void __noreturn cpu_soft_restart(unsigned long entry,
+					       unsigned long arg0,
+					       unsigned long arg1,
+					       unsigned long arg2)
+{
+	typeof(__cpu_soft_restart) *restart;
+	pgd_t *idmap_pgd;
+	pmd_t *idmap_pmd;
+	long pa_start, pa_end;
+	long i, j, m, n, delta;
+	long idmap_pmd_size;
+
+	pa_start = standard_resources->start;
+	pa_end = standard_resources->end;
+
+	idmap_pmd_size = (pa_end - pa_start + 1) / PMD_SIZE * sizeof(pmd_t);
+
+	idmap_pgd = (pgd_t *)__va((csr_read(CSR_SATP) & ((1UL<<44)-1))<< PAGE_SHIFT);
+	idmap_pmd = (pmd_t *)__get_free_pages(GFP_KERNEL, get_order(idmap_pmd_size));
+
+	m = (pa_start >> PGDIR_SHIFT) % PTRS_PER_PGD;
+	n = (pa_end >> PGDIR_SHIFT) % PTRS_PER_PGD;
+
+	for (i = 0; m <= n; m++, i++)
+		idmap_pgd[m] = pfn_pgd(PFN_DOWN(__pa(idmap_pmd)) + i,
+				__pgprot(_PAGE_TABLE));
+
+	m = pa_start >> PMD_SHIFT;
+	n = (pa_end + 1) >> PMD_SHIFT;
+	delta = n - m;
+
+	for (i = (pa_start + 1) % PMD_SIZE, j = 0; i <= delta; i++, j++)
+		idmap_pmd[i] = pfn_pmd(PFN_DOWN(pa_start + j * PMD_SIZE),
+				__pgprot(pgprot_val(PAGE_KERNEL) | _PAGE_EXEC));
+
+	restart = (void *)__pa_symbol(__cpu_soft_restart);
+	restart(entry, arg0, arg1, arg2);
+	unreachable();
+}
+
+#endif
diff --git a/arch/riscv/kernel/cpu.c b/arch/riscv/kernel/cpu.c
index 7da3c6a93..b186f6db3 100644
--- a/arch/riscv/kernel/cpu.c
+++ b/arch/riscv/kernel/cpu.c
@@ -48,7 +48,7 @@ int riscv_of_processor_hartid(struct device_node *node)
 
 static void print_isa(struct seq_file *f, const char *orig_isa)
 {
-	static const char *ext = "mafdcsu";
+	static const char *ext = "mafdcvsu";
 	const char *isa = orig_isa;
 	const char *e;
 
diff --git a/arch/riscv/kernel/cpufeature.c b/arch/riscv/kernel/cpufeature.c
index a5ad00043..8689df054 100644
--- a/arch/riscv/kernel/cpufeature.c
+++ b/arch/riscv/kernel/cpufeature.c
@@ -17,6 +17,10 @@ unsigned long elf_hwcap __read_mostly;
 bool has_fpu __read_mostly;
 #endif
 
+#ifdef CONFIG_VECTOR
+bool has_vector __read_mostly;
+#endif
+
 void riscv_fill_hwcap(void)
 {
 	struct device_node *node;
@@ -30,6 +34,7 @@ void riscv_fill_hwcap(void)
 	isa2hwcap['f'] = isa2hwcap['F'] = COMPAT_HWCAP_ISA_F;
 	isa2hwcap['d'] = isa2hwcap['D'] = COMPAT_HWCAP_ISA_D;
 	isa2hwcap['c'] = isa2hwcap['C'] = COMPAT_HWCAP_ISA_C;
+	isa2hwcap['v'] = isa2hwcap['V'] = COMPAT_HWCAP_ISA_V;
 
 	elf_hwcap = 0;
 
@@ -44,7 +49,8 @@ void riscv_fill_hwcap(void)
 			continue;
 		}
 
-		for (i = 0; i < strlen(isa); ++i)
+		/* skip "rv64" */
+		for (i = 4; i < strlen(isa); ++i)
 			this_hwcap |= isa2hwcap[(unsigned char)(isa[i])];
 
 		/*
@@ -71,4 +77,9 @@ void riscv_fill_hwcap(void)
 	if (elf_hwcap & (COMPAT_HWCAP_ISA_F | COMPAT_HWCAP_ISA_D))
 		has_fpu = true;
 #endif
+
+#ifdef CONFIG_VECTOR
+	if (elf_hwcap & COMPAT_HWCAP_ISA_V)
+		has_vector = true;
+#endif
 }
diff --git a/arch/riscv/kernel/cpuidle.c b/arch/riscv/kernel/cpuidle.c
new file mode 100644
index 000000000..051f9ab5a
--- /dev/null
+++ b/arch/riscv/kernel/cpuidle.c
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#include <asm/proc-fns.h>
+#include <linux/kernel.h>
+
+void cpu_do_idle(void)
+{
+	__asm__ __volatile__ ("wfi");
+
+}
diff --git a/arch/riscv/kernel/crash_dump.c b/arch/riscv/kernel/crash_dump.c
new file mode 100644
index 000000000..991e8e7ed
--- /dev/null
+++ b/arch/riscv/kernel/crash_dump.c
@@ -0,0 +1,69 @@
+/*
+ * Routines for doing kexec-based kdump
+ *
+ * Copyright (C) 2020-2025 Alibaba Group Holding Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/crash_dump.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/memblock.h>
+#include <linux/uaccess.h>
+
+/**
+ * copy_oldmem_page() - copy one page from old kernel memory
+ * @pfn: page frame number to be copied
+ * @buf: buffer where the copied page is placed
+ * @csize: number of bytes to copy
+ * @offset: offset in bytes into the page
+ * @userbuf: if set, @buf is in a user address space
+ *
+ * This function copies one page from old kernel memory into buffer pointed by
+ * @buf. If @buf is in userspace, set @userbuf to %1. Returns number of bytes
+ * copied or negative error in case of failure.
+ */
+ssize_t copy_oldmem_page(unsigned long pfn, char *buf,
+			 size_t csize, unsigned long offset,
+			 int userbuf)
+{
+	void *vaddr;
+
+	if (!csize)
+		return 0;
+
+	vaddr = memremap(__pfn_to_phys(pfn), PAGE_SIZE, MEMREMAP_WB);
+	if (!vaddr)
+		return -ENOMEM;
+
+	if (userbuf) {
+		if (copy_to_user((char __user *)buf, vaddr + offset, csize)) {
+			memunmap(vaddr);
+			return -EFAULT;
+		}
+	} else {
+		memcpy(buf, vaddr + offset, csize);
+	}
+
+	memunmap(vaddr);
+
+	return csize;
+}
+
+/**
+ * elfcorehdr_read - read from ELF core header
+ * @buf: buffer where the data is placed
+ * @count: number of bytes to read
+ * @ppos: address in the memory
+ *
+ * This function reads @count bytes from elf core header which exists
+ * on crash dump kernel's memory.
+ */
+ssize_t elfcorehdr_read(char *buf, size_t count, u64 *ppos)
+{
+	memcpy(buf, phys_to_virt((phys_addr_t)*ppos), count);
+	return count;
+}
diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.S
index 8ca479831..96c5de81a 100644
--- a/arch/riscv/kernel/entry.S
+++ b/arch/riscv/kernel/entry.S
@@ -76,7 +76,7 @@ _save_context:
 	 * Disable the FPU to detect illegal usage of floating point in kernel
 	 * space.
 	 */
-	li t0, SR_SUM | SR_FS
+	li t0, SR_SUM | SR_FS | SR_VS
 
 	REG_L s0, TASK_TI_USER_SP(tp)
 	csrrc s1, CSR_SSTATUS, t0
diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S
index 72f89b759..c7edddff4 100644
--- a/arch/riscv/kernel/head.S
+++ b/arch/riscv/kernel/head.S
@@ -60,7 +60,7 @@ _start_kernel:
 	 * Disable FPU to detect illegal usage of
 	 * floating point in kernel space
 	 */
-	li t0, SR_FS
+	li t0, SR_FS | SR_VS
 	csrc CSR_SSTATUS, t0
 
 #ifdef CONFIG_SMP
diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index fffac6ddb..04f11b7a6 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -17,6 +17,7 @@
 #define INTERRUPT_CAUSE_SOFTWARE	IRQ_S_SOFT
 #define INTERRUPT_CAUSE_TIMER		IRQ_S_TIMER
 #define INTERRUPT_CAUSE_EXTERNAL	IRQ_S_EXT
+#define INTERRUPT_CAUSE_PMU		IRQ_S_PMU
 
 int arch_show_interrupts(struct seq_file *p, int prec)
 {
@@ -24,6 +25,7 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 	return 0;
 }
 
+extern int riscv_pmu_handle_irq(void);
 asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
@@ -33,6 +35,11 @@ asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 	case INTERRUPT_CAUSE_TIMER:
 		riscv_timer_interrupt();
 		break;
+#ifdef CONFIG_THEAD_XT_V1_PMU
+	case INTERRUPT_CAUSE_PMU:
+		riscv_pmu_handle_irq();
+		break;
+#endif
 #ifdef CONFIG_SMP
 	case INTERRUPT_CAUSE_SOFTWARE:
 		/*
diff --git a/arch/riscv/kernel/machine_kexec.c b/arch/riscv/kernel/machine_kexec.c
new file mode 100644
index 000000000..2f96d5479
--- /dev/null
+++ b/arch/riscv/kernel/machine_kexec.c
@@ -0,0 +1,163 @@
+/*
+ * kexec for riscv
+ *
+ * Copyright (C) 2020-2025 Alibaba Group Holding Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/kexec.h>
+#include <linux/page-flags.h>
+#include <linux/smp.h>
+
+#include <asm/cacheflush.h>
+#include <asm/mmu.h>
+#include <asm/mmu_context.h>
+#include <asm/page.h>
+
+#include "cpu-reset.h"
+
+/* Global variables for the riscv_relocate_new_kernel routine. */
+extern const unsigned char riscv_relocate_new_kernel[];
+extern const unsigned long riscv_relocate_new_kernel_size;
+
+/*
+ * kexec_image_info - For debugging output.
+ */
+#define kexec_image_info(_i) _kexec_image_info(__func__, __LINE__, _i)
+static void _kexec_image_info(const char *func, int line,
+	const struct kimage *kimage)
+{
+	unsigned long i;
+
+	pr_debug("%s:%d:\n", func, line);
+	pr_debug("  kexec kimage info:\n");
+	pr_debug("    type:        %d\n", kimage->type);
+	pr_debug("    start:       0x%lx\n", kimage->start);
+	pr_debug("    head:        0x%lx\n", kimage->head);
+	pr_debug("    nr_segments: %lu\n", kimage->nr_segments);
+
+	for (i = 0; i < kimage->nr_segments; i++) {
+		pr_debug("      segment[%lu]: %016lx - %016lx, 0x%lx bytes, %lu pages\n",
+			i,
+			kimage->segment[i].mem,
+			kimage->segment[i].mem + kimage->segment[i].memsz,
+			kimage->segment[i].memsz,
+			kimage->segment[i].memsz /  PAGE_SIZE);
+	}
+}
+
+void machine_kexec_cleanup(struct kimage *kimage)
+{
+	/* Empty routine needed to avoid build errors. */
+}
+
+/**
+ * machine_kexec_prepare - Prepare for a kexec reboot.
+ *
+ * Called from the core kexec code when a kernel image is loaded.
+ * Forbid loading a kexec kernel if we have no way of hotplugging cpus or cpus
+ * are stuck in the kernel. This avoids a panic once we hit machine_kexec().
+ */
+int machine_kexec_prepare(struct kimage *kimage)
+{
+	kexec_image_info(kimage);
+
+	return 0;
+}
+
+/**
+ * machine_kexec - Do the kexec reboot.
+ *
+ * Called from the core kexec code for a sys_reboot with LINUX_REBOOT_CMD_KEXEC.
+ */
+void machine_kexec(struct kimage *kimage)
+{
+	phys_addr_t reboot_code_buffer_phys;
+	void *reboot_code_buffer;
+
+	reboot_code_buffer_phys = page_to_phys(kimage->control_code_page);
+	reboot_code_buffer = phys_to_virt(reboot_code_buffer_phys);
+
+	pr_debug("%s:%d: control_code_page:        0x%lx\n", __func__, __LINE__,
+		(long)kimage->control_code_page);
+	pr_debug("%s:%d: reboot_code_buffer_phys:  0x%lx\n", __func__, __LINE__,
+		(long)reboot_code_buffer_phys);
+	pr_debug("%s:%d: reboot_code_buffer:       0x%lx\n", __func__, __LINE__,
+		(long)reboot_code_buffer);
+	pr_debug("%s:%d: relocate_new_kernel:      0x%lx\n", __func__, __LINE__,
+		(long)riscv_relocate_new_kernel);
+	pr_debug("%s:%d: relocate_new_kernel_size: 0x%lx(%lu) bytes\n",
+		__func__, __LINE__, riscv_relocate_new_kernel_size,
+		riscv_relocate_new_kernel_size);
+
+	/*
+	 * Copy riscv_relocate_new_kernel to the reboot_code_buffer for use
+	 * after the kernel is shut down.
+	 */
+	memcpy(reboot_code_buffer, riscv_relocate_new_kernel,
+		riscv_relocate_new_kernel_size);
+
+	pr_info("Bye!\n");
+
+	local_irq_disable();
+
+	cpu_soft_restart(reboot_code_buffer_phys, kimage->head,
+				kimage->segment[0].mem, kimage->segment[2].mem);
+
+	BUG(); /* Should never get here. */
+}
+
+static void machine_kexec_mask_interrupts(void)
+{
+	unsigned int i;
+	struct irq_desc *desc;
+
+	for_each_irq_desc(i, desc) {
+		struct irq_chip *chip;
+		int ret;
+
+		chip = irq_desc_get_chip(desc);
+		if (!chip)
+			continue;
+
+		/*
+		 * First try to remove the active state. If this
+		 * fails, try to EOI the interrupt.
+		 */
+		ret = irq_set_irqchip_state(i, IRQCHIP_STATE_ACTIVE, false);
+
+		if (ret && irqd_irq_inprogress(&desc->irq_data) &&
+		    chip->irq_eoi)
+			chip->irq_eoi(&desc->irq_data);
+
+		if (chip->irq_mask)
+			chip->irq_mask(&desc->irq_data);
+
+		if (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))
+			chip->irq_disable(&desc->irq_data);
+	}
+}
+
+/**
+ * machine_crash_shutdown - shutdown non-crashing cpus and save registers
+ */
+extern void crash_smp_send_stop(void);
+void machine_crash_shutdown(struct pt_regs *regs)
+{
+	local_irq_disable();
+
+	/* shutdown non-crashing cpus */
+	crash_smp_send_stop();
+
+	/* for crashing cpu */
+	crash_save_cpu(regs, smp_processor_id());
+	machine_kexec_mask_interrupts();
+
+	pr_info("Starting crashdump kernel...\n");
+}
diff --git a/arch/riscv/kernel/module.c b/arch/riscv/kernel/module.c
index 6bf5b1674..483d5f02f 100644
--- a/arch/riscv/kernel/module.c
+++ b/arch/riscv/kernel/module.c
@@ -253,7 +253,7 @@ static int apply_r_riscv_align_rela(struct module *me, u32 *location,
 	pr_err(
 	  "%s: The unexpected relocation type 'R_RISCV_ALIGN' from PC = %p\n",
 	  me->name, location);
-	return -EINVAL;
+	return 0; /* Do not return -EINVAL when relocation type is R_RISCV_ALIGN */
 }
 
 static int apply_r_riscv_add32_rela(struct module *me, u32 *location,
diff --git a/arch/riscv/kernel/perf_event.c b/arch/riscv/kernel/perf_event.c
index 91626d9ae..577071620 100644
--- a/arch/riscv/kernel/perf_event.c
+++ b/arch/riscv/kernel/perf_event.c
@@ -477,9 +477,9 @@ int __init init_hw_perf_events(void)
 		if (of_id)
 			riscv_pmu = of_id->data;
 		of_node_put(node);
+		perf_pmu_register(riscv_pmu->pmu, "cpu", PERF_TYPE_RAW);
 	}
 
-	perf_pmu_register(riscv_pmu->pmu, "cpu", PERF_TYPE_RAW);
 	return 0;
 }
 arch_initcall(init_hw_perf_events);
diff --git a/arch/riscv/kernel/process.c b/arch/riscv/kernel/process.c
index 330b34706..ab5a9c068 100644
--- a/arch/riscv/kernel/process.c
+++ b/arch/riscv/kernel/process.c
@@ -74,6 +74,12 @@ void start_thread(struct pt_regs *regs, unsigned long pc,
 		 */
 		fstate_restore(current, regs);
 	}
+
+	if (has_vector) {
+		regs->sstatus |= SR_VS_INITIAL;
+		vstate_restore(current, regs);
+	}
+
 	regs->sepc = pc;
 	regs->sp = sp;
 	set_fs(USER_DS);
diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 1252113ef..7a4866146 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -26,6 +26,9 @@ enum riscv_regset {
 #ifdef CONFIG_FPU
 	REGSET_F,
 #endif
+#ifdef CONFIG_VECTOR
+	REGSET_V,
+#endif
 };
 
 static int riscv_gpr_get(struct task_struct *target,
@@ -92,6 +95,34 @@ static int riscv_fpr_set(struct task_struct *target,
 }
 #endif
 
+#ifdef CONFIG_VECTOR
+static int riscv_vr_get(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 void *kbuf, void __user *ubuf)
+{
+	int ret;
+	struct __riscv_v_state *vstate = &target->thread.vstate;
+
+	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, vstate, 0,
+				  offsetof(struct __riscv_v_state, vtype));
+	return ret;
+}
+
+static int riscv_vr_set(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+	struct __riscv_v_state *vstate = &target->thread.vstate;
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, vstate, 0,
+				 offsetof(struct __riscv_v_state, vtype));
+	return ret;
+}
+#endif
+
 static const struct user_regset riscv_user_regset[] = {
 	[REGSET_X] = {
 		.core_note_type = NT_PRSTATUS,
@@ -111,6 +142,16 @@ static const struct user_regset riscv_user_regset[] = {
 		.set = &riscv_fpr_set,
 	},
 #endif
+#ifdef CONFIG_VECTOR
+	[REGSET_V] = {
+		.core_note_type = NT_RISCV_VECTOR,
+		.n = ELF_NVREG,
+		.size = sizeof(elf_greg_t),
+		.align = sizeof(elf_greg_t),
+		.get = &riscv_vr_get,
+		.set = &riscv_vr_set,
+	},
+#endif
 };
 
 static const struct user_regset_view riscv_user_native_view = {
diff --git a/arch/riscv/kernel/relocate_kernel.S b/arch/riscv/kernel/relocate_kernel.S
new file mode 100644
index 000000000..e61847d55
--- /dev/null
+++ b/arch/riscv/kernel/relocate_kernel.S
@@ -0,0 +1,32 @@
+/*
+ * kexec for riscv
+ *
+ * Copyright (C) 2020-2025 Alibaba Group Holding Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kexec.h>
+#include <linux/linkage.h>
+
+#include <asm/kexec.h>
+#include <asm/page.h>
+
+ENTRY(riscv_relocate_new_kernel)
+	/* Start new image. */
+	mv	s1, a1
+	mv	a0, zero
+	mv	a1, a2
+	mv	a2, zero
+	mv	a3, zero
+	jr	s1
+ENDPROC(riscv_relocate_new_kernel)
+
+.Lcopy_end:
+.org	KEXEC_CONTROL_PAGE_SIZE
+
+.globl riscv_relocate_new_kernel_size
+riscv_relocate_new_kernel_size:
+	.quad	.Lcopy_end - riscv_relocate_new_kernel
diff --git a/arch/riscv/kernel/reset.c b/arch/riscv/kernel/reset.c
index aa56bb135..8f22530f5 100644
--- a/arch/riscv/kernel/reset.c
+++ b/arch/riscv/kernel/reset.c
@@ -31,3 +31,16 @@ void machine_power_off(void)
 {
 	pm_power_off();
 }
+
+void machine_shutdown(void)
+{
+}
+
+static struct notifier_block sbi_srst_reboot_nb;
+ void __init sbi_init(void)
+{
+	pm_power_off = sbi_srst_power_off;
+	sbi_srst_reboot_nb.notifier_call = sbi_srst_reboot;
+	sbi_srst_reboot_nb.priority = 192;
+	register_restart_handler(&sbi_srst_reboot_nb);
+}
diff --git a/arch/riscv/kernel/setup.c b/arch/riscv/kernel/setup.c
index 845ae0e12..23dfe0c61 100644
--- a/arch/riscv/kernel/setup.c
+++ b/arch/riscv/kernel/setup.c
@@ -21,6 +21,7 @@
 #include <asm/sections.h>
 #include <asm/pgtable.h>
 #include <asm/smp.h>
+#include <asm/sbi.h>
 #include <asm/tlbflush.h>
 #include <asm/thread_info.h>
 
@@ -75,6 +76,7 @@ void __init setup_arch(char **cmdline_p)
 #ifdef CONFIG_SMP
 	setup_smp();
 #endif
+	sbi_init();
 
 #ifdef CONFIG_DUMMY_CONSOLE
 	conswitchp = &dummy_con;
diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c
index d0f6f212f..40c1b82fc 100644
--- a/arch/riscv/kernel/signal.c
+++ b/arch/riscv/kernel/signal.c
@@ -78,6 +78,41 @@ static long save_fp_state(struct pt_regs *regs,
 #define restore_fp_state(task, regs) (0)
 #endif
 
+#ifdef CONFIG_VECTOR
+static long restore_v_state(struct pt_regs *regs,
+			    struct __riscv_v_state *sc_vregs)
+{
+	long err;
+	struct __riscv_v_state __user *state = sc_vregs;
+
+	err = __copy_from_user(&current->thread.vstate, state, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	vstate_restore(current, regs);
+
+	return err;
+}
+
+static long save_v_state(struct pt_regs *regs,
+			 struct __riscv_v_state *sc_vregs)
+{
+	long err;
+	struct __riscv_v_state __user *state = sc_vregs;
+
+	vstate_save(current, regs);
+	err = __copy_to_user(state, &current->thread.vstate, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	return err;
+}
+#else
+#define save_v_state(task, regs) (0)
+#define restore_v_state(task, regs) (0)
+#endif
+
+
 static long restore_sigcontext(struct pt_regs *regs,
 	struct sigcontext __user *sc)
 {
@@ -87,6 +122,9 @@ static long restore_sigcontext(struct pt_regs *regs,
 	/* Restore the floating-point state. */
 	if (has_fpu)
 		err |= restore_fp_state(regs, &sc->sc_fpregs);
+	/* Restore the vector state. */
+	if (has_vector)
+		err |= restore_v_state(regs, &sc->sc_vregs);
 	return err;
 }
 
@@ -140,6 +178,9 @@ static long setup_sigcontext(struct rt_sigframe __user *frame,
 	/* Save the floating-point state. */
 	if (has_fpu)
 		err |= save_fp_state(regs, &sc->sc_fpregs);
+	/* Save the vector state. */
+	if (has_vector)
+		err |= save_v_state(regs, &sc->sc_vregs);
 	return err;
 }
 
diff --git a/arch/riscv/kernel/smpboot.c b/arch/riscv/kernel/smpboot.c
index 261f4087c..a1b09bea7 100644
--- a/arch/riscv/kernel/smpboot.c
+++ b/arch/riscv/kernel/smpboot.c
@@ -102,6 +102,7 @@ int __cpu_up(unsigned int cpu, struct task_struct *tidle)
 	int hartid = cpuid_to_hartid_map(cpu);
 	tidle->thread_info.cpu = cpu;
 
+	SBI_CALL_1(0x09000003, hartid);
 	/*
 	 * On RISC-V systems, all harts boot on their own accord.  Our _start
 	 * selects the first hart to boot the kernel and causes the remainder
diff --git a/arch/riscv/kernel/time.c b/arch/riscv/kernel/time.c
index 6a53c02e9..a2c9ad639 100644
--- a/arch/riscv/kernel/time.c
+++ b/arch/riscv/kernel/time.c
@@ -8,6 +8,7 @@
 #include <linux/delay.h>
 #include <asm/sbi.h>
 #include <asm/processor.h>
+#include <linux/of_clk.h>
 
 unsigned long riscv_timebase;
 EXPORT_SYMBOL_GPL(riscv_timebase);
@@ -24,5 +25,8 @@ void __init time_init(void)
 	riscv_timebase = prop;
 
 	lpj_fine = riscv_timebase / HZ;
+#ifdef CONFIG_COMMON_CLK
+	of_clk_init(NULL);
+#endif
 	timer_probe();
 }
diff --git a/arch/riscv/kernel/vector.S b/arch/riscv/kernel/vector.S
new file mode 100644
index 000000000..0afc308a6
--- /dev/null
+++ b/arch/riscv/kernel/vector.S
@@ -0,0 +1,84 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ * Copyright (C) 2017 SiFive
+ * Copyright (C) 2019 T-HEAD
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+
+#include <asm/asm.h>
+#include <asm/csr.h>
+#include <asm/asm-offsets.h>
+
+ENTRY(__vstate_save)
+	li	a2,  TASK_THREAD_V0
+	add	a0,  a0, a2
+
+	li	t1, (SR_VS | SR_FS)
+	csrs	sstatus, t1
+
+	csrr	t0,  CSR_VSTART
+	sd	t0,  TASK_THREAD_VSTART_V0(a0)
+	csrr	t0,  CSR_VXSAT
+	sd	t0,  TASK_THREAD_VXSAT_V0(a0)
+	csrr	t0,  CSR_VXRM
+	sd	t0,  TASK_THREAD_VXRM_V0(a0)
+	csrr	t0,  CSR_VL
+	sd	t0,  TASK_THREAD_VL_V0(a0)
+	csrr	t0,  CSR_VTYPE
+	sd	t0,  TASK_THREAD_VTYPE_V0(a0)
+
+	vsetvli	t0, x0, e8,m8
+	vsb.v	v0,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	vsb.v	v8,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	vsb.v	v16, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	vsb.v	v24, (a0)
+
+	csrc	sstatus, t1
+	ret
+ENDPROC(__vstate_save)
+
+ENTRY(__vstate_restore)
+	li	a2,  TASK_THREAD_V0
+	add	a0,  a0, a2
+	mv	t2,  a0
+
+	li	t1, (SR_VS | SR_FS)
+	csrs	sstatus, t1
+
+	vsetvli	t0, x0, e8,m8
+	vlb.v	v0,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	vlb.v	v8,  (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	vlb.v	v16, (a0)
+	addi	a0, a0, RISCV_VECTOR_VLENB*8
+	vlb.v	v24, (a0)
+
+	mv	a0,  t2
+	ld	t0,  TASK_THREAD_VSTART_V0(a0)
+	csrw	CSR_VSTART, t0
+	ld	t0,  TASK_THREAD_VXSAT_V0(a0)
+	csrw	CSR_VXSAT, t0
+	ld	t0,  TASK_THREAD_VXRM_V0(a0)
+	csrw	CSR_VXRM, t0
+	ld	t0,  TASK_THREAD_VL_V0(a0)
+	ld	t2,  TASK_THREAD_VTYPE_V0(a0)
+	vsetvl	t0, t0, t2
+
+	csrc	sstatus, t1
+	ret
+ENDPROC(__vstate_restore)
diff --git a/arch/riscv/mm/Makefile b/arch/riscv/mm/Makefile
index 9d9a17335..27711a91c 100644
--- a/arch/riscv/mm/Makefile
+++ b/arch/riscv/mm/Makefile
@@ -12,6 +12,9 @@ obj-y += ioremap.o
 obj-y += cacheflush.o
 obj-y += context.o
 obj-y += sifive_l2_cache.o
+obj-y += dma-mapping.o
+obj-y += asid.o
+obj-y += context.o
 
 ifeq ($(CONFIG_MMU),y)
 obj-$(CONFIG_SMP) += tlbflush.o
diff --git a/arch/riscv/mm/asid.c b/arch/riscv/mm/asid.c
new file mode 100644
index 000000000..48b1699eb
--- /dev/null
+++ b/arch/riscv/mm/asid.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Generic ASID allocator.
+ *
+ * Based on arch/arm/mm/context.c
+ *
+ * Copyright (C) 2002-2003 Deep Blue Solutions Ltd, all rights reserved.
+ * Copyright (C) 2012 ARM Ltd.
+ */
+
+#include <linux/slab.h>
+#include <linux/mm_types.h>
+
+#include <asm/asid.h>
+
+#define reserved_asid(info, cpu) (*per_cpu_ptr((info)->reserved, cpu))
+
+#define ASID_MASK(info)			(~GENMASK((info)->bits - 1, 0))
+#define ASID_FIRST_VERSION(info)	(1UL << ((info)->bits))
+
+#define asid2idx(info, asid)		(((asid) & ~ASID_MASK(info)) >> (info)->ctxt_shift)
+#define idx2asid(info, idx)		(((idx) << (info)->ctxt_shift) & ~ASID_MASK(info))
+
+static void flush_context(struct asid_info *info)
+{
+	int i;
+	u64 asid;
+
+	/* Update the list of reserved ASIDs and the ASID bitmap. */
+	bitmap_clear(info->map, 0, NUM_CTXT_ASIDS(info));
+
+	for_each_possible_cpu(i) {
+		asid = atomic64_xchg_relaxed(&active_asid(info, i), 0);
+		/*
+		 * If this CPU has already been through a
+		 * rollover, but hasn't run another task in
+		 * the meantime, we must preserve its reserved
+		 * ASID, as this is the only trace we have of
+		 * the process it is still running.
+		 */
+		if (asid == 0)
+			asid = reserved_asid(info, i);
+		__set_bit(asid2idx(info, asid), info->map);
+		reserved_asid(info, i) = asid;
+	}
+
+	/*
+	 * Queue a TLB invalidation for each CPU to perform on next
+	 * context-switch
+	 */
+	cpumask_setall(&info->flush_pending);
+}
+
+static bool check_update_reserved_asid(struct asid_info *info, u64 asid,
+				       u64 newasid)
+{
+	int cpu;
+	bool hit = false;
+
+	/*
+	 * Iterate over the set of reserved ASIDs looking for a match.
+	 * If we find one, then we can update our mm to use newasid
+	 * (i.e. the same ASID in the current generation) but we can't
+	 * exit the loop early, since we need to ensure that all copies
+	 * of the old ASID are updated to reflect the mm. Failure to do
+	 * so could result in us missing the reserved ASID in a future
+	 * generation.
+	 */
+	for_each_possible_cpu(cpu) {
+		if (reserved_asid(info, cpu) == asid) {
+			hit = true;
+			reserved_asid(info, cpu) = newasid;
+		}
+	}
+
+	return hit;
+}
+
+static u64 new_context(struct asid_info *info, atomic64_t *pasid,
+		       struct mm_struct *mm)
+{
+	static u32 cur_idx = 1;
+	u64 asid = atomic64_read(pasid);
+	u64 generation = atomic64_read(&info->generation);
+
+	if (asid != 0) {
+		u64 newasid = generation | (asid & ~ASID_MASK(info));
+
+		/*
+		 * If our current ASID was active during a rollover, we
+		 * can continue to use it and this was just a false alarm.
+		 */
+		if (check_update_reserved_asid(info, asid, newasid))
+			return newasid;
+
+		/*
+		 * We had a valid ASID in a previous life, so try to re-use
+		 * it if possible.
+		 */
+		if (!__test_and_set_bit(asid2idx(info, asid), info->map))
+			return newasid;
+	}
+
+	/*
+	 * Allocate a free ASID. If we can't find one, take a note of the
+	 * currently active ASIDs and mark the TLBs as requiring flushes.  We
+	 * always count from ASID #2 (index 1), as we use ASID #0 when setting
+	 * a reserved TTBR0 for the init_mm and we allocate ASIDs in even/odd
+	 * pairs.
+	 */
+	asid = find_next_zero_bit(info->map, NUM_CTXT_ASIDS(info), cur_idx);
+	if (asid != NUM_CTXT_ASIDS(info))
+		goto set_asid;
+
+	/* We're out of ASIDs, so increment the global generation count */
+	generation = atomic64_add_return_relaxed(ASID_FIRST_VERSION(info),
+						 &info->generation);
+	flush_context(info);
+
+	/* We have more ASIDs than CPUs, so this will always succeed */
+	asid = find_next_zero_bit(info->map, NUM_CTXT_ASIDS(info), 1);
+
+set_asid:
+	__set_bit(asid, info->map);
+	cur_idx = asid;
+	cpumask_clear(mm_cpumask(mm));
+	return idx2asid(info, asid) | generation;
+}
+
+/*
+ * Generate a new ASID for the context.
+ *
+ * @pasid: Pointer to the current ASID batch allocated. It will be updated
+ * with the new ASID batch.
+ * @cpu: current CPU ID. Must have been acquired through get_cpu()
+ */
+void asid_new_context(struct asid_info *info, atomic64_t *pasid,
+		      unsigned int cpu, struct mm_struct *mm)
+{
+	unsigned long flags;
+	u64 asid;
+
+	raw_spin_lock_irqsave(&info->lock, flags);
+	/* Check that our ASID belongs to the current generation. */
+	asid = atomic64_read(pasid);
+	if ((asid ^ atomic64_read(&info->generation)) >> info->bits) {
+		asid = new_context(info, pasid, mm);
+		atomic64_set(pasid, asid);
+	}
+
+	if (cpumask_test_and_clear_cpu(cpu, &info->flush_pending))
+		info->flush_cpu_ctxt_cb();
+
+	atomic64_set(&active_asid(info, cpu), asid);
+	cpumask_set_cpu(cpu, mm_cpumask(mm));
+	raw_spin_unlock_irqrestore(&info->lock, flags);
+}
+
+/*
+ * Initialize the ASID allocator
+ *
+ * @info: Pointer to the asid allocator structure
+ * @bits: Number of ASIDs available
+ * @asid_per_ctxt: Number of ASIDs to allocate per-context. ASIDs are
+ * allocated contiguously for a given context. This value should be a power of
+ * 2.
+ */
+int asid_allocator_init(struct asid_info *info,
+			u32 bits, unsigned int asid_per_ctxt,
+			void (*flush_cpu_ctxt_cb)(void))
+{
+	info->bits = bits;
+	info->ctxt_shift = ilog2(asid_per_ctxt);
+	info->flush_cpu_ctxt_cb = flush_cpu_ctxt_cb;
+	/*
+	 * Expect allocation after rollover to fail if we don't have at least
+	 * one more ASID than CPUs. ASID #0 is always reserved.
+	 */
+	WARN_ON(NUM_CTXT_ASIDS(info) - 1 <= num_possible_cpus());
+	atomic64_set(&info->generation, ASID_FIRST_VERSION(info));
+	info->map = kcalloc(BITS_TO_LONGS(NUM_CTXT_ASIDS(info)),
+			    sizeof(*info->map), GFP_KERNEL);
+	if (!info->map)
+		return -ENOMEM;
+
+	raw_spin_lock_init(&info->lock);
+
+	return 0;
+}
diff --git a/arch/riscv/mm/cacheflush.c b/arch/riscv/mm/cacheflush.c
index c54bd3c79..4dc87930f 100644
--- a/arch/riscv/mm/cacheflush.c
+++ b/arch/riscv/mm/cacheflush.c
@@ -74,3 +74,96 @@ void flush_icache_pte(pte_t pte)
 	if (!test_and_set_bit(PG_dcache_clean, &page->flags))
 		flush_icache_all();
 }
+
+void dma_wbinv_range(unsigned long start, unsigned long end)
+{
+	register unsigned long i asm("a0") = start & ~(L1_CACHE_BYTES - 1);
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x02b5000b"); /* dcache.cipa a0 */
+
+	asm volatile (".long 0x01b0000b");
+}
+
+void dma_wb_range(unsigned long start, unsigned long end)
+{
+	register unsigned long i asm("a0") = start & ~(L1_CACHE_BYTES - 1);
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x0295000b"); /* dcache.cpa a0 */
+
+	asm volatile (".long 0x01b0000b");
+}
+
+void dma_usr_va_wb_range(void *user_addr, unsigned long len)
+{
+	unsigned long start = (unsigned long)user_addr;
+	unsigned long end = start + len;
+	register unsigned long i asm("a5") = start & ~(L1_CACHE_BYTES - 1);
+
+	csr_set(CSR_SSTATUS, SR_SUM);
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile(".long 0x0257800b"); /* dcache.cva a5 */
+
+	asm volatile(".long 0x01b0000b");
+
+	csr_clear(CSR_SSTATUS, SR_SUM);
+}
+
+void dma_usr_va_inv_range(void *user_addr, unsigned long len)
+{
+	unsigned long start = (unsigned long)user_addr;
+	unsigned long end = start + len;
+	register unsigned long i asm("a5") = start & ~(L1_CACHE_BYTES - 1);
+
+	csr_set(CSR_SSTATUS, SR_SUM);
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x0267800b"); /* dcache.iva a5 */
+
+	asm volatile(".long 0x01b0000b");
+
+	csr_clear(CSR_SSTATUS, SR_SUM);
+}
+
+void dma_va_wb_range(void *kernel_addr, unsigned long len)
+{
+	unsigned long start = (unsigned long)kernel_addr;
+	unsigned long end = start + len;
+	register unsigned long i asm("a5") = start & ~(L1_CACHE_BYTES - 1);
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile(".long 0x0257800b"); /* dcache.cva a5 */
+
+	asm volatile(".long 0x01b0000b");
+}
+
+void dma_va_inv_range(void *kernel_addr, unsigned long len)
+{
+	unsigned long start = (unsigned long)kernel_addr;
+	unsigned long end = start + len;
+	register unsigned long i asm("a5") = start & ~(L1_CACHE_BYTES - 1);
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x0267800b"); /* dcache.iva a5 */
+
+	asm volatile(".long 0x01b0000b");
+}
+
+void dma_va_wbinv_range(void *kernel_addr, unsigned long len)
+{
+	unsigned long start = (unsigned long)kernel_addr;
+	unsigned long end = start + len;
+	register unsigned long i asm("a5") = start & ~(L1_CACHE_BYTES - 1);
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x0277800b"); /* dcache.civa a5 */
+
+	asm volatile(".long 0x01b0000b");
+}
+
+void dma_clean_dcache_all(void)
+{
+	asm volatile(".long 0x0010000b":::"memory") ;
+}
diff --git a/arch/riscv/mm/context.c b/arch/riscv/mm/context.c
index ca66d4415..cae066cfe 100644
--- a/arch/riscv/mm/context.c
+++ b/arch/riscv/mm/context.c
@@ -44,6 +44,7 @@ void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	struct task_struct *task)
 {
 	unsigned int cpu;
+	unsigned long asid;
 
 	if (unlikely(prev == next))
 		return;
@@ -58,8 +59,46 @@ void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	cpumask_clear_cpu(cpu, mm_cpumask(prev));
 	cpumask_set_cpu(cpu, mm_cpumask(next));
 
-	csr_write(CSR_SATP, virt_to_pfn(next->pgd) | SATP_MODE);
-	local_flush_tlb_all();
+	check_and_switch_context(next, cpu);
+	asid = (next->context.asid.counter & SATP_ASID_MASK)
+		<< SATP_ASID_SHIFT;
+
+	csr_write(sptbr, virt_to_pfn(next->pgd) | SATP_MODE | asid);
 
 	flush_icache_deferred(next);
 }
+
+static DEFINE_PER_CPU(atomic64_t, active_asids);
+static DEFINE_PER_CPU(u64, reserved_asids);
+
+struct asid_info asid_info;
+
+void check_and_switch_context(struct mm_struct *mm, unsigned int cpu)
+{
+	asid_check_context(&asid_info, &mm->context.asid, cpu, mm);
+}
+
+static void asid_flush_cpu_ctxt(void)
+{
+	local_flush_tlb_all();
+}
+
+static int asids_init(void)
+{
+	BUG_ON(((1 << SATP_ASID_BITS) - 1) <= num_possible_cpus());
+
+	if (asid_allocator_init(&asid_info, SATP_ASID_BITS, 1,
+				asid_flush_cpu_ctxt))
+		panic("Unable to initialize ASID allocator for %lu ASIDs\n",
+		      NUM_ASIDS(&asid_info));
+
+	asid_info.active = &active_asids;
+	asid_info.reserved = &reserved_asids;
+
+	pr_info("ASID allocator initialised with %lu entries\n",
+		NUM_CTXT_ASIDS(&asid_info));
+
+	local_flush_tlb_all();
+	return 0;
+}
+early_initcall(asids_init);
diff --git a/arch/riscv/mm/dma-mapping.c b/arch/riscv/mm/dma-mapping.c
new file mode 100644
index 000000000..17e3a7398
--- /dev/null
+++ b/arch/riscv/mm/dma-mapping.c
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2018 Hangzhou C-SKY Microsystems co.,ltd.
+
+#include <linux/cache.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+#include <linux/dma-noncoherent.h>
+#include <linux/genalloc.h>
+#include <linux/highmem.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <asm/cache.h>
+#include <linux/dma-iommu.h>
+
+void arch_dma_prep_coherent(struct page *page, size_t size)
+{
+	void *ptr = page_address(page);
+
+	memset(ptr, 0, size);
+	dma_wbinv_range(page_to_phys(page), page_to_phys(page) + size);
+}
+
+static inline void cache_op(phys_addr_t paddr, size_t size,
+			    void (*fn)(unsigned long start, unsigned long end))
+{
+	unsigned long start = (unsigned long)paddr;
+
+	fn(start, start + size);
+}
+
+void arch_sync_dma_for_device(struct device *dev, phys_addr_t paddr,
+			      size_t size, enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		cache_op(paddr, size, dma_wb_range);
+		break;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, dma_wbinv_range);
+		break;
+	default:
+		BUG();
+	}
+}
+
+void arch_sync_dma_for_cpu(struct device *dev, phys_addr_t paddr,
+			   size_t size, enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		return;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, dma_wbinv_range);
+		break;
+	default:
+		BUG();
+	}
+}
+
+pgprot_t arch_dma_mmap_pgprot(struct device *dev, pgprot_t prot,
+		unsigned long attrs)
+{
+	if (attrs & DMA_ATTR_WRITE_COMBINE)
+		return pgprot_writecombine(prot);
+	return pgprot_noncached(prot);
+}
+
+void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
+			const struct iommu_ops *iommu, bool coherent)
+{
+	dev->dma_coherent = coherent;
+	if (iommu)
+		iommu_setup_dma_ops(dev, dma_base, size);
+
+}
+EXPORT_SYMBOL_GPL(arch_setup_dma_ops);
diff --git a/arch/riscv/mm/fault.c b/arch/riscv/mm/fault.c
index 247b8c859..dfc48e5d2 100644
--- a/arch/riscv/mm/fault.c
+++ b/arch/riscv/mm/fault.c
@@ -218,6 +218,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 		pmd_t *pmd, *pmd_k;
 		pte_t *pte_k;
 		int index;
+		unsigned long pfn;
 
 		/* User mode accesses just cause a SIGSEGV */
 		if (user_mode(regs))
@@ -232,7 +233,8 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 		 * of a task switch.
 		 */
 		index = pgd_index(addr);
-		pgd = (pgd_t *)pfn_to_virt(csr_read(CSR_SATP)) + index;
+		pfn = csr_read(CSR_SATP) & SATP_PPN;
+		pgd = (pgd_t *)pfn_to_virt(pfn) + index;
 		pgd_k = init_mm.pgd + index;
 
 		if (!pgd_present(*pgd_k))
diff --git a/arch/riscv/mm/init.c b/arch/riscv/mm/init.c
index b1eb6a041..45607d33d 100644
--- a/arch/riscv/mm/init.c
+++ b/arch/riscv/mm/init.c
@@ -13,6 +13,9 @@
 #include <linux/of_fdt.h>
 #include <linux/libfdt.h>
 
+#include <linux/crash_dump.h>
+#include <linux/dma-contiguous.h>
+
 #include <asm/fixmap.h>
 #include <asm/tlbflush.h>
 #include <asm/sections.h>
@@ -27,13 +30,175 @@ EXPORT_SYMBOL(empty_zero_page);
 
 extern char _start[];
 
+#ifdef CONFIG_KEXEC_CORE
+static void __init reserve_crashkernel(void)
+{
+	unsigned long long crash_base, crash_size;
+	int ret;
+
+	ret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),
+			&crash_size, &crash_base);
+	if (ret || !crash_size)
+		return;
+
+	if (crash_base == 0) {
+		crash_base = memblock_find_in_range(0, __pfn_to_phys(max_low_pfn)-1,
+				crash_size, SZ_2M);
+		pr_debug("crash_base: 0x%llx\n", crash_base);
+	}
+
+	memblock_reserve(crash_base, crash_size);
+
+	pr_info("crashkernel reserved: 0x%016llx - 0x%016llx (%lld MB)\n",
+		crash_base, crash_base + crash_size, crash_size >> 20);
+
+	crashk_res.start = crash_base;
+	crashk_res.end = crash_base + crash_size - 1;
+}
+#else
+static void __init reserve_crashkernel(void)
+{
+}
+#endif /* CONFIG_KEXEC_CORE */
+
+#ifdef CONFIG_CRASH_DUMP
+static int __init early_init_dt_scan_elfcorehdr(unsigned long node,
+		const char *uname, int depth, void *data)
+{
+	const __be32 *reg;
+	int len;
+
+	if (depth != 1 || strcmp(uname, "chosen") != 0)
+		return 0;
+
+	reg = of_get_flat_dt_prop(node, "linux,elfcorehdr", &len);
+	if (!reg || (len < (dt_root_addr_cells + dt_root_size_cells)))
+		return 1;
+
+	elfcorehdr_addr = dt_mem_next_cell(dt_root_addr_cells, &reg);
+	elfcorehdr_size = dt_mem_next_cell(dt_root_size_cells, &reg);
+
+	return 1;
+}
+
+/*
+ * reserve_elfcorehdr() - reserves memory for elf core header
+ *
+ * This function reserves the memory occupied by an elf core header
+ * described in the device tree. This region contains all the
+ * information about primary kernel's core image and is used by a dump
+ * capture kernel to access the system memory on primary kernel.
+ */
+static void __init reserve_elfcorehdr(void)
+{
+	of_scan_flat_dt(early_init_dt_scan_elfcorehdr, NULL);
+
+	if (!elfcorehdr_size)
+		return;
+
+	if (memblock_is_region_reserved(elfcorehdr_addr, elfcorehdr_size)) {
+		pr_warn("elfcorehdr is overlapped\n");
+		return;
+	}
+
+	memblock_reserve(elfcorehdr_addr, elfcorehdr_size);
+
+	pr_info("Reserving %lldKB of memory at 0x%llx for elfcorehdr\n",
+		elfcorehdr_size >> 10, elfcorehdr_addr);
+}
+#else
+static void __init reserve_elfcorehdr(void)
+{
+}
+#endif /* CONFIG_CRASH_DUMP */
+
+/*
+ * Standard memory resources
+ */
+static struct resource mem_res[] = {
+	{
+		.name = "Kernel code",
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_SYSTEM_RAM
+	},
+	{
+		.name = "Kernel data",
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_SYSTEM_RAM
+	}
+};
+
+#define kernel_code mem_res[0]
+#define kernel_data mem_res[1]
+
+static int num_standard_resources;
+struct resource *standard_resources;
+
+extern char _start[];
+static void __init request_standard_resources(void)
+{
+	struct memblock_region *region;
+	struct resource *res;
+	unsigned long i = 0;
+	size_t res_size;
+
+	kernel_code.start   = __pa_symbol(_start);
+	kernel_code.end     = __pa_symbol(__init_end - 1);
+	kernel_data.start   = __pa_symbol(_sdata);
+	kernel_data.end     = __pa_symbol(_end - 1);
+
+	num_standard_resources = memblock.memory.cnt;
+	res_size = num_standard_resources * sizeof(*standard_resources);
+	standard_resources = memblock_alloc(res_size, SMP_CACHE_BYTES);
+	if (!standard_resources)
+		panic("%s: Failed to allocate %zu bytes\n", __func__, res_size);
+
+	for_each_memblock(memory, region) {
+		res = &standard_resources[i++];
+		if (memblock_is_nomap(region)) {
+			res->name  = "reserved";
+			res->flags = IORESOURCE_MEM;
+		} else {
+			res->name  = "System RAM";
+			res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+		}
+		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
+		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
+
+		request_resource(&iomem_resource, res);
+
+		if (kernel_code.start >= res->start &&
+		    kernel_code.end <= res->end)
+			request_resource(res, &kernel_code);
+		if (kernel_data.start >= res->start &&
+		    kernel_data.end <= res->end)
+			request_resource(res, &kernel_data);
+#ifdef CONFIG_KEXEC_CORE
+		/* Userspace will find "Crash kernel" region in /proc/iomem. */
+		if (crashk_res.end && crashk_res.start >= res->start &&
+		    crashk_res.end <= res->end)
+			request_resource(res, &crashk_res);
+#endif
+	}
+}
+
+void __init riscv_kdump_crash(void)
+{
+	reserve_crashkernel();
+	reserve_elfcorehdr();
+	request_standard_resources();
+}
+
+static phys_addr_t dma32_phys_limit __ro_after_init;
+
 static void __init zone_sizes_init(void)
 {
 	unsigned long max_zone_pfns[MAX_NR_ZONES] = { 0, };
 
 #ifdef CONFIG_ZONE_DMA32
-	max_zone_pfns[ZONE_DMA32] = PFN_DOWN(min(4UL * SZ_1G,
-			(unsigned long) PFN_PHYS(max_low_pfn)));
+	max_zone_pfns[ZONE_DMA32] = PFN_DOWN(dma32_phys_limit);
 #endif
 	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
 
@@ -117,6 +282,7 @@ void __init setup_bootmem(void)
 
 	max_pfn = PFN_DOWN(memblock_end_of_DRAM());
 	max_low_pfn = max_pfn;
+	dma32_phys_limit = min(4UL * SZ_1G, (unsigned long)PFN_PHYS(max_low_pfn));
 	set_max_mapnr(max_low_pfn);
 
 #ifdef CONFIG_BLK_DEV_INITRD
@@ -130,6 +296,7 @@ void __init setup_bootmem(void)
 	memblock_reserve(dtb_early_pa, fdt_totalsize(dtb_early_va));
 
 	early_init_fdt_scan_reserved_mem();
+	dma_contiguous_reserve(dma32_phys_limit);
 	memblock_allow_resize();
 	memblock_dump_all();
 
@@ -171,8 +338,8 @@ void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot)
 		set_pte(ptep, pfn_pte(phys >> PAGE_SHIFT, prot));
 	} else {
 		pte_clear(&init_mm, addr, ptep);
-		local_flush_tlb_page(addr);
 	}
+	local_flush_tlb_page(addr);
 }
 
 static pte_t *__init get_pte_virt(phys_addr_t pa)
@@ -458,6 +625,7 @@ void __init paging_init(void)
 	sparse_init();
 	setup_zero_page();
 	zone_sizes_init();
+	riscv_kdump_crash();
 }
 
 #ifdef CONFIG_SPARSEMEM_VMEMMAP
diff --git a/arch/riscv/mm/ioremap.c b/arch/riscv/mm/ioremap.c
index ac621ddb4..91367eb1c 100644
--- a/arch/riscv/mm/ioremap.c
+++ b/arch/riscv/mm/ioremap.c
@@ -50,26 +50,19 @@ static void __iomem *__ioremap_caller(phys_addr_t addr, size_t size,
 	return (void __iomem *)(vaddr + offset);
 }
 
-/*
- * ioremap     -   map bus memory into CPU space
- * @offset:    bus address of the memory
- * @size:      size of the resource to map
- *
- * ioremap performs a platform specific sequence of operations to
- * make bus memory CPU accessible via the readb/readw/readl/writeb/
- * writew/writel functions and the other mmio helpers. The returned
- * address is not guaranteed to be usable directly as a virtual
- * address.
- *
- * Must be freed with iounmap.
- */
-void __iomem *ioremap(phys_addr_t offset, unsigned long size)
+void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot)
 {
-	return __ioremap_caller(offset, size, PAGE_KERNEL,
-		__builtin_return_address(0));
+	return __ioremap_caller(phys_addr, size, prot,
+				__builtin_return_address(0));
 }
-EXPORT_SYMBOL(ioremap);
+EXPORT_SYMBOL(__ioremap);
 
+void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size)
+{
+	return __ioremap_caller(phys_addr, size, PAGE_KERNEL,
+				__builtin_return_address(0));
+}
+EXPORT_SYMBOL(ioremap_cache);
 
 /**
  * iounmap - Free a IO remapping
@@ -82,3 +75,16 @@ void iounmap(volatile void __iomem *addr)
 	vunmap((void *)((unsigned long)addr & PAGE_MASK));
 }
 EXPORT_SYMBOL(iounmap);
+
+pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+			      unsigned long size, pgprot_t vma_prot)
+{
+	if (!pfn_valid(pfn)) {
+		return pgprot_noncached(vma_prot);
+	} else if (file->f_flags & O_SYNC) {
+		return pgprot_writecombine(vma_prot);
+	}
+
+	return vma_prot;
+}
+EXPORT_SYMBOL(phys_mem_access_prot);
diff --git a/arch/riscv/mm/tlbflush.c b/arch/riscv/mm/tlbflush.c
index 24cd33d2c..605b0e4be 100644
--- a/arch/riscv/mm/tlbflush.c
+++ b/arch/riscv/mm/tlbflush.c
@@ -2,6 +2,56 @@
 
 #include <linux/mm.h>
 #include <linux/smp.h>
+
+#define XUANTIE
+#ifdef XUANTIE
+#include <asm/mmu_context.h>
+
+void flush_tlb_all(void)
+{
+	__asm__ __volatile__ ("sfence.vma" : : : "memory");
+}
+
+void flush_tlb_mm(struct mm_struct *mm)
+{
+	int newpid = cpu_asid(mm);
+
+	__asm__ __volatile__ ("sfence.vma zero, %0"
+				:
+				: "r"(newpid)
+				: "memory");
+}
+
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)
+{
+	int newpid = cpu_asid(vma->vm_mm);
+
+	addr &= PAGE_MASK;
+
+	__asm__ __volatile__ ("sfence.vma %0, %1"
+				:
+				: "r"(addr), "r"(newpid)
+				: "memory");
+}
+
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+			unsigned long end)
+{
+	unsigned long newpid = cpu_asid(vma->vm_mm);
+
+	start &= PAGE_MASK;
+	end   += PAGE_SIZE - 1;
+	end   &= PAGE_MASK;
+
+	while (start < end) {
+		__asm__ __volatile__ ("sfence.vma %0, %1"
+					:
+					: "r"(start), "r"(newpid)
+					: "memory");
+		start += PAGE_SIZE;
+	}
+}
+#else
 #include <asm/sbi.h>
 
 void flush_tlb_all(void)
@@ -33,3 +83,4 @@ void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 {
 	__sbi_tlb_flush_range(mm_cpumask(vma->vm_mm), start, end - start);
 }
+#endif
-- 
2.17.1

