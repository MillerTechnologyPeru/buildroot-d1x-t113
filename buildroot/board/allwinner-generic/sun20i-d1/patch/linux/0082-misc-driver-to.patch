From edf57434e12f801a0a27e755eabf6ecd9e5098f2 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 17:24:10 +0800
Subject: [PATCH 82/93] misc driver to

---
 drivers/misc/Kconfig                          |   33 +
 drivers/misc/Makefile                         |    8 +
 drivers/misc/hisi_hikey_usb.c                 |  178 +++
 drivers/misc/lkdtm/Makefile                   |    1 +
 drivers/misc/lkdtm/bugs.c                     |   10 +-
 drivers/misc/lkdtm/heap.c                     |    9 +-
 drivers/misc/lkdtm/perms.c                    |   22 +-
 drivers/misc/lkdtm/usercopy.c                 |    9 +-
 drivers/misc/sunxi-addr/Kconfig               |    6 +
 drivers/misc/sunxi-addr/Makefile              |    5 +
 drivers/misc/sunxi-addr/sha256.c              |  178 +++
 drivers/misc/sunxi-addr/sunxi-addr.c          |  384 ++++++
 drivers/misc/sunxi-bootevent/Kconfig          |   10 +
 drivers/misc/sunxi-bootevent/Makefile         |    6 +
 drivers/misc/sunxi-bootevent/bootevent.c      |  316 +++++
 drivers/misc/sunxi-bootevent/bootevent.h      |   42 +
 drivers/misc/sunxi-gorilla/Kconfig            |   44 +
 drivers/misc/sunxi-gorilla/Makefile           |    4 +
 drivers/misc/sunxi-gorilla/gorilla-common.h   |   69 +
 drivers/misc/sunxi-gorilla/gorilla-de-tcon.c  | 1109 +++++++++++++++++
 .../misc/sunxi-gorilla/gorilla-extra-mem.c    |   89 ++
 drivers/misc/sunxi-gorilla/gorilla-memc.c     |  183 +++
 drivers/misc/sunxi-gorilla/gorilla-nsi.c      |  107 ++
 drivers/misc/sunxi-rf/Kconfig                 |    9 +
 drivers/misc/sunxi-rf/Makefile                |    8 +
 drivers/misc/sunxi-rf/internal.h              |   35 +
 drivers/misc/sunxi-rf/sunxi-bluetooth.c       |  300 +++++
 drivers/misc/sunxi-rf/sunxi-modem.c           |  264 ++++
 drivers/misc/sunxi-rf/sunxi-rfkill.c          |  197 +++
 drivers/misc/sunxi-rf/sunxi-rfkill.h          |   95 ++
 drivers/misc/sunxi-rf/sunxi-wlan.c            |  456 +++++++
 drivers/misc/sunxi-tvutils/Kconfig            |   26 +
 drivers/misc/sunxi-tvutils/Makefile           |    8 +
 drivers/misc/sunxi-tvutils/arisc_rpm/Makefile |    6 +
 .../sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.c |  297 +++++
 .../sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.h |   30 +
 drivers/misc/sunxi-tvutils/mipsloader.c       |  192 +++
 drivers/misc/sunxi-tvutils/tvutils.c          |  361 ++++++
 drivers/misc/sunxi_cpu_comm.c                 |   87 ++
 drivers/misc/sunxi_cpu_comm.h                 |   29 +
 drivers/misc/uid_sys_stats.c                  |  706 +++++++++++
 41 files changed, 5908 insertions(+), 20 deletions(-)
 create mode 100644 drivers/misc/hisi_hikey_usb.c
 create mode 100644 drivers/misc/sunxi-addr/Kconfig
 create mode 100644 drivers/misc/sunxi-addr/Makefile
 create mode 100644 drivers/misc/sunxi-addr/sha256.c
 create mode 100644 drivers/misc/sunxi-addr/sunxi-addr.c
 create mode 100644 drivers/misc/sunxi-bootevent/Kconfig
 create mode 100644 drivers/misc/sunxi-bootevent/Makefile
 create mode 100644 drivers/misc/sunxi-bootevent/bootevent.c
 create mode 100644 drivers/misc/sunxi-bootevent/bootevent.h
 create mode 100644 drivers/misc/sunxi-gorilla/Kconfig
 create mode 100644 drivers/misc/sunxi-gorilla/Makefile
 create mode 100644 drivers/misc/sunxi-gorilla/gorilla-common.h
 create mode 100644 drivers/misc/sunxi-gorilla/gorilla-de-tcon.c
 create mode 100644 drivers/misc/sunxi-gorilla/gorilla-extra-mem.c
 create mode 100644 drivers/misc/sunxi-gorilla/gorilla-memc.c
 create mode 100644 drivers/misc/sunxi-gorilla/gorilla-nsi.c
 create mode 100644 drivers/misc/sunxi-rf/Kconfig
 create mode 100644 drivers/misc/sunxi-rf/Makefile
 create mode 100644 drivers/misc/sunxi-rf/internal.h
 create mode 100644 drivers/misc/sunxi-rf/sunxi-bluetooth.c
 create mode 100644 drivers/misc/sunxi-rf/sunxi-modem.c
 create mode 100644 drivers/misc/sunxi-rf/sunxi-rfkill.c
 create mode 100644 drivers/misc/sunxi-rf/sunxi-rfkill.h
 create mode 100644 drivers/misc/sunxi-rf/sunxi-wlan.c
 create mode 100644 drivers/misc/sunxi-tvutils/Kconfig
 create mode 100644 drivers/misc/sunxi-tvutils/Makefile
 create mode 100644 drivers/misc/sunxi-tvutils/arisc_rpm/Makefile
 create mode 100644 drivers/misc/sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.c
 create mode 100644 drivers/misc/sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.h
 create mode 100644 drivers/misc/sunxi-tvutils/mipsloader.c
 create mode 100644 drivers/misc/sunxi-tvutils/tvutils.c
 create mode 100644 drivers/misc/sunxi_cpu_comm.c
 create mode 100644 drivers/misc/sunxi_cpu_comm.h
 create mode 100644 drivers/misc/uid_sys_stats.c

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index c55b63750..6f15108e8 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -458,6 +458,21 @@ config MISC_RTSX
 	tristate
 	default MISC_RTSX_PCI || MISC_RTSX_USB
 
+config UID_SYS_STATS
+	bool "Per-UID statistics"
+	depends on PROFILING && TASK_XACCT && TASK_IO_ACCOUNTING
+	help
+	  Per UID based cpu time statistics exported to /proc/uid_cputime
+	  Per UID based io statistics exported to /proc/uid_io
+	  Per UID based procstat control in /proc/uid_procstat
+
+config UID_SYS_STATS_DEBUG
+	bool "Per-TASK statistics"
+	depends on UID_SYS_STATS
+	default n
+	help
+	  Per TASK based io statistics exported to /proc/uid_io
+
 config PVPANIC
 	tristate "pvpanic device support"
 	depends on HAS_IOMEM && (ACPI || OF)
@@ -466,6 +481,18 @@ config PVPANIC
 	  a paravirtualized device provided by QEMU; it lets a virtual machine
 	  (guest) communicate panic events to the host.
 
+config HISI_HIKEY_USB
+	tristate "USB functionality of HiSilicon Hikey Platform"
+	depends on OF && GPIOLIB
+	help
+	  If you say yes here you get support for usb functionality of HiSilicon Hikey Platform.
+
+config SUNXI_CPU_COMM
+	tristate "sunxi cpu comm api for tv subsystem"
+	depends on RPMSG_SUNXI_AMP
+	help
+	  If you say yes here you get support for tv subsystem cpu comm protocol.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
@@ -481,4 +508,10 @@ source "drivers/misc/cxl/Kconfig"
 source "drivers/misc/ocxl/Kconfig"
 source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/habanalabs/Kconfig"
+source "drivers/misc/sunxi-rf/Kconfig"
+source "drivers/misc/sunxi-addr/Kconfig"
+source "drivers/misc/sunxi-bootevent/Kconfig"
+source "drivers/misc/sunxi-gorilla/Kconfig"
+source "drivers/misc/sunxi-tvutils/Kconfig"
+
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index c1860d35d..304c0ba16 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -57,3 +57,11 @@ obj-y				+= cardreader/
 obj-$(CONFIG_PVPANIC)   	+= pvpanic.o
 obj-$(CONFIG_HABANA_AI)		+= habanalabs/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
+obj-$(CONFIG_UID_SYS_STATS)	+= uid_sys_stats.o
+obj-$(CONFIG_HISI_HIKEY_USB)	+= hisi_hikey_usb.o
+obj-$(CONFIG_SUNXI_RFKILL)      += sunxi-rf/
+obj-$(CONFIG_SUNXI_ADDR_MGT)    += sunxi-addr/
+obj-$(CONFIG_SUNXI_BOOTEVENT)   += sunxi-bootevent/
+obj-y                           += sunxi-gorilla/
+obj-$(CONFIG_ARCH_SUNXI)        += sunxi-tvutils/
+obj-$(CONFIG_SUNXI_CPU_COMM)	+= sunxi_cpu_comm.o
diff --git a/drivers/misc/hisi_hikey_usb.c b/drivers/misc/hisi_hikey_usb.c
new file mode 100644
index 000000000..32015bc9c
--- /dev/null
+++ b/drivers/misc/hisi_hikey_usb.c
@@ -0,0 +1,178 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Support for usb functionality of Hikey series boards
+ * based on Hisilicon Kirin Soc.
+ *
+ * Copyright (C) 2017-2018 Hilisicon Electronics Co., Ltd.
+ *		http://www.huawei.com
+ *
+ * Authors: Yu Chen <chenyu56@huawei.com>
+ */
+
+#include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/slab.h>
+#include <linux/usb/role.h>
+
+#define DEVICE_DRIVER_NAME "hisi_hikey_usb"
+
+#define HUB_VBUS_POWER_ON 1
+#define HUB_VBUS_POWER_OFF 0
+#define USB_SWITCH_TO_HUB 1
+#define USB_SWITCH_TO_TYPEC 0
+#define TYPEC_VBUS_POWER_ON 1
+#define TYPEC_VBUS_POWER_OFF 0
+
+struct hisi_hikey_usb {
+	struct gpio_desc *otg_switch;
+	struct gpio_desc *typec_vbus;
+	struct gpio_desc *hub_vbus;
+
+	struct usb_role_switch *hub_role_sw;
+	struct usb_role_switch *dev_role_sw;
+	struct notifier_block nb;
+};
+
+static void hub_power_ctrl(struct hisi_hikey_usb *hisi_hikey_usb, int value)
+{
+	gpiod_set_value_cansleep(hisi_hikey_usb->hub_vbus, value);
+}
+
+static void usb_switch_ctrl(struct hisi_hikey_usb *hisi_hikey_usb,
+			    int switch_to)
+{
+	gpiod_set_value_cansleep(hisi_hikey_usb->otg_switch, switch_to);
+}
+
+static void usb_typec_power_ctrl(struct hisi_hikey_usb *hisi_hikey_usb,
+				 int value)
+{
+	gpiod_set_value_cansleep(hisi_hikey_usb->typec_vbus, value);
+}
+
+static int hub_usb_role_switch_set(struct device *dev, enum usb_role role)
+{
+	struct hisi_hikey_usb *hisi_hikey_usb = dev_get_drvdata(dev);
+
+	if (!hisi_hikey_usb || !hisi_hikey_usb->dev_role_sw)
+		return -EINVAL;
+
+	switch (role) {
+	case USB_ROLE_NONE:
+		usb_typec_power_ctrl(hisi_hikey_usb, TYPEC_VBUS_POWER_OFF);
+		usb_switch_ctrl(hisi_hikey_usb, USB_SWITCH_TO_HUB);
+		hub_power_ctrl(hisi_hikey_usb, HUB_VBUS_POWER_ON);
+		break;
+	case USB_ROLE_HOST:
+		hub_power_ctrl(hisi_hikey_usb, HUB_VBUS_POWER_OFF);
+		usb_switch_ctrl(hisi_hikey_usb, USB_SWITCH_TO_TYPEC);
+		usb_typec_power_ctrl(hisi_hikey_usb, TYPEC_VBUS_POWER_ON);
+		break;
+	case USB_ROLE_DEVICE:
+		hub_power_ctrl(hisi_hikey_usb, HUB_VBUS_POWER_OFF);
+		usb_typec_power_ctrl(hisi_hikey_usb, TYPEC_VBUS_POWER_OFF);
+		usb_switch_ctrl(hisi_hikey_usb, USB_SWITCH_TO_TYPEC);
+		break;
+	default:
+		break;
+	}
+
+	return usb_role_switch_set_role(hisi_hikey_usb->dev_role_sw, role);
+}
+
+static enum usb_role hub_usb_role_switch_get(struct device *dev)
+{
+	struct hisi_hikey_usb *hisi_hikey_usb = dev_get_drvdata(dev);
+
+	if (!hisi_hikey_usb || !hisi_hikey_usb->dev_role_sw)
+		return -EINVAL;
+
+	return usb_role_switch_get_role(hisi_hikey_usb->dev_role_sw);
+}
+
+static int hisi_hikey_usb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct hisi_hikey_usb *hisi_hikey_usb;
+	struct usb_role_switch_desc hub_role_switch = {NULL};
+
+	hisi_hikey_usb = devm_kzalloc(dev, sizeof(*hisi_hikey_usb), GFP_KERNEL);
+	if (!hisi_hikey_usb)
+		return -ENOMEM;
+
+	hisi_hikey_usb->typec_vbus = devm_gpiod_get(dev, "typec-vbus",
+						    GPIOD_OUT_LOW);
+	if (IS_ERR(hisi_hikey_usb->typec_vbus))
+		return PTR_ERR(hisi_hikey_usb->typec_vbus);
+
+	hisi_hikey_usb->otg_switch = devm_gpiod_get(dev, "otg-switch",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(hisi_hikey_usb->otg_switch))
+		return PTR_ERR(hisi_hikey_usb->otg_switch);
+
+	/* hub-vdd33-en is optional */
+	hisi_hikey_usb->hub_vbus = devm_gpiod_get_optional(dev, "hub-vdd33-en",
+							   GPIOD_OUT_HIGH);
+	if (IS_ERR(hisi_hikey_usb->hub_vbus))
+		return PTR_ERR(hisi_hikey_usb->hub_vbus);
+
+	hisi_hikey_usb->dev_role_sw = usb_role_switch_get(dev);
+	if (!hisi_hikey_usb->dev_role_sw)
+		return -EPROBE_DEFER;
+	if (IS_ERR(hisi_hikey_usb->dev_role_sw))
+		return PTR_ERR(hisi_hikey_usb->dev_role_sw);
+
+	hub_role_switch.fwnode = dev_fwnode(dev);
+	hub_role_switch.set = hub_usb_role_switch_set;
+	hub_role_switch.get = hub_usb_role_switch_get;
+	hisi_hikey_usb->hub_role_sw = usb_role_switch_register(dev,
+							&hub_role_switch);
+
+	if (IS_ERR(hisi_hikey_usb->hub_role_sw)) {
+		usb_role_switch_put(hisi_hikey_usb->dev_role_sw);
+		return PTR_ERR(hisi_hikey_usb->hub_role_sw);
+	}
+
+	platform_set_drvdata(pdev, hisi_hikey_usb);
+
+	return 0;
+}
+
+static int  hisi_hikey_usb_remove(struct platform_device *pdev)
+{
+	struct hisi_hikey_usb *hisi_hikey_usb = platform_get_drvdata(pdev);
+
+	if (hisi_hikey_usb->hub_role_sw)
+		usb_role_switch_unregister(hisi_hikey_usb->hub_role_sw);
+
+	if (hisi_hikey_usb->dev_role_sw)
+		usb_role_switch_put(hisi_hikey_usb->dev_role_sw);
+
+	return 0;
+}
+
+static const struct of_device_id id_table_hisi_hikey_usb[] = {
+	{.compatible = "hisilicon,gpio_hubv1"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, id_table_hisi_hikey_usb);
+
+static struct platform_driver hisi_hikey_usb_driver = {
+	.probe = hisi_hikey_usb_probe,
+	.remove = hisi_hikey_usb_remove,
+	.driver = {
+		.name = DEVICE_DRIVER_NAME,
+		.of_match_table = id_table_hisi_hikey_usb,
+	},
+};
+
+module_platform_driver(hisi_hikey_usb_driver);
+
+MODULE_AUTHOR("Yu Chen <chenyu56@huawei.com>");
+MODULE_DESCRIPTION("Driver Support for USB functionality of Hikey");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/lkdtm/Makefile b/drivers/misc/lkdtm/Makefile
index c70b38220..dd4c936d4 100644
--- a/drivers/misc/lkdtm/Makefile
+++ b/drivers/misc/lkdtm/Makefile
@@ -13,6 +13,7 @@ lkdtm-$(CONFIG_LKDTM)		+= cfi.o
 
 KASAN_SANITIZE_stackleak.o	:= n
 KCOV_INSTRUMENT_rodata.o	:= n
+CFLAGS_REMOVE_rodata.o		+= $(CC_FLAGS_LTO)
 
 OBJCOPYFLAGS :=
 OBJCOPYFLAGS_rodata_objcopy.o	:= \
diff --git a/drivers/misc/lkdtm/bugs.c b/drivers/misc/lkdtm/bugs.c
index 4d5a51276..e5d33ca01 100644
--- a/drivers/misc/lkdtm/bugs.c
+++ b/drivers/misc/lkdtm/bugs.c
@@ -113,9 +113,8 @@ noinline void lkdtm_CORRUPT_STACK(void)
 	/* Use default char array length that triggers stack protection. */
 	char data[8] __aligned(sizeof(void *));
 
-	__lkdtm_CORRUPT_STACK(&data);
-
-	pr_info("Corrupted stack containing char array ...\n");
+	pr_info("Corrupting stack containing char array ...\n");
+	__lkdtm_CORRUPT_STACK((void *)&data);
 }
 
 /* Same as above but will only get a canary with -fstack-protector-strong */
@@ -126,9 +125,8 @@ noinline void lkdtm_CORRUPT_STACK_STRONG(void)
 		unsigned long *ptr;
 	} data __aligned(sizeof(void *));
 
-	__lkdtm_CORRUPT_STACK(&data);
-
-	pr_info("Corrupted stack containing union ...\n");
+	pr_info("Corrupting stack containing union ...\n");
+	__lkdtm_CORRUPT_STACK((void *)&data);
 }
 
 void lkdtm_UNALIGNED_LOAD_STORE_WRITE(void)
diff --git a/drivers/misc/lkdtm/heap.c b/drivers/misc/lkdtm/heap.c
index 3c5cec85e..1323bc16f 100644
--- a/drivers/misc/lkdtm/heap.c
+++ b/drivers/misc/lkdtm/heap.c
@@ -58,11 +58,12 @@ void lkdtm_READ_AFTER_FREE(void)
 	int *base, *val, saw;
 	size_t len = 1024;
 	/*
-	 * The slub allocator uses the first word to store the free
-	 * pointer in some configurations. Use the middle of the
-	 * allocation to avoid running into the freelist
+	 * The slub allocator will use the either the first word or
+	 * the middle of the allocation to store the free pointer,
+	 * depending on configurations. Store in the second word to
+	 * avoid running into the freelist.
 	 */
-	size_t offset = (len / sizeof(*base)) / 2;
+	size_t offset = sizeof(*base);
 
 	base = kmalloc(len, GFP_KERNEL);
 	if (!base) {
diff --git a/drivers/misc/lkdtm/perms.c b/drivers/misc/lkdtm/perms.c
index 62f76d506..2dede2ef6 100644
--- a/drivers/misc/lkdtm/perms.c
+++ b/drivers/misc/lkdtm/perms.c
@@ -57,6 +57,7 @@ static noinline void execute_location(void *dst, bool write)
 	}
 	pr_info("attempting bad execution at %px\n", func);
 	func();
+	pr_err("FAIL: func returned\n");
 }
 
 static void execute_user_location(void *dst)
@@ -75,20 +76,22 @@ static void execute_user_location(void *dst)
 		return;
 	pr_info("attempting bad execution at %px\n", func);
 	func();
+	pr_err("FAIL: func returned\n");
 }
 
 void lkdtm_WRITE_RO(void)
 {
-	/* Explicitly cast away "const" for the test. */
-	unsigned long *ptr = (unsigned long *)&rodata;
+	/* Explicitly cast away "const" for the test and make volatile. */
+	volatile unsigned long *ptr = (unsigned long *)&rodata;
 
 	pr_info("attempting bad rodata write at %px\n", ptr);
 	*ptr ^= 0xabcd1234;
+	pr_err("FAIL: survived bad write\n");
 }
 
 void lkdtm_WRITE_RO_AFTER_INIT(void)
 {
-	unsigned long *ptr = &ro_after_init;
+	volatile unsigned long *ptr = &ro_after_init;
 
 	/*
 	 * Verify we were written to during init. Since an Oops
@@ -102,19 +105,21 @@ void lkdtm_WRITE_RO_AFTER_INIT(void)
 
 	pr_info("attempting bad ro_after_init write at %px\n", ptr);
 	*ptr ^= 0xabcd1234;
+	pr_err("FAIL: survived bad write\n");
 }
 
 void lkdtm_WRITE_KERN(void)
 {
 	size_t size;
-	unsigned char *ptr;
+	volatile unsigned char *ptr;
 
 	size = (unsigned long)do_overwritten - (unsigned long)do_nothing;
 	ptr = (unsigned char *)do_overwritten;
 
 	pr_info("attempting bad %zu byte write at %px\n", size, ptr);
-	memcpy(ptr, (unsigned char *)do_nothing, size);
+	memcpy((void *)ptr, (unsigned char *)do_nothing, size);
 	flush_icache_range((unsigned long)ptr, (unsigned long)(ptr + size));
+	pr_err("FAIL: survived bad write\n");
 
 	do_overwritten();
 }
@@ -193,9 +198,11 @@ void lkdtm_ACCESS_USERSPACE(void)
 	pr_info("attempting bad read at %px\n", ptr);
 	tmp = *ptr;
 	tmp += 0xc0dec0de;
+	pr_err("FAIL: survived bad read\n");
 
 	pr_info("attempting bad write at %px\n", ptr);
 	*ptr = tmp;
+	pr_err("FAIL: survived bad write\n");
 
 	vm_munmap(user_addr, PAGE_SIZE);
 }
@@ -203,19 +210,20 @@ void lkdtm_ACCESS_USERSPACE(void)
 void lkdtm_ACCESS_NULL(void)
 {
 	unsigned long tmp;
-	unsigned long *ptr = (unsigned long *)NULL;
+	volatile unsigned long *ptr = (unsigned long *)NULL;
 
 	pr_info("attempting bad read at %px\n", ptr);
 	tmp = *ptr;
 	tmp += 0xc0dec0de;
+	pr_err("FAIL: survived bad read\n");
 
 	pr_info("attempting bad write at %px\n", ptr);
 	*ptr = tmp;
+	pr_err("FAIL: survived bad write\n");
 }
 
 void __init lkdtm_perms_init(void)
 {
 	/* Make sure we can write to __ro_after_init values during __init */
 	ro_after_init |= 0xAA;
-
 }
diff --git a/drivers/misc/lkdtm/usercopy.c b/drivers/misc/lkdtm/usercopy.c
index e172719dd..120e9ffd0 100644
--- a/drivers/misc/lkdtm/usercopy.c
+++ b/drivers/misc/lkdtm/usercopy.c
@@ -304,19 +304,22 @@ void lkdtm_USERCOPY_KERNEL(void)
 		return;
 	}
 
-	pr_info("attempting good copy_to_user from kernel rodata\n");
+	pr_info("attempting good copy_to_user from kernel rodata: %px\n",
+		test_text);
 	if (copy_to_user((void __user *)user_addr, test_text,
 			 unconst + sizeof(test_text))) {
 		pr_warn("copy_to_user failed unexpectedly?!\n");
 		goto free_user;
 	}
 
-	pr_info("attempting bad copy_to_user from kernel text\n");
-	if (copy_to_user((void __user *)user_addr, vm_mmap,
+	pr_info("attempting bad copy_to_user from kernel text: %px\n",
+		vm_mmap);
+	if (copy_to_user((void __user *)user_addr, __va_function(vm_mmap),
 			 unconst + PAGE_SIZE)) {
 		pr_warn("copy_to_user failed, but lacked Oops\n");
 		goto free_user;
 	}
+	pr_err("FAIL: survived bad copy_to_user()\n");
 
 free_user:
 	vm_munmap(user_addr, PAGE_SIZE);
diff --git a/drivers/misc/sunxi-addr/Kconfig b/drivers/misc/sunxi-addr/Kconfig
new file mode 100644
index 000000000..4268887ea
--- /dev/null
+++ b/drivers/misc/sunxi-addr/Kconfig
@@ -0,0 +1,6 @@
+config SUNXI_ADDR_MGT
+  tristate "Allwinner Network MAC Addess Manager"
+  depends on SUNXI_RFKILL || BT || ETHERNET
+  help
+    allwinner network mac address management
+
diff --git a/drivers/misc/sunxi-addr/Makefile b/drivers/misc/sunxi-addr/Makefile
new file mode 100644
index 000000000..f01fd4783
--- /dev/null
+++ b/drivers/misc/sunxi-addr/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for wifi mac addr manager drivers
+#
+sunxi_addr-objs := sunxi-addr.o sha256.o
+obj-$(CONFIG_SUNXI_ADDR_MGT)   += sunxi_addr.o
diff --git a/drivers/misc/sunxi-addr/sha256.c b/drivers/misc/sunxi-addr/sha256.c
new file mode 100644
index 000000000..78825810c
--- /dev/null
+++ b/drivers/misc/sunxi-addr/sha256.c
@@ -0,0 +1,178 @@
+/*
+ * Local implement of sha256.
+ *
+ * Copyright (C) 2013 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/****************************** MACROS ******************************/
+#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
+#define CH(x, y, z)    (((x) & (y)) ^ (~(x) & (z)))
+#define MAJ(x, y, z)   (((x) & (y)) ^  ((x) & (z)) ^ ((y) & (z)))
+#define EP0(x)         (ROTRIGHT(x,  2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
+#define EP1(x)         (ROTRIGHT(x,  6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
+#define SIG0(x)        (ROTRIGHT(x,  7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
+#define SIG1(x)        (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))
+
+/**************************** VARIABLES *****************************/
+static const uint32_t k[64] = {
+	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+struct sha256_ctx {
+	uint8_t data[64];   /* current 512-bit chunk of message data, just like a buffer */
+	uint32_t datalen;   /* sign the data length of current chunk */
+	uint64_t bitlen;    /* the bit length of the total message */
+	uint32_t state[8];  /* store the middle state of hash abstract */
+};
+
+/*********************** FUNCTION DEFINITIONS ***********************/
+static void sha256_transform(struct sha256_ctx *ctx, const uint8_t *data)
+{
+	uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
+
+	/* initialization */
+	for (i = 0, j = 0; i < 16; ++i, j += 4)
+		m[i] = (data[j] << 24) | (data[j + 1] << 16) |
+			(data[j + 2] << 8) | (data[j + 3]);
+	for ( ; i < 64; ++i)
+		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
+
+	a = ctx->state[0];
+	b = ctx->state[1];
+	c = ctx->state[2];
+	d = ctx->state[3];
+	e = ctx->state[4];
+	f = ctx->state[5];
+	g = ctx->state[6];
+	h = ctx->state[7];
+
+	for (i = 0; i < 64; ++i) {
+		t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
+		t2 = EP0(a) + MAJ(a, b, c);
+		h = g;
+		g = f;
+		f = e;
+		e = d + t1;
+		d = c;
+		c = b;
+		b = a;
+		a = t1 + t2;
+	}
+
+	ctx->state[0] += a;
+	ctx->state[1] += b;
+	ctx->state[2] += c;
+	ctx->state[3] += d;
+	ctx->state[4] += e;
+	ctx->state[5] += f;
+	ctx->state[6] += g;
+	ctx->state[7] += h;
+}
+
+static void sha256_init(struct sha256_ctx *ctx)
+{
+	ctx->datalen = 0;
+	ctx->bitlen = 0;
+	ctx->state[0] = 0x6a09e667;
+	ctx->state[1] = 0xbb67ae85;
+	ctx->state[2] = 0x3c6ef372;
+	ctx->state[3] = 0xa54ff53a;
+	ctx->state[4] = 0x510e527f;
+	ctx->state[5] = 0x9b05688c;
+	ctx->state[6] = 0x1f83d9ab;
+	ctx->state[7] = 0x5be0cd19;
+}
+
+static void sha256_update(struct sha256_ctx *ctx, const uint8_t *data, size_t len)
+{
+	uint32_t i;
+
+	for (i = 0; i < len; ++i) {
+		ctx->data[ctx->datalen] = data[i];
+		ctx->datalen++;
+		if (ctx->datalen == 64) {
+			/* 64 byte = 512 bit  means the buffer ctx->data has
+			 * fully stored one chunk of message,
+			 * so do the sha256 hash map for the current chunk.
+			 */
+			sha256_transform(ctx, ctx->data);
+			ctx->bitlen += 512;
+			ctx->datalen = 0;
+		}
+	}
+}
+
+static void sha256_final(struct sha256_ctx *ctx, uint8_t *hash)
+{
+	uint32_t i;
+
+	i = ctx->datalen;
+
+	/* Pad whatever data is left in the buffer. */
+	if (ctx->datalen < 56) {
+		ctx->data[i++] = 0x80;  /* pad 10000000 = 0x80 */
+		while (i < 56)
+			ctx->data[i++] = 0x00;
+	} else {
+		ctx->data[i++] = 0x80;
+		while (i < 64)
+			ctx->data[i++] = 0x00;
+		sha256_transform(ctx, ctx->data);
+		memset(ctx->data, 0, 56);
+	}
+
+	/* Append to the padding the total message's length in bits and transform. */
+	ctx->bitlen += ctx->datalen * 8;
+	ctx->data[63] = ctx->bitlen;
+	ctx->data[62] = ctx->bitlen >> 8;
+	ctx->data[61] = ctx->bitlen >> 16;
+	ctx->data[60] = ctx->bitlen >> 24;
+	ctx->data[59] = ctx->bitlen >> 32;
+	ctx->data[58] = ctx->bitlen >> 40;
+	ctx->data[57] = ctx->bitlen >> 48;
+	ctx->data[56] = ctx->bitlen >> 56;
+	sha256_transform(ctx, ctx->data);
+
+	/* copying the final state to the output hash(use big endian). */
+	for (i = 0; i < 4; ++i) {
+		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
+	}
+}
+
+int hmac_sha256(const uint8_t *plaintext, ssize_t psize, uint8_t *output)
+{
+	struct sha256_ctx ctx;
+
+	sha256_init(&ctx);
+	sha256_update(&ctx, plaintext, psize);
+	sha256_final(&ctx, output);
+	return 0;
+}
diff --git a/drivers/misc/sunxi-addr/sunxi-addr.c b/drivers/misc/sunxi-addr/sunxi-addr.c
new file mode 100644
index 000000000..77c5439a7
--- /dev/null
+++ b/drivers/misc/sunxi-addr/sunxi-addr.c
@@ -0,0 +1,384 @@
+/*
+ * The driver of SUNXI NET MAC ADDR Manager.
+ *
+ * Copyright (C) 2013 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/random.h>
+
+#define ADDR_MGT_DBG(fmt, arg...) printk(KERN_DEBUG "[ADDR_MGT] %s: " fmt "\n",\
+				__func__, ## arg)
+#define ADDR_MGT_ERR(fmt, arg...) printk(KERN_ERR "[ADDR_MGT] %s: " fmt "\n",\
+				__func__, ## arg)
+
+#define MODULE_CUR_VERSION  "v1.0.10"
+
+#define MATCH_STR_LEN       20
+#define ADDR_VAL_LEN        6
+#define ADDR_STR_LEN        18
+#define ID_LEN              16
+#define HASH_LEN            32
+
+#define TYPE_ANY            0
+#define TYPE_BURN           1
+#define TYPE_IDGEN          2
+#define TYPE_USER           3
+#define TYPE_RAND           4
+
+#define ADDR_FMT_STR        0
+#define ADDR_FMT_VAL        1
+
+#define IS_TYPE_INVALID(x)  ((x < TYPE_ANY) || (x > TYPE_RAND))
+
+#define ADDR_CLASS_ATTR_ADD(name) \
+static ssize_t addr_##name##_show(struct class *class, \
+		struct class_attribute *attr, char *buffer) \
+{ \
+	char addr[ADDR_STR_LEN]; \
+	if (IS_TYPE_INVALID(get_addr_by_name(ADDR_FMT_STR, addr, #name))) \
+		return 0; \
+	return sprintf(buffer, "%.17s\n", addr); \
+} \
+static ssize_t addr_##name##_store(struct class *class, \
+		struct class_attribute *attr, \
+		const char *buffer, size_t count) \
+{ \
+	if (count != ADDR_STR_LEN) { \
+		ADDR_MGT_ERR("Length wrong."); \
+		return -EINVAL; \
+	} \
+	set_addr_by_name(TYPE_USER, ADDR_FMT_STR, buffer, #name); \
+	return count; \
+} \
+static CLASS_ATTR_RW(addr_##name);
+
+struct addr_mgt_info {
+	unsigned int type_def;
+	unsigned int type_cur;
+	unsigned int flag;
+	char *addr;
+	char *name;
+};
+
+static struct addr_mgt_info info[] = {
+	{TYPE_ANY, TYPE_ANY, 1, NULL, "wifi"},
+	{TYPE_ANY, TYPE_ANY, 0, NULL, "bt"  },
+	{TYPE_ANY, TYPE_ANY, 1, NULL, "eth" },
+};
+
+extern int hmac_sha256(const uint8_t *plaintext, ssize_t psize, uint8_t *output);
+
+#if IS_ENABLED(CONFIG_SUNXI_SID)
+#include <linux/sunxi-sid.h>
+#else
+static int sunxi_get_soc_chipid(uint8_t *id)
+{
+	(void)id;
+	return -1;
+}
+#endif
+
+static int addr_parse(int fmt, const char *addr, int check)
+{
+	char val_buf[ADDR_VAL_LEN];
+	char cmp_buf[ADDR_VAL_LEN];
+	int  ret = ADDR_VAL_LEN;
+
+	if (fmt == ADDR_FMT_STR)
+		ret = sscanf(addr, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+					&val_buf[0], &val_buf[1], &val_buf[2],
+					&val_buf[3], &val_buf[4], &val_buf[5]);
+	else
+		memcpy(val_buf, addr, ADDR_VAL_LEN);
+
+	if (ret != ADDR_VAL_LEN)
+		return -1;
+
+	if (check && (val_buf[0] & 0x3))
+		return -1;
+
+	memset(cmp_buf, 0x00, ADDR_VAL_LEN);
+	if (memcmp(val_buf, cmp_buf, ADDR_VAL_LEN) == 0)
+		return -1;
+
+	memset(cmp_buf, 0xFF, ADDR_VAL_LEN);
+	if (memcmp(val_buf, cmp_buf, ADDR_VAL_LEN) == 0)
+		return -1;
+
+	return 0;
+}
+
+static struct addr_mgt_info *addr_find_by_name(char *name)
+{
+	int i = 0;
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		if (strcmp(info[i].name, name) == 0)
+			return &info[i];
+	}
+	return NULL;
+}
+
+static int get_addr_by_name(int fmt, char *addr, char *name)
+{
+	struct addr_mgt_info *t;
+
+	t = addr_find_by_name(name);
+	if (t == NULL) {
+		ADDR_MGT_ERR("can't find addr named: %s", name);
+		return -1;
+	}
+
+	if (t->addr == NULL) {
+		ADDR_MGT_ERR("t->addr: ", t->addr);
+		return -1;
+	}
+
+	if (IS_TYPE_INVALID(t->type_cur)) {
+		ADDR_MGT_ERR("addr type invalid");
+		return -1;
+	}
+
+	if (addr_parse(ADDR_FMT_VAL, t->addr, t->flag)) {
+		ADDR_MGT_ERR("addr parse fail(%s)", t->addr);
+		return -1;
+	}
+
+	if (fmt == ADDR_FMT_STR)
+		sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
+				t->addr[0], t->addr[1], t->addr[2],
+				t->addr[3], t->addr[4], t->addr[5]);
+	else
+		memcpy(addr, t->addr, ADDR_VAL_LEN);
+
+	return t->type_cur;
+}
+
+static int set_addr_by_name(int type, int fmt, const char *addr, char *name)
+{
+	struct addr_mgt_info *t;
+
+	t = addr_find_by_name(name);
+	if (t == NULL) {
+		ADDR_MGT_ERR("can't find addr named: %s", name);
+		return -1;
+	}
+
+	if (addr_parse(fmt, addr, t->flag)) {
+		ADDR_MGT_ERR("addr parse fail(%s)", addr);
+		return -1;
+	}
+
+	t->type_cur = type;
+	if (fmt == ADDR_FMT_STR)
+		sscanf(addr, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+				&t->addr[0], &t->addr[1], &t->addr[2],
+				&t->addr[3], &t->addr[4], &t->addr[5]);
+	else
+		memcpy(t->addr, addr, ADDR_VAL_LEN);
+
+	return 0;
+}
+
+int get_custom_mac_address(int fmt, char *name, char *addr)
+{
+	return get_addr_by_name(fmt, addr, name);
+}
+EXPORT_SYMBOL_GPL(get_custom_mac_address);
+
+static int addr_factory(struct device_node *np,
+			int idx, int type, char *mac, char *name)
+{
+	int  ret;
+	char match[MATCH_STR_LEN];
+	const char *p;
+	char id[ID_LEN], cmp_buf[ID_LEN];
+	static char hash[HASH_LEN];
+	static int initial = -1;
+
+	switch (type) {
+	case TYPE_BURN:
+		sprintf(match, "addr_%s", name);
+		ret = of_property_read_string_index(np, match, 0, &p);
+		if (ret)
+			return -1;
+
+		ret = sscanf(p, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+			&mac[0], &mac[1], &mac[2],
+			&mac[3], &mac[4], &mac[5]);
+
+		if (ret != ADDR_VAL_LEN)
+			return -1;
+		break;
+	case TYPE_IDGEN:
+		if (idx > HASH_LEN / ADDR_VAL_LEN - 1)
+			return -1;
+		if (initial == -1) {
+			if (sunxi_get_soc_chipid(id)) {
+				initial = 0;
+				return -1;
+			}
+			memset(cmp_buf, 0x00, ID_LEN);
+			if (memcmp(id, cmp_buf, ID_LEN) == 0) {
+				initial = 0;
+				return -1;
+			}
+			if (hmac_sha256(id, ID_LEN, hash)) {
+				initial = 0;
+				return -1;
+			}
+			initial = 1;
+		}
+
+		if (initial == 0)
+			return -1;
+
+		memcpy(mac, &hash[idx * ADDR_VAL_LEN], ADDR_VAL_LEN);
+		break;
+	case TYPE_RAND:
+		get_random_bytes(mac, ADDR_VAL_LEN);
+		break;
+	default:
+		ADDR_MGT_ERR("unsupport type: %d", type);
+		return -1;
+	}
+	return 0;
+}
+
+static int addr_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int  type, i, j;
+	char match[MATCH_STR_LEN];
+	char addr[ADDR_VAL_LEN];
+	int  type_tab[] = {TYPE_BURN, TYPE_IDGEN, TYPE_RAND};
+
+	/* init addr type and value */
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		sprintf(match, "type_addr_%s", info[i].name);
+		if (of_property_read_u32(np, match, &type)) {
+			ADDR_MGT_DBG("Failed to get type_def_%s, use default: %d",
+						info[i].name, info[i].type_def);
+		} else {
+			info[i].type_def = type;
+			info[i].type_cur = type;
+		}
+
+		if (IS_TYPE_INVALID(info[i].type_def))
+			return -1;
+		if (info[i].type_def != TYPE_ANY) {
+			if (addr_factory(np, i, info[i].type_def, addr, info[i].name))
+				return -1;
+		} else {
+			for (j = 0; j < ARRAY_SIZE(type_tab); j++) {
+				if (!addr_factory(np, i, type_tab[j], addr, info[i].name)) {
+					info[i].type_cur = type_tab[j];
+					break;
+				}
+			}
+		}
+
+		if (info[i].flag)
+			addr[0] &= 0xFC;
+
+		if (addr_parse(ADDR_FMT_VAL, addr, info[i].flag))
+			return -1;
+		else {
+			info[i].addr = devm_kzalloc(&pdev->dev, ADDR_VAL_LEN, GFP_KERNEL);
+			memcpy(info[i].addr, addr, ADDR_VAL_LEN);
+		}
+	}
+	return 0;
+}
+
+static ssize_t summary_show(struct class *class,
+				struct class_attribute *attr, char *buffer)
+{
+	int i = 0, ret = 0;
+
+	ret += sprintf(&buffer[ret], "name cfg cur address\n");
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		ret += sprintf(&buffer[ret],
+			"%4s  %d   %d  %02X:%02X:%02X:%02X:%02X:%02X\n",
+			info[i].name,   info[i].type_def, info[i].type_cur,
+			info[i].addr[0], info[i].addr[1], info[i].addr[2],
+			info[i].addr[3], info[i].addr[4], info[i].addr[5]);
+	}
+	return ret;
+}
+static CLASS_ATTR_RO(summary);
+
+ADDR_CLASS_ATTR_ADD(wifi);
+ADDR_CLASS_ATTR_ADD(bt);
+ADDR_CLASS_ATTR_ADD(eth);
+
+static struct attribute *addr_class_attrs[] = {
+	&class_attr_summary.attr,
+	&class_attr_addr_wifi.attr,
+	&class_attr_addr_bt.attr,
+	&class_attr_addr_eth.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(addr_class);
+
+static struct class addr_class = {
+	.name = "addr_mgt",
+	.owner = THIS_MODULE,
+	.class_groups = addr_class_groups,
+};
+
+static const struct of_device_id addr_mgt_ids[] = {
+	{ .compatible = "allwinner,sunxi-addr_mgt" },
+	{ /* Sentinel */ }
+};
+
+static int addr_mgt_probe(struct platform_device *pdev)
+{
+	int status;
+
+	ADDR_MGT_DBG("module version: %s", MODULE_CUR_VERSION);
+	status = class_register(&addr_class);
+	if (status < 0) {
+		ADDR_MGT_ERR("class register error, status: %d.", status);
+		return -1;
+	}
+
+	if (addr_init(pdev)) {
+		ADDR_MGT_ERR("failed to init addr.");
+		class_unregister(&addr_class);
+		return -1;
+	}
+	ADDR_MGT_DBG("success.");
+	return 0;
+}
+
+static int addr_mgt_remove(struct platform_device *pdev)
+{
+	class_unregister(&addr_class);
+	return 0;
+}
+
+static struct platform_driver addr_mgt_driver = {
+	.probe  = addr_mgt_probe,
+	.remove = addr_mgt_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "sunxi-addr-mgt",
+		.of_match_table = addr_mgt_ids,
+	},
+};
+
+module_platform_driver_probe(addr_mgt_driver, addr_mgt_probe);
+
+MODULE_AUTHOR("Allwinnertech");
+MODULE_DESCRIPTION("Network MAC Addess Manager");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/sunxi-bootevent/Kconfig b/drivers/misc/sunxi-bootevent/Kconfig
new file mode 100644
index 000000000..5ff07f2aa
--- /dev/null
+++ b/drivers/misc/sunxi-bootevent/Kconfig
@@ -0,0 +1,10 @@
+#
+# sunxi bootevent debugger driver.
+#
+config SUNXI_BOOTEVENT
+  tristate "Enable sunxi bootevent debugger tool"
+  default n
+  help
+    SUNXI_BOOTEVENT is used to debug bootting time,If you are not sure
+	about whether to enable it or not, please set n.
+
diff --git a/drivers/misc/sunxi-bootevent/Makefile b/drivers/misc/sunxi-bootevent/Makefile
new file mode 100644
index 000000000..0a2846948
--- /dev/null
+++ b/drivers/misc/sunxi-bootevent/Makefile
@@ -0,0 +1,6 @@
+
+#
+# Makefile for sunxi bootevent drivers
+#
+
+obj-$(CONFIG_SUNXI_BOOTEVENT)   += bootevent.o
diff --git a/drivers/misc/sunxi-bootevent/bootevent.c b/drivers/misc/sunxi-bootevent/bootevent.c
new file mode 100644
index 000000000..b3b95541f
--- /dev/null
+++ b/drivers/misc/sunxi-bootevent/bootevent.c
@@ -0,0 +1,316 @@
+/*
+ * Copyright(c) 2017-2018 Allwinnertech Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/kallsyms.h>
+#include <linux/utsname.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sched/clock.h>
+#include <linux/uaccess.h>
+#include <linux/seq_file.h>
+
+#define BOOT_STR_SIZE 256
+#define BUF_COUNT 12
+#define LOGS_PER_BUF 80
+#define TRACK_TASK_COMM
+#define MSG_SIZE 128
+
+#define SEQ_printf(m, x...)	    \
+	do {			    \
+		if (m)		    \
+			seq_printf(m, x);	\
+		else		    \
+			pr_err(x);	    \
+	} while (0)
+
+
+struct log_t {
+	char *comm_event;
+#ifdef TRACK_TASK_COMM
+	pid_t pid;
+#endif
+	u64 timestamp;
+};
+
+static struct log_t *bootevent[BUF_COUNT];
+static unsigned long log_count;
+static bool bootevent_enabled;
+static u64 timestamp_on, timestamp_off;
+
+static int bootprof_uboot_t, bootprof_boot0_t;
+core_param(boot0_time, bootprof_boot0_t, int, 0644);
+core_param(uboot_time, bootprof_uboot_t, int, 0644);
+
+static DEFINE_MUTEX(bootevent_lock);
+
+long long nsec_high(unsigned long long nsec)
+{
+	if ((long long)nsec < 0) {
+		nsec = -nsec;
+		do_div(nsec, 1000000);
+		return -nsec;
+	}
+	do_div(nsec, 1000000);
+
+	return nsec;
+}
+
+unsigned long nsec_low(unsigned long long nsec)
+{
+	if ((long long)nsec < 0)
+		nsec = -nsec;
+
+	return do_div(nsec, 1000000);
+}
+
+void log_boot(char *str)
+{
+	unsigned long long ts;
+	struct log_t *p = NULL;
+	size_t n = strlen(str) + 1;
+
+	if (!bootevent_enabled)
+		return;
+	ts = sched_clock();
+
+	mutex_lock(&bootevent_lock);
+	if (log_count >= (LOGS_PER_BUF * BUF_COUNT)) {
+		pr_err("[BOOTEVENT] not enuough bootevent buffer\n");
+		goto out;
+	} else if (log_count && !(log_count % LOGS_PER_BUF)) {
+		bootevent[log_count / LOGS_PER_BUF] =
+			kzalloc(sizeof(struct log_t) * LOGS_PER_BUF,
+				GFP_ATOMIC | __GFP_NORETRY | __GFP_NOWARN);
+	}
+	if (!bootevent[log_count / LOGS_PER_BUF]) {
+		pr_err("no memory for bootevent\n");
+		goto out;
+	}
+	p = &bootevent[log_count / LOGS_PER_BUF][log_count % LOGS_PER_BUF];
+
+	p->timestamp = ts;
+#ifdef TRACK_TASK_COMM
+	p->pid = current->pid;
+	n += TASK_COMM_LEN;
+#endif
+	p->comm_event = kzalloc(n, GFP_ATOMIC | __GFP_NORETRY |
+			  __GFP_NOWARN);
+	if (!p->comm_event) {
+		bootevent_enabled = false;
+		goto out;
+	}
+#ifdef TRACK_TASK_COMM
+	memcpy(p->comm_event, current->comm, TASK_COMM_LEN);
+	memcpy(p->comm_event + TASK_COMM_LEN, str, n - TASK_COMM_LEN);
+#else
+	memcpy(p->comm_event, str, n);
+#endif
+	log_count++;
+out:
+	mutex_unlock(&bootevent_lock);
+}
+
+
+void bootevent_initcall(initcall_t fn, unsigned long long ts)
+{
+#define INITCALL_THRESHOLD 15000000
+	/* log more than 15ms initcalls */
+	unsigned long msec_rem;
+	char msgbuf[MSG_SIZE];
+
+	if (ts > INITCALL_THRESHOLD) {
+		msec_rem = do_div(ts, NSEC_PER_MSEC);
+		snprintf(msgbuf, MSG_SIZE, "initcall: %pf %5llu.%06lums",
+			 fn, ts, msec_rem);
+		log_boot(msgbuf);
+	}
+}
+
+void bootevent_probe(unsigned long long ts, struct device *dev,
+			   struct device_driver *drv, unsigned long probe)
+{
+#define PROBE_THRESHOLD 15000000
+	/* log more than 15ms probes*/
+	unsigned long msec_rem;
+	char msgbuf[MSG_SIZE];
+	int pos = 0;
+
+	if (ts <= PROBE_THRESHOLD)
+		return;
+	msec_rem = do_div(ts, NSEC_PER_MSEC);
+
+	pos += snprintf(msgbuf, MSG_SIZE, "probe: probe=%pf", (void *)probe);
+	if (drv)
+		pos += snprintf(msgbuf + pos, MSG_SIZE - pos, " drv=%s(%p)",
+				drv->name ? drv->name : "",
+				(void *)drv);
+
+	if (dev && dev->init_name)
+		pos += snprintf(msgbuf + pos, MSG_SIZE - pos, " dev=%s(%p)",
+				dev->init_name, (void *)dev);
+
+	pos += snprintf(msgbuf + pos, MSG_SIZE - pos, " %5llu.%06lums",
+			ts, msec_rem);
+
+	log_boot(msgbuf);
+}
+
+void
+bootevent_pdev_register(unsigned long long ts, struct platform_device *pdev)
+{
+#define PROBE_THRESHOLD 15000000
+	/* log more than 15ms probes*/
+	unsigned long msec_rem;
+	char msgbuf[MSG_SIZE];
+
+	if (ts <= PROBE_THRESHOLD || !pdev)
+		return;
+	msec_rem = do_div(ts, NSEC_PER_MSEC);
+	snprintf(msgbuf, MSG_SIZE, "probe: pdev=%s(%p) %5llu.%06lums",
+		 pdev->name, (void *)pdev, ts, msec_rem);
+
+	log_boot(msgbuf);
+}
+
+static void sunxi_bootevent_switch(int on)
+{
+	mutex_lock(&bootevent_lock);
+	if (bootevent_enabled ^ on) {
+		unsigned long long ts = sched_clock();
+
+		pr_err("BOOTEVENT:%10Ld.%06ld: %s\n",
+		       nsec_high(ts), nsec_low(ts), on ? "ON" : "OFF");
+
+		if (on) {
+			bootevent_enabled = 1;
+			timestamp_on = ts;
+		} else {
+			/* boot up complete */
+			bootevent_enabled = 0;
+			timestamp_off = ts;
+		}
+	}
+	mutex_unlock(&bootevent_lock);
+}
+
+static ssize_t
+sunxi_bootevent_write(struct file *filp, const char *ubuf,
+						size_t cnt, loff_t *data)
+{
+	char buf[BOOT_STR_SIZE];
+	size_t copy_size = cnt;
+
+	if (cnt >= sizeof(buf))
+		copy_size = BOOT_STR_SIZE - 1;
+
+	if (copy_from_user(&buf, ubuf, copy_size))
+		return -EFAULT;
+
+	if (cnt == 1 && buf[0] == '1') {
+		sunxi_bootevent_switch(1);
+		return 1;
+	} else if (cnt == 1 && buf[0] == '0') {
+		sunxi_bootevent_switch(0);
+		return 1;
+	}
+
+	buf[copy_size] = 0;
+	log_boot(buf);
+
+	return cnt;
+
+}
+
+static int sunxi_bootevent_show(struct seq_file *m, void *v)
+{
+	int i;
+	struct log_t *p;
+
+	SEQ_printf(m, "----------------------------------------\n");
+	SEQ_printf(m, "%d BOOTEVENT (unit:msec)\n", bootevent_enabled);
+	SEQ_printf(m, "----------------------------------------\n");
+
+	SEQ_printf(m, "%10s        : %d ms\n", "boot0", bootprof_boot0_t);
+	SEQ_printf(m, "%10s        : %d ms\n", "uboot", bootprof_uboot_t);
+	SEQ_printf(m, "----------------------------------------\n");
+
+	SEQ_printf(m, "%10Ld.%06ld : ON\n",
+		   nsec_high(timestamp_on), nsec_low(timestamp_on));
+
+	for (i = 0; i < log_count; i++) {
+		p = &bootevent[i / LOGS_PER_BUF][i % LOGS_PER_BUF];
+		if (!p->comm_event)
+			continue;
+#ifdef TRACK_TASK_COMM
+#define FMT "%10Ld.%06ld :%5d-%-16s: %s\n"
+#else
+#define FMT "%10Ld.%06ld : %s\n"
+#endif
+		SEQ_printf(m, FMT, nsec_high(p->timestamp),
+			   nsec_low(p->timestamp),
+#ifdef TRACK_TASK_COMM
+			   p->pid, p->comm_event, p->comm_event + TASK_COMM_LEN
+#else
+			   p->comm_event
+#endif
+			   );
+	}
+
+	SEQ_printf(m, "%10Ld.%06ld : OFF\n",
+		   nsec_high(timestamp_off), nsec_low(timestamp_off));
+	SEQ_printf(m, "----------------------------------------\n");
+	return 0;
+}
+
+static int sunxi_bootevent_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_bootevent_show, inode->i_private);
+}
+
+static const struct file_operations sunxi_bootevent_fops = {
+	.open    = sunxi_bootevent_open,
+	.write   = sunxi_bootevent_write,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+static int __init init_boot_event(void)
+{
+	struct proc_dir_entry *pe;
+
+	memset(bootevent, 0, sizeof(struct log_t *) * BUF_COUNT);
+	bootevent[0] = kzalloc(sizeof(struct log_t) * LOGS_PER_BUF,
+			      GFP_ATOMIC | __GFP_NORETRY | __GFP_NOWARN);
+	if (!bootevent[0])
+		goto fail;
+	sunxi_bootevent_switch(1);
+
+	pe = proc_create("bootevent", 0664, NULL, &sunxi_bootevent_fops);
+	if (!pe)
+		return -ENOMEM;
+
+fail:
+	return 0;
+}
+
+early_initcall(init_boot_event);
+
+MODULE_DESCRIPTION("bootevent driver for debug bootting time");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/sunxi-bootevent/bootevent.h b/drivers/misc/sunxi-bootevent/bootevent.h
new file mode 100644
index 000000000..9e8fc4773
--- /dev/null
+++ b/drivers/misc/sunxi-bootevent/bootevent.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright(c) 2017-2018 Allwinnertech Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef _BOOTEVENT_H_
+#define _BOOTEVENT_H_
+#ifdef CONFIG_SCHEDSTATS
+extern void log_boot(char *str);
+#else
+#define log_boot(str)
+#endif
+
+#include <linux/sched.h>
+#ifndef TIME_LOG_START
+#define TIME_LOG_START() \
+	({ts = sched_clock(); })
+#endif
+
+#ifndef TIME_LOG_END
+#define TIME_LOG_END() \
+	({ts = sched_clock() - ts; })
+#endif
+
+#include <linux/platform_device.h>
+#include <linux/sched/clock.h>
+void bootevent_initcall(initcall_t fn, unsigned long long ts);
+void bootevent_probe(unsigned long long ts, struct device *dev,
+		    struct device_driver *drv, unsigned long probe);
+void bootevent_pdev_register(unsigned long long ts,
+			    struct platform_device *pdev);
+#endif
diff --git a/drivers/misc/sunxi-gorilla/Kconfig b/drivers/misc/sunxi-gorilla/Kconfig
new file mode 100644
index 000000000..1ab9175bd
--- /dev/null
+++ b/drivers/misc/sunxi-gorilla/Kconfig
@@ -0,0 +1,44 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+menu "sunxi Gorilla ESL platform"
+
+config SUNXI_GORILLA
+	bool "sunxi Gorilla ESL platform support"
+	default n
+	help
+	  sunxi Gorilla ESL platform support
+
+config GORILLA_MEMC
+	tristate "Gorilla memory controller driver"
+	default n
+	depends on SUNXI_GORILLA
+	help
+	  sunxi Gorilla memory controller driver
+
+config GORILLA_EXTRA_MEM
+	tristate "Gorilla extra memory driver"
+	default n
+	depends on SUNXI_GORILLA
+	select GORILLA_MEMC
+	help
+	  This driver maps physical memory to the kernel. In this way, the
+	  memory can be used as a normal storage media from either kernel or
+	  user space. In other words, you can read/write the memory just like
+	  reading/writing registers. It's useful when you want to access
+	  physical memory from user space, e.g. when testing an extra DDR.
+
+config GORILLA_NSI
+	tristate "Gorilla NSI driver"
+	default n
+	depends on SUNXI_GORILLA
+	help
+	  sunxi Gorilla NSI driver
+
+config GORILLA_DE_TCON
+	tristate "Gorilla DE/TCON driver"
+	default n
+	depends on SUNXI_GORILLA
+	help
+	  sunxi Gorilla DE/TCON driver
+
+endmenu
diff --git a/drivers/misc/sunxi-gorilla/Makefile b/drivers/misc/sunxi-gorilla/Makefile
new file mode 100644
index 000000000..74b29ed1e
--- /dev/null
+++ b/drivers/misc/sunxi-gorilla/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_GORILLA_MEMC)      += gorilla-memc.o
+obj-$(CONFIG_GORILLA_EXTRA_MEM) += gorilla-extra-mem.o
+obj-$(CONFIG_GORILLA_NSI)       += gorilla-nsi.o
+obj-$(CONFIG_GORILLA_DE_TCON)   += gorilla-de-tcon.o
\ No newline at end of file
diff --git a/drivers/misc/sunxi-gorilla/gorilla-common.h b/drivers/misc/sunxi-gorilla/gorilla-common.h
new file mode 100644
index 000000000..138ef1dea
--- /dev/null
+++ b/drivers/misc/sunxi-gorilla/gorilla-common.h
@@ -0,0 +1,69 @@
+/*
+ * sunxi gorilla common functions
+ *
+ * Copyright (c) 2020, Martin <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+
+static noinline int write_paddr(struct device *dev, u64 paddr, u32 val)
+{
+	void __iomem *vaddr;
+
+	dev_dbg(dev, "%s(): BEGIN: paddr=0x%llx, val=0x%08x\n", __func__, paddr, val);
+	dev_dbg(dev, "%s(): ioremap()\n", __func__);
+	vaddr = ioremap(paddr, 4);
+	if (IS_ERR_OR_NULL(vaddr)) {
+		dev_dbg(dev, "%s(): ioremap() failed: paddr=0x%llx\n", __func__, paddr);
+		return 0;
+	}
+	dev_dbg(dev, "%s(): writel()\n", __func__);
+	writel(val, vaddr);
+	dev_dbg(dev, "%s(): iounmap()\n", __func__);
+	iounmap(vaddr);
+	dev_dbg(dev, "%s(): END\n", __func__);
+	return 0;
+}
+
+static noinline u32 __maybe_unused read_paddr(struct device *dev, u64 paddr)
+{
+	u32 val;
+	void __iomem *vaddr;
+
+	dev_dbg(dev, "%s(): BEGIN: paddr=0x%llx\n", __func__, paddr);
+	dev_dbg(dev, "%s(): ioremap()\n", __func__);
+	vaddr = ioremap(paddr, 4);
+	if (IS_ERR_OR_NULL(vaddr)) {
+		dev_dbg(dev, "%s(): ioremap() failed: paddr=0x%llx\n", __func__, paddr);
+		return 0;
+	}
+	dev_dbg(dev, "%s(): readl()\n", __func__);
+	val = readl(vaddr);
+	dev_dbg(dev, "%s(): iounmap()\n", __func__);
+	iounmap(vaddr);
+	dev_dbg(dev, "%s(): END:   paddr=0x%llx, val=0x%08x\n", __func__, paddr, val);
+	return val;
+}
+
+#define write_reg_by_address(paddr, val)	write_paddr(chip->dev, paddr, val)
+#define read_reg_by_address(paddr)              read_paddr(chip->dev, paddr)
diff --git a/drivers/misc/sunxi-gorilla/gorilla-de-tcon.c b/drivers/misc/sunxi-gorilla/gorilla-de-tcon.c
new file mode 100644
index 000000000..75243b9bd
--- /dev/null
+++ b/drivers/misc/sunxi-gorilla/gorilla-de-tcon.c
@@ -0,0 +1,1109 @@
+/*
+ * sunxi gorilla DE/TCON driver (For AW1855)
+ *
+ * Copyright (c) 2020, Martin <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define DEBUG	 /* Enable dev_dbg */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include "gorilla-common.h"
+
+/* Use TCON as hardware interrupt source. See AW1855_TCON_LCD_Spec_V0.1 */
+#define LCD_GINT0_REG				(0x4)    /* LCD global interrupt register 0 */
+#define LCD_VB_INT_EN				BIT(31)  /* Enable the VB interrupt */
+#define LCD_VB_INT_FLAG				BIT(15)  /* Asserted during vertical no-display period every frame. Write 0 to clear it */
+
+struct gorilla_de_tcon {
+	struct device *dev;
+	void __iomem *base;
+	int irq;
+};
+
+static int de_tcon_init(struct gorilla_de_tcon *chip)
+{
+	// config DE
+	// DE inner
+	int data = 0x5;
+	write_reg_by_address(0x06000000, data);
+	write_reg_by_address(0x06000004, data);
+	write_reg_by_address(0x06000008, data);
+	//init_mem(sdram06.hex);// baseAddr, hexFileName, wrapSize, wrapEnable
+	write_reg_by_address(0x06010000, 0x20000000); // Clock gate of scaler and DMA module
+
+	write_reg_by_address(0x06100000, 0x00000000);
+	write_reg_by_address(0x06101000, 0x00000f00);
+	write_reg_by_address(0x06101004, 0x00000000);
+	write_reg_by_address(0x06101008, 0x031e04ff);
+	write_reg_by_address(0x0610100c, 0x00000000);
+	write_reg_by_address(0x06101010, 0x00000000);
+	write_reg_by_address(0x06101014, 0x00000000);
+	write_reg_by_address(0x06101018, 0x031504ff);
+	write_reg_by_address(0x0610101c, 0x00000000);
+	write_reg_by_address(0x06101020, 0x00000000);
+	write_reg_by_address(0x06101024, 0x00000000);
+	write_reg_by_address(0x06101028, 0x031f04ff);
+	write_reg_by_address(0x0610102c, 0x00000000);
+	write_reg_by_address(0x06101030, 0x00000000);
+	write_reg_by_address(0x06101034, 0x00000000);
+	write_reg_by_address(0x06101038, 0x031f04ff);
+	write_reg_by_address(0x0610103c, 0x00000000);
+	write_reg_by_address(0x06101040, 0x00000000);
+	write_reg_by_address(0x06101044, 0x00000000);
+	write_reg_by_address(0x06101048, 0x00000000);
+	write_reg_by_address(0x0610104c, 0x00000000);
+	write_reg_by_address(0x06101050, 0x00000000);
+	write_reg_by_address(0x06101054, 0x00000000);
+	write_reg_by_address(0x06101058, 0x00000000);
+	write_reg_by_address(0x0610105c, 0x00000000);
+	write_reg_by_address(0x06101060, 0x00000000);
+	write_reg_by_address(0x06101064, 0x00000000);
+	write_reg_by_address(0x06101068, 0x00000000);
+	write_reg_by_address(0x0610106c, 0x00000000);
+	write_reg_by_address(0x06101070, 0x00000000);
+	write_reg_by_address(0x06101074, 0x00000000);
+	write_reg_by_address(0x06101078, 0x00000000);
+	write_reg_by_address(0x0610107c, 0x00000000);
+	write_reg_by_address(0x06101080, 0x00043210);
+	write_reg_by_address(0x06101084, 0x00000000);
+	write_reg_by_address(0x06101088, 0xff123456);
+	write_reg_by_address(0x0610108c, 0x031f04ff);
+	write_reg_by_address(0x06101090, 0x03010301);
+	write_reg_by_address(0x06101094, 0x03010301);
+	write_reg_by_address(0x06101098, 0x03010301);
+	write_reg_by_address(0x0610109c, 0x03010301);
+	write_reg_by_address(0x061010a0, 0x00000000);
+	write_reg_by_address(0x061010a4, 0x00000000);
+	write_reg_by_address(0x061010a8, 0x00000000);
+	write_reg_by_address(0x061010ac, 0x00000000);
+	write_reg_by_address(0x061010b0, 0x00000000);
+	write_reg_by_address(0x061010b4, 0x00000000);
+	write_reg_by_address(0x061010b8, 0x00000000);
+	write_reg_by_address(0x061010bc, 0x00000000);
+	write_reg_by_address(0x061010c0, 0x00000000);
+	write_reg_by_address(0x061010c4, 0x00000000);
+	write_reg_by_address(0x061010c8, 0x00000000);
+	write_reg_by_address(0x061010cc, 0x00000000);
+	write_reg_by_address(0x061010d0, 0x00000000);
+	write_reg_by_address(0x061010d4, 0x00000000);
+	write_reg_by_address(0x061010d8, 0x00000000);
+	write_reg_by_address(0x061010dc, 0x00000000);
+	write_reg_by_address(0x061010e0, 0x00000000);
+	write_reg_by_address(0x061010e4, 0x00000000);
+	write_reg_by_address(0x061010e8, 0x00000000);
+	write_reg_by_address(0x061010ec, 0x00000000);
+	write_reg_by_address(0x061010f0, 0x00000000);
+	write_reg_by_address(0x061010f4, 0x00000000);
+	write_reg_by_address(0x061010f8, 0x00000000);
+	write_reg_by_address(0x061010fc, 0x00000000);
+	write_reg_by_address(0x06102000, 0x00008001);
+	write_reg_by_address(0x06102004, 0x031f04ff);
+	write_reg_by_address(0x06102008, 0x00000000);
+	write_reg_by_address(0x0610200c, 0x00001400);
+	write_reg_by_address(0x06102010, 0x00000500);
+	write_reg_by_address(0x06102014, 0x00000500);
+	write_reg_by_address(0x06102018, 0x64000000);
+	write_reg_by_address(0x0610201c, 0x00000000);
+	write_reg_by_address(0x06102020, 0x00000000);
+	write_reg_by_address(0x06102024, 0x00000000);
+	write_reg_by_address(0x06102028, 0x00000000);
+	write_reg_by_address(0x0610202c, 0x00000000);
+	write_reg_by_address(0x06102030, 0x00008001);
+	write_reg_by_address(0x06102034, 0x00c7018f);
+	write_reg_by_address(0x06102038, 0x0006000c);
+	write_reg_by_address(0x0610203c, 0x00000780);
+	write_reg_by_address(0x06102040, 0x000001e0);
+	write_reg_by_address(0x06102044, 0x000001e0);
+	write_reg_by_address(0x06102048, 0x64803c18);
+	write_reg_by_address(0x0610204c, 0x00000000);
+	write_reg_by_address(0x06102050, 0x00000000);
+	write_reg_by_address(0x06102054, 0x00000000);
+	write_reg_by_address(0x06102058, 0x00000000);
+	write_reg_by_address(0x0610205c, 0x00000000);
+	write_reg_by_address(0x06102060, 0x00000000);
+	write_reg_by_address(0x06102064, 0x00000000);
+	write_reg_by_address(0x06102068, 0x00000000);
+	write_reg_by_address(0x0610206c, 0x00000000);
+	write_reg_by_address(0x06102070, 0x00000000);
+	write_reg_by_address(0x06102074, 0x00000000);
+	write_reg_by_address(0x06102078, 0x00000000);
+	write_reg_by_address(0x0610207c, 0x00000000);
+	write_reg_by_address(0x06102080, 0x00000000);
+	write_reg_by_address(0x06102084, 0x00000000);
+	write_reg_by_address(0x06102088, 0x00000000);
+	write_reg_by_address(0x0610208c, 0x00000000);
+	write_reg_by_address(0x06102090, 0x00000000);
+	write_reg_by_address(0x06102094, 0x00000000);
+	write_reg_by_address(0x06102098, 0x00000000);
+	write_reg_by_address(0x0610209c, 0x00000000);
+	write_reg_by_address(0x061020a0, 0x00000000);
+	write_reg_by_address(0x061020a4, 0x00000000);
+	write_reg_by_address(0x061020a8, 0x00000000);
+	write_reg_by_address(0x061020ac, 0x00000000);
+	write_reg_by_address(0x061020b0, 0x00000000);
+	write_reg_by_address(0x061020b4, 0x00000000);
+	write_reg_by_address(0x061020b8, 0x00000000);
+	write_reg_by_address(0x061020bc, 0x00000000);
+	write_reg_by_address(0x061020c0, 0x00000000);
+	write_reg_by_address(0x061020c4, 0x00000000);
+	write_reg_by_address(0x061020c8, 0x00000000);
+	write_reg_by_address(0x061020cc, 0x00000000);
+	write_reg_by_address(0x061020d0, 0x00000000);
+	write_reg_by_address(0x061020d4, 0x00000000);
+	write_reg_by_address(0x061020d8, 0x00000000);
+	write_reg_by_address(0x061020dc, 0x00000000);
+	write_reg_by_address(0x061020e0, 0x00000000);
+	write_reg_by_address(0x061020e4, 0x00000000);
+	write_reg_by_address(0x061020e8, 0x031f04ff);
+	write_reg_by_address(0x061020ec, 0x00000000);
+	write_reg_by_address(0x061020f0, 0x00000000);
+	write_reg_by_address(0x061020f4, 0x00000000);
+	write_reg_by_address(0x061020f8, 0x00000000);
+	write_reg_by_address(0x061020fc, 0x00000000);
+	write_reg_by_address(0x06103000, 0x9c008003);
+	write_reg_by_address(0x06103004, 0x031f04ff);
+	write_reg_by_address(0x06103008, 0x00000000);
+	write_reg_by_address(0x0610300c, 0x00001400);
+	write_reg_by_address(0x06103010, 0x00000500);
+	write_reg_by_address(0x06103014, 0x00000500);
+	write_reg_by_address(0x06103018, 0x65000000);
+	write_reg_by_address(0x0610301c, 0x00000000);
+	write_reg_by_address(0x06103020, 0x00000000);
+	write_reg_by_address(0x06103024, 0x00000000);
+	write_reg_by_address(0x06103028, 0x00000000);
+	write_reg_by_address(0x0610302c, 0x00000000);
+	write_reg_by_address(0x06103030, 0x9c008003);
+	write_reg_by_address(0x06103034, 0x00c7018f);
+	write_reg_by_address(0x06103038, 0x0006000c);
+	write_reg_by_address(0x0610303c, 0x00000780);
+	write_reg_by_address(0x06103040, 0x000001e0);
+	write_reg_by_address(0x06103044, 0x000001e0);
+	write_reg_by_address(0x06103048, 0x65803c18);
+	write_reg_by_address(0x0610304c, 0x00000000);
+	write_reg_by_address(0x06103050, 0x00000000);
+	write_reg_by_address(0x06103054, 0x00000000);
+	write_reg_by_address(0x06103058, 0x00000000);
+	write_reg_by_address(0x0610305c, 0x00000000);
+	write_reg_by_address(0x06103060, 0x00000000);
+	write_reg_by_address(0x06103064, 0x00000000);
+	write_reg_by_address(0x06103068, 0x00000000);
+	write_reg_by_address(0x0610306c, 0x00000000);
+	write_reg_by_address(0x06103070, 0x00000000);
+	write_reg_by_address(0x06103074, 0x00000000);
+	write_reg_by_address(0x06103078, 0x00000000);
+	write_reg_by_address(0x0610307c, 0x00000000);
+	write_reg_by_address(0x06103080, 0x00000000);
+	write_reg_by_address(0x06103084, 0x00000000);
+	write_reg_by_address(0x06103088, 0x00000000);
+	write_reg_by_address(0x0610308c, 0x00000000);
+	write_reg_by_address(0x06103090, 0x00000000);
+	write_reg_by_address(0x06103094, 0x00000000);
+	write_reg_by_address(0x06103098, 0x00000000);
+	write_reg_by_address(0x0610309c, 0x00000000);
+	write_reg_by_address(0x061030a0, 0x00000000);
+	write_reg_by_address(0x061030a4, 0x00000000);
+	write_reg_by_address(0x061030a8, 0x00000000);
+	write_reg_by_address(0x061030ac, 0x00000000);
+	write_reg_by_address(0x061030b0, 0x00000000);
+	write_reg_by_address(0x061030b4, 0x00000000);
+	write_reg_by_address(0x061030b8, 0x00000000);
+	write_reg_by_address(0x061030bc, 0x00000000);
+	write_reg_by_address(0x061030c0, 0x00000000);
+	write_reg_by_address(0x061030c4, 0x00000000);
+	write_reg_by_address(0x061030c8, 0x00000000);
+	write_reg_by_address(0x061030cc, 0x00000000);
+	write_reg_by_address(0x061030d0, 0x00000000);
+	write_reg_by_address(0x061030d4, 0x00000000);
+	write_reg_by_address(0x061030d8, 0x00000000);
+	write_reg_by_address(0x061030dc, 0x00000000);
+	write_reg_by_address(0x061030e0, 0x00000000);
+	write_reg_by_address(0x061030e4, 0x00000000);
+	write_reg_by_address(0x061030e8, 0x031f04ff);
+	write_reg_by_address(0x061030ec, 0x00000000);
+	write_reg_by_address(0x061030f0, 0x00000000);
+	write_reg_by_address(0x061030f4, 0x00000000);
+	write_reg_by_address(0x061030f8, 0x00000000);
+	write_reg_by_address(0x061030fc, 0x00000000);
+	write_reg_by_address(0x06104000, 0x98000003);
+	write_reg_by_address(0x06104004, 0x031f04fe);
+	write_reg_by_address(0x06104008, 0x00000000);
+	write_reg_by_address(0x0610400c, 0x00001400);
+	write_reg_by_address(0x06104010, 0x66000000);
+	write_reg_by_address(0x06104014, 0x00000000);
+	write_reg_by_address(0x06104018, 0x00000000);
+	write_reg_by_address(0x0610401c, 0x00000000);
+	write_reg_by_address(0x06104020, 0x00000000);
+	write_reg_by_address(0x06104024, 0x00000000);
+	write_reg_by_address(0x06104028, 0x00000000);
+	write_reg_by_address(0x0610402c, 0x00000000);
+	write_reg_by_address(0x06104030, 0x00000000);
+	write_reg_by_address(0x06104034, 0x00000000);
+	write_reg_by_address(0x06104038, 0x00000000);
+	write_reg_by_address(0x0610403c, 0x00000000);
+	write_reg_by_address(0x06104040, 0x00000000);
+	write_reg_by_address(0x06104044, 0x00000000);
+	write_reg_by_address(0x06104048, 0x00000000);
+	write_reg_by_address(0x0610404c, 0x00000000);
+	write_reg_by_address(0x06104050, 0x00000000);
+	write_reg_by_address(0x06104054, 0x00000000);
+	write_reg_by_address(0x06104058, 0x00000000);
+	write_reg_by_address(0x0610405c, 0x00000000);
+	write_reg_by_address(0x06104060, 0x00000000);
+	write_reg_by_address(0x06104064, 0x00000000);
+	write_reg_by_address(0x06104068, 0x00000000);
+	write_reg_by_address(0x0610406c, 0x00000000);
+	write_reg_by_address(0x06104070, 0x00000000);
+	write_reg_by_address(0x06104074, 0x00000000);
+	write_reg_by_address(0x06104078, 0x00000000);
+	write_reg_by_address(0x0610407c, 0x00000000);
+	write_reg_by_address(0x06104080, 0x00000000);
+	write_reg_by_address(0x06104084, 0x00000000);
+	write_reg_by_address(0x06104088, 0x031f04ff);
+	write_reg_by_address(0x0610408c, 0x00000000);
+	write_reg_by_address(0x06104090, 0x00000000);
+	write_reg_by_address(0x06104094, 0x00000000);
+	write_reg_by_address(0x06104098, 0x00000000);
+	write_reg_by_address(0x0610409c, 0x00000000);
+	write_reg_by_address(0x061040a0, 0x00000000);
+	write_reg_by_address(0x061040a4, 0x00000000);
+	write_reg_by_address(0x061040a8, 0x00000000);
+	write_reg_by_address(0x061040ac, 0x00000000);
+	write_reg_by_address(0x061040b0, 0x00000000);
+	write_reg_by_address(0x061040b4, 0x00000000);
+	write_reg_by_address(0x061040b8, 0x00000000);
+	write_reg_by_address(0x061040bc, 0x00000000);
+	write_reg_by_address(0x061040c0, 0x00000000);
+	write_reg_by_address(0x061040c4, 0x00000000);
+	write_reg_by_address(0x061040c8, 0x00000000);
+	write_reg_by_address(0x061040cc, 0x00000000);
+	write_reg_by_address(0x061040d0, 0x00000000);
+	write_reg_by_address(0x061040d4, 0x00000000);
+	write_reg_by_address(0x061040d8, 0x00000000);
+	write_reg_by_address(0x061040dc, 0x00000000);
+	write_reg_by_address(0x061040e0, 0x00000000);
+	write_reg_by_address(0x061040e4, 0x00000000);
+	write_reg_by_address(0x061040e8, 0x00000000);
+	write_reg_by_address(0x061040ec, 0x00000000);
+	write_reg_by_address(0x061040f0, 0x00000000);
+	write_reg_by_address(0x061040f4, 0x00000000);
+	write_reg_by_address(0x061040f8, 0x00000000);
+	write_reg_by_address(0x061040fc, 0x00000000);
+	write_reg_by_address(0x06105000, 0x98000003);
+	write_reg_by_address(0x06105004, 0x031f04fe);
+	write_reg_by_address(0x06105008, 0x00000000);
+	write_reg_by_address(0x0610500c, 0x00001400);
+	write_reg_by_address(0x06105010, 0x67000000);
+	write_reg_by_address(0x06105014, 0x00000000);
+	write_reg_by_address(0x06105018, 0x00000000);
+	write_reg_by_address(0x0610501c, 0x00000000);
+	write_reg_by_address(0x06105020, 0x00000000);
+	write_reg_by_address(0x06105024, 0x00000000);
+	write_reg_by_address(0x06105028, 0x00000000);
+	write_reg_by_address(0x0610502c, 0x00000000);
+	write_reg_by_address(0x06105030, 0x00000000);
+	write_reg_by_address(0x06105034, 0x00000000);
+	write_reg_by_address(0x06105038, 0x00000000);
+	write_reg_by_address(0x0610503c, 0x00000000);
+	write_reg_by_address(0x06105040, 0x00000000);
+	write_reg_by_address(0x06105044, 0x00000000);
+	write_reg_by_address(0x06105048, 0x00000000);
+	write_reg_by_address(0x0610504c, 0x00000000);
+	write_reg_by_address(0x06105050, 0x00000000);
+	write_reg_by_address(0x06105054, 0x00000000);
+	write_reg_by_address(0x06105058, 0x00000000);
+	write_reg_by_address(0x0610505c, 0x00000000);
+	write_reg_by_address(0x06105060, 0x00000000);
+	write_reg_by_address(0x06105064, 0x00000000);
+	write_reg_by_address(0x06105068, 0x00000000);
+	write_reg_by_address(0x0610506c, 0x00000000);
+	write_reg_by_address(0x06105070, 0x00000000);
+	write_reg_by_address(0x06105074, 0x00000000);
+	write_reg_by_address(0x06105078, 0x00000000);
+	write_reg_by_address(0x0610507c, 0x00000000);
+	write_reg_by_address(0x06105080, 0x00000000);
+	write_reg_by_address(0x06105084, 0x00000000);
+	write_reg_by_address(0x06105088, 0x031f04fe);
+	write_reg_by_address(0x0610508c, 0x00000000);
+	write_reg_by_address(0x06105090, 0x00000000);
+	write_reg_by_address(0x06105094, 0x00000000);
+	write_reg_by_address(0x06105098, 0x00000000);
+	write_reg_by_address(0x0610509c, 0x00000000);
+	write_reg_by_address(0x061050a0, 0x00000000);
+	write_reg_by_address(0x061050a4, 0x00000000);
+	write_reg_by_address(0x061050a8, 0x00000000);
+	write_reg_by_address(0x061050ac, 0x00000000);
+	write_reg_by_address(0x061050b0, 0x00000000);
+	write_reg_by_address(0x061050b4, 0x00000000);
+	write_reg_by_address(0x061050b8, 0x00000000);
+	write_reg_by_address(0x061050bc, 0x00000000);
+	write_reg_by_address(0x061050c0, 0x00000000);
+	write_reg_by_address(0x061050c4, 0x00000000);
+	write_reg_by_address(0x061050c8, 0x00000000);
+	write_reg_by_address(0x061050cc, 0x00000000);
+	write_reg_by_address(0x061050d0, 0x00000000);
+	write_reg_by_address(0x061050d4, 0x00000000);
+	write_reg_by_address(0x061050d8, 0x00000000);
+	write_reg_by_address(0x061050dc, 0x00000000);
+	write_reg_by_address(0x061050e0, 0x00000000);
+	write_reg_by_address(0x061050e4, 0x00000000);
+	write_reg_by_address(0x061050e8, 0x00000000);
+	write_reg_by_address(0x061050ec, 0x00000000);
+	write_reg_by_address(0x061050f0, 0x00000000);
+	write_reg_by_address(0x061050f4, 0x00000000);
+	write_reg_by_address(0x061050f8, 0x00000000);
+	write_reg_by_address(0x061050fc, 0x00000000);
+	write_reg_by_address(0x06100004, 0x00000000);
+	write_reg_by_address(0x06100008, 0x00000001);
+	write_reg_by_address(0x0610000c, 0x031f04ff);
+	write_reg_by_address(0x06100000, 0x00000001);
+
+	//[SCALERVIDEO_0]
+	write_reg_by_address(0x0612000c, 0x00000000);
+	write_reg_by_address(0x06120040, 0x031e04ff);
+	write_reg_by_address(0x06120080, 0x031f04ff);
+	write_reg_by_address(0x06120088, 0x00100000);
+	write_reg_by_address(0x0612008c, 0x00100520);
+	write_reg_by_address(0x06120090, 0x00000000);
+	write_reg_by_address(0x06120098, 0x00000000);
+	write_reg_by_address(0x0612009c, 0x00000000);
+	write_reg_by_address(0x061200c0, 0x031f04ff);
+	write_reg_by_address(0x061200c8, 0x00100000);
+	write_reg_by_address(0x061200cc, 0x00100520);
+	write_reg_by_address(0x061200d0, 0x00000000);
+	write_reg_by_address(0x061200d8, 0x00000000);
+	write_reg_by_address(0x061200dc, 0x00000000);
+	write_reg_by_address(0x06120200, 0x40000000);
+	write_reg_by_address(0x06120204, 0x40fe0000);
+	write_reg_by_address(0x06120208, 0x3ffd0100);
+	write_reg_by_address(0x0612020c, 0x3efc0100);
+	write_reg_by_address(0x06120210, 0x3efb0100);
+	write_reg_by_address(0x06120214, 0x3dfa0200);
+	write_reg_by_address(0x06120218, 0x3cf90200);
+	write_reg_by_address(0x0612021c, 0x3bf80200);
+	write_reg_by_address(0x06120220, 0x39f70200);
+	write_reg_by_address(0x06120224, 0x37f70200);
+	write_reg_by_address(0x06120228, 0x35f70200);
+	write_reg_by_address(0x0612022c, 0x33f70200);
+	write_reg_by_address(0x06120230, 0x31f70200);
+	write_reg_by_address(0x06120234, 0x2ef70200);
+	write_reg_by_address(0x06120238, 0x2cf70200);
+	write_reg_by_address(0x0612023c, 0x2af70200);
+	write_reg_by_address(0x06120240, 0x27f70200);
+	write_reg_by_address(0x06120244, 0x24f80100);
+	write_reg_by_address(0x06120248, 0x22f80100);
+	write_reg_by_address(0x0612024c, 0x1ef90100);
+	write_reg_by_address(0x06120250, 0x1cf90100);
+	write_reg_by_address(0x06120254, 0x19fa0100);
+	write_reg_by_address(0x06120258, 0x17fa0100);
+	write_reg_by_address(0x0612025c, 0x14fb0100);
+	write_reg_by_address(0x06120260, 0x11fc0000);
+	write_reg_by_address(0x06120264, 0x0ffc0000);
+	write_reg_by_address(0x06120268, 0x0cfd0000);
+	write_reg_by_address(0x0612026c, 0x0afd0000);
+	write_reg_by_address(0x06120270, 0x08fe0000);
+	write_reg_by_address(0x06120274, 0x05ff0000);
+	write_reg_by_address(0x06120278, 0x03ff0000);
+	write_reg_by_address(0x0612027c, 0x02000000);
+	write_reg_by_address(0x06120300, 0x00000000);
+	write_reg_by_address(0x06120304, 0x00000002);
+	write_reg_by_address(0x06120308, 0x0000ff04);
+	write_reg_by_address(0x0612030c, 0x0000ff06);
+	write_reg_by_address(0x06120310, 0x0000fe08);
+	write_reg_by_address(0x06120314, 0x0000fd0a);
+	write_reg_by_address(0x06120318, 0x0000fd0c);
+	write_reg_by_address(0x0612031c, 0x0000fc0f);
+	write_reg_by_address(0x06120320, 0x0000fc12);
+	write_reg_by_address(0x06120324, 0x0001fb14);
+	write_reg_by_address(0x06120328, 0x0001fa17);
+	write_reg_by_address(0x0612032c, 0x0001fa19);
+	write_reg_by_address(0x06120330, 0x0001f91c);
+	write_reg_by_address(0x06120334, 0x0001f91f);
+	write_reg_by_address(0x06120338, 0x0001f822);
+	write_reg_by_address(0x0612033c, 0x0001f824);
+	write_reg_by_address(0x06120340, 0x0002f727);
+	write_reg_by_address(0x06120344, 0x0002f72a);
+	write_reg_by_address(0x06120348, 0x0002f72c);
+	write_reg_by_address(0x0612034c, 0x0002f72f);
+	write_reg_by_address(0x06120350, 0x0002f731);
+	write_reg_by_address(0x06120354, 0x0002f733);
+	write_reg_by_address(0x06120358, 0x0002f735);
+	write_reg_by_address(0x0612035c, 0x0002f737);
+	write_reg_by_address(0x06120360, 0x0002f73a);
+	write_reg_by_address(0x06120364, 0x0002f83b);
+	write_reg_by_address(0x06120368, 0x0002f93c);
+	write_reg_by_address(0x0612036c, 0x0002fa3d);
+	write_reg_by_address(0x06120370, 0x0001fb3e);
+	write_reg_by_address(0x06120374, 0x0001fc3f);
+	write_reg_by_address(0x06120378, 0x0001fd40);
+	write_reg_by_address(0x0612037c, 0x0000fe40);
+	write_reg_by_address(0x06120400, 0x00004000);
+	write_reg_by_address(0x06120404, 0x000140ff);
+	write_reg_by_address(0x06120408, 0x00033ffe);
+	write_reg_by_address(0x0612040c, 0x00043ffd);
+	write_reg_by_address(0x06120410, 0x00063efc);
+	write_reg_by_address(0x06120414, 0xff083dfc);
+	write_reg_by_address(0x06120418, 0x000a3bfb);
+	write_reg_by_address(0x0612041c, 0xff0d39fb);
+	write_reg_by_address(0x06120420, 0xff0f37fb);
+	write_reg_by_address(0x06120424, 0xff1136fa);
+	write_reg_by_address(0x06120428, 0xfe1433fb);
+	write_reg_by_address(0x0612042c, 0xfe1631fb);
+	write_reg_by_address(0x06120430, 0xfd192ffb);
+	write_reg_by_address(0x06120434, 0xfd1c2cfb);
+	write_reg_by_address(0x06120438, 0xfd1f29fb);
+	write_reg_by_address(0x0612043c, 0xfc2127fc);
+	write_reg_by_address(0x06120440, 0xfc2424fc);
+	write_reg_by_address(0x06120444, 0xfc2721fc);
+	write_reg_by_address(0x06120448, 0xfb291ffd);
+	write_reg_by_address(0x0612044c, 0xfb2c1cfd);
+	write_reg_by_address(0x06120450, 0xfb2f19fd);
+	write_reg_by_address(0x06120454, 0xfb3116fe);
+	write_reg_by_address(0x06120458, 0xfb3314fe);
+	write_reg_by_address(0x0612045c, 0xfa3611ff);
+	write_reg_by_address(0x06120460, 0xfb370fff);
+	write_reg_by_address(0x06120464, 0xfb390dff);
+	write_reg_by_address(0x06120468, 0xfb3b0a00);
+	write_reg_by_address(0x0612046c, 0xfc3d08ff);
+	write_reg_by_address(0x06120470, 0xfc3e0600);
+	write_reg_by_address(0x06120474, 0xfd3f0400);
+	write_reg_by_address(0x06120478, 0xfe3f0300);
+	write_reg_by_address(0x0612047c, 0xff400100);
+	write_reg_by_address(0x06120600, 0x40000000);
+	write_reg_by_address(0x06120604, 0x40fe0000);
+	write_reg_by_address(0x06120608, 0x3ffd0100);
+	write_reg_by_address(0x0612060c, 0x3efc0100);
+	write_reg_by_address(0x06120610, 0x3efb0100);
+	write_reg_by_address(0x06120614, 0x3dfa0200);
+	write_reg_by_address(0x06120618, 0x3cf90200);
+	write_reg_by_address(0x0612061c, 0x3bf80200);
+	write_reg_by_address(0x06120620, 0x39f70200);
+	write_reg_by_address(0x06120624, 0x37f70200);
+	write_reg_by_address(0x06120628, 0x35f70200);
+	write_reg_by_address(0x0612062c, 0x33f70200);
+	write_reg_by_address(0x06120630, 0x31f70200);
+	write_reg_by_address(0x06120634, 0x2ef70200);
+	write_reg_by_address(0x06120638, 0x2cf70200);
+	write_reg_by_address(0x0612063c, 0x2af70200);
+	write_reg_by_address(0x06120640, 0x27f70200);
+	write_reg_by_address(0x06120644, 0x24f80100);
+	write_reg_by_address(0x06120648, 0x22f80100);
+	write_reg_by_address(0x0612064c, 0x1ef90100);
+	write_reg_by_address(0x06120650, 0x1cf90100);
+	write_reg_by_address(0x06120654, 0x19fa0100);
+	write_reg_by_address(0x06120658, 0x17fa0100);
+	write_reg_by_address(0x0612065c, 0x14fb0100);
+	write_reg_by_address(0x06120660, 0x11fc0000);
+	write_reg_by_address(0x06120664, 0x0ffc0000);
+	write_reg_by_address(0x06120668, 0x0cfd0000);
+	write_reg_by_address(0x0612066c, 0x0afd0000);
+	write_reg_by_address(0x06120670, 0x08fe0000);
+	write_reg_by_address(0x06120674, 0x05ff0000);
+	write_reg_by_address(0x06120678, 0x03ff0000);
+	write_reg_by_address(0x0612067c, 0x02000000);
+	write_reg_by_address(0x06120700, 0x00000000);
+	write_reg_by_address(0x06120704, 0x00000002);
+	write_reg_by_address(0x06120708, 0x0000ff04);
+	write_reg_by_address(0x0612070c, 0x0000ff06);
+	write_reg_by_address(0x06120710, 0x0000fe08);
+	write_reg_by_address(0x06120714, 0x0000fd0a);
+	write_reg_by_address(0x06120718, 0x0000fd0c);
+	write_reg_by_address(0x0612071c, 0x0000fc0f);
+	write_reg_by_address(0x06120720, 0x0000fc12);
+	write_reg_by_address(0x06120724, 0x0001fb14);
+	write_reg_by_address(0x06120728, 0x0001fa17);
+	write_reg_by_address(0x0612072c, 0x0001fa19);
+	write_reg_by_address(0x06120730, 0x0001f91c);
+	write_reg_by_address(0x06120734, 0x0001f91f);
+	write_reg_by_address(0x06120738, 0x0001f822);
+	write_reg_by_address(0x0612073c, 0x0001f824);
+	write_reg_by_address(0x06120740, 0x0002f727);
+	write_reg_by_address(0x06120744, 0x0002f72a);
+	write_reg_by_address(0x06120748, 0x0002f72c);
+	write_reg_by_address(0x0612074c, 0x0002f72f);
+	write_reg_by_address(0x06120750, 0x0002f731);
+	write_reg_by_address(0x06120754, 0x0002f733);
+	write_reg_by_address(0x06120758, 0x0002f735);
+	write_reg_by_address(0x0612075c, 0x0002f737);
+	write_reg_by_address(0x06120760, 0x0002f73a);
+	write_reg_by_address(0x06120764, 0x0002f83b);
+	write_reg_by_address(0x06120768, 0x0002f93c);
+	write_reg_by_address(0x0612076c, 0x0002fa3d);
+	write_reg_by_address(0x06120770, 0x0001fb3e);
+	write_reg_by_address(0x06120774, 0x0001fc3f);
+	write_reg_by_address(0x06120778, 0x0001fd40);
+	write_reg_by_address(0x0612077c, 0x0000fe40);
+	write_reg_by_address(0x06120800, 0x00004000);
+	write_reg_by_address(0x06120804, 0x000140ff);
+	write_reg_by_address(0x06120808, 0x00033ffe);
+	write_reg_by_address(0x0612080c, 0x00043ffd);
+	write_reg_by_address(0x06120810, 0x00063efc);
+	write_reg_by_address(0x06120814, 0xff083dfc);
+	write_reg_by_address(0x06120818, 0x000a3bfb);
+	write_reg_by_address(0x0612081c, 0xff0d39fb);
+	write_reg_by_address(0x06120820, 0xff0f37fb);
+	write_reg_by_address(0x06120824, 0xff1136fa);
+	write_reg_by_address(0x06120828, 0xfe1433fb);
+	write_reg_by_address(0x0612082c, 0xfe1631fb);
+	write_reg_by_address(0x06120830, 0xfd192ffb);
+	write_reg_by_address(0x06120834, 0xfd1c2cfb);
+	write_reg_by_address(0x06120838, 0xfd1f29fb);
+	write_reg_by_address(0x0612083c, 0xfc2127fc);
+	write_reg_by_address(0x06120840, 0xfc2424fc);
+	write_reg_by_address(0x06120844, 0xfc2721fc);
+	write_reg_by_address(0x06120848, 0xfb291ffd);
+	write_reg_by_address(0x0612084c, 0xfb2c1cfd);
+	write_reg_by_address(0x06120850, 0xfb2f19fd);
+	write_reg_by_address(0x06120854, 0xfb3116fe);
+	write_reg_by_address(0x06120858, 0xfb3314fe);
+	write_reg_by_address(0x0612085c, 0xfa3611ff);
+	write_reg_by_address(0x06120860, 0xfb370fff);
+	write_reg_by_address(0x06120864, 0xfb390dff);
+	write_reg_by_address(0x06120868, 0xfb3b0a00);
+	write_reg_by_address(0x0612086c, 0xfc3d08ff);
+	write_reg_by_address(0x06120870, 0xfc3e0600);
+	write_reg_by_address(0x06120874, 0xfd3f0400);
+	write_reg_by_address(0x06120878, 0xfe3f0300);
+	write_reg_by_address(0x0612087c, 0xff400100);
+	write_reg_by_address(0x06120000, 0x00000011);
+
+	//[SCALERVIDEO_1]
+	write_reg_by_address(0x0614000c, 0x00000000);
+	write_reg_by_address(0x06140040, 0x031504ff);
+	write_reg_by_address(0x06140080, 0x031f04ff);
+	write_reg_by_address(0x06140088, 0x00100000);
+	write_reg_by_address(0x0614008c, 0x001033d8);
+	write_reg_by_address(0x06140090, 0x00000000);
+	write_reg_by_address(0x06140098, 0x00000000);
+	write_reg_by_address(0x0614009c, 0x00000000);
+	write_reg_by_address(0x061400c0, 0x031f04ff);
+	write_reg_by_address(0x061400c8, 0x00100000);
+	write_reg_by_address(0x061400cc, 0x001033d8);
+	write_reg_by_address(0x061400d0, 0x00000000);
+	write_reg_by_address(0x061400d8, 0x00000000);
+	write_reg_by_address(0x061400dc, 0x00000000);
+	write_reg_by_address(0x06140200, 0x40000000);
+	write_reg_by_address(0x06140204, 0x40fe0000);
+	write_reg_by_address(0x06140208, 0x3ffd0100);
+	write_reg_by_address(0x0614020c, 0x3efc0100);
+	write_reg_by_address(0x06140210, 0x3efb0100);
+	write_reg_by_address(0x06140214, 0x3dfa0200);
+	write_reg_by_address(0x06140218, 0x3cf90200);
+	write_reg_by_address(0x0614021c, 0x3bf80200);
+	write_reg_by_address(0x06140220, 0x39f70200);
+	write_reg_by_address(0x06140224, 0x37f70200);
+	write_reg_by_address(0x06140228, 0x35f70200);
+	write_reg_by_address(0x0614022c, 0x33f70200);
+	write_reg_by_address(0x06140230, 0x31f70200);
+	write_reg_by_address(0x06140234, 0x2ef70200);
+	write_reg_by_address(0x06140238, 0x2cf70200);
+	write_reg_by_address(0x0614023c, 0x2af70200);
+	write_reg_by_address(0x06140240, 0x27f70200);
+	write_reg_by_address(0x06140244, 0x24f80100);
+	write_reg_by_address(0x06140248, 0x22f80100);
+	write_reg_by_address(0x0614024c, 0x1ef90100);
+	write_reg_by_address(0x06140250, 0x1cf90100);
+	write_reg_by_address(0x06140254, 0x19fa0100);
+	write_reg_by_address(0x06140258, 0x17fa0100);
+	write_reg_by_address(0x0614025c, 0x14fb0100);
+	write_reg_by_address(0x06140260, 0x11fc0000);
+	write_reg_by_address(0x06140264, 0x0ffc0000);
+	write_reg_by_address(0x06140268, 0x0cfd0000);
+	write_reg_by_address(0x0614026c, 0x0afd0000);
+	write_reg_by_address(0x06140270, 0x08fe0000);
+	write_reg_by_address(0x06140274, 0x05ff0000);
+	write_reg_by_address(0x06140278, 0x03ff0000);
+	write_reg_by_address(0x0614027c, 0x02000000);
+	write_reg_by_address(0x06140300, 0x00000000);
+	write_reg_by_address(0x06140304, 0x00000002);
+	write_reg_by_address(0x06140308, 0x0000ff04);
+	write_reg_by_address(0x0614030c, 0x0000ff06);
+	write_reg_by_address(0x06140310, 0x0000fe08);
+	write_reg_by_address(0x06140314, 0x0000fd0a);
+	write_reg_by_address(0x06140318, 0x0000fd0c);
+	write_reg_by_address(0x0614031c, 0x0000fc0f);
+	write_reg_by_address(0x06140320, 0x0000fc12);
+	write_reg_by_address(0x06140324, 0x0001fb14);
+	write_reg_by_address(0x06140328, 0x0001fa17);
+	write_reg_by_address(0x0614032c, 0x0001fa19);
+	write_reg_by_address(0x06140330, 0x0001f91c);
+	write_reg_by_address(0x06140334, 0x0001f91f);
+	write_reg_by_address(0x06140338, 0x0001f822);
+	write_reg_by_address(0x0614033c, 0x0001f824);
+	write_reg_by_address(0x06140340, 0x0002f727);
+	write_reg_by_address(0x06140344, 0x0002f72a);
+	write_reg_by_address(0x06140348, 0x0002f72c);
+	write_reg_by_address(0x0614034c, 0x0002f72f);
+	write_reg_by_address(0x06140350, 0x0002f731);
+	write_reg_by_address(0x06140354, 0x0002f733);
+	write_reg_by_address(0x06140358, 0x0002f735);
+	write_reg_by_address(0x0614035c, 0x0002f737);
+	write_reg_by_address(0x06140360, 0x0002f73a);
+	write_reg_by_address(0x06140364, 0x0002f83b);
+	write_reg_by_address(0x06140368, 0x0002f93c);
+	write_reg_by_address(0x0614036c, 0x0002fa3d);
+	write_reg_by_address(0x06140370, 0x0001fb3e);
+	write_reg_by_address(0x06140374, 0x0001fc3f);
+	write_reg_by_address(0x06140378, 0x0001fd40);
+	write_reg_by_address(0x0614037c, 0x0000fe40);
+	write_reg_by_address(0x06140400, 0x00004000);
+	write_reg_by_address(0x06140404, 0x000140ff);
+	write_reg_by_address(0x06140408, 0x00033ffe);
+	write_reg_by_address(0x0614040c, 0x00043ffd);
+	write_reg_by_address(0x06140410, 0x00063efc);
+	write_reg_by_address(0x06140414, 0xff083dfc);
+	write_reg_by_address(0x06140418, 0x000a3bfb);
+	write_reg_by_address(0x0614041c, 0xff0d39fb);
+	write_reg_by_address(0x06140420, 0xff0f37fb);
+	write_reg_by_address(0x06140424, 0xff1136fa);
+	write_reg_by_address(0x06140428, 0xfe1433fb);
+	write_reg_by_address(0x0614042c, 0xfe1631fb);
+	write_reg_by_address(0x06140430, 0xfd192ffb);
+	write_reg_by_address(0x06140434, 0xfd1c2cfb);
+	write_reg_by_address(0x06140438, 0xfd1f29fb);
+	write_reg_by_address(0x0614043c, 0xfc2127fc);
+	write_reg_by_address(0x06140440, 0xfc2424fc);
+	write_reg_by_address(0x06140444, 0xfc2721fc);
+	write_reg_by_address(0x06140448, 0xfb291ffd);
+	write_reg_by_address(0x0614044c, 0xfb2c1cfd);
+	write_reg_by_address(0x06140450, 0xfb2f19fd);
+	write_reg_by_address(0x06140454, 0xfb3116fe);
+	write_reg_by_address(0x06140458, 0xfb3314fe);
+	write_reg_by_address(0x0614045c, 0xfa3611ff);
+	write_reg_by_address(0x06140460, 0xfb370fff);
+	write_reg_by_address(0x06140464, 0xfb390dff);
+	write_reg_by_address(0x06140468, 0xfb3b0a00);
+	write_reg_by_address(0x0614046c, 0xfc3d08ff);
+	write_reg_by_address(0x06140470, 0xfc3e0600);
+	write_reg_by_address(0x06140474, 0xfd3f0400);
+	write_reg_by_address(0x06140478, 0xfe3f0300);
+	write_reg_by_address(0x0614047c, 0xff400100);
+	write_reg_by_address(0x06140600, 0x40000000);
+	write_reg_by_address(0x06140604, 0x40fe0000);
+	write_reg_by_address(0x06140608, 0x3ffd0100);
+	write_reg_by_address(0x0614060c, 0x3efc0100);
+	write_reg_by_address(0x06140610, 0x3efb0100);
+	write_reg_by_address(0x06140614, 0x3dfa0200);
+	write_reg_by_address(0x06140618, 0x3cf90200);
+	write_reg_by_address(0x0614061c, 0x3bf80200);
+	write_reg_by_address(0x06140620, 0x39f70200);
+	write_reg_by_address(0x06140624, 0x37f70200);
+	write_reg_by_address(0x06140628, 0x35f70200);
+	write_reg_by_address(0x0614062c, 0x33f70200);
+	write_reg_by_address(0x06140630, 0x31f70200);
+	write_reg_by_address(0x06140634, 0x2ef70200);
+	write_reg_by_address(0x06140638, 0x2cf70200);
+	write_reg_by_address(0x0614063c, 0x2af70200);
+	write_reg_by_address(0x06140640, 0x27f70200);
+	write_reg_by_address(0x06140644, 0x24f80100);
+	write_reg_by_address(0x06140648, 0x22f80100);
+	write_reg_by_address(0x0614064c, 0x1ef90100);
+	write_reg_by_address(0x06140650, 0x1cf90100);
+	write_reg_by_address(0x06140654, 0x19fa0100);
+	write_reg_by_address(0x06140658, 0x17fa0100);
+	write_reg_by_address(0x0614065c, 0x14fb0100);
+	write_reg_by_address(0x06140660, 0x11fc0000);
+	write_reg_by_address(0x06140664, 0x0ffc0000);
+	write_reg_by_address(0x06140668, 0x0cfd0000);
+	write_reg_by_address(0x0614066c, 0x0afd0000);
+	write_reg_by_address(0x06140670, 0x08fe0000);
+	write_reg_by_address(0x06140674, 0x05ff0000);
+	write_reg_by_address(0x06140678, 0x03ff0000);
+	write_reg_by_address(0x0614067c, 0x02000000);
+	write_reg_by_address(0x06140700, 0x00000000);
+	write_reg_by_address(0x06140704, 0x00000002);
+	write_reg_by_address(0x06140708, 0x0000ff04);
+	write_reg_by_address(0x0614070c, 0x0000ff06);
+	write_reg_by_address(0x06140710, 0x0000fe08);
+	write_reg_by_address(0x06140714, 0x0000fd0a);
+	write_reg_by_address(0x06140718, 0x0000fd0c);
+	write_reg_by_address(0x0614071c, 0x0000fc0f);
+	write_reg_by_address(0x06140720, 0x0000fc12);
+	write_reg_by_address(0x06140724, 0x0001fb14);
+	write_reg_by_address(0x06140728, 0x0001fa17);
+	write_reg_by_address(0x0614072c, 0x0001fa19);
+	write_reg_by_address(0x06140730, 0x0001f91c);
+	write_reg_by_address(0x06140734, 0x0001f91f);
+	write_reg_by_address(0x06140738, 0x0001f822);
+	write_reg_by_address(0x0614073c, 0x0001f824);
+	write_reg_by_address(0x06140740, 0x0002f727);
+	write_reg_by_address(0x06140744, 0x0002f72a);
+	write_reg_by_address(0x06140748, 0x0002f72c);
+	write_reg_by_address(0x0614074c, 0x0002f72f);
+	write_reg_by_address(0x06140750, 0x0002f731);
+	write_reg_by_address(0x06140754, 0x0002f733);
+	write_reg_by_address(0x06140758, 0x0002f735);
+	write_reg_by_address(0x0614075c, 0x0002f737);
+	write_reg_by_address(0x06140760, 0x0002f73a);
+	write_reg_by_address(0x06140764, 0x0002f83b);
+	write_reg_by_address(0x06140768, 0x0002f93c);
+	write_reg_by_address(0x0614076c, 0x0002fa3d);
+	write_reg_by_address(0x06140770, 0x0001fb3e);
+	write_reg_by_address(0x06140774, 0x0001fc3f);
+	write_reg_by_address(0x06140778, 0x0001fd40);
+	write_reg_by_address(0x0614077c, 0x0000fe40);
+	write_reg_by_address(0x06140800, 0x00004000);
+	write_reg_by_address(0x06140804, 0x000140ff);
+	write_reg_by_address(0x06140808, 0x00033ffe);
+	write_reg_by_address(0x0614080c, 0x00043ffd);
+	write_reg_by_address(0x06140810, 0x00063efc);
+	write_reg_by_address(0x06140814, 0xff083dfc);
+	write_reg_by_address(0x06140818, 0x000a3bfb);
+	write_reg_by_address(0x0614081c, 0xff0d39fb);
+	write_reg_by_address(0x06140820, 0xff0f37fb);
+	write_reg_by_address(0x06140824, 0xff1136fa);
+	write_reg_by_address(0x06140828, 0xfe1433fb);
+	write_reg_by_address(0x0614082c, 0xfe1631fb);
+	write_reg_by_address(0x06140830, 0xfd192ffb);
+	write_reg_by_address(0x06140834, 0xfd1c2cfb);
+	write_reg_by_address(0x06140838, 0xfd1f29fb);
+	write_reg_by_address(0x0614083c, 0xfc2127fc);
+	write_reg_by_address(0x06140840, 0xfc2424fc);
+	write_reg_by_address(0x06140844, 0xfc2721fc);
+	write_reg_by_address(0x06140848, 0xfb291ffd);
+	write_reg_by_address(0x0614084c, 0xfb2c1cfd);
+	write_reg_by_address(0x06140850, 0xfb2f19fd);
+	write_reg_by_address(0x06140854, 0xfb3116fe);
+	write_reg_by_address(0x06140858, 0xfb3314fe);
+	write_reg_by_address(0x0614085c, 0xfa3611ff);
+	write_reg_by_address(0x06140860, 0xfb370fff);
+	write_reg_by_address(0x06140864, 0xfb390dff);
+	write_reg_by_address(0x06140868, 0xfb3b0a00);
+	write_reg_by_address(0x0614086c, 0xfc3d08ff);
+	write_reg_by_address(0x06140870, 0xfc3e0600);
+	write_reg_by_address(0x06140874, 0xfd3f0400);
+	write_reg_by_address(0x06140878, 0xfe3f0300);
+	write_reg_by_address(0x0614087c, 0xff400100);
+	write_reg_by_address(0x06140000, 0x00000011);
+
+	//[CSC_1]
+	write_reg_by_address(0x061f0000, 0x00000000);
+	write_reg_by_address(0x061f0004, 0x00000000);
+	write_reg_by_address(0x061f0008, 0x00000000);
+	write_reg_by_address(0x061f000c, 0x00000000);
+	write_reg_by_address(0x061f0010, 0x00000000);
+	write_reg_by_address(0x061f0014, 0x00000000);
+	write_reg_by_address(0x061f0018, 0x00000000);
+	write_reg_by_address(0x061f001c, 0x00000000);
+	write_reg_by_address(0x061f0020, 0x00000000);
+	write_reg_by_address(0x061f0024, 0x00000000);
+	write_reg_by_address(0x061f0028, 0x00000000);
+	write_reg_by_address(0x061f002c, 0x00000000);
+	write_reg_by_address(0x061f0030, 0x00000000);
+	write_reg_by_address(0x061f0034, 0x00000000);
+	write_reg_by_address(0x061f0038, 0x00000000);
+	write_reg_by_address(0x061f003c, 0x00000000);
+	write_reg_by_address(0x061f0040, 0xff000000);
+
+	//[SCALERUI_2]
+	write_reg_by_address(0x0616000c, 0x00000000);
+	write_reg_by_address(0x06160010, 0x00000000);
+	write_reg_by_address(0x06160040, 0x031f04ff);
+	write_reg_by_address(0x06160080, 0x031f04ff);
+	write_reg_by_address(0x06160088, 0x00100000);
+	write_reg_by_address(0x0616008c, 0x00100000);
+	write_reg_by_address(0x06160090, 0x00000000);
+	write_reg_by_address(0x06160098, 0x00000000);
+	write_reg_by_address(0x0616009c, 0x00000000);
+	write_reg_by_address(0x06160200, 0x00004000);
+	write_reg_by_address(0x06160204, 0x00033ffe);
+	write_reg_by_address(0x06160208, 0x00063efc);
+	write_reg_by_address(0x0616020c, 0x000a3bfb);
+	write_reg_by_address(0x06160210, 0xff0f37fb);
+	write_reg_by_address(0x06160214, 0xfe1433fb);
+	write_reg_by_address(0x06160218, 0xfd192ffb);
+	write_reg_by_address(0x0616021c, 0xfd1f29fb);
+	write_reg_by_address(0x06160220, 0xfc2424fc);
+	write_reg_by_address(0x06160224, 0xfb291ffd);
+	write_reg_by_address(0x06160228, 0xfb2f19fd);
+	write_reg_by_address(0x0616022c, 0xfb3314fe);
+	write_reg_by_address(0x06160230, 0xfb370fff);
+	write_reg_by_address(0x06160234, 0xfb3b0a00);
+	write_reg_by_address(0x06160238, 0xfc3e0600);
+	write_reg_by_address(0x0616023c, 0xfe3f0300);
+	write_reg_by_address(0x06160000, 0x00000010);
+
+	//[SCALERUI_3]
+	write_reg_by_address(0x0617000c, 0x00000000);
+	write_reg_by_address(0x06170010, 0x00000000);
+	write_reg_by_address(0x06170040, 0x031f04ff);
+	write_reg_by_address(0x06170080, 0x031f04fe);
+	write_reg_by_address(0x06170088, 0x000ffccc);
+	write_reg_by_address(0x0617008c, 0x00100000);
+	write_reg_by_address(0x06170090, 0x00000000);
+	write_reg_by_address(0x06170098, 0x00000000);
+	write_reg_by_address(0x0617009c, 0x00000000);
+	write_reg_by_address(0x06170200, 0x00004000);
+	write_reg_by_address(0x06170204, 0x00033ffe);
+	write_reg_by_address(0x06170208, 0x00063efc);
+	write_reg_by_address(0x0617020c, 0x000a3bfb);
+	write_reg_by_address(0x06170210, 0xff0f37fb);
+	write_reg_by_address(0x06170214, 0xfe1433fb);
+	write_reg_by_address(0x06170218, 0xfd192ffb);
+	write_reg_by_address(0x0617021c, 0xfd1f29fb);
+	write_reg_by_address(0x06170220, 0xfc2424fc);
+	write_reg_by_address(0x06170224, 0xfb291ffd);
+	write_reg_by_address(0x06170228, 0xfb2f19fd);
+	write_reg_by_address(0x0617022c, 0xfb3314fe);
+	write_reg_by_address(0x06170230, 0xfb370fff);
+	write_reg_by_address(0x06170234, 0xfb3b0a00);
+	write_reg_by_address(0x06170238, 0xfc3e0600);
+	write_reg_by_address(0x0617023c, 0xfe3f0300);
+	write_reg_by_address(0x06170000, 0x00000011);
+
+	//[WB]
+	//write_reg_by_address(0x01c0d000, 0x00000000);
+	write_reg_by_address(0x06010004, 0x031f04ff);
+	write_reg_by_address(0x06010008, 0x00000000);
+	write_reg_by_address(0x0601000c, 0x031f04ff);
+	write_reg_by_address(0x06010010, 0x673e8000);
+	write_reg_by_address(0x06010014, 0x6743c604);
+	write_reg_by_address(0x06010018, 0x67451788);
+	write_reg_by_address(0x0601001c, 0x00000000);
+	write_reg_by_address(0x06010020, 0x00000000);
+	write_reg_by_address(0x06010024, 0x00000000);
+	write_reg_by_address(0x06010028, 0x00000000);
+	write_reg_by_address(0x0601002c, 0x00000000);
+	write_reg_by_address(0x06010030, 0x000002d0);
+	write_reg_by_address(0x06010034, 0x00000168);
+	write_reg_by_address(0x06010040, 0x00000000);
+	write_reg_by_address(0x06010044, 0x00000008);
+	write_reg_by_address(0x06010048, 0x00000001);
+	write_reg_by_address(0x0601004c, 0x00000000);
+	write_reg_by_address(0x06010054, 0x00000005);
+	write_reg_by_address(0x06010070, 0x00000000);
+	write_reg_by_address(0x06010074, 0x00000000);
+	write_reg_by_address(0x06010080, 0x031f04ff);
+	write_reg_by_address(0x06010084, 0x01df02cf);
+	write_reg_by_address(0x06010088, 0x001c71c4);
+	write_reg_by_address(0x0601008c, 0x001aaaa8);
+	write_reg_by_address(0x06010050, 0x00000020);
+	write_reg_by_address(0x06010100, 0x000000bb);
+	write_reg_by_address(0x06010104, 0x00000274);
+	write_reg_by_address(0x06010108, 0x0000003f);
+	write_reg_by_address(0x0601010c, 0x00004200);
+	write_reg_by_address(0x06010110, 0x00001f98);
+	write_reg_by_address(0x06010114, 0x00001ea5);
+	write_reg_by_address(0x06010118, 0x000001c1);
+	write_reg_by_address(0x0601011c, 0x00020200);
+	write_reg_by_address(0x06010120, 0x000001c1);
+	write_reg_by_address(0x06010124, 0x00001e67);
+	write_reg_by_address(0x06010128, 0x00001fd7);
+	write_reg_by_address(0x0601012c, 0x00020200);
+	write_reg_by_address(0x06010200, 0x000e240e);
+	write_reg_by_address(0x06010280, 0x000e240e);
+	write_reg_by_address(0x06010204, 0x0010240c);
+	write_reg_by_address(0x06010284, 0x0010240c);
+	write_reg_by_address(0x06010208, 0x0013230a);
+	write_reg_by_address(0x06010288, 0x0013230a);
+	write_reg_by_address(0x0601020c, 0x00142309);
+	write_reg_by_address(0x0601028c, 0x00142309);
+	write_reg_by_address(0x06010210, 0x00162208);
+	write_reg_by_address(0x06010290, 0x00162208);
+	write_reg_by_address(0x06010214, 0x01182106);
+	write_reg_by_address(0x06010294, 0x01182106);
+	write_reg_by_address(0x06010218, 0x011a2005);
+	write_reg_by_address(0x06010298, 0x011a2005);
+	write_reg_by_address(0x0601021c, 0x021b1f04);
+	write_reg_by_address(0x0601029c, 0x021b1f04);
+	write_reg_by_address(0x06010220, 0x031d1d03);
+	write_reg_by_address(0x060102a0, 0x031d1d03);
+	write_reg_by_address(0x06010224, 0x041e1c02);
+	write_reg_by_address(0x060102a4, 0x041e1c02);
+	write_reg_by_address(0x06010228, 0x05201a01);
+	write_reg_by_address(0x060102a8, 0x05201a01);
+	write_reg_by_address(0x0601022c, 0x06211801);
+	write_reg_by_address(0x060102ac, 0x06211801);
+	write_reg_by_address(0x06010230, 0x07221601);
+	write_reg_by_address(0x060102b0, 0x07221601);
+	write_reg_by_address(0x06010234, 0x09231400);
+	write_reg_by_address(0x060102b4, 0x09231400);
+	write_reg_by_address(0x06010238, 0x0a231300);
+	write_reg_by_address(0x060102b8, 0x0a231300);
+	write_reg_by_address(0x0601023c, 0x0c231100);
+	write_reg_by_address(0x060102bc, 0x0c231100);
+	//write_reg_by_address(0x06010000, 0x20000001);
+	write_reg_by_address(0x06100000, 0x00000001);
+	write_reg_by_address(0x06000010, 0x00000000);
+	//write_reg_by_address(0x01c0d0f8, 0x00000008);
+	//write_reg_by_address(0x01c0d0fc, 0x00002000);
+	//write_reg_by_address(0x01c0d000, 0x00000000);
+	//write_reg_by_address(0x01c0d004, 0x00000000);
+	//write_reg_by_address(0x01c0d008, 0x00000000);
+	//write_reg_by_address(0x01c0d040, 0x00000040);
+	//write_reg_by_address(0x01c0d044, 0x80000020);
+	//write_reg_by_address(0x01c0d048, 0x04ff031f);
+	//write_reg_by_address(0x01c0d04c, 0x05130003);
+	//write_reg_by_address(0x01c0d050, 0x06660003);
+	//write_reg_by_address(0x01c0d054, 0x00020002);
+	//write_reg_by_address(0x01c0d058, 0x00000000);
+	//write_reg_by_address(0x01c0d088, 0x00000000);
+	//write_reg_by_address(0x01c0d08c, 0x00000000);
+	//write_reg_by_address(0x01c0d090, 0x00000001);
+	//write_reg_by_address(0x01c0d040, 0x80000040);
+	//write_reg_by_address(0x01c0d000, 0x80000000);
+
+	// config tcon
+	write_reg_by_address(0x300B06C, 0x22222222);
+	write_reg_by_address(0x300B070, 0x22222222);
+	write_reg_by_address(0x300B074, 0x22222222);
+	data = read_reg_by_address(0x0651001c); // (DISP0_IF_TOP_BASE+0x1c)
+	data = data & 0xfffffff0;
+	write_reg_by_address(0x0651001c, data);
+	write_reg_by_address(0x06511000+0x000, 0x00000000);  //tcon_gctl
+	write_reg_by_address(0x06511000+0x004, 0x80000000);  //tcon_gint0
+	write_reg_by_address(0x06511000+0x008, 0x00000000);  //tcon_gint1
+	write_reg_by_address(0x06511000+0x044, 0xf0000000 | 1); //tcon0_dclk
+	write_reg_by_address(0x06511000+0x048, (800-1)<<16  | (1280-1));  //tcon0_basic0 x y
+	write_reg_by_address(0x06511000+0x04c, (800+10-1)<<16 | (5-1));  //tcon0_basic1  ht hbp
+	write_reg_by_address(0x06511000+0x050, ((1280+10)*2)<<16 | (5-1)); //tcon0_basic2	vt vbp
+	write_reg_by_address(0x06511000+0x054, (2-1)<<16 | (2-1));  //tcon0_basic3	hspw vspw
+	write_reg_by_address(0x06511000+0x058, 0x00000000);  //tcon0_hv
+	write_reg_by_address(0x06511000+0x088, 0x00000000);  //tcon0_inv
+	write_reg_by_address(0x06511000+0x08c, 0x00000000);  //tcon0_tri
+	write_reg_by_address(0x06511000+0x040, 0x80000021);  //tcon0_enable
+	write_reg_by_address(0x06511000+0x000, 0x80000000);  //tcon_enable
+
+	return 0;
+}
+
+static void tcon_irq_enable(struct gorilla_de_tcon *chip)
+{
+	u32 val;
+
+	dev_dbg(chip->dev, "%s()\n", __func__);
+	val = readl(chip->base + LCD_GINT0_REG) | LCD_VB_INT_EN;
+	writel(val, chip->base + LCD_GINT0_REG);
+}
+
+static u32 tcon_irq_check(struct gorilla_de_tcon *chip)
+{
+	u32 val;
+
+	val = readl(chip->base + LCD_GINT0_REG) & LCD_VB_INT_FLAG;
+	if (val) {
+		//dev_dbg(chip->dev, "%s(): IRQ asserted\n", __func__);
+	} else {
+		dev_warn(chip->dev, "%s(): IRQ NOT asserted\n", __func__);
+	}
+
+	return val;
+}
+
+static void tcon_irq_clear(struct gorilla_de_tcon *chip)
+{
+	u32 val;
+
+	//dev_dbg(chip->dev, "%s()\n", __func__);
+
+	val = readl(chip->base + LCD_GINT0_REG) & ~LCD_VB_INT_FLAG;
+	writel(val, chip->base + LCD_GINT0_REG);
+#if 1
+	/* FIXME: TCON IRQ has to be cleared twice. This is a hardware issue.
+	 * The workaround below is dangerous... */
+	while (readl(chip->base + LCD_GINT0_REG) | LCD_VB_INT_FLAG) {
+		dev_dbg(chip->dev, "%s(): re-clear irq\n", __func__);
+		val = readl(chip->base + LCD_GINT0_REG) & ~LCD_VB_INT_FLAG;
+		writel(val, chip->base + LCD_GINT0_REG);
+	}
+#endif
+}
+
+static irqreturn_t gorilla_tcon_isr(int irq, void *id)
+{
+	struct gorilla_de_tcon *chip = (struct gorilla_de_tcon *)id;
+
+	dev_dbg(chip->dev, "%s()\n", __func__);
+	tcon_irq_check(chip);
+	tcon_irq_clear(chip);
+	//dev_dbg(chip->dev, "%s(): IRQ_HANDLED\n", __func__);
+	return IRQ_HANDLED;
+}
+
+static const struct of_device_id gorilla_de_tcon_dt_ids[] = {
+	{.compatible = "sunxi,gorilla-de-tcon"},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, gorilla_de_tcon_dt_ids);
+
+static int gorilla_de_tcon_probe(struct platform_device *pdev)
+{
+	struct gorilla_de_tcon *chip;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int err;
+
+	dev_dbg(dev, "%s(): BEGIN\n", __func__);
+
+	/* Initialize private data structure `chip` */
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, chip);
+	chip->dev = dev;
+
+	/* Initialize hardware */
+	de_tcon_init(chip);
+
+	/* Map IRQ registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM\n");
+		return -EINVAL;
+	}
+	chip->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(chip->base)) {
+		dev_err(dev, "Fail to map IO resource\n");
+		return PTR_ERR(chip->base);
+	}
+	//chip->res = res;
+
+	/* Setup IRQ */
+	chip->irq = platform_get_irq(pdev, 0);
+	if (chip->irq < 0) {
+		dev_err(dev, "No IRQ resource\n");
+		return -EINVAL;
+	}
+	err = devm_request_irq(dev, chip->irq, gorilla_tcon_isr, 0,
+				dev_name(dev), chip);
+	if (err) {
+		dev_err(dev, "Could not request IRQ\n");
+		return err;
+	}
+	tcon_irq_enable(chip);  /* already enabled in de_tcon_init() */
+
+	dev_dbg(dev, "%s(): END\n", __func__);
+	return 0;
+}
+
+static struct platform_driver gorilla_de_tcon_driver = {
+	.probe    = gorilla_de_tcon_probe,
+	.driver   = {
+		.name  = "gorilla-de-tcon",
+		.owner = THIS_MODULE,
+		.of_match_table = gorilla_de_tcon_dt_ids,
+	},
+};
+
+module_platform_driver(gorilla_de_tcon_driver);
+
+MODULE_DESCRIPTION("sunxi gorilla DE/TCON driver");
+MODULE_AUTHOR("Martin <wuyan@allwinnertech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/misc/sunxi-gorilla/gorilla-extra-mem.c b/drivers/misc/sunxi-gorilla/gorilla-extra-mem.c
new file mode 100644
index 000000000..b65189ad2
--- /dev/null
+++ b/drivers/misc/sunxi-gorilla/gorilla-extra-mem.c
@@ -0,0 +1,89 @@
+/*
+ * Use extra memories as normal storage media
+ *
+ * Copyright (c) 2020, Martin <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define DEBUG	 /* Enable dev_dbg */
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+
+struct gorilla_extra_mem {
+	struct device *dev;
+	void __iomem *base;
+};
+
+static int gorilla_extra_mem_probe(struct platform_device *pdev)
+{
+	struct gorilla_extra_mem *chip;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+
+	dev_dbg(dev, "%s(): BEGIN\n", __func__);
+
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, chip);
+	chip->dev = dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM\n");
+		return -EINVAL;
+	}
+	chip->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(chip->base)) {
+		dev_err(dev, "Fail to map IO resource\n");
+		return PTR_ERR(chip->base);
+	}
+
+	dev_dbg(dev, "%s(): END\n", __func__);
+	return 0;
+}
+
+static int gorilla_extra_mem_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id gorilla_extra_mem_dt_ids[] = {
+	{ .compatible = "sunxi,gorilla-extra-mem" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, gorilla_extra_mem_dt_ids);
+
+static struct platform_driver gorilla_extra_mem_driver = {
+	.probe    = gorilla_extra_mem_probe,
+	.remove   = gorilla_extra_mem_remove,
+	.driver   = {
+		.name  = "gorilla-extra-mem",
+		.owner = THIS_MODULE,
+		.of_match_table = gorilla_extra_mem_dt_ids,
+	},
+};
+module_platform_driver(gorilla_extra_mem_driver);
+
+MODULE_DESCRIPTION("sunxi gorilla extra memory driver");
+MODULE_AUTHOR("Martin <wuyan@allwinnertech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/misc/sunxi-gorilla/gorilla-memc.c b/drivers/misc/sunxi-gorilla/gorilla-memc.c
new file mode 100644
index 000000000..1d059ee84
--- /dev/null
+++ b/drivers/misc/sunxi-gorilla/gorilla-memc.c
@@ -0,0 +1,183 @@
+/*
+ * sunxi gorilla memory controller driver (For AW1855)
+ *
+ * Copyright (c) 2020, Martin <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define DEBUG	 /* Enable dev_dbg */
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include "gorilla-common.h"
+
+struct gorilla_memc {
+	struct device *dev;
+};
+
+/*
+ * initialize sunxi memc
+ * @freq: 12 or 24. default is 12
+ * @do_traning: default is false
+ */
+static noinline int gorilla_memc_init(struct gorilla_memc *chip, int freq, bool do_traning)
+{
+	struct device *dev = chip->dev;
+	u32 data = 0;
+
+	dev_dbg(dev, "%s(): BEGIN\n", __func__);
+
+	write_reg_by_address(0x0482300c, 0x00008000);
+	write_reg_by_address(0x04810020, 0xffffffff);
+	data = read_reg_by_address(0x04810000);
+	write_reg_by_address(0x04810000, 0x004319f5);
+	write_reg_by_address(0x04823030, 0x00001c70);
+	write_reg_by_address(0x04823034, 0x00000000);
+	write_reg_by_address(0x04823038, 0x00000018);
+	write_reg_by_address(0x0482303c, 0x00000000);
+	write_reg_by_address(0x04823058, 0x0c0f180c);
+	write_reg_by_address(0x0482305c, 0x00030310);
+	write_reg_by_address(0x04823060, 0x04060509);
+	write_reg_by_address(0x04823064, 0x0000400c);
+	write_reg_by_address(0x04823068, 0x05020305);
+	write_reg_by_address(0x0482306c, 0x05050403);
+	data = read_reg_by_address(0x04823078);
+	write_reg_by_address(0x04823078, 0x90006610);
+	write_reg_by_address(0x04823080, 0x02040102);
+	write_reg_by_address(0x04823044, 0x01e007c3);
+	write_reg_by_address(0x04823050, 0x03c00800);
+	write_reg_by_address(0x04823054, 0x24000500);
+	//write_reg_by_address(0x04823090, 0x00490069);
+	data = read_reg_by_address(0x0481000c);
+	write_reg_by_address(0x0481000c, 0x0000018f);
+	data = read_reg_by_address(0x04823108);
+	write_reg_by_address(0x04823108, 0x000023c0);
+	data = read_reg_by_address(0x04823344);
+	write_reg_by_address(0x04823344, 0x40020281);
+	data = read_reg_by_address(0x048233c4);
+	write_reg_by_address(0x048233c4, 0x40020281);
+	data = read_reg_by_address(0x04823444);
+	write_reg_by_address(0x04823444, 0x40020281);
+	data = read_reg_by_address(0x048234c4);
+	write_reg_by_address(0x048234c4, 0x40020281);
+	data = read_reg_by_address(0x04823208);
+	write_reg_by_address(0x04823208, 0x0002034a);
+	data = read_reg_by_address(0x04823108);
+	write_reg_by_address(0x04823108, 0x00002380);
+	data = read_reg_by_address(0x04823060);
+	data = read_reg_by_address(0x048230bc);
+	write_reg_by_address(0x048230bc, 0x00f00104);
+	data = read_reg_by_address(0x0482311c);
+	write_reg_by_address(0x0482311c, 0x4c00041f);
+	data = read_reg_by_address(0x048230c0);
+	write_reg_by_address(0x048230c0, 0x83000081);
+	data = read_reg_by_address(0x04823140);
+	write_reg_by_address(0x04823140, 0x013b3bbb);
+	write_reg_by_address(0x04823000, 0x000001f2);
+	write_reg_by_address(0x04823000, 0x000001f3);
+
+	data = read_reg_by_address(0x04823010);
+	while (data != 1) {
+		data = read_reg_by_address(0x04823010);
+	}
+
+	data = read_reg_by_address(0x04810014);
+	write_reg_by_address(0x04810014, data);
+
+	data = read_reg_by_address(0x04823018);
+	while (data != 1) {
+		data = read_reg_by_address(0x04823018);
+	}
+
+	data = read_reg_by_address(0x0482310c);
+	write_reg_by_address(0x0482310c, 0xc0aa0060);
+	data = read_reg_by_address(0x0482308c);
+	write_reg_by_address(0x0482308c, 0x80200010);
+	data = read_reg_by_address(0x0482308c);
+	write_reg_by_address(0x0482308c, 0x00200010);
+	write_reg_by_address(0x04810020, 0xffffffff);
+	write_reg_by_address(0x04810024, 0x000007ff);
+	write_reg_by_address(0x04810028, 0x0000ffff);
+	data = read_reg_by_address(0x04810000);
+	write_reg_by_address(0x04810000, 0x004319f5);
+	data = read_reg_by_address(0x04810000);
+	write_reg_by_address(0x04810000, 0x004319f5);
+	data = read_reg_by_address(0x04810000);
+	write_reg_by_address(0x04823120, 0x00000303);
+	data = read_reg_by_address(0x04810000);
+	data = read_reg_by_address(0x04810004);
+
+	write_reg_by_address(0x048200a0, 0x10000000);
+
+	dev_dbg(dev, "%s(): END\n", __func__);
+	return 0;
+}
+
+static int gorilla_memc_probe(struct platform_device *pdev)
+{
+	struct gorilla_memc *chip;
+	struct device *dev = &pdev->dev;
+	int err;
+
+	dev_dbg(dev, "%s(): BEGIN\n", __func__);
+
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, chip);
+	chip->dev = dev;
+
+	err = gorilla_memc_init(chip, 24, false);
+	if (err) {
+		dev_err(dev, "gorilla_memc_init() failed\n");
+		return err;
+	}
+
+	dev_dbg(dev, "%s(): END\n", __func__);
+	return 0;
+}
+
+static int gorilla_memc_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id gorilla_memc_dt_ids[] = {
+	{.compatible = "sunxi,gorilla-memc" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, gorilla_memc_dt_ids);
+
+static struct platform_driver gorilla_memc_driver = {
+	.probe    = gorilla_memc_probe,
+	.remove   = gorilla_memc_remove,
+	.driver   = {
+		.name  = "gorilla-memc",
+		.owner = THIS_MODULE,
+		.of_match_table = gorilla_memc_dt_ids,
+	},
+};
+module_platform_driver(gorilla_memc_driver);
+
+MODULE_DESCRIPTION("sunxi gorilla memory controller driver");
+MODULE_AUTHOR("Martin <wuyan@allwinnertech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/misc/sunxi-gorilla/gorilla-nsi.c b/drivers/misc/sunxi-gorilla/gorilla-nsi.c
new file mode 100644
index 000000000..bfabacd82
--- /dev/null
+++ b/drivers/misc/sunxi-gorilla/gorilla-nsi.c
@@ -0,0 +1,107 @@
+/*
+ * sunxi gorilla IRQ test driver (For AW1855)
+ *
+ * Copyright (c) 2020, Martin <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define DEBUG	 /* Enable dev_dbg */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include "gorilla-common.h"
+
+struct gorilla_nsi {
+	struct device *dev;
+};
+
+static int nsi_init(struct gorilla_nsi *chip)
+{
+	write_reg_by_address(0x05101614, 0xa);
+	write_reg_by_address(0x05101618, 0x1);
+	write_reg_by_address(0x05102414, 0xf);
+	write_reg_by_address(0x05102418, 0x1);
+	write_reg_by_address(0x05100218, 0x1);
+	write_reg_by_address(0x05100028, 0xe4);
+	write_reg_by_address(0x0510002c, 0x5d);
+	write_reg_by_address(0x05102028, 0xf2);
+	write_reg_by_address(0x0510202c, 0x9c);
+	write_reg_by_address(0x05100228, 0x2d7);
+	write_reg_by_address(0x0510022c, 0x1d4);
+	write_reg_by_address(0x05102e90, 0x80202020);
+	write_reg_by_address(0x05100010, 0x1);
+	write_reg_by_address(0x05100210, 0x1);
+	write_reg_by_address(0x05102010, 0x1);
+	write_reg_by_address(0x05102e94, 0x0);
+	write_reg_by_address(0x05102e98, 0x0);
+	write_reg_by_address(0x051000C0, 0x1);
+	write_reg_by_address(0x051000C8, 0x8342);
+	write_reg_by_address(0x051002C0, 0x1);
+	write_reg_by_address(0x051002C8, 0x8342);
+	write_reg_by_address(0x051016C0, 0x1);
+	write_reg_by_address(0x051016C8, 0x8342);
+	write_reg_by_address(0x051020C0, 0x1);
+	write_reg_by_address(0x051020C8, 0x8342);
+	write_reg_by_address(0x05102CC0, 0x1);
+	write_reg_by_address(0x05102CC8, 0x8342);
+
+	return 0;
+}
+
+static const struct of_device_id gorilla_nsi_dt_ids[] = {
+	{.compatible = "sunxi,gorilla-nsi"},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, gorilla_nsi_dt_ids);
+
+static int gorilla_nsi_probe(struct platform_device *pdev)
+{
+	struct gorilla_nsi *chip;
+	struct device *dev = &pdev->dev;
+
+	dev_dbg(dev, "%s(): BEGIN\n", __func__);
+
+	/* Initialize private data structure `chip` */
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, chip);
+	chip->dev = dev;
+
+	/* Initialize hardware */
+	nsi_init(chip);
+
+	dev_dbg(dev, "%s(): END\n", __func__);
+	return 0;
+}
+
+static struct platform_driver gorilla_nsi_driver = {
+	.probe    = gorilla_nsi_probe,
+	.driver   = {
+		.name  = "gorilla-nsi",
+		.owner = THIS_MODULE,
+		.of_match_table = gorilla_nsi_dt_ids,
+	},
+};
+
+module_platform_driver(gorilla_nsi_driver);
+
+MODULE_DESCRIPTION("sunxi gorilla NSI driver");
+MODULE_AUTHOR("Martin <wuyan@allwinnertech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/misc/sunxi-rf/Kconfig b/drivers/misc/sunxi-rf/Kconfig
new file mode 100644
index 000000000..854d7a881
--- /dev/null
+++ b/drivers/misc/sunxi-rf/Kconfig
@@ -0,0 +1,9 @@
+#
+# Allwinner rfkill driver.
+#
+config SUNXI_RFKILL
+  tristate "Allwinner rfkill driver"
+  depends on WIRELESS || RFKILL
+  help
+    allwinner rfkill driver
+
diff --git a/drivers/misc/sunxi-rf/Makefile b/drivers/misc/sunxi-rf/Makefile
new file mode 100644
index 000000000..adadfe7ee
--- /dev/null
+++ b/drivers/misc/sunxi-rf/Makefile
@@ -0,0 +1,8 @@
+
+#
+# Makefile for wifi bluetooth power controller drivers
+#
+
+sunxi_rfkill-objs := sunxi-modem.o sunxi-bluetooth.o sunxi-wlan.o sunxi-rfkill.o
+
+obj-$(CONFIG_SUNXI_RFKILL)   += sunxi_rfkill.o
diff --git a/drivers/misc/sunxi-rf/internal.h b/drivers/misc/sunxi-rf/internal.h
new file mode 100644
index 000000000..8945985e4
--- /dev/null
+++ b/drivers/misc/sunxi-rf/internal.h
@@ -0,0 +1,35 @@
+/*
+ * drivers/misc/sunxi-rf/internal.h
+ *
+ * Copyright (c) 2014 softwinner.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __INTERNEL_H
+#define __INTERNEL_H
+
+#include <linux/platform_device.h>
+
+void rfkill_poweren_set(int dev, int on_off);
+void rfkill_chipen_set(int dev, int on_off);
+
+int sunxi_wlan_init(struct platform_device *);
+int sunxi_wlan_deinit(struct platform_device *);
+
+int sunxi_bt_init(struct platform_device *);
+int sunxi_bt_deinit(struct platform_device *);
+
+int sunxi_modem_init(struct platform_device *);
+int sunxi_modem_deinit(struct platform_device *);
+
+#endif
diff --git a/drivers/misc/sunxi-rf/sunxi-bluetooth.c b/drivers/misc/sunxi-rf/sunxi-bluetooth.c
new file mode 100644
index 000000000..42a96c04b
--- /dev/null
+++ b/drivers/misc/sunxi-rf/sunxi-bluetooth.c
@@ -0,0 +1,300 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/clk.h>
+#include <linux/rfkill.h>
+#include <linux/regulator/consumer.h>
+#include <linux/platform_device.h>
+#include "internal.h"
+#include "sunxi-rfkill.h"
+
+static struct sunxi_bt_platdata *bluetooth_data;
+static const struct of_device_id sunxi_bt_ids[];
+
+static int sunxi_bt_on(struct sunxi_bt_platdata *data, bool on_off);
+static DEFINE_MUTEX(sunxi_bluetooth_mutex);
+
+void sunxi_bluetooth_set_power(bool on_off)
+{
+	struct platform_device *pdev;
+	int ret = 0;
+
+	if (!bluetooth_data)
+		return;
+
+	pdev = bluetooth_data->pdev;
+	mutex_lock(&sunxi_bluetooth_mutex);
+	rfkill_poweren_set(WL_DEV_BLUETOOTH, on_off);
+	if (on_off != bluetooth_data->power_state) {
+		ret = sunxi_bt_on(bluetooth_data, on_off);
+		if (ret)
+			dev_err(&pdev->dev, "set power failed\n");
+	}
+	rfkill_chipen_set(WL_DEV_BLUETOOTH, on_off);
+	mutex_unlock(&sunxi_bluetooth_mutex);
+}
+EXPORT_SYMBOL_GPL(sunxi_bluetooth_set_power);
+
+static int sunxi_bt_on(struct sunxi_bt_platdata *data, bool on_off)
+{
+	struct platform_device *pdev = data->pdev;
+	struct device *dev = &pdev->dev;
+	int ret = 0, i;
+
+	if (on_off) {
+		for (i = 0; i < CLK_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->clk[i]))
+				clk_prepare_enable(data->clk[i]);
+		}
+
+		for (i = 0; i < PWR_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->power[i])) {
+				if (data->power_vol[i]) {
+					ret = regulator_set_voltage(data->power[i],
+							data->power_vol[i], data->power_vol[i]);
+					if (ret < 0) {
+						dev_err(dev, "bt power[%d] (%s) set voltage failed\n",
+								i, data->power_name[i]);
+						return ret;
+					}
+
+					ret = regulator_get_voltage(data->power[i]);
+					if (ret != data->power_vol[i]) {
+						dev_err(dev, "bt power[%d] (%s) get voltage failed\n",
+								i, data->power_name[i]);
+						return ret;
+					}
+				}
+
+				ret = regulator_enable(data->power[i]);
+				if (ret < 0) {
+					dev_err(dev, "bt power[%d] (%s) enable failed\n",
+								i, data->power_name[i]);
+					return ret;
+				}
+			}
+		}
+
+		if (gpio_is_valid(data->gpio_bt_rst)) {
+			mdelay(10);
+			gpio_set_value(data->gpio_bt_rst, !data->gpio_bt_rst_assert);
+		}
+	} else {
+		if (gpio_is_valid(data->gpio_bt_rst))
+			gpio_set_value(data->gpio_bt_rst, data->gpio_bt_rst_assert);
+
+		for (i = 0; i < PWR_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->power[i])) {
+				ret = regulator_disable(data->power[i]);
+				if (ret < 0) {
+					dev_err(dev, "bt power[%d] (%s) disable failed\n",
+								i, data->power_name[i]);
+					return ret;
+				}
+			}
+		}
+
+		for (i = 0; i < CLK_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->clk[i]))
+				clk_disable_unprepare(data->clk[i]);
+		}
+	}
+
+	data->power_state = on_off;
+	dev_info(dev, "bt power %s success\n", on_off ? "on" : "off");
+
+	return 0;
+}
+
+static int sunxi_bt_set_block(void *data, bool blocked)
+{
+	struct sunxi_bt_platdata *platdata = data;
+	struct platform_device *pdev = platdata->pdev;
+	int ret;
+
+	if (!bluetooth_data)
+		return 0;
+
+	if (blocked != platdata->power_state) {
+		dev_warn(&pdev->dev, "block state already is %d\n", blocked);
+		return 0;
+	}
+
+	dev_info(&pdev->dev, "set block: %d\n", blocked);
+	rfkill_poweren_set(WL_DEV_BLUETOOTH, !blocked);
+	ret = sunxi_bt_on(platdata, !blocked);
+	if (ret) {
+		dev_err(&pdev->dev, "set block failed\n");
+		return ret;
+	}
+
+	rfkill_chipen_set(WL_DEV_BLUETOOTH, !blocked);
+
+	return 0;
+}
+
+static const struct rfkill_ops sunxi_bt_rfkill_ops = {
+	.set_block = sunxi_bt_set_block,
+};
+
+int sunxi_bt_init(struct platform_device *pdev)
+{
+	struct device_node *np = of_find_matching_node(pdev->dev.of_node, sunxi_bt_ids);
+	struct device *dev = &pdev->dev;
+	struct sunxi_bt_platdata *data;
+	enum of_gpio_flags config;
+	int ret = 0;
+	int count, i;
+
+	if (!dev)
+		return -ENOMEM;
+
+	if (!np)
+		return 0;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	data->pdev = pdev;
+
+	count = of_property_count_strings(np, "bt_power");
+	if (count <= 0) {
+		dev_warn(dev, "Missing bt_power.\n");
+	} else {
+		if (count > PWR_MAX) {
+			dev_warn(dev, "bt power count large than max(%d).\n", PWR_MAX);
+			count = PWR_MAX;
+		}
+		ret = of_property_read_string_array(np, "bt_power",
+					(const char **)data->power_name, count);
+		if (ret < 0)
+			return -ENOMEM;
+
+		ret = of_property_read_u32_array(np, "bt_power_vol",
+					(u32 *)data->power_vol, count);
+		if (ret < 0)
+			dev_warn(dev, "Missing bt_power_vol config.\n");
+
+		for (i = 0; i < count; i++) {
+			data->power[i] = regulator_get(dev, data->power_name[i]);
+			if (IS_ERR_OR_NULL(data->power[i]))
+				return -ENOMEM;
+
+			dev_info(dev, "bt power[%d] (%s) voltage: %dmV\n",
+					i, data->power_name[i], data->power_vol[i] / 1000);
+		}
+	}
+
+	count = of_property_count_strings(np, "clock-names");
+	if (count <= 0) {
+		count = CLK_MAX;
+		for (i = 0; i < count; i++) {
+			data->clk[i] = of_clk_get(np, i);
+			if (IS_ERR_OR_NULL(data->clk[i]))
+				break;
+			data->clk_name[i] = devm_kzalloc(dev, 16, GFP_KERNEL);
+			sprintf(data->clk_name[i], "clk%d", i);
+			dev_info(dev, "bt clock[%d] (%s)\n", i, data->clk_name[i]);
+		}
+	} else {
+		if (count > CLK_MAX) {
+			dev_warn(dev, "bt clocks count large than max(%d > %d).\n",
+						count, CLK_MAX);
+			count = CLK_MAX;
+		}
+		ret = of_property_read_string_array(np, "clock-names",
+					(const char **)data->clk_name, count);
+		if (ret < 0)
+			return -ENOMEM;
+
+		for (i = 0; i < count; i++) {
+			data->clk[i] = of_clk_get(np, i);
+			if (IS_ERR_OR_NULL(data->clk[i]))
+				return -ENOMEM;
+			dev_info(dev, "bt clock[%d] (%s)\n", i, data->clk_name[i]);
+		}
+	}
+
+	data->gpio_bt_rst = of_get_named_gpio_flags(np, "bt_rst_n", 0, &config);
+	if (!gpio_is_valid(data->gpio_bt_rst)) {
+		dev_err(dev, "get gpio bt_rst failed\n");
+	} else {
+		data->gpio_bt_rst_assert = (config == OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		dev_info(dev, "bt_rst gpio=%d assert=%d\n", data->gpio_bt_rst, data->gpio_bt_rst_assert);
+
+		ret = devm_gpio_request(dev, data->gpio_bt_rst, "bt_rst");
+		if (ret < 0) {
+			dev_err(dev, "can't request bt_rst gpio %d\n",
+				data->gpio_bt_rst);
+			return ret;
+		}
+
+		ret = gpio_direction_output(data->gpio_bt_rst, data->gpio_bt_rst_assert);
+		if (ret < 0) {
+			dev_err(dev, "can't request output direction bt_rst gpio %d\n",
+				data->gpio_bt_rst);
+			return ret;
+		}
+	}
+
+	data->rfkill = rfkill_alloc("sunxi-bt", dev, RFKILL_TYPE_BLUETOOTH,
+				&sunxi_bt_rfkill_ops, data);
+	if (!data->rfkill)
+		return -ENOMEM;
+
+	rfkill_set_states(data->rfkill, true, false);
+
+	ret = rfkill_register(data->rfkill);
+	if (ret)
+		goto fail_rfkill;
+
+	data->power_state = 0;
+	bluetooth_data = data;
+	return 0;
+
+fail_rfkill:
+	if (data->rfkill)
+		rfkill_destroy(data->rfkill);
+
+	return ret;
+}
+
+int sunxi_bt_deinit(struct platform_device *pdev)
+{
+	struct sunxi_bt_platdata *data = bluetooth_data;
+	struct rfkill *rfk;
+	int i;
+
+	if (!data)
+		return 0;
+
+	rfk = data->rfkill;
+	if (rfk) {
+		rfkill_unregister(rfk);
+		rfkill_destroy(rfk);
+	}
+
+	if (data->power_state)
+		sunxi_bluetooth_set_power(0);
+
+	for (i = 0; i < PWR_MAX; i++) {
+		if (!IS_ERR_OR_NULL(data->power[i]))
+			regulator_put(data->power[i]);
+	}
+
+	bluetooth_data = NULL;
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_bt_ids[] = {
+	{ .compatible = "allwinner,sunxi-bt" },
+	{ /* Sentinel */ }
+};
+
+MODULE_DESCRIPTION("sunxi bluetooth driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/sunxi-rf/sunxi-modem.c b/drivers/misc/sunxi-rf/sunxi-modem.c
new file mode 100644
index 000000000..451864b1f
--- /dev/null
+++ b/drivers/misc/sunxi-rf/sunxi-modem.c
@@ -0,0 +1,264 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/rfkill.h>
+
+#include "sunxi-rfkill.h"
+
+static struct sunxi_modem_platdata *modem_data;
+static const struct of_device_id sunxi_modem_ids[];
+
+static int sunxi_modem_on(struct sunxi_modem_platdata *data, bool on_off);
+static DEFINE_MUTEX(sunxi_modem_mutex);
+
+void sunxi_modem_set_power(bool on_off)
+{
+	struct platform_device *pdev;
+	int ret = 0;
+
+	if (!modem_data)
+		return;
+
+	pdev = modem_data->pdev;
+	mutex_lock(&sunxi_modem_mutex);
+	if (on_off != modem_data->power_state) {
+		ret = sunxi_modem_on(modem_data, on_off);
+		if (ret)
+			dev_err(&pdev->dev, "set power failed\n");
+	}
+	mutex_unlock(&sunxi_modem_mutex);
+}
+EXPORT_SYMBOL_GPL(sunxi_modem_set_power);
+
+static int sunxi_modem_on(struct sunxi_modem_platdata *data, bool on_off)
+{
+	struct platform_device *pdev = data->pdev;
+	struct device *dev = &pdev->dev;
+	int ret = 0, i;
+
+	if (on_off) {
+		for (i = 0; i < PWR_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->power[i])) {
+				if (data->power_vol[i]) {
+					ret = regulator_set_voltage(data->power[i],
+							data->power_vol[i], data->power_vol[i]);
+					if (ret < 0) {
+						dev_err(dev, "modem power[%d] (%s) set voltage failed\n",
+								i, data->power_name[i]);
+						return ret;
+					}
+
+					ret = regulator_get_voltage(data->power[i]);
+					if (ret != data->power_vol[i]) {
+						dev_err(dev, "modem power[%d] (%s) get voltage failed\n",
+								i, data->power_name[i]);
+						return ret;
+					}
+				}
+
+				ret = regulator_enable(data->power[i]);
+				if (ret < 0) {
+					dev_err(dev, "modem power[%d] (%s) enable failed\n",
+								i, data->power_name[i]);
+					return ret;
+				}
+			}
+		}
+
+		if (gpio_is_valid(data->gpio_modem_rst)) {
+			mdelay(10);
+			gpio_set_value(data->gpio_modem_rst, !data->gpio_modem_rst_assert);
+		}
+	} else {
+		if (gpio_is_valid(data->gpio_modem_rst))
+			gpio_set_value(data->gpio_modem_rst, data->gpio_modem_rst_assert);
+
+		for (i = 0; i < PWR_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->power[i])) {
+				ret = regulator_disable(data->power[i]);
+				if (ret < 0) {
+					dev_err(dev, "modem power[%d] (%s) disable failed\n",
+								i, data->power_name[i]);
+					return ret;
+				}
+			}
+		}
+	}
+
+	data->power_state = on_off;
+	dev_info(dev, "modem power %s success\n", on_off ? "on" : "off");
+
+	return 0;
+}
+
+static int sunxi_modem_set_block(void *data, bool blocked)
+{
+	struct sunxi_modem_platdata *platdata = data;
+	struct platform_device *pdev = platdata->pdev;
+	int ret;
+
+	if (!modem_data)
+		return 0;
+
+	if (blocked != platdata->power_state) {
+		dev_warn(&pdev->dev, "block state already is %d\n", blocked);
+		return 0;
+	}
+
+	dev_info(&pdev->dev, "set block: %d\n", blocked);
+	ret = sunxi_modem_on(platdata, !blocked);
+	if (ret) {
+		dev_err(&pdev->dev, "set block failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct rfkill_ops sunxi_modem_rfkill_ops = {
+	.set_block = sunxi_modem_set_block,
+};
+
+int sunxi_modem_init(struct platform_device *pdev)
+{
+	struct device_node *np = of_find_matching_node(pdev->dev.of_node, sunxi_modem_ids);
+	struct device *dev = &pdev->dev;
+	struct sunxi_modem_platdata *data;
+	enum of_gpio_flags config;
+	int ret = 0;
+	int count, i;
+
+	if (!dev)
+		return -ENOMEM;
+
+	if (!np)
+		return 0;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	data->pdev = pdev;
+
+	count = of_property_count_strings(np, "modem_power");
+	if (count <= 0) {
+		dev_warn(dev, "Missing modem_power.\n");
+	} else {
+		if (count > PWR_MAX) {
+			dev_warn(dev, "modem power count large than max(%d > %d).\n",
+				count, PWR_MAX);
+			count = PWR_MAX;
+		}
+		ret = of_property_read_string_array(np, "modem_power",
+					(const char **)data->power_name, count);
+		if (ret < 0)
+			return -ENOMEM;
+
+		ret = of_property_read_u32_array(np, "modem_power_vol",
+					(u32 *)data->power_vol, count);
+		if (ret < 0)
+			dev_warn(dev, "Missing modem_power_vol config.\n");
+
+		for (i = 0; i < count; i++) {
+			data->power[i] = regulator_get(dev, data->power_name[i]);
+			if (IS_ERR_OR_NULL(data->power[i]))
+				return -ENOMEM;
+
+			dev_info(dev, "modem power[%d] (%s) voltage: %dmV\n",
+					i, data->power_name[i], data->power_vol[i] / 1000);
+		}
+	}
+
+	for (i = 0; i < count; i++) {
+		data->power[i] = regulator_get(dev, data->power_name[i]);
+		if (IS_ERR_OR_NULL(data->power[i]))
+			return -ENOMEM;
+		dev_info(dev, "modem power[%d] (%s)\n", i, data->power_name[i]);
+	}
+
+	data->gpio_modem_rst = of_get_named_gpio_flags(np, "modem_rst", 0, &config);
+	if (!gpio_is_valid(data->gpio_modem_rst)) {
+		dev_err(dev, "get gpio modem_rst failed\n");
+	} else {
+		data->gpio_modem_rst_assert = (config == OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		dev_info(dev, "modem_rst gpio=%d assert=%d\n", data->gpio_modem_rst, data->gpio_modem_rst_assert);
+
+		ret = devm_gpio_request(dev, data->gpio_modem_rst, "modem_rst");
+		if (ret < 0) {
+			dev_err(dev, "can't request modem_rst gpio %d\n",
+				data->gpio_modem_rst);
+			return ret;
+		}
+
+		ret = gpio_direction_output(data->gpio_modem_rst, data->gpio_modem_rst_assert);
+		if (ret < 0) {
+			dev_err(dev, "can't request output direction modem_rst gpio %d\n",
+				data->gpio_modem_rst);
+			return ret;
+		}
+		gpio_set_value(data->gpio_modem_rst, data->gpio_modem_rst_assert);
+	}
+
+	data->rfkill = rfkill_alloc("sunxi-modem", dev, RFKILL_TYPE_WWAN,
+				&sunxi_modem_rfkill_ops, data);
+	if (!data->rfkill)
+		ret = -ENOMEM;
+
+	rfkill_set_states(data->rfkill, true, false);
+
+	ret = rfkill_register(data->rfkill);
+	if (ret)
+		goto fail_rfkill;
+
+	data->power_state = 0;
+	modem_data = data;
+	return 0;
+
+fail_rfkill:
+	if (data->rfkill)
+		rfkill_destroy(data->rfkill);
+
+	return ret;
+}
+
+int sunxi_modem_deinit(struct platform_device *pdev)
+{
+	struct sunxi_modem_platdata *data = platform_get_drvdata(pdev);
+	struct rfkill *rfk;
+	int i;
+
+	if (!data)
+		return 0;
+
+	rfk = data->rfkill;
+	if (rfk) {
+		rfkill_unregister(rfk);
+		rfkill_destroy(rfk);
+	}
+
+	if (data->power_state)
+		sunxi_modem_set_power(0);
+
+	for (i = 0; i < PWR_MAX; i++) {
+		if (!IS_ERR_OR_NULL(data->power[i]))
+			regulator_put(data->power[i]);
+	}
+
+	modem_data = NULL;
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_modem_ids[] = {
+	{ .compatible = "allwinner,sunxi-modem" },
+	{ /* Sentinel */ }
+};
+
+MODULE_DESCRIPTION("sunxi modem rfkill driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/sunxi-rf/sunxi-rfkill.c b/drivers/misc/sunxi-rf/sunxi-rfkill.c
new file mode 100644
index 000000000..a2ff37f26
--- /dev/null
+++ b/drivers/misc/sunxi-rf/sunxi-rfkill.c
@@ -0,0 +1,197 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/capability.h>
+#include "internal.h"
+#include "sunxi-rfkill.h"
+
+#define MODULE_CUR_VERSION   "v1.0.9"
+
+static struct sunxi_rfkill_platdata *rfkill_data;
+
+void rfkill_chipen_set(int dev, int on_off)
+{
+	/* Only wifi and bt both close, chip_en goes down,
+	 * otherwise, set chip_en up to keep module work.
+	 * dev   : device to set power status. 0: wifi, 1: bt
+	 * on_off: power status to set. 0: off, 1: on
+	 */
+	static int power_state;
+	bool set_val;
+
+	if (!rfkill_data)
+		return;
+
+	if (dev == WL_DEV_WIFI || dev == WL_DEV_BLUETOOTH) {
+		power_state &= ~(1 << dev);
+		power_state |= ((on_off > 0) << dev);
+	}
+
+	if (gpio_is_valid(rfkill_data->gpio_chip_en)) {
+		set_val = (power_state != 0) ?
+					 rfkill_data->gpio_chip_en_assert :
+					!rfkill_data->gpio_chip_en_assert;
+		gpio_set_value(rfkill_data->gpio_chip_en, set_val);
+	}
+}
+
+void rfkill_poweren_set(int dev, int on_off)
+{
+	/* Only wifi and bt both close, power_en goes down,
+	 * otherwise, set power_en up to keep module work.
+	 * dev   : device to set power status. 0: wifi, 1: bt
+	 * on_off: power status to set. 0: off, 1: on
+	 */
+	static int power_state;
+	bool set_val;
+
+	if (!rfkill_data)
+		return;
+
+	if (dev == WL_DEV_WIFI || dev == WL_DEV_BLUETOOTH) {
+		power_state &= ~(1 << dev);
+		power_state |= ((on_off > 0) << dev);
+	}
+
+	if (gpio_is_valid(rfkill_data->gpio_power_en)) {
+		set_val = (power_state != 0) ?
+					 rfkill_data->gpio_power_en_assert :
+					!rfkill_data->gpio_power_en_assert;
+		gpio_set_value(rfkill_data->gpio_power_en, set_val);
+	}
+}
+
+static int rfkill_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct sunxi_rfkill_platdata *data;
+	enum of_gpio_flags config;
+	char *pctrl_name = PINCTRL_STATE_DEFAULT;
+	struct pinctrl_state *pctrl_state = NULL;
+	int ret = 0;
+
+	if (!dev)
+		return -ENOMEM;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+
+	dev_info(dev, "module version: %s\n", MODULE_CUR_VERSION);
+	data->pctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(data->pctrl)) {
+		dev_warn(dev, "devm_pinctrl_get() failed!\n");
+	} else {
+		pctrl_state = pinctrl_lookup_state(data->pctrl, pctrl_name);
+		if (IS_ERR(pctrl_state)) {
+			dev_warn(dev, "pinctrl_lookup_state(%s) failed! return %p \n",
+					pctrl_name, pctrl_state);
+		} else {
+			ret = pinctrl_select_state(data->pctrl, pctrl_state);
+			if (ret < 0) {
+				dev_warn(dev, "pinctrl_select_state(%s) failed! return %d \n",
+						pctrl_name, ret);
+			}
+		}
+	}
+
+	data->gpio_chip_en = of_get_named_gpio_flags(np, "chip_en", 0, &config);
+	if (!gpio_is_valid(data->gpio_chip_en)) {
+		dev_err(dev, "get gpio chip_en failed\n");
+	} else {
+		data->gpio_chip_en_assert = (config == OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		dev_info(dev, "chip_en gpio=%d assert=%d\n", data->gpio_chip_en, data->gpio_chip_en_assert);
+
+		ret = devm_gpio_request(dev, data->gpio_chip_en, "chip_en");
+		if (ret < 0) {
+			dev_err(dev, "can't request chip_en gpio %d\n",
+				data->gpio_chip_en);
+			return ret;
+		}
+
+		ret = gpio_direction_output(data->gpio_chip_en, !data->gpio_chip_en_assert);
+		if (ret < 0) {
+			dev_err(dev, "can't request output direction chip_en gpio %d\n",
+				data->gpio_chip_en);
+			return ret;
+		}
+	}
+
+	data->gpio_power_en = of_get_named_gpio_flags(np, "power_en", 0, &config);
+	if (!gpio_is_valid(data->gpio_power_en)) {
+		dev_err(dev, "get gpio power_en failed\n");
+	} else {
+		data->gpio_power_en_assert = (config == OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		dev_info(dev, "power_en gpio=%d assert=%d\n", data->gpio_power_en, data->gpio_power_en_assert);
+
+		ret = devm_gpio_request(dev, data->gpio_power_en, "power_en");
+		if (ret < 0) {
+			dev_err(dev, "can't request power_en gpio %d\n",
+				data->gpio_power_en);
+			return ret;
+		}
+
+		ret = gpio_direction_output(data->gpio_power_en, !data->gpio_power_en);
+		if (ret < 0) {
+			dev_err(dev, "can't request output direction power_en gpio %d\n",
+				data->gpio_power_en);
+			return ret;
+		}
+	}
+
+	ret = sunxi_wlan_init(pdev);
+	if (ret)
+		goto err_wlan;
+
+	ret = sunxi_bt_init(pdev);
+	if (ret)
+		goto err_bt;
+
+	ret = sunxi_modem_init(pdev);
+	if (ret)
+		goto err_modem;
+
+	rfkill_data = data;
+	return 0;
+
+err_modem:
+	sunxi_bt_deinit(pdev);
+err_bt:
+	sunxi_wlan_deinit(pdev);
+err_wlan:
+	return ret;
+}
+
+static int rfkill_remove(struct platform_device *pdev)
+{
+	sunxi_modem_deinit(pdev);
+	sunxi_bt_deinit(pdev);
+	sunxi_wlan_deinit(pdev);
+	rfkill_data = NULL;
+	return 0;
+}
+
+static const struct of_device_id rfkill_ids[] = {
+	{ .compatible = "allwinner,sunxi-rfkill" },
+	{ /* Sentinel */ }
+};
+
+static struct platform_driver rfkill_driver = {
+	.probe  = rfkill_probe,
+	.remove = rfkill_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "sunxi-rfkill",
+		.of_match_table = rfkill_ids,
+	},
+};
+
+module_platform_driver_probe(rfkill_driver, rfkill_probe);
+
+MODULE_DESCRIPTION("sunxi rfkill driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/sunxi-rf/sunxi-rfkill.h b/drivers/misc/sunxi-rf/sunxi-rfkill.h
new file mode 100644
index 000000000..f58768a18
--- /dev/null
+++ b/drivers/misc/sunxi-rf/sunxi-rfkill.h
@@ -0,0 +1,95 @@
+/*
+ * drivers/misc/sunxi-rf/sunxi-rfkill.h
+ *
+ * Copyright (c) 2014 softwinner.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SUNXI_RFKILL_H
+#define __SUNXI_RFKILL_H
+
+#include <linux/regulator/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/rfkill.h>
+
+#define WL_DEV_WIFI            0  /* bit0 */
+#define WL_DEV_BLUETOOTH       1  /* bit1 */
+
+#define CLK_MAX                5
+#define PWR_MAX                5
+
+struct sunxi_rfkill_platdata {
+	struct pinctrl *pctrl;
+	int gpio_power_en;
+	bool gpio_power_en_assert;
+	int gpio_chip_en;
+	bool gpio_chip_en_assert;
+};
+
+struct sunxi_modem_platdata {
+	struct regulator *power[PWR_MAX];
+	char  *power_name[PWR_MAX];
+	u32    power_vol[PWR_MAX];
+
+	int gpio_modem_rst;
+	bool gpio_modem_rst_assert;
+
+	bool power_state;
+	struct rfkill *rfkill;
+	struct platform_device *pdev;
+};
+
+struct sunxi_bt_platdata {
+	struct regulator *power[PWR_MAX];
+	char  *power_name[PWR_MAX];
+	u32    power_vol[PWR_MAX];
+
+	struct clk *clk[CLK_MAX];
+	char  *clk_name[CLK_MAX];
+
+	int gpio_bt_rst;
+	bool gpio_bt_rst_assert;
+
+	int power_state;
+	struct rfkill *rfkill;
+	struct platform_device *pdev;
+};
+
+struct sunxi_wlan_platdata {
+	unsigned int wakeup_enable;
+	int bus_index;
+
+	struct regulator *power[PWR_MAX];
+	char  *power_name[PWR_MAX];
+	u32    power_vol[PWR_MAX];
+
+	struct clk *clk[CLK_MAX];
+	char  *clk_name[CLK_MAX];
+
+	int gpio_wlan_regon;
+	bool gpio_wlan_regon_assert;
+	int gpio_wlan_hostwake;
+	bool gpio_wlan_hostwake_assert;
+
+	int power_state;
+	struct platform_device *pdev;
+};
+
+void sunxi_wlan_set_power(bool on_off);
+int  sunxi_wlan_get_bus_index(void);
+int  sunxi_wlan_get_oob_irq(int *irq_flags, int *wakeup_enable);
+void sunxi_bluetooth_set_power(bool on_off);
+void sunxi_modem_set_power(bool on_off);
+
+#endif /* SUNXI_RFKILL_H */
diff --git a/drivers/misc/sunxi-rf/sunxi-wlan.c b/drivers/misc/sunxi-rf/sunxi-wlan.c
new file mode 100644
index 000000000..98ef08e90
--- /dev/null
+++ b/drivers/misc/sunxi-rf/sunxi-wlan.c
@@ -0,0 +1,456 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/rfkill.h>
+#include <linux/regulator/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/capability.h>
+#include <linux/pm_wakeirq.h>
+#include "internal.h"
+#include "sunxi-rfkill.h"
+
+static struct sunxi_wlan_platdata *wlan_data;
+static const struct of_device_id sunxi_wlan_ids[];
+
+static int sunxi_wlan_on(struct sunxi_wlan_platdata *data, bool on_off);
+static DEFINE_MUTEX(sunxi_wlan_mutex);
+
+#if IS_ENABLED(CONFIG_MMC_SUNXI)
+extern void sunxi_mmc_rescan_card(unsigned ids);
+#else
+static void sunxi_mmc_rescan_card(unsigned ids)
+{
+	(void)ids;
+}
+#endif
+
+void sunxi_wlan_set_power(bool on_off)
+{
+	struct platform_device *pdev;
+	int ret = 0;
+
+	if (!wlan_data)
+		return;
+
+	pdev = wlan_data->pdev;
+	mutex_lock(&sunxi_wlan_mutex);
+	rfkill_poweren_set(WL_DEV_WIFI, on_off);
+	if (on_off != wlan_data->power_state) {
+		ret = sunxi_wlan_on(wlan_data, on_off);
+		if (ret)
+			dev_err(&pdev->dev, "set power failed\n");
+	}
+
+	rfkill_chipen_set(WL_DEV_WIFI, on_off);
+
+	mutex_unlock(&sunxi_wlan_mutex);
+}
+EXPORT_SYMBOL_GPL(sunxi_wlan_set_power);
+
+int sunxi_wlan_get_bus_index(void)
+{
+	struct platform_device *pdev;
+
+	if (!wlan_data)
+		return -EINVAL;
+
+	pdev = wlan_data->pdev;
+	dev_info(&pdev->dev, "bus_index: %d\n", wlan_data->bus_index);
+	return wlan_data->bus_index;
+}
+EXPORT_SYMBOL_GPL(sunxi_wlan_get_bus_index);
+
+int sunxi_wlan_get_oob_irq(int *irq_flags, int *wakup_enable)
+{
+	struct platform_device *pdev;
+	int host_oob_irq = 0;
+	int oob_irq_flags = 0;
+
+	if (!wlan_data || !gpio_is_valid(wlan_data->gpio_wlan_hostwake))
+		return 0;
+
+	pdev = wlan_data->pdev;
+
+	host_oob_irq = gpio_to_irq(wlan_data->gpio_wlan_hostwake);
+	if (host_oob_irq < 0)
+		dev_err(&pdev->dev, "map gpio [%d] to virq failed, errno = %d\n",
+			wlan_data->gpio_wlan_hostwake, host_oob_irq);
+
+	oob_irq_flags = IRQF_SHARED;
+	if (wlan_data->gpio_wlan_hostwake_assert)
+		oob_irq_flags |= IRQF_TRIGGER_RISING;
+	else
+		oob_irq_flags |= IRQF_TRIGGER_LOW;
+
+	oob_irq_flags |= IRQF_NO_SUSPEND;
+	*irq_flags = oob_irq_flags;
+	*wakup_enable = wlan_data->wakeup_enable;
+
+	return host_oob_irq;
+}
+EXPORT_SYMBOL_GPL(sunxi_wlan_get_oob_irq);
+
+static int sunxi_wlan_on(struct sunxi_wlan_platdata *data, bool on_off)
+{
+	struct platform_device *pdev = data->pdev;
+	struct device *dev = &pdev->dev;
+	int ret = 0, i;
+
+	if (on_off) {
+		for (i = 0; i < CLK_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->clk[i]))
+				clk_prepare_enable(data->clk[i]);
+		}
+
+		for (i = 0; i < PWR_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->power[i])) {
+				if (data->power_vol[i]) {
+					ret = regulator_set_voltage(data->power[i],
+							data->power_vol[i], data->power_vol[i]);
+					if (ret < 0) {
+						dev_err(dev, "wlan power[%d] (%s) set voltage failed\n",
+									i, data->power_name[i]);
+						return ret;
+					}
+
+					ret = regulator_get_voltage(data->power[i]);
+					if (ret != data->power_vol[i]) {
+						dev_err(dev, "wlan power[%d] (%s) get voltage failed\n",
+								i, data->power_name[i]);
+						return ret;
+					}
+				}
+
+				ret = regulator_enable(data->power[i]);
+				if (ret < 0) {
+					dev_err(dev, "wlan power[%d] (%s) enable failed\n",
+								i, data->power_name[i]);
+					return ret;
+				}
+			}
+		}
+
+		if (gpio_is_valid(data->gpio_wlan_regon)) {
+			mdelay(10);
+			gpio_set_value(data->gpio_wlan_regon, data->gpio_wlan_regon_assert);
+		}
+	} else {
+		if (gpio_is_valid(data->gpio_wlan_regon))
+			gpio_set_value(data->gpio_wlan_regon, !data->gpio_wlan_regon_assert);
+
+		for (i = 0; i < PWR_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->power[i])) {
+				ret = regulator_disable(data->power[i]);
+				if (ret < 0) {
+					dev_err(dev, "wlan power[%d] (%s) disable failed\n",
+								i, data->power_name[i]);
+					return ret;
+				}
+			}
+		}
+
+		for (i = 0; i < CLK_MAX; i++) {
+			if (!IS_ERR_OR_NULL(data->clk[i]))
+				clk_disable_unprepare(data->clk[i]);
+		}
+	}
+
+	wlan_data->power_state = on_off;
+	dev_info(dev, "wlan power %s success\n", on_off ? "on" : "off");
+
+	return 0;
+}
+
+static ssize_t power_state_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	if (!wlan_data)
+		return 0;
+	return sprintf(buf, "%d\n", wlan_data->power_state);
+}
+
+static ssize_t power_state_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long state;
+	int err;
+
+	if (!wlan_data)
+		return 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = kstrtoul(buf, 0, &state);
+	if (err)
+		return err;
+
+	if (state > 1)
+		return -EINVAL;
+
+	if (state != wlan_data->power_state) {
+		sunxi_wlan_set_power(state);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(power_state, S_IRUGO | S_IWUSR,
+		power_state_show, power_state_store);
+
+static ssize_t scan_device_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long state;
+	int err;
+	int bus = wlan_data->bus_index;
+
+	if (!wlan_data)
+		return 0;
+
+	err = kstrtoul(buf, 0, &state);
+	if (err)
+		return err;
+
+	dev_info(dev, "start scan device on bus_index: %d\n",
+			wlan_data->bus_index);
+	if (bus < 0) {
+		dev_err(dev, "scan device fail!\n");
+		return -1;
+	}
+	sunxi_mmc_rescan_card(bus);
+
+	return count;
+}
+
+static DEVICE_ATTR(scan_device, S_IRUGO | S_IWUSR,
+		NULL, scan_device_store);
+
+static struct attribute *misc_attributes[] = {
+	&dev_attr_power_state.attr,
+	&dev_attr_scan_device.attr,
+	NULL,
+};
+
+static struct attribute_group misc_attribute_group = {
+	.name  = "rf-ctrl",
+	.attrs = misc_attributes,
+};
+
+static struct miscdevice sunxi_wlan_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name  = "sunxi-wlan",
+};
+
+int sunxi_wlan_init(struct platform_device *pdev)
+{
+	struct device_node *np = of_find_matching_node(pdev->dev.of_node, sunxi_wlan_ids);
+	struct device *dev = &pdev->dev;
+	struct sunxi_wlan_platdata *data;
+	enum of_gpio_flags config;
+	u32 val;
+	int ret = 0;
+	int count, i;
+
+	if (!dev)
+		return -ENOMEM;
+
+	if (!np)
+		return 0;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+
+	data->pdev = pdev;
+
+	data->bus_index = -1;
+	if (!of_property_read_u32(np, "wlan_busnum", &val)) {
+		switch (val) {
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+			data->bus_index = val;
+			break;
+		default:
+			dev_err(dev, "unsupported wlan_busnum (%u)\n", val);
+			return -EINVAL;
+		}
+	}
+	dev_info(dev, "wlan_busnum (%u)\n", val);
+
+	count = of_property_count_strings(np, "wlan_power");
+	if (count <= 0) {
+		dev_warn(dev, "Missing wlan_power.\n");
+	} else {
+		if (count > PWR_MAX) {
+			dev_warn(dev, "wlan power count large than max(%d > %d).\n",
+						count, PWR_MAX);
+			count = PWR_MAX;
+		}
+		ret = of_property_read_string_array(np, "wlan_power",
+					(const char **)data->power_name, count);
+		if (ret < 0)
+			return -ENOMEM;
+
+		ret = of_property_read_u32_array(np, "wlan_power_vol",
+					(u32 *)data->power_vol, count);
+		if (ret < 0)
+			dev_warn(dev, "Missing wlan_power_vol config.\n");
+
+		for (i = 0; i < count; i++) {
+			data->power[i] = regulator_get(dev, data->power_name[i]);
+
+			if (IS_ERR_OR_NULL(data->power[i]))
+				return -ENOMEM;
+
+			dev_info(dev, "wlan power[%d] (%s) voltage: %dmV\n",
+					i, data->power_name[i], data->power_vol[i] / 1000);
+		}
+	}
+
+	count = of_property_count_strings(np, "clock-names");
+	if (count <= 0) {
+		count = CLK_MAX;
+		for (i = 0; i < count; i++) {
+			data->clk[i] = of_clk_get(np, i);
+			if (IS_ERR_OR_NULL(data->clk[i]))
+				break;
+			data->clk_name[i] = devm_kzalloc(dev, 16, GFP_KERNEL);
+			sprintf(data->clk_name[i], "clk%d", i);
+			dev_info(dev, "wlan clock[%d] (%s)\n", i, data->clk_name[i]);
+		}
+	} else {
+		if (count > CLK_MAX) {
+			dev_warn(dev, "wlan clocks count large than max(%d).\n", CLK_MAX);
+			count = CLK_MAX;
+		}
+		ret = of_property_read_string_array(np, "clock-names",
+					(const char **)data->clk_name, count);
+		if (ret < 0)
+			return -ENOMEM;
+
+		for (i = 0; i < count; i++) {
+			data->clk[i] = of_clk_get(np, i);
+			if (IS_ERR_OR_NULL(data->clk[i]))
+				return -ENOMEM;
+			dev_info(dev, "wlan clock[%d] (%s)\n", i, data->clk_name[i]);
+		}
+	}
+
+	data->gpio_wlan_regon = of_get_named_gpio_flags(np, "wlan_regon", 0, &config);
+	if (!gpio_is_valid(data->gpio_wlan_regon)) {
+		dev_err(dev, "get gpio wlan_regon failed\n");
+	} else {
+		data->gpio_wlan_regon_assert = (config == OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		dev_info(dev, "wlan_regon gpio=%d assert=%d\n", data->gpio_wlan_regon, data->gpio_wlan_regon_assert);
+
+		ret = devm_gpio_request(dev, data->gpio_wlan_regon,
+				"wlan_regon");
+		if (ret < 0) {
+			dev_err(dev, "can't request wlan_regon gpio %d\n",
+				data->gpio_wlan_regon);
+			return ret;
+		}
+
+		ret = gpio_direction_output(data->gpio_wlan_regon, !data->gpio_wlan_regon_assert);
+		if (ret < 0) {
+			dev_err(dev, "can't request output direction wlan_regon gpio %d\n",
+				data->gpio_wlan_regon);
+			return ret;
+		}
+	}
+
+	data->gpio_wlan_hostwake = of_get_named_gpio_flags(np, "wlan_hostwake", 0, &config);
+	if (!gpio_is_valid(data->gpio_wlan_hostwake)) {
+		dev_err(dev, "get gpio wlan_hostwake failed\n");
+	} else {
+		data->gpio_wlan_hostwake_assert = (config == OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		dev_info(dev, "wlan_hostwake gpio=%d assert=%d\n", data->gpio_wlan_hostwake, data->gpio_wlan_hostwake_assert);
+
+		ret = devm_gpio_request(dev, data->gpio_wlan_hostwake,
+				"wlan_hostwake");
+		if (ret < 0) {
+			dev_err(dev, "can't request wlan_hostwake gpio %d\n",
+				data->gpio_wlan_hostwake);
+			return ret;
+		}
+
+		ret = gpio_direction_input(data->gpio_wlan_hostwake);
+		if (ret < 0) {
+			dev_err(dev,
+				"can't request input direction wlan_hostwake gpio %d\n",
+				data->gpio_wlan_hostwake);
+			return ret;
+		}
+
+		/*
+		 * wakeup_source relys on wlan_hostwake, if wlan_hostwake gpio
+		 * isn't configured, then whether wakeup_source is configured
+		 * or not is unmeaningful.
+		 */
+		if (!of_property_read_bool(np, "wakeup-source")) {
+			dev_info(dev, "wakeup source is disbled!\n");
+		} else {
+			dev_info(dev, "wakeup source is enabled\n");
+			data->wakeup_enable = 1;
+		}
+	}
+
+	ret = misc_register(&sunxi_wlan_dev);
+	if (ret) {
+		dev_err(dev, "sunxi-wlan register driver as misc device error!\n");
+		return ret;
+	}
+	ret = sysfs_create_group(&sunxi_wlan_dev.this_device->kobj,
+			&misc_attribute_group);
+	if (ret) {
+		dev_err(dev, "sunxi-wlan register sysfs create group failed!\n");
+		return ret;
+	}
+
+	data->power_state = 0;
+	wlan_data = data;
+	return 0;
+}
+
+int sunxi_wlan_deinit(struct platform_device *pdev)
+{
+	struct sunxi_wlan_platdata *data = wlan_data;
+	int i;
+
+	if (!data)
+		return 0;
+
+	sysfs_remove_group(&(sunxi_wlan_dev.this_device->kobj),
+			&misc_attribute_group);
+	misc_deregister(&sunxi_wlan_dev);
+
+	if (data->power_state)
+		sunxi_wlan_set_power(0);
+
+	for (i = 0; i < PWR_MAX; i++) {
+		if (!IS_ERR_OR_NULL(data->power[i]))
+			regulator_put(data->power[i]);
+	}
+
+	wlan_data = NULL;
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_wlan_ids[] = {
+	{ .compatible = "allwinner,sunxi-wlan" },
+	{ /* Sentinel */ }
+};
+
+MODULE_DESCRIPTION("sunxi wlan driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/sunxi-tvutils/Kconfig b/drivers/misc/sunxi-tvutils/Kconfig
new file mode 100644
index 000000000..a44c7d98a
--- /dev/null
+++ b/drivers/misc/sunxi-tvutils/Kconfig
@@ -0,0 +1,26 @@
+#
+# sunxi system information driver.
+#
+#
+config SUNXI_MIPSLOADER
+	bool "enable sunxi mips firmware loader driver"
+	depends on (ARCH_SUNXI)
+	default n
+	help
+	  Choose Y to enable sunxi mips firmware loader driver
+
+config SUNXI_TVUTILS
+	bool "enable sunxi tv subsystem utils driver"
+	depends on (ARCH_SUNXI)
+	default n
+	help
+	  Choose Y to enable sunxi tv subsystem utils driver
+
+config SUNXI_ARISC_RPM
+	bool "enable sunxi remote processor messaging driver for arisc"
+	depends on (ARCH_SUNXI)
+    depends on (RPMSG_SUNXI_AMP)
+	default n
+	help
+	  Choose Y to enable sunxi remote processor messaging driver for arisc
+
diff --git a/drivers/misc/sunxi-tvutils/Makefile b/drivers/misc/sunxi-tvutils/Makefile
new file mode 100644
index 000000000..ea6529e68
--- /dev/null
+++ b/drivers/misc/sunxi-tvutils/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for sunxi tv subsystem drivers
+#
+
+obj-$(CONFIG_SUNXI_MIPSLOADER) += mipsloader.o
+obj-$(CONFIG_SUNXI_TVUTILS)    += tvutils.o
+obj-$(CONFIG_SUNXI_ARISC_RPM)  += arisc_rpm/
+
diff --git a/drivers/misc/sunxi-tvutils/arisc_rpm/Makefile b/drivers/misc/sunxi-tvutils/arisc_rpm/Makefile
new file mode 100644
index 000000000..700fca459
--- /dev/null
+++ b/drivers/misc/sunxi-tvutils/arisc_rpm/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for sunxi tv subsystem drivers
+#
+#
+obj-$(CONFIG_SUNXI_ARISC_RPM)  += sunxi_arisc_rpm.o
+
diff --git a/drivers/misc/sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.c b/drivers/misc/sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.c
new file mode 100644
index 000000000..9be048cb2
--- /dev/null
+++ b/drivers/misc/sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.c
@@ -0,0 +1,297 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020, allwinnertech.
+ * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rpmsg.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+
+#include "sunxi_arisc_rpm.h"
+
+#define MSG_BLOCK_CACHED_SIZE (32)
+
+enum rpm_received_state {
+	RPM_RECEIVED_IDLE,
+	RPM_RECEIVED_HEADER,
+	RPM_RECEIVED_PAYLOAD,
+};
+
+struct rpm_msg_block {
+	struct list_head link;
+	uint8_t type;
+	uint8_t length;
+	uint8_t payload[MAX_PAYLOAD_SIZE];
+};
+
+struct rpm_received_info {
+	int state;
+	int received_length;
+	struct rpm_msg_block *msg_block;
+};
+
+struct sunxi_rpm_private {
+	struct mutex mutex;
+	struct rpmsg_device *sunxi_arisc_rpmsg_device;
+
+	uint8_t seqnumber;
+	sunxi_arisc_message_cb received_cb;
+	struct rpm_received_info received_info;
+
+	spinlock_t list_lock;
+	struct list_head free_list_head;
+	struct list_head ready_list;
+
+	struct work_struct received_notify_work;
+};
+
+struct sunxi_rpm_private *rpm_private;
+
+static void message_block_init(struct sunxi_rpm_private *rpm)
+{
+	int i = 0;
+	struct rpm_msg_block *block;
+
+	INIT_LIST_HEAD(&rpm->free_list_head);
+	INIT_LIST_HEAD(&rpm->ready_list);
+
+	while (i < MSG_BLOCK_CACHED_SIZE) {
+		block = kmalloc(sizeof(struct rpm_msg_block), GFP_KERNEL | __GFP_ZERO);
+		if (IS_ERR_OR_NULL(block)) {
+			pr_err("kmalloc rpm_msg_block failed!\n");
+			return;
+		}
+		list_add(&block->link, &rpm->free_list_head);
+		i++;
+	}
+}
+
+static void message_block_destroy(struct sunxi_rpm_private *rpm)
+{
+	struct rpm_msg_block *block, *next;
+
+	list_for_each_entry_safe(block, next, &rpm_private->free_list_head, link) {
+		list_del(&block->link);
+		kfree(block);
+	}
+}
+
+static inline struct rpm_msg_block *alloc_msg_block(void)
+{
+	unsigned long flags;
+	struct rpm_msg_block *block = NULL;
+
+	spin_lock_irqsave(&rpm_private->list_lock, flags);
+	if (!list_empty(&rpm_private->free_list_head)) {
+		block = list_first_entry(&rpm_private->free_list_head, struct rpm_msg_block, link);
+		list_del_init(&block->link);
+	}
+	spin_unlock_irqrestore(&rpm_private->list_lock, flags);
+
+	return block;
+}
+
+static inline void free_msg_block(struct rpm_msg_block *block)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&rpm_private->list_lock, flags);
+	list_add(&block->link, &rpm_private->free_list_head);
+	spin_unlock_irqrestore(&rpm_private->list_lock, flags);
+}
+
+void sunxi_arisc_rpm_register_message_callback(sunxi_arisc_message_cb cb)
+{
+	mutex_lock(&rpm_private->mutex);
+	rpm_private->received_cb = cb;
+	mutex_unlock(&rpm_private->mutex);
+}
+EXPORT_SYMBOL(sunxi_arisc_rpm_register_message_callback);
+
+int sunxi_arisc_rpm_send(uint8_t type, uint8_t length, const uint8_t *pdata)
+{
+	int ret, i = 0;
+	struct message_amp *msg;
+	int size = sizeof(struct message_amp) + length;
+
+	msg = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
+	if (IS_ERR_OR_NULL(msg)) {
+		return -ENOMEM;
+	}
+	msg->magic = MESSAGE_AMP_MAGIC;
+	msg->type  = type;
+	msg->count = length;
+
+	while (i < length) {
+		msg->paras[i] = pdata[i];
+		i++;
+	}
+
+	mutex_lock(&rpm_private->mutex);
+	msg->seqnumber = rpm_private->seqnumber++;
+	ret = rpmsg_send(rpm_private->sunxi_arisc_rpmsg_device->ept, msg, size);
+	mutex_unlock(&rpm_private->mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_arisc_rpm_send);
+
+
+static void notify_msg(struct rpm_msg_block *block)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&rpm_private->list_lock, flags);
+	list_add_tail(&block->link, &rpm_private->ready_list);
+	spin_unlock_irqrestore(&rpm_private->list_lock, flags);
+
+	schedule_work(&rpm_private->received_notify_work);
+}
+
+/* call from interrupt context!!! */
+static int sunxi_arisc_rpm_cb(struct rpmsg_device *rpdev, void *data, int len,
+		void *priv, u32 src)
+{
+	struct rpm_received_info *info;
+	uint32_t rx, i;
+	uint8_t magic;
+
+	if (len != 4) {
+		dev_err(&rpdev->dev, "invalid rpm length from endpoint addr: 0x%08x\n", rpdev->ept->addr);
+		return -1;
+	}
+
+	rx = *(uint32_t *)data;
+	info = &rpm_private->received_info;
+
+	switch (info->state) {
+	case RPM_RECEIVED_IDLE:
+		magic = rx & 0xff;
+		if (magic == MESSAGE_AMP_MAGIC) {
+			info->msg_block = alloc_msg_block();
+			if (IS_ERR_OR_NULL(info->msg_block)) {
+				pr_err("alloc rpm msg block failed!\n");
+				break;
+			}
+			info->received_length = 0;
+			info->state = RPM_RECEIVED_HEADER;
+
+			info->msg_block->type	= (uint8_t)((rx >> 16) & 0xff);
+			info->msg_block->length = (uint8_t)((rx >> 24) & 0xff);
+		}
+		pr_debug("rpm header: %08x\n", rx);
+		break;
+	case RPM_RECEIVED_HEADER:
+		if (info->msg_block->length == 0) {
+			// zero length payload message.
+			notify_msg(info->msg_block);
+			info->msg_block = NULL;
+			info->state = RPM_RECEIVED_IDLE;
+		} else
+			info->state = RPM_RECEIVED_PAYLOAD;
+
+		break;
+	case RPM_RECEIVED_PAYLOAD:
+		i = 0;
+		while (i < 4) {
+			info->msg_block->payload[info->received_length++] = (rx >> (i * 8)) & 0xFF;
+			if (info->received_length >= info->msg_block->length)
+				break;
+			i++;
+		}
+		if (info->received_length == info->msg_block->length) {
+			notify_msg(info->msg_block);
+			info->msg_block = NULL;
+			info->state = RPM_RECEIVED_IDLE;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void sunxi_arisc_rpm_received_worker(struct work_struct *work)
+{
+	unsigned long flags;
+	struct list_head tmp;
+	struct rpm_msg_block *block, *next;
+
+	spin_lock_irqsave(&rpm_private->list_lock, flags);
+	list_replace_init(&rpm_private->ready_list, &tmp);
+	spin_unlock_irqrestore(&rpm_private->list_lock, flags);
+
+	list_for_each_entry_safe(block, next, &tmp, link) {
+		list_del(&block->link);
+		if (rpm_private->received_cb) {
+			rpm_private->received_cb(block->type, block->length, block->payload);
+		}
+		print_hex_dump_debug("	", DUMP_PREFIX_OFFSET, 16, 1, block->payload, block->length, false);
+		free_msg_block(block);
+	}
+}
+
+static int sunxi_arisc_rpm_probe(struct rpmsg_device *rpdev)
+{
+	dev_info(&rpdev->dev, "create rpmsg channel: 0x%x -> 0x%x!\n",
+			rpdev->src, rpdev->dst);
+
+	rpm_private = kmalloc(sizeof(struct sunxi_rpm_private), GFP_KERNEL | __GFP_ZERO);
+	if (IS_ERR_OR_NULL(rpm_private)) {
+		return -ENOMEM;
+	}
+
+	rpm_private->sunxi_arisc_rpmsg_device = rpdev;
+	rpm_private->seqnumber = 0;
+	rpm_private->received_cb = NULL;
+
+	rpm_private->received_info.state = RPM_RECEIVED_IDLE;
+	rpm_private->received_info.received_length = 0;
+	rpm_private->received_info.msg_block = NULL;
+
+	message_block_init(rpm_private);
+
+	INIT_WORK(&rpm_private->received_notify_work, sunxi_arisc_rpm_received_worker);
+
+	spin_lock_init(&rpm_private->list_lock);
+	mutex_init(&rpm_private->mutex);
+
+	return 0;
+}
+
+static void sunxi_arisc_rpm_remove(struct rpmsg_device *rpdev)
+{
+	if (rpm_private) {
+		flush_work(&rpm_private->received_notify_work);
+		cancel_work_sync(&rpm_private->received_notify_work);
+
+		message_block_destroy(rpm_private);
+		kfree(rpm_private);
+	}
+
+	dev_info(&rpdev->dev, "rpmsg sample client driver is removed\n");
+}
+
+static struct rpmsg_device_id rpmsg_driver_id_table[] = {
+	{ .name = "sunxi,cpus-msgbox" },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_driver_id_table);
+
+static struct rpmsg_driver sunxi_arisc_rpm_client = {
+	.drv.name = KBUILD_MODNAME,
+	.id_table = rpmsg_driver_id_table,
+	.probe	  = sunxi_arisc_rpm_probe,
+	.callback = sunxi_arisc_rpm_cb,
+	.remove   = sunxi_arisc_rpm_remove,
+};
+
+module_rpmsg_driver(sunxi_arisc_rpm_client);
+MODULE_DESCRIPTION("sunxi arisc remote processor messaging client driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/misc/sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.h b/drivers/misc/sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.h
new file mode 100644
index 000000000..b88742694
--- /dev/null
+++ b/drivers/misc/sunxi-tvutils/arisc_rpm/sunxi_arisc_rpm.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020, allwinnertech.
+ * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ */
+
+#ifndef _SUNXI_ARISC_RPM_H_
+#define _SUNXI_ARISC_RPM_H_
+
+#define MAX_PAYLOAD_SIZE 128
+#define MESSAGE_AMP_MAGIC 0xA5
+
+#define MESSAGE_TYPE_BASE 0x00
+#define MESSAGE_TYPE_TEST (MESSAGE_TYPE_BASE + 0x01)
+
+typedef struct message_amp {
+	unsigned char magic;		/* identify the begin of message frame */
+	unsigned char seqnumber;
+	unsigned char type;			/* message type define by user */
+	unsigned char count;		/* message paras count unit of byte */
+	unsigned char reserved[4];
+	unsigned char paras[0];		/* the point of message parameters */
+} message_amp_t;
+
+typedef void (*sunxi_arisc_message_cb)(uint8_t, uint8_t, uint8_t *);
+
+int sunxi_arisc_rpm_send(uint8_t type, uint8_t length, const uint8_t *pdata);
+void sunxi_arisc_rpm_register_message_callback(sunxi_arisc_message_cb cb);
+
+#endif
diff --git a/drivers/misc/sunxi-tvutils/mipsloader.c b/drivers/misc/sunxi-tvutils/mipsloader.c
new file mode 100644
index 000000000..6edff4879
--- /dev/null
+++ b/drivers/misc/sunxi-tvutils/mipsloader.c
@@ -0,0 +1,192 @@
+/*
+ * Copyright(c) 2017-2018 Allwinnertech Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/io.h>
+#include <asm-generic/cacheflush.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+
+MODULE_AUTHOR("allwinnertech.com");
+MODULE_LICENSE("Dual BSD/GPL");
+
+#define MIPS_MEMORY_OFFSET 0x44000000
+#define MIPS_MEMORY_SIZE   0x01400000
+
+#define MIPS_SRAM_MEMORY_OFFSET 0x104000
+#define MIPS_SRAM_MEMORY_SIZE	0x001000
+
+#define MIPS_LOADER_IOC_RW 0x0648
+#define MIPS_FIRMWARE_R    0x01
+#define MIPS_FIRMWARE_W    0x00
+
+struct firmware_info {
+	uint32_t type;
+	uint32_t offset;
+	uint32_t size;
+	uint64_t buffer;
+};
+
+static void *mips_firmware_mem_va;
+static void *mips_sram_mem_va;
+
+static void *mips_memory_map(uint32_t offset, uint32_t size)
+{
+	void *va = NULL;
+
+	pr_info("mipsloader: memremap offset 0x%08x size 0x%08x\n", offset, size);
+	va = memremap(offset, size, MEMREMAP_WB);
+	if (!va) {
+		pr_info("unable to map memory region: 0x%08x+0x%08x\n", offset, size);
+		return NULL;
+	}
+	pr_info("mipsloader: memremap pa 0x%08x --> %px\n", offset, va);
+	memset(va, 0, size);
+	flush_cache_all();
+	return va;
+}
+
+static void mips_memory_unmap(void)
+{
+	if (mips_firmware_mem_va)
+		memunmap(mips_firmware_mem_va);
+	if (mips_sram_mem_va)
+		memunmap(mips_sram_mem_va);
+}
+
+static int mipsloader_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int mipsloader_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int mipsloader_firmware_rw(struct firmware_info *info)
+{
+	uint32_t offset;
+	void *base = 0;
+
+	if (info->offset >= MIPS_MEMORY_OFFSET
+			&& info->offset + info->size <= MIPS_MEMORY_OFFSET + MIPS_MEMORY_SIZE) {
+		pr_info("mipsloader: r/w DRAM space\n");
+		offset = info->offset - MIPS_MEMORY_OFFSET;
+		base = mips_firmware_mem_va + offset;
+	} else if (info->offset >= MIPS_SRAM_MEMORY_OFFSET
+			&& info->offset + info->size < MIPS_SRAM_MEMORY_OFFSET + MIPS_SRAM_MEMORY_SIZE) {
+		pr_info("mipsloader: r/w SRAM space\n");
+		offset = info->offset - MIPS_SRAM_MEMORY_OFFSET;
+		base = mips_sram_mem_va + offset;
+	} else {
+		pr_err("mipsloader: out of mips firmware memory range\n");
+		return -EINVAL;
+	}
+
+	if (info->type == MIPS_FIRMWARE_R) {
+		if (copy_to_user(u64_to_user_ptr(info->buffer), base, info->size)) {
+			pr_err("mipsloader: read firmware failed\n");
+			return -1;
+		}
+	} else {
+		if (copy_from_user(base, (void __user *)(info->buffer), info->size)) {
+			pr_err("mipsloader: write firmware failed\n");
+			return -1;
+		}
+		flush_cache_all();
+	}
+	return 0;
+}
+
+static long mipsloader_ioctl(struct file *file, unsigned int cmd,
+		unsigned long param)
+{
+	struct firmware_info info;
+
+	pr_info("mipsloader: cmd: 0x%08x param: %#lx\n", cmd, param);
+	switch (cmd) {
+	case MIPS_LOADER_IOC_RW:
+		if (copy_from_user(&info, (void __user *)param,
+					sizeof(struct firmware_info))) {
+			pr_err("mipsloader: copy_from_user fail\n");
+			return	-EFAULT;
+		}
+		return mipsloader_firmware_rw(&info);
+	default:
+		pr_err("mipsloader: unknown cmd %08x\n", cmd);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int mipsloader_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	pr_info("mipsloader: phy %016lx size %lu\n",
+			(vma->vm_pgoff << PAGE_SHIFT), (vma->vm_end - vma->vm_start));
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static const struct file_operations mipsloader_ops = {
+	.owner	 = THIS_MODULE,
+	.open	 = mipsloader_open,
+	.release = mipsloader_release,
+	.mmap	 = mipsloader_mmap,
+	.unlocked_ioctl = mipsloader_ioctl,
+	.compat_ioctl   = mipsloader_ioctl,
+};
+
+struct miscdevice mipsloader_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name  = "mipsloader",
+	.fops  = &mipsloader_ops,
+};
+
+static int mipsloader_init(void)
+{
+	int result = 0;
+
+	result = misc_register(&mipsloader_device);
+	if (result)
+		pr_err("Error %d adding mipsloader", result);
+
+	mips_firmware_mem_va = mips_memory_map(MIPS_MEMORY_OFFSET, MIPS_MEMORY_SIZE);
+	mips_sram_mem_va = mips_memory_map(MIPS_SRAM_MEMORY_OFFSET, MIPS_SRAM_MEMORY_SIZE);
+	return 0;
+}
+
+static void mipsloader_exit(void)
+{
+	mips_memory_unmap();
+	misc_deregister(&mipsloader_device);
+}
+
+module_init(mipsloader_init);
+module_exit(mipsloader_exit);
+
diff --git a/drivers/misc/sunxi-tvutils/tvutils.c b/drivers/misc/sunxi-tvutils/tvutils.c
new file mode 100644
index 000000000..f2fdba79b
--- /dev/null
+++ b/drivers/misc/sunxi-tvutils/tvutils.c
@@ -0,0 +1,361 @@
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/io.h>
+#include <asm-generic/cacheflush.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+
+MODULE_AUTHOR("allwinnertech.com");
+MODULE_LICENSE("Dual BSD/GPL");
+
+#define IMAGE_LOADER_IOC_ADD   0x064800
+#define IMAGE_LOADER_IOC_CLEAR 0x064801
+
+struct dma_buf_attach_info {
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt;
+	dma_addr_t dma_addr;
+};
+
+struct image_block {
+	struct dma_buf *buf;
+	uint32_t size;
+
+	struct dma_buf_attach_info info;
+	struct list_head link;
+};
+
+struct image_data {
+	int dmafd;
+	uint32_t buffer_size;
+};
+
+static LIST_HEAD(image_list_head);
+
+static struct device *get_imagedevice(void);
+
+static int tvutils_open (struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int tvutils_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int __attach_buf(struct dma_buf *buf, struct dma_buf_attach_info *info)
+{
+	info->attachment = dma_buf_attach(buf, get_imagedevice());
+	if (IS_ERR(info->attachment)) {
+		pr_err("dma_buf_attach failed\n");
+		return -1;
+	}
+	info->sgt = dma_buf_map_attachment(info->attachment, DMA_TO_DEVICE);
+	if (IS_ERR_OR_NULL(info->sgt)) {
+		pr_err("dma_buf_map_attachment failed\n");
+		dma_buf_detach(buf, info->attachment);
+		return -1;
+	}
+	info->dma_addr = sg_dma_address(info->sgt->sgl);
+	return 0;
+}
+
+static int __detach_buf(struct dma_buf *buf, struct dma_buf_attach_info *info)
+{
+	dma_buf_unmap_attachment(info->attachment, info->sgt, DMA_TO_DEVICE);
+	dma_buf_detach(buf, info->attachment);
+	return 0;
+}
+
+static int tvutils_add(struct image_data *data)
+{
+	struct image_block *block;
+	struct dma_buf *buf = dma_buf_get(data->dmafd);
+	if (IS_ERR(buf)) {
+		pr_err("dma_buf_get failed, fd=%d\n", data->dmafd);
+		return -EINVAL;
+	}
+
+	block = kmalloc(
+			sizeof(struct image_block), GFP_KERNEL | __GFP_ZERO);
+	if (block == NULL) {
+		pr_err("kmalloc for image_block failed\n");
+		dma_buf_put(buf);
+		return -ENOMEM;
+	}
+
+	if (__attach_buf(buf, &block->info) != 0) {
+		dma_buf_put(buf);
+		kfree(block);
+		return -EINVAL;
+	}
+
+	block->buf = buf;
+	block->size = data->buffer_size;
+	INIT_LIST_HEAD(&block->link);
+
+	list_add_tail(&block->link, &image_list_head);
+
+	return 0;
+}
+
+static int tvutils_clear(void)
+{
+	struct image_block *block, *next;
+
+	list_for_each_entry_safe(block, next, &image_list_head, link) {
+		list_del(&block->link);
+		__detach_buf(block->buf, &block->info);
+		dma_buf_put(block->buf);
+		kfree(block);
+	}
+	return 0;
+}
+
+static long tvutils_ioctl(struct file *file, unsigned int cmd,
+		unsigned long param)
+{
+	struct image_data data;
+
+	switch (cmd) {
+	case IMAGE_LOADER_IOC_ADD:
+		if (copy_from_user(&data, (void __user *)param, sizeof(struct image_data))) {
+			pr_err("tvutils: copy_from_user fail\n");
+			return	-EFAULT;
+		}
+		return tvutils_add(&data);
+	case IMAGE_LOADER_IOC_CLEAR:
+		return tvutils_clear();
+	default:
+		pr_err("tvutils: unknown cmd %08x\n", cmd);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static ssize_t imgdev_imgbuf_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	struct image_block *block, *next;
+	int printed = 0;
+	printed += sprintf(buf, "active image buffers: \n");
+
+	list_for_each_entry_safe(block, next, &image_list_head, link) {
+		printed += sprintf(buf + printed, " physical offset: %016llx size: %d\n",
+				block->info.dma_addr, block->size);
+	}
+
+	return printed;
+}
+
+#define CCMU_REG_BASE			0x02001000
+#define CCMU_REG_LENGTH			0x1000
+#define UART_BUS_GATING_RST_REG 0x090C
+
+static ssize_t tvutils_tvdisp_debug_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	void __iomem *va = NULL;
+
+	if (strncasecmp(buf, "1", 1) == 0) {
+		va = ioremap(CCMU_REG_BASE, CCMU_REG_LENGTH);
+		if (IS_ERR_OR_NULL(va)) {
+			pr_err("ioremap ccmu error: %pK\n", va);
+			goto __out;
+		}
+		// tvdisp subsystem gating and reset
+		writel(0x00010001, va + 0x0dd8); // tvdisp
+		iounmap(va);
+
+		// tvdisp top
+		va = ioremap(0x05700000, 0x100);
+		if (IS_ERR_OR_NULL(va)) {
+			pr_err("ioremap tvdisp_top error: %pK\n", va);
+			goto __out;
+		}
+		writel(0xFFFFFFFF, va + 0x0000);
+		writel(0xFFFFFFFF, va + 0x0004);
+		writel(0xFFFFFFFF, va + 0x0040);
+		writel(0xFFFFFFFF, va + 0x0044);
+		writel(0xFFFFFFFF, va + 0x0080);
+		writel(0xFFFFFFFF, va + 0x0084);
+		writel(0xFFFFFFFF, va + 0x0088);
+		iounmap(va);
+	}
+
+__out:
+	return count;
+}
+
+static ssize_t tvutils_tvcap_debug_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	void __iomem *va = NULL;
+
+	if (strncasecmp(buf, "1", 1) == 0) {
+		va = ioremap(CCMU_REG_BASE, CCMU_REG_LENGTH);
+		if (IS_ERR_OR_NULL(va)) {
+			pr_err("ioremap ccmu error: %pK\n", va);
+			goto __out;
+		}
+		// tvcap subsystem gating and reset
+		writel(0x00010001, va + 0x0d88); // tvcap
+		iounmap(va);
+
+		// tvcap top
+		va = ioremap(0x06E00000, 0x100);
+		if (IS_ERR_OR_NULL(va)) {
+			pr_err("ioremap tvcap_top error: %pK\n", va);
+			goto __out;
+
+		}
+		writel(0xFFFFFFFF, va + 0x0000);
+		writel(0xFFFFFFFF, va + 0x0004);
+		writel(0xFFFFFFFF, va + 0x0008);
+		iounmap(va);
+	}
+
+__out:
+	return count;
+}
+
+static ssize_t tvutils_tvfe_debug_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	void __iomem *va = NULL;
+
+	if (strncasecmp(buf, "1", 1) == 0) {
+		va = ioremap(CCMU_REG_BASE, CCMU_REG_LENGTH);
+		if (IS_ERR_OR_NULL(va)) {
+			pr_err("ioremap ccmu error: %pK\n", va);
+			goto __out;
+		}
+		// tvfe subsystem gating and reset
+		writel(0x00010001, va + 0x0d64); // tvfe
+		iounmap(va);
+
+		// tvfe top
+		va = ioremap(0x06700000, 0x100);
+		if (IS_ERR_OR_NULL(va)) {
+			pr_err("ioremap tvdisp_top error: %pK\n", va);
+			goto __out;
+		}
+		writel(0x003003FF, va + 0x0000);
+		writel(0x00000003, va + 0x0004);
+		iounmap(va);
+	}
+
+__out:
+	return count;
+}
+
+static DEVICE_ATTR(imgbuf, 0444, imgdev_imgbuf_show, NULL);
+static DEVICE_ATTR(tvdisp, 0444, NULL, tvutils_tvdisp_debug_store);
+static DEVICE_ATTR(tvcap,  0444, NULL, tvutils_tvcap_debug_store);
+static DEVICE_ATTR(tvfe,   0444, NULL, tvutils_tvfe_debug_store);
+
+static struct attribute *imgdev_attrs[] = {
+	&dev_attr_imgbuf.attr,
+	&dev_attr_tvdisp.attr,
+	&dev_attr_tvcap.attr,
+	&dev_attr_tvfe.attr,
+	NULL
+};
+
+static const struct attribute_group imgdev_attr_group = {
+	.attrs = imgdev_attrs
+};
+
+static const struct attribute_group *imgdev_attr_groups[] = {
+	&imgdev_attr_group,
+	NULL
+};
+
+static struct file_operations tvutils_ops = {
+	.owner	 = THIS_MODULE,
+	.open	 = tvutils_open,
+	.release = tvutils_release,
+	.unlocked_ioctl = tvutils_ioctl,
+};
+
+static u64 disp_dmamask = DMA_BIT_MASK(32);
+struct miscdevice tvutils_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name  = "tvutils",
+	.fops  = &tvutils_ops,
+	.groups = imgdev_attr_groups,
+};
+
+static struct device *get_imagedevice(void)
+{
+	tvutils_device.this_device->dma_mask = &disp_dmamask;
+	return tvutils_device.this_device;
+}
+
+static void tvutils_ccmu_init(void)
+{
+	void __iomem *va = ioremap(CCMU_REG_BASE, CCMU_REG_LENGTH);
+	if (IS_ERR_OR_NULL(va)) {
+		pr_err("ioremap ccmu error: %pK\n", va);
+		return;
+	}
+
+	// Init uart0/uart1/uart2 clk and reset
+	writel(0x00050005, va + UART_BUS_GATING_RST_REG);
+
+	iounmap(va);
+}
+
+static void tvutils_nsi_config(void)
+{
+#define NSI_BASE (0x02020000)
+#define NSI_LEN  (0x00001000)
+
+	void __iomem *va = ioremap(NSI_BASE, NSI_LEN);
+	if (IS_ERR_OR_NULL(va)) {
+		pr_err("ioremap nsi error: %pK\n", va);
+		return;
+	}
+	writel(0x0000000a, va + 0x0814);
+	iounmap(va);
+}
+
+static int tvutils_init(void)
+{
+	int result = 0;
+	result = misc_register(&tvutils_device);
+	if (result)
+		pr_err(KERN_WARNING "Error %d adding tvutils", result);
+
+	tvutils_ccmu_init();
+	tvutils_nsi_config();
+	return 0;
+}
+
+static void tvutils_exit(void)
+{
+	tvutils_clear();
+	misc_deregister(&tvutils_device);
+}
+
+module_init(tvutils_init);
+module_exit(tvutils_exit);
+
+MODULE_AUTHOR("allwinnertech.com");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/misc/sunxi_cpu_comm.c b/drivers/misc/sunxi_cpu_comm.c
new file mode 100644
index 000000000..b7f090ef6
--- /dev/null
+++ b/drivers/misc/sunxi_cpu_comm.c
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2020, allwinnertech.
+ * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rpmsg.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+
+#include "sunxi_cpu_comm.h"
+
+#define CPU_COMM_MSG_LEN 4
+
+static struct rpmsg_device *cpu_comm_rpmsg_device;
+static cpu_comm_cb msgbox_received_cb;
+
+void sunxi_cpu_comm_register_isr_cb(cpu_comm_cb cb)
+{
+	msgbox_received_cb = cb;
+}
+EXPORT_SYMBOL(sunxi_cpu_comm_register_isr_cb);
+
+int sunxi_cpu_comm_send_intr_to_mips(communication_type type, msgbox_cpu_type target, int ack)
+{
+	uint32_t data = type;
+
+	if (target != CPU_MIPS)
+		return -EINVAL;
+
+	return rpmsg_send(cpu_comm_rpmsg_device->ept, &data, CPU_COMM_MSG_LEN);
+}
+EXPORT_SYMBOL(sunxi_cpu_comm_send_intr_to_mips);
+
+static int rpmsg_cpu_comm_cb(struct rpmsg_device *rpdev, void *data, int len,
+		void *priv, u32 src)
+{
+	uint32_t comm_type = 0;
+
+	if (len == CPU_COMM_MSG_LEN) {
+		comm_type = *(uint32_t *)data;
+		if (msgbox_received_cb != NULL)
+			msgbox_received_cb(comm_type, CPU_MIPS);
+	} else {
+		dev_err(&rpdev->dev, "unknown message from addr: 0x%08x\n", rpdev->ept->addr);
+		print_hex_dump_debug(__func__, DUMP_PREFIX_NONE, 16, 1, data, len,
+				true);
+	}
+	return 0;
+}
+
+static int rpmsg_cpu_comm_probe(struct rpmsg_device *rpdev)
+{
+	cpu_comm_rpmsg_device = rpdev;
+	dev_info(&rpdev->dev, "create rpmsg channel: 0x%x -> 0x%x!\n",
+			rpdev->src, rpdev->dst);
+	return 0;
+}
+
+static void rpmsg_cpu_comm_remove(struct rpmsg_device *rpdev)
+{
+	cpu_comm_rpmsg_device = NULL;
+	msgbox_received_cb = NULL;
+	dev_info(&rpdev->dev, "rpmsg sample client driver is removed\n");
+}
+
+static struct rpmsg_device_id rpmsg_driver_id_table[] = {
+	{ .name = "sunxi,mips-msgbox" },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_driver_id_table);
+
+static struct rpmsg_driver rpmsg_cpu_comm_client = {
+	.drv.name = KBUILD_MODNAME,
+	.id_table = rpmsg_driver_id_table,
+	.probe	  = rpmsg_cpu_comm_probe,
+	.callback = rpmsg_cpu_comm_cb,
+	.remove   = rpmsg_cpu_comm_remove,
+};
+
+module_rpmsg_driver(rpmsg_cpu_comm_client);
+MODULE_DESCRIPTION("sunxi remote processor messaging client driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/misc/sunxi_cpu_comm.h b/drivers/misc/sunxi_cpu_comm.h
new file mode 100644
index 000000000..518555302
--- /dev/null
+++ b/drivers/misc/sunxi_cpu_comm.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020, allwinnertech.
+ * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ */
+
+#ifndef _SUNXI_CPU_COMM_H_
+#define _SUNXI_CPU_COMM_H_
+
+typedef enum _tag_communication_type {
+	SUNXI_TYPE_CALL,
+	SUNXI_TYPE_RETURN,
+	SUNXI_TYPE_CALL_ACK,
+	SUNXI_TYPE_RETURN_ACK,
+	SUNXI_TYPE_COMM_ALL,
+} communication_type;
+
+typedef enum _tag_msgbox_cpu_type {
+	CPU_ARM  = 0,
+	CPU_RISC = 1,
+	CPU_MIPS = 2
+} msgbox_cpu_type;
+
+typedef void (*cpu_comm_cb)(communication_type, msgbox_cpu_type);
+
+void sunxi_cpu_comm_register_isr_cb(cpu_comm_cb cb);
+int sunxi_cpu_comm_send_intr_to_mips(communication_type type, msgbox_cpu_type target, int ack);
+
+#endif
diff --git a/drivers/misc/uid_sys_stats.c b/drivers/misc/uid_sys_stats.c
new file mode 100644
index 000000000..6f17a3c8a
--- /dev/null
+++ b/drivers/misc/uid_sys_stats.c
@@ -0,0 +1,706 @@
+/* drivers/misc/uid_sys_stats.c
+ *
+ * Copyright (C) 2014 - 2015 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/atomic.h>
+#include <linux/err.h>
+#include <linux/hashtable.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/profile.h>
+#include <linux/rtmutex.h>
+#include <linux/sched/cputime.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+
+#define UID_HASH_BITS	10
+DECLARE_HASHTABLE(hash_table, UID_HASH_BITS);
+
+static DEFINE_RT_MUTEX(uid_lock);
+static struct proc_dir_entry *cpu_parent;
+static struct proc_dir_entry *io_parent;
+static struct proc_dir_entry *proc_parent;
+
+struct io_stats {
+	u64 read_bytes;
+	u64 write_bytes;
+	u64 rchar;
+	u64 wchar;
+	u64 fsync;
+};
+
+#define UID_STATE_FOREGROUND	0
+#define UID_STATE_BACKGROUND	1
+#define UID_STATE_BUCKET_SIZE	2
+
+#define UID_STATE_TOTAL_CURR	2
+#define UID_STATE_TOTAL_LAST	3
+#define UID_STATE_DEAD_TASKS	4
+#define UID_STATE_SIZE		5
+
+#define MAX_TASK_COMM_LEN 256
+
+struct task_entry {
+	char comm[MAX_TASK_COMM_LEN];
+	pid_t pid;
+	struct io_stats io[UID_STATE_SIZE];
+	struct hlist_node hash;
+};
+
+struct uid_entry {
+	uid_t uid;
+	u64 utime;
+	u64 stime;
+	u64 active_utime;
+	u64 active_stime;
+	int state;
+	struct io_stats io[UID_STATE_SIZE];
+	struct hlist_node hash;
+#ifdef CONFIG_UID_SYS_STATS_DEBUG
+	DECLARE_HASHTABLE(task_entries, UID_HASH_BITS);
+#endif
+};
+
+static u64 compute_write_bytes(struct task_struct *task)
+{
+	if (task->ioac.write_bytes <= task->ioac.cancelled_write_bytes)
+		return 0;
+
+	return task->ioac.write_bytes - task->ioac.cancelled_write_bytes;
+}
+
+static void compute_io_bucket_stats(struct io_stats *io_bucket,
+					struct io_stats *io_curr,
+					struct io_stats *io_last,
+					struct io_stats *io_dead)
+{
+	/* tasks could switch to another uid group, but its io_last in the
+	 * previous uid group could still be positive.
+	 * therefore before each update, do an overflow check first
+	 */
+	int64_t delta;
+
+	delta = io_curr->read_bytes + io_dead->read_bytes -
+		io_last->read_bytes;
+	io_bucket->read_bytes += delta > 0 ? delta : 0;
+	delta = io_curr->write_bytes + io_dead->write_bytes -
+		io_last->write_bytes;
+	io_bucket->write_bytes += delta > 0 ? delta : 0;
+	delta = io_curr->rchar + io_dead->rchar - io_last->rchar;
+	io_bucket->rchar += delta > 0 ? delta : 0;
+	delta = io_curr->wchar + io_dead->wchar - io_last->wchar;
+	io_bucket->wchar += delta > 0 ? delta : 0;
+	delta = io_curr->fsync + io_dead->fsync - io_last->fsync;
+	io_bucket->fsync += delta > 0 ? delta : 0;
+
+	io_last->read_bytes = io_curr->read_bytes;
+	io_last->write_bytes = io_curr->write_bytes;
+	io_last->rchar = io_curr->rchar;
+	io_last->wchar = io_curr->wchar;
+	io_last->fsync = io_curr->fsync;
+
+	memset(io_dead, 0, sizeof(struct io_stats));
+}
+
+#ifdef CONFIG_UID_SYS_STATS_DEBUG
+static void get_full_task_comm(struct task_entry *task_entry,
+		struct task_struct *task)
+{
+	int i = 0, offset = 0, len = 0;
+	/* save one byte for terminating null character */
+	int unused_len = MAX_TASK_COMM_LEN - TASK_COMM_LEN - 1;
+	char buf[MAX_TASK_COMM_LEN - TASK_COMM_LEN - 1];
+	struct mm_struct *mm = task->mm;
+
+	/* fill the first TASK_COMM_LEN bytes with thread name */
+	__get_task_comm(task_entry->comm, TASK_COMM_LEN, task);
+	i = strlen(task_entry->comm);
+	while (i < TASK_COMM_LEN)
+		task_entry->comm[i++] = ' ';
+
+	/* next the executable file name */
+	if (mm) {
+		down_read(&mm->mmap_sem);
+		if (mm->exe_file) {
+			char *pathname = d_path(&mm->exe_file->f_path, buf,
+					unused_len);
+
+			if (!IS_ERR(pathname)) {
+				len = strlcpy(task_entry->comm + i, pathname,
+						unused_len);
+				i += len;
+				task_entry->comm[i++] = ' ';
+				unused_len--;
+			}
+		}
+		up_read(&mm->mmap_sem);
+	}
+	unused_len -= len;
+
+	/* fill the rest with command line argument
+	 * replace each null or new line character
+	 * between args in argv with whitespace */
+	len = get_cmdline(task, buf, unused_len);
+	while (offset < len) {
+		if (buf[offset] != '\0' && buf[offset] != '\n')
+			task_entry->comm[i++] = buf[offset];
+		else
+			task_entry->comm[i++] = ' ';
+		offset++;
+	}
+
+	/* get rid of trailing whitespaces in case when arg is memset to
+	 * zero before being reset in userspace
+	 */
+	while (task_entry->comm[i-1] == ' ')
+		i--;
+	task_entry->comm[i] = '\0';
+}
+
+static struct task_entry *find_task_entry(struct uid_entry *uid_entry,
+		struct task_struct *task)
+{
+	struct task_entry *task_entry;
+
+	hash_for_each_possible(uid_entry->task_entries, task_entry, hash,
+			task->pid) {
+		if (task->pid == task_entry->pid) {
+			/* if thread name changed, update the entire command */
+			int len = strnchr(task_entry->comm, ' ', TASK_COMM_LEN)
+				- task_entry->comm;
+
+			if (strncmp(task_entry->comm, task->comm, len))
+				get_full_task_comm(task_entry, task);
+			return task_entry;
+		}
+	}
+	return NULL;
+}
+
+static struct task_entry *find_or_register_task(struct uid_entry *uid_entry,
+		struct task_struct *task)
+{
+	struct task_entry *task_entry;
+	pid_t pid = task->pid;
+
+	task_entry = find_task_entry(uid_entry, task);
+	if (task_entry)
+		return task_entry;
+
+	task_entry = kzalloc(sizeof(struct task_entry), GFP_ATOMIC);
+	if (!task_entry)
+		return NULL;
+
+	get_full_task_comm(task_entry, task);
+
+	task_entry->pid = pid;
+	hash_add(uid_entry->task_entries, &task_entry->hash, (unsigned int)pid);
+
+	return task_entry;
+}
+
+static void remove_uid_tasks(struct uid_entry *uid_entry)
+{
+	struct task_entry *task_entry;
+	unsigned long bkt_task;
+	struct hlist_node *tmp_task;
+
+	hash_for_each_safe(uid_entry->task_entries, bkt_task,
+			tmp_task, task_entry, hash) {
+		hash_del(&task_entry->hash);
+		kfree(task_entry);
+	}
+}
+
+static void set_io_uid_tasks_zero(struct uid_entry *uid_entry)
+{
+	struct task_entry *task_entry;
+	unsigned long bkt_task;
+
+	hash_for_each(uid_entry->task_entries, bkt_task, task_entry, hash) {
+		memset(&task_entry->io[UID_STATE_TOTAL_CURR], 0,
+			sizeof(struct io_stats));
+	}
+}
+
+static void add_uid_tasks_io_stats(struct uid_entry *uid_entry,
+		struct task_struct *task, int slot)
+{
+	struct task_entry *task_entry = find_or_register_task(uid_entry, task);
+	struct io_stats *task_io_slot = &task_entry->io[slot];
+
+	task_io_slot->read_bytes += task->ioac.read_bytes;
+	task_io_slot->write_bytes += compute_write_bytes(task);
+	task_io_slot->rchar += task->ioac.rchar;
+	task_io_slot->wchar += task->ioac.wchar;
+	task_io_slot->fsync += task->ioac.syscfs;
+}
+
+static void compute_io_uid_tasks(struct uid_entry *uid_entry)
+{
+	struct task_entry *task_entry;
+	unsigned long bkt_task;
+
+	hash_for_each(uid_entry->task_entries, bkt_task, task_entry, hash) {
+		compute_io_bucket_stats(&task_entry->io[uid_entry->state],
+					&task_entry->io[UID_STATE_TOTAL_CURR],
+					&task_entry->io[UID_STATE_TOTAL_LAST],
+					&task_entry->io[UID_STATE_DEAD_TASKS]);
+	}
+}
+
+static void show_io_uid_tasks(struct seq_file *m, struct uid_entry *uid_entry)
+{
+	struct task_entry *task_entry;
+	unsigned long bkt_task;
+
+	hash_for_each(uid_entry->task_entries, bkt_task, task_entry, hash) {
+		/* Separated by comma because space exists in task comm */
+		seq_printf(m, "task,%s,%lu,%llu,%llu,%llu,%llu,%llu,%llu,%llu,%llu,%llu,%llu\n",
+				task_entry->comm,
+				(unsigned long)task_entry->pid,
+				task_entry->io[UID_STATE_FOREGROUND].rchar,
+				task_entry->io[UID_STATE_FOREGROUND].wchar,
+				task_entry->io[UID_STATE_FOREGROUND].read_bytes,
+				task_entry->io[UID_STATE_FOREGROUND].write_bytes,
+				task_entry->io[UID_STATE_BACKGROUND].rchar,
+				task_entry->io[UID_STATE_BACKGROUND].wchar,
+				task_entry->io[UID_STATE_BACKGROUND].read_bytes,
+				task_entry->io[UID_STATE_BACKGROUND].write_bytes,
+				task_entry->io[UID_STATE_FOREGROUND].fsync,
+				task_entry->io[UID_STATE_BACKGROUND].fsync);
+	}
+}
+#else
+static void remove_uid_tasks(struct uid_entry *uid_entry) {};
+static void set_io_uid_tasks_zero(struct uid_entry *uid_entry) {};
+static void add_uid_tasks_io_stats(struct uid_entry *uid_entry,
+		struct task_struct *task, int slot) {};
+static void compute_io_uid_tasks(struct uid_entry *uid_entry) {};
+static void show_io_uid_tasks(struct seq_file *m,
+		struct uid_entry *uid_entry) {}
+#endif
+
+static struct uid_entry *find_uid_entry(uid_t uid)
+{
+	struct uid_entry *uid_entry;
+	hash_for_each_possible(hash_table, uid_entry, hash, uid) {
+		if (uid_entry->uid == uid)
+			return uid_entry;
+	}
+	return NULL;
+}
+
+static struct uid_entry *find_or_register_uid(uid_t uid)
+{
+	struct uid_entry *uid_entry;
+
+	uid_entry = find_uid_entry(uid);
+	if (uid_entry)
+		return uid_entry;
+
+	uid_entry = kzalloc(sizeof(struct uid_entry), GFP_ATOMIC);
+	if (!uid_entry)
+		return NULL;
+
+	uid_entry->uid = uid;
+#ifdef CONFIG_UID_SYS_STATS_DEBUG
+	hash_init(uid_entry->task_entries);
+#endif
+	hash_add(hash_table, &uid_entry->hash, uid);
+
+	return uid_entry;
+}
+
+static int uid_cputime_show(struct seq_file *m, void *v)
+{
+	struct uid_entry *uid_entry = NULL;
+	struct task_struct *task, *temp;
+	struct user_namespace *user_ns = current_user_ns();
+	u64 utime;
+	u64 stime;
+	unsigned long bkt;
+	uid_t uid;
+
+	rt_mutex_lock(&uid_lock);
+
+	hash_for_each(hash_table, bkt, uid_entry, hash) {
+		uid_entry->active_stime = 0;
+		uid_entry->active_utime = 0;
+	}
+
+	rcu_read_lock();
+	do_each_thread(temp, task) {
+		uid = from_kuid_munged(user_ns, task_uid(task));
+		if (!uid_entry || uid_entry->uid != uid)
+			uid_entry = find_or_register_uid(uid);
+		if (!uid_entry) {
+			rcu_read_unlock();
+			rt_mutex_unlock(&uid_lock);
+			pr_err("%s: failed to find the uid_entry for uid %d\n",
+				__func__, uid);
+			return -ENOMEM;
+		}
+		/* avoid double accounting of dying threads */
+		if (!(task->flags & PF_EXITING)) {
+			task_cputime_adjusted(task, &utime, &stime);
+			uid_entry->active_utime += utime;
+			uid_entry->active_stime += stime;
+		}
+	} while_each_thread(temp, task);
+	rcu_read_unlock();
+
+	hash_for_each(hash_table, bkt, uid_entry, hash) {
+		u64 total_utime = uid_entry->utime +
+							uid_entry->active_utime;
+		u64 total_stime = uid_entry->stime +
+							uid_entry->active_stime;
+		seq_printf(m, "%d: %llu %llu\n", uid_entry->uid,
+			ktime_to_us(total_utime), ktime_to_us(total_stime));
+	}
+
+	rt_mutex_unlock(&uid_lock);
+	return 0;
+}
+
+static int uid_cputime_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, uid_cputime_show, PDE_DATA(inode));
+}
+
+static const struct file_operations uid_cputime_fops = {
+	.open		= uid_cputime_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int uid_remove_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, NULL, NULL);
+}
+
+static ssize_t uid_remove_write(struct file *file,
+			const char __user *buffer, size_t count, loff_t *ppos)
+{
+	struct uid_entry *uid_entry;
+	struct hlist_node *tmp;
+	char uids[128];
+	char *start_uid, *end_uid = NULL;
+	long int uid_start = 0, uid_end = 0;
+
+	if (count >= sizeof(uids))
+		count = sizeof(uids) - 1;
+
+	if (copy_from_user(uids, buffer, count))
+		return -EFAULT;
+
+	uids[count] = '\0';
+	end_uid = uids;
+	start_uid = strsep(&end_uid, "-");
+
+	if (!start_uid || !end_uid)
+		return -EINVAL;
+
+	if (kstrtol(start_uid, 10, &uid_start) != 0 ||
+		kstrtol(end_uid, 10, &uid_end) != 0) {
+		return -EINVAL;
+	}
+
+	rt_mutex_lock(&uid_lock);
+
+	for (; uid_start <= uid_end; uid_start++) {
+		hash_for_each_possible_safe(hash_table, uid_entry, tmp,
+							hash, (uid_t)uid_start) {
+			if (uid_start == uid_entry->uid) {
+				remove_uid_tasks(uid_entry);
+				hash_del(&uid_entry->hash);
+				kfree(uid_entry);
+			}
+		}
+	}
+
+	rt_mutex_unlock(&uid_lock);
+	return count;
+}
+
+static const struct file_operations uid_remove_fops = {
+	.open		= uid_remove_open,
+	.release	= single_release,
+	.write		= uid_remove_write,
+};
+
+
+static void add_uid_io_stats(struct uid_entry *uid_entry,
+			struct task_struct *task, int slot)
+{
+	struct io_stats *io_slot = &uid_entry->io[slot];
+
+	/* avoid double accounting of dying threads */
+	if (slot != UID_STATE_DEAD_TASKS && (task->flags & PF_EXITING))
+		return;
+
+	io_slot->read_bytes += task->ioac.read_bytes;
+	io_slot->write_bytes += compute_write_bytes(task);
+	io_slot->rchar += task->ioac.rchar;
+	io_slot->wchar += task->ioac.wchar;
+	io_slot->fsync += task->ioac.syscfs;
+
+	add_uid_tasks_io_stats(uid_entry, task, slot);
+}
+
+static void update_io_stats_all_locked(void)
+{
+	struct uid_entry *uid_entry = NULL;
+	struct task_struct *task, *temp;
+	struct user_namespace *user_ns = current_user_ns();
+	unsigned long bkt;
+	uid_t uid;
+
+	hash_for_each(hash_table, bkt, uid_entry, hash) {
+		memset(&uid_entry->io[UID_STATE_TOTAL_CURR], 0,
+			sizeof(struct io_stats));
+		set_io_uid_tasks_zero(uid_entry);
+	}
+
+	rcu_read_lock();
+	do_each_thread(temp, task) {
+		uid = from_kuid_munged(user_ns, task_uid(task));
+		if (!uid_entry || uid_entry->uid != uid)
+			uid_entry = find_or_register_uid(uid);
+		if (!uid_entry)
+			continue;
+		add_uid_io_stats(uid_entry, task, UID_STATE_TOTAL_CURR);
+	} while_each_thread(temp, task);
+	rcu_read_unlock();
+
+	hash_for_each(hash_table, bkt, uid_entry, hash) {
+		compute_io_bucket_stats(&uid_entry->io[uid_entry->state],
+					&uid_entry->io[UID_STATE_TOTAL_CURR],
+					&uid_entry->io[UID_STATE_TOTAL_LAST],
+					&uid_entry->io[UID_STATE_DEAD_TASKS]);
+		compute_io_uid_tasks(uid_entry);
+	}
+}
+
+static void update_io_stats_uid_locked(struct uid_entry *uid_entry)
+{
+	struct task_struct *task, *temp;
+	struct user_namespace *user_ns = current_user_ns();
+
+	memset(&uid_entry->io[UID_STATE_TOTAL_CURR], 0,
+		sizeof(struct io_stats));
+	set_io_uid_tasks_zero(uid_entry);
+
+	rcu_read_lock();
+	do_each_thread(temp, task) {
+		if (from_kuid_munged(user_ns, task_uid(task)) != uid_entry->uid)
+			continue;
+		add_uid_io_stats(uid_entry, task, UID_STATE_TOTAL_CURR);
+	} while_each_thread(temp, task);
+	rcu_read_unlock();
+
+	compute_io_bucket_stats(&uid_entry->io[uid_entry->state],
+				&uid_entry->io[UID_STATE_TOTAL_CURR],
+				&uid_entry->io[UID_STATE_TOTAL_LAST],
+				&uid_entry->io[UID_STATE_DEAD_TASKS]);
+	compute_io_uid_tasks(uid_entry);
+}
+
+
+static int uid_io_show(struct seq_file *m, void *v)
+{
+	struct uid_entry *uid_entry;
+	unsigned long bkt;
+
+	rt_mutex_lock(&uid_lock);
+
+	update_io_stats_all_locked();
+
+	hash_for_each(hash_table, bkt, uid_entry, hash) {
+		seq_printf(m, "%d %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu\n",
+				uid_entry->uid,
+				uid_entry->io[UID_STATE_FOREGROUND].rchar,
+				uid_entry->io[UID_STATE_FOREGROUND].wchar,
+				uid_entry->io[UID_STATE_FOREGROUND].read_bytes,
+				uid_entry->io[UID_STATE_FOREGROUND].write_bytes,
+				uid_entry->io[UID_STATE_BACKGROUND].rchar,
+				uid_entry->io[UID_STATE_BACKGROUND].wchar,
+				uid_entry->io[UID_STATE_BACKGROUND].read_bytes,
+				uid_entry->io[UID_STATE_BACKGROUND].write_bytes,
+				uid_entry->io[UID_STATE_FOREGROUND].fsync,
+				uid_entry->io[UID_STATE_BACKGROUND].fsync);
+
+		show_io_uid_tasks(m, uid_entry);
+	}
+
+	rt_mutex_unlock(&uid_lock);
+	return 0;
+}
+
+static int uid_io_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, uid_io_show, PDE_DATA(inode));
+}
+
+static const struct file_operations uid_io_fops = {
+	.open		= uid_io_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int uid_procstat_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, NULL, NULL);
+}
+
+static ssize_t uid_procstat_write(struct file *file,
+			const char __user *buffer, size_t count, loff_t *ppos)
+{
+	struct uid_entry *uid_entry;
+	uid_t uid;
+	int argc, state;
+	char input[128];
+
+	if (count >= sizeof(input))
+		return -EINVAL;
+
+	if (copy_from_user(input, buffer, count))
+		return -EFAULT;
+
+	input[count] = '\0';
+
+	argc = sscanf(input, "%u %d", &uid, &state);
+	if (argc != 2)
+		return -EINVAL;
+
+	if (state != UID_STATE_BACKGROUND && state != UID_STATE_FOREGROUND)
+		return -EINVAL;
+
+	rt_mutex_lock(&uid_lock);
+
+	uid_entry = find_or_register_uid(uid);
+	if (!uid_entry) {
+		rt_mutex_unlock(&uid_lock);
+		return -EINVAL;
+	}
+
+	if (uid_entry->state == state) {
+		rt_mutex_unlock(&uid_lock);
+		return count;
+	}
+
+	update_io_stats_uid_locked(uid_entry);
+
+	uid_entry->state = state;
+
+	rt_mutex_unlock(&uid_lock);
+
+	return count;
+}
+
+static const struct file_operations uid_procstat_fops = {
+	.open		= uid_procstat_open,
+	.release	= single_release,
+	.write		= uid_procstat_write,
+};
+
+static int process_notifier(struct notifier_block *self,
+			unsigned long cmd, void *v)
+{
+	struct task_struct *task = v;
+	struct uid_entry *uid_entry;
+	u64 utime, stime;
+	uid_t uid;
+
+	if (!task)
+		return NOTIFY_OK;
+
+	rt_mutex_lock(&uid_lock);
+	uid = from_kuid_munged(current_user_ns(), task_uid(task));
+	uid_entry = find_or_register_uid(uid);
+	if (!uid_entry) {
+		pr_err("%s: failed to find uid %d\n", __func__, uid);
+		goto exit;
+	}
+
+	task_cputime_adjusted(task, &utime, &stime);
+	uid_entry->utime += utime;
+	uid_entry->stime += stime;
+
+	add_uid_io_stats(uid_entry, task, UID_STATE_DEAD_TASKS);
+
+exit:
+	rt_mutex_unlock(&uid_lock);
+	return NOTIFY_OK;
+}
+
+static struct notifier_block process_notifier_block = {
+	.notifier_call	= process_notifier,
+};
+
+static int __init proc_uid_sys_stats_init(void)
+{
+	hash_init(hash_table);
+
+	cpu_parent = proc_mkdir("uid_cputime", NULL);
+	if (!cpu_parent) {
+		pr_err("%s: failed to create uid_cputime proc entry\n",
+			__func__);
+		goto err;
+	}
+
+	proc_create_data("remove_uid_range", 0222, cpu_parent,
+		&uid_remove_fops, NULL);
+	proc_create_data("show_uid_stat", 0444, cpu_parent,
+		&uid_cputime_fops, NULL);
+
+	io_parent = proc_mkdir("uid_io", NULL);
+	if (!io_parent) {
+		pr_err("%s: failed to create uid_io proc entry\n",
+			__func__);
+		goto err;
+	}
+
+	proc_create_data("stats", 0444, io_parent,
+		&uid_io_fops, NULL);
+
+	proc_parent = proc_mkdir("uid_procstat", NULL);
+	if (!proc_parent) {
+		pr_err("%s: failed to create uid_procstat proc entry\n",
+			__func__);
+		goto err;
+	}
+
+	proc_create_data("set", 0222, proc_parent,
+		&uid_procstat_fops, NULL);
+
+	profile_event_register(PROFILE_TASK_EXIT, &process_notifier_block);
+
+	return 0;
+
+err:
+	remove_proc_subtree("uid_cputime", NULL);
+	remove_proc_subtree("uid_io", NULL);
+	remove_proc_subtree("uid_procstat", NULL);
+	return -ENOMEM;
+}
+
+early_initcall(proc_uid_sys_stats_init);
-- 
2.17.1

