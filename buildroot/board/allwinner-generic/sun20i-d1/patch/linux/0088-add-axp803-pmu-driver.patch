From 40dd6e87e213ca277bb730f892fb6123fdd85b82 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 17:25:36 +0800
Subject: [PATCH 88/93] add axp803 pmu driver

---
 drivers/power/reset/Kconfig               |    4 +-
 drivers/power/reset/hisi-reboot.c         |   59 +-
 drivers/power/reset/sc27xx-poweroff.c     |   21 +-
 drivers/power/supply/Kconfig              |    9 +-
 drivers/power/supply/Makefile             |    3 +
 drivers/power/supply/axp803_ac_power.c    |  336 ++++++
 drivers/power/supply/axp803_battery.c     | 1223 +++++++++++++++++++++
 drivers/power/supply/axp803_charger.h     |  238 ++++
 drivers/power/supply/axp803_usb_power.c   |  474 ++++++++
 drivers/power/supply/power_supply_core.c  |   67 +-
 drivers/power/supply/power_supply_sysfs.c |  492 +++++----
 drivers/power/supply/qcom_smbb.c          |   81 +-
 drivers/power/supply/sc27xx_fuel_gauge.c  |   61 +-
 13 files changed, 2831 insertions(+), 237 deletions(-)
 create mode 100644 drivers/power/supply/axp803_ac_power.c
 create mode 100644 drivers/power/supply/axp803_battery.c
 create mode 100644 drivers/power/supply/axp803_charger.h
 create mode 100644 drivers/power/supply/axp803_usb_power.c

diff --git a/drivers/power/reset/Kconfig b/drivers/power/reset/Kconfig
index a56423727..f58f303de 100644
--- a/drivers/power/reset/Kconfig
+++ b/drivers/power/reset/Kconfig
@@ -94,7 +94,7 @@ config POWER_RESET_GPIO_RESTART
 	  create a binding in your devicetree.
 
 config POWER_RESET_HISI
-	bool "Hisilicon power-off driver"
+	tristate "Hisilicon power-off driver"
 	depends on ARCH_HISI
 	help
 	  Reboot support for Hisilicon boards.
@@ -238,7 +238,7 @@ config SYSCON_REBOOT_MODE
 	  action according to the mode.
 
 config POWER_RESET_SC27XX
-	bool "Spreadtrum SC27xx PMIC power-off driver"
+	tristate "Spreadtrum SC27xx PMIC power-off driver"
 	depends on MFD_SC27XX_PMIC || COMPILE_TEST
 	help
 	  This driver supports powering off a system through
diff --git a/drivers/power/reset/hisi-reboot.c b/drivers/power/reset/hisi-reboot.c
index 0ba5fdce1..283afb538 100644
--- a/drivers/power/reset/hisi-reboot.c
+++ b/drivers/power/reset/hisi-reboot.c
@@ -8,26 +8,64 @@
  * Author: Haojian Zhuang <haojian.zhuang@linaro.org>
  */
 
+#include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/module.h>
+#include <linux/mfd/syscon.h>
 #include <linux/notifier.h>
 #include <linux/of_address.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
+#include <linux/regmap.h>
+#include <asm/system_misc.h>
 
 #include <asm/proc-fns.h>
 
 static void __iomem *base;
 static u32 reboot_offset;
+static struct regmap *pmu_regmap;
+static struct regmap *sctrl_regmap;
+
+#define REBOOT_REASON_BOOTLOADER (0x01)
+#define REBOOT_REASON_COLDBOOT   (0x00)
+#define DDR_BYPASS               BIT(31)
+
+#define RST_FLAG_MASK            GENMASK(7, 0)
+
+#define PMU_HRST_OFFSET		((0x101) << 2)
+#define SCPEREN1_OFFSET		(0x170)
 
 static int hisi_restart_handler(struct notifier_block *this,
 				unsigned long mode, void *cmd)
 {
-	writel_relaxed(0xdeadbeef, base + reboot_offset);
+	int ret;
+	char reboot_reason;
+
+	if (!cmd || !strcmp(cmd, "bootloader"))
+		reboot_reason = REBOOT_REASON_BOOTLOADER;
+	else
+		reboot_reason = REBOOT_REASON_COLDBOOT;
+
+	if (base) {
+		writel_relaxed(0xdeadbeef, base + reboot_offset);
+	} else {
+		ret = regmap_update_bits(pmu_regmap, PMU_HRST_OFFSET,
+					 RST_FLAG_MASK, reboot_reason);
+		if (ret)
+			return ret;
+
+		ret = regmap_write(sctrl_regmap, SCPEREN1_OFFSET, DDR_BYPASS);
+		if (ret)
+			return ret;
+
+		ret = regmap_write(sctrl_regmap, reboot_offset, 0xdeadbeef);
+		if (ret)
+			return ret;
+	}
 
 	while (1)
-		cpu_do_idle();
+		mdelay(1);
 
 	return NOTIFY_DONE;
 }
@@ -44,8 +82,17 @@ static int hisi_reboot_probe(struct platform_device *pdev)
 
 	base = of_iomap(np, 0);
 	if (!base) {
-		WARN(1, "failed to map base address");
-		return -ENODEV;
+		pmu_regmap = syscon_regmap_lookup_by_phandle(np, "pmu-regmap");
+		if (!pmu_regmap) {
+			WARN(1, "failed to regmap pmu address");
+			return -ENODEV;
+		}
+
+		sctrl_regmap = syscon_regmap_lookup_by_phandle(np, "sctrl-regmap");
+		if (!sctrl_regmap) {
+			WARN(1, "failed to regmap sctrl address");
+			return -ENODEV;
+		}
 	}
 
 	if (of_property_read_u32(np, "reboot-offset", &reboot_offset) < 0) {
@@ -66,6 +113,7 @@ static int hisi_reboot_probe(struct platform_device *pdev)
 
 static const struct of_device_id hisi_reboot_of_match[] = {
 	{ .compatible = "hisilicon,sysctrl" },
+	{ .compatible = "hisilicon,hi3660-reboot" },
 	{}
 };
 
@@ -77,3 +125,6 @@ static struct platform_driver hisi_reboot_driver = {
 	},
 };
 module_platform_driver(hisi_reboot_driver);
+
+MODULE_DESCRIPTION("Reset driver for HiSi SoCs");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/power/reset/sc27xx-poweroff.c b/drivers/power/reset/sc27xx-poweroff.c
index 29fb08b8f..69863074d 100644
--- a/drivers/power/reset/sc27xx-poweroff.c
+++ b/drivers/power/reset/sc27xx-poweroff.c
@@ -6,6 +6,7 @@
 
 #include <linux/cpu.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/pm.h>
 #include <linux/regmap.h>
@@ -13,6 +14,8 @@
 
 #define SC27XX_PWR_PD_HW	0xc2c
 #define SC27XX_PWR_OFF_EN	BIT(0)
+#define SC27XX_SLP_CTRL		0xdf0
+#define SC27XX_LDO_XTL_EN	BIT(3)
 
 static struct regmap *regmap;
 
@@ -27,10 +30,13 @@ static struct regmap *regmap;
  */
 static void sc27xx_poweroff_shutdown(void)
 {
-#ifdef CONFIG_PM_SLEEP_SMP
-	int cpu = smp_processor_id();
+#ifdef CONFIG_HOTPLUG_CPU
+	int cpu;
 
-	freeze_secondary_cpus(cpu);
+	for_each_online_cpu(cpu) {
+		if (cpu != smp_processor_id())
+			cpu_down(cpu);
+	}
 #endif
 }
 
@@ -40,6 +46,9 @@ static struct syscore_ops poweroff_syscore_ops = {
 
 static void sc27xx_poweroff_do_poweroff(void)
 {
+	/* Disable the external subsys connection's power firstly */
+	regmap_write(regmap, SC27XX_SLP_CTRL, SC27XX_LDO_XTL_EN);
+
 	regmap_write(regmap, SC27XX_PWR_PD_HW, SC27XX_PWR_OFF_EN);
 }
 
@@ -63,4 +72,8 @@ static struct platform_driver sc27xx_poweroff_driver = {
 		.name = "sc27xx-poweroff",
 	},
 };
-builtin_platform_driver(sc27xx_poweroff_driver);
+module_platform_driver(sc27xx_poweroff_driver);
+
+MODULE_DESCRIPTION("Power off driver for SC27XX PMIC Device");
+MODULE_AUTHOR("Baolin Wang <baolin.wang@unisoc.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index d6fdc10c2..bf138bd97 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -353,6 +353,13 @@ config AXP288_FUEL_GAUGE
 	  monitoring as well as alerts for battery over/under voltage and
 	  over/under temperature.
 
+config AXP803_POWER
+	tristate "AXP803 power supply driver"
+	depends on MFD_AXP2101
+	help
+	  This driver provides support for the power supply features of
+	  AXP803 PMIC.
+
 config BATTERY_MAX17040
 	tristate "Maxim MAX17040 Fuel Gauge"
 	depends on I2C
@@ -480,7 +487,7 @@ config CHARGER_GPIO
 	  called gpio-charger.
 
 config CHARGER_MANAGER
-	bool "Battery charger manager for multiple chargers"
+	tristate "Battery charger manager for multiple chargers"
 	depends on REGULATOR
 	select EXTCON
 	help
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 6c7da920e..13e668014 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -23,6 +23,9 @@ obj-$(CONFIG_CHARGER_ADP5061)	+= adp5061.o
 obj-$(CONFIG_BATTERY_ACT8945A)	+= act8945a_charger.o
 obj-$(CONFIG_BATTERY_AXP20X)	+= axp20x_battery.o
 obj-$(CONFIG_CHARGER_AXP20X)	+= axp20x_ac_power.o
+obj-$(CONFIG_AXP803_POWER)	+= axp803_usb_power.o
+obj-$(CONFIG_AXP803_POWER)	+= axp803_ac_power.o
+obj-$(CONFIG_AXP803_POWER)	+= axp803_battery.o
 obj-$(CONFIG_BATTERY_CPCAP)	+= cpcap-battery.o
 obj-$(CONFIG_BATTERY_DS2760)	+= ds2760_battery.o
 obj-$(CONFIG_BATTERY_DS2780)	+= ds2780_battery.o
diff --git a/drivers/power/supply/axp803_ac_power.c b/drivers/power/supply/axp803_ac_power.c
new file mode 100644
index 000000000..49a7fd618
--- /dev/null
+++ b/drivers/power/supply/axp803_ac_power.c
@@ -0,0 +1,336 @@
+#define pr_fmt(x) KBUILD_MODNAME ": " x "\n"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/param.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/fs.h>
+#include <linux/ktime.h>
+#include <linux/of.h>
+#include <linux/timekeeping.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <asm/irq.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/err.h>
+#include <linux/mfd/axp2101.h>
+#include "axp803_charger.h"
+
+struct axp803_ac_power {
+	char                      *name;
+	struct device             *dev;
+	struct axp_config_info     dts_info;
+	struct regmap             *regmap;
+	struct power_supply       *ac_supply;
+	struct delayed_work        ac_supply_mon;
+};
+
+static int axp803_ac_set_vhold(struct axp803_ac_power *ac_power, int vol)
+{
+	unsigned int tmp;
+	struct regmap *map = ac_power->regmap;
+
+	if (vol) {
+		regmap_update_bits(map, AXP803_CHARGE_AC_SET, 0x40, 0x40);
+		if (vol >= 4000 && vol <= 4700) {
+			tmp = (vol - 4000)/100;
+			regmap_update_bits(map, AXP803_CHARGE_AC_SET,
+					0x7 << 3, tmp << 3);
+		} else {
+			pr_err("set ac limit voltage error, %d mV\n", vol);
+		}
+	} else {
+		regmap_update_bits(map, AXP803_CHARGE_AC_SET, 0x40, 0x00);
+	}
+
+	return 0;
+}
+
+static int axp803_ac_set_ihold(struct axp803_ac_power *ac_power, int cur)
+{
+	unsigned int tmp;
+	struct regmap *map = ac_power->regmap;
+
+	if (cur) {
+		if (cur >= 1500 && cur <= 4000) {
+			tmp = (cur - 1500) / 500;
+			regmap_update_bits(map, AXP803_CHARGE_AC_SET, 0x7, tmp);
+		} else {
+			pr_err("set ac limit current error, %d mA\n", cur);
+		}
+	} else {
+		regmap_update_bits(map, AXP803_CHARGE_AC_SET, 0x40, 0x40);
+	}
+
+	return 0;
+}
+
+static enum power_supply_property axp803_ac_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static int axp803_ac_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	int ret = 0;
+	unsigned int reg_value;
+	struct axp803_ac_power *ac_power = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = psy->desc->name;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		ret = regmap_read(ac_power->regmap, AXP803_STATUS, &reg_value);
+		if (ret)
+			return ret;
+		val->intval = !!(reg_value & AXP803_STATUS_AC_PRESENT);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = regmap_read(ac_power->regmap, AXP803_STATUS, &reg_value);
+		if (ret)
+			return ret;
+		val->intval = !!(reg_value & AXP803_STATUS_AC_USED);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct power_supply_desc axp803_ac_desc = {
+	.name = "axp803-ac",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.get_property = axp803_ac_get_property,
+	.properties = axp803_ac_props,
+	.num_properties = ARRAY_SIZE(axp803_ac_props),
+};
+
+static int axp803_ac_power_init(struct axp803_ac_power *ac_power)
+{
+	struct axp_config_info *axp_config = &ac_power->dts_info;
+
+	axp803_ac_set_vhold(ac_power, axp_config->pmu_ac_vol);
+	axp803_ac_set_ihold(ac_power, axp_config->pmu_ac_cur);
+	return 0;
+}
+
+static irqreturn_t axp803_ac_power_irq(int irq, void *data)
+{
+	struct axp803_ac_power *ac_power = data;
+
+	power_supply_changed(ac_power->ac_supply);
+
+	return IRQ_HANDLED;
+}
+
+enum axp803_ac_power_virqs {
+	AXP803_VIRQ_ACIN,
+	AXP803_VIRQ_ACRE,
+
+	AXP803_AC_VIRQ_MAX_VIRQ,
+};
+
+static struct axp_interrupts axp803_ac_irq[] = {
+	[AXP803_VIRQ_ACIN] = {"ac in", axp803_ac_power_irq},
+	[AXP803_VIRQ_ACRE] = {"ac out", axp803_ac_power_irq},
+};
+
+static void axp803_ac_power_monitor(struct work_struct *work)
+{
+	struct axp803_ac_power *ac_power =
+		container_of(work, typeof(*ac_power), ac_supply_mon.work);
+
+	schedule_delayed_work(&ac_power->ac_supply_mon, msecs_to_jiffies(500));
+}
+
+static int axp803_ac_power_dt_parse(struct axp803_ac_power *ac_power)
+{
+	struct axp_config_info *axp_config = &ac_power->dts_info;
+	struct device_node *node = ac_power->dev->of_node;
+
+	if (!of_device_is_available(node)) {
+		pr_err("%s: failed\n", __func__);
+		return -1;
+	}
+
+	AXP_OF_PROP_READ(pmu_ac_vol,                     4400);
+	AXP_OF_PROP_READ(pmu_ac_cur,                        0);
+
+	axp_config->wakeup_ac_in =
+		of_property_read_bool(node, "wakeup_ac_in");
+	axp_config->wakeup_ac_out =
+		of_property_read_bool(node, "wakeup_ac_out");
+
+	return 0;
+}
+
+static int axp803_ac_power_probe(struct platform_device *pdev)
+{
+	struct axp20x_dev *axp_dev = dev_get_drvdata(pdev->dev.parent);
+	struct power_supply_config psy_cfg = {};
+	struct axp803_ac_power *ac_power;
+	int i, irq;
+	int ret = 0;
+
+	if (!axp_dev->irq) {
+		pr_err("can not register axp803 ac without irq\n");
+		return -EINVAL;
+	}
+
+	ac_power = devm_kzalloc(&pdev->dev, sizeof(*ac_power), GFP_KERNEL);
+	if (!ac_power) {
+		pr_err("axp803 ac power alloc failed\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ac_power->name = "axp803-ac-power";
+	ac_power->dev = &pdev->dev;
+	ac_power->regmap = axp_dev->regmap;
+
+	platform_set_drvdata(pdev, ac_power);
+
+	ret = axp803_ac_power_dt_parse(ac_power);
+	if (ret) {
+		pr_err("%s parse device tree err\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	ret = axp803_ac_power_init(ac_power);
+	if (ret < 0) {
+		pr_err("axp210x init chip fail!\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	psy_cfg.of_node = pdev->dev.of_node;
+	psy_cfg.drv_data = ac_power;
+
+	ac_power->ac_supply = devm_power_supply_register(ac_power->dev,
+			&axp803_ac_desc, &psy_cfg);
+
+	if (IS_ERR(ac_power->ac_supply)) {
+		pr_err("axp803 failed to register ac power\n");
+		ret = PTR_ERR(ac_power->ac_supply);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(axp803_ac_irq); i++) {
+		irq = platform_get_irq_byname(pdev, axp803_ac_irq[i].name);
+		if (irq < 0) {
+			dev_warn(&pdev->dev, "No IRQ for %s: %d\n",
+				 axp803_ac_irq[i].name, irq);
+			continue;
+		}
+		irq = regmap_irq_get_virq(axp_dev->regmap_irqc, irq);
+		ret = devm_request_any_context_irq(&pdev->dev, irq,
+						   axp803_ac_irq[i].isr, 0,
+						   axp803_ac_irq[i].name, ac_power);
+		if (ret < 0)
+			dev_warn(&pdev->dev, "Error requesting %s IRQ %d: %d\n",
+				axp803_ac_irq[i].name, irq, ret);
+
+		dev_dbg(&pdev->dev, "Requested %s IRQ %d: %d\n",
+			axp803_ac_irq[i].name, irq, ret);
+
+		/* we use this variable to suspend irq */
+		axp803_ac_irq[i].irq = irq;
+	}
+
+
+	INIT_DELAYED_WORK(&ac_power->ac_supply_mon, axp803_ac_power_monitor);
+	schedule_delayed_work(&ac_power->ac_supply_mon, msecs_to_jiffies(500));
+
+	return 0;
+}
+
+static int axp803_ac_power_remove(struct platform_device *pdev)
+{
+	struct axp803_ac_power *ac_power = platform_get_drvdata(pdev);
+
+	cancel_delayed_work_sync(&ac_power->ac_supply_mon);
+
+	return 0;
+}
+
+static inline void axp_irq_set(unsigned int irq, bool enable)
+{
+	if (enable)
+		enable_irq(irq);
+	else
+		disable_irq(irq);
+}
+
+static void axp803_ac_virq_dts_set(struct axp803_ac_power *ac_power, bool enable)
+{
+	struct axp_config_info *dts_info = &ac_power->dts_info;
+
+	if (!dts_info->wakeup_usb_in)
+		axp_irq_set(axp803_ac_irq[AXP803_VIRQ_ACIN].irq,
+				enable);
+	if (!dts_info->wakeup_usb_out)
+		axp_irq_set(axp803_ac_irq[AXP803_VIRQ_ACRE].irq,
+				enable);
+}
+
+static int axp803_ac_power_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct axp803_ac_power *ac_power = platform_get_drvdata(pdev);
+
+	axp803_ac_virq_dts_set(ac_power, false);
+
+	return 0;
+}
+
+static int axp803_ac_power_resume(struct platform_device *pdev)
+{
+	struct axp803_ac_power *ac_power = platform_get_drvdata(pdev);
+
+	axp803_ac_virq_dts_set(ac_power, true);
+
+	return 0;
+}
+
+static const struct of_device_id axp803_ac_power_match[] = {
+	{
+		.compatible = "x-powers,axp803-ac-power-supply",
+		.data = (void *)AXP803_ID,
+	}, { /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, axp803_ac_power_match);
+
+static struct platform_driver axp803_ac_power_driver = {
+	.driver = {
+		.name = "axp803-ac-power-supply",
+		.of_match_table = axp803_ac_power_match,
+	},
+	.probe = axp803_ac_power_probe,
+	.remove = axp803_ac_power_remove,
+	.suspend = axp803_ac_power_suspend,
+	.resume = axp803_ac_power_resume,
+};
+
+module_platform_driver(axp803_ac_power_driver);
+
+MODULE_AUTHOR("wangxiaoliang <wangxiaoliang@x-powers.com>");
+MODULE_DESCRIPTION("axp803 ac power driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/supply/axp803_battery.c b/drivers/power/supply/axp803_battery.c
new file mode 100644
index 000000000..7376cfb7a
--- /dev/null
+++ b/drivers/power/supply/axp803_battery.c
@@ -0,0 +1,1223 @@
+#define pr_fmt(x) KBUILD_MODNAME ": " x "\n"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/param.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/fs.h>
+#include <linux/ktime.h>
+#include <linux/of.h>
+#include <linux/timekeeping.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <asm/irq.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/err.h>
+#include <linux/mfd/axp2101.h>
+#include "axp803_charger.h"
+
+struct axp803_bat_power {
+	char                      *name;
+	struct device             *dev;
+	struct axp_config_info     dts_info;
+	struct regmap             *regmap;
+	struct power_supply       *bat_supply;
+	struct delayed_work        bat_supply_mon;
+};
+
+static bool charger_debug;
+
+static int axp803_get_bat_health(struct axp803_bat_power *bat_power)
+{
+	unsigned int reg_value;
+	int ret = 0;
+
+	ret = regmap_read(bat_power->regmap, AXP803_MODE_CHGSTATUS, &reg_value);
+	if (reg_value & AXP803_FAULT_LOG_BATINACT)
+		return POWER_SUPPLY_HEALTH_DEAD;
+	else if (reg_value & AXP803_FAULT_LOG_OVER_TEMP)
+		return POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (reg_value & AXP803_FAULT_LOG_COLD)
+		return POWER_SUPPLY_HEALTH_COLD;
+	else
+		return POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static inline int axp803_vbat_to_mV(unsigned int reg)
+{
+	return ((int)(((reg >> 8) << 4) | (reg & 0x000F))) * 1100 / 1000;
+}
+
+static int axp803_get_vbat(struct axp803_bat_power *bat_power)
+{
+	unsigned char temp_val[2];
+	unsigned int res;
+	int ret = 0;
+
+	ret = regmap_bulk_read(bat_power->regmap, AXP803_VBATH_RES, temp_val, 2);
+	if (ret < 0)
+		return ret;
+
+	res = (temp_val[0] << 8) | temp_val[1];
+
+	return axp803_vbat_to_mV(res);
+}
+
+static inline int axp803_icharge_to_mA(unsigned int reg)
+{
+	return (int)(((reg >> 8) << 4) | (reg & 0x000F));
+}
+
+static int axp803_get_ibat(struct axp803_bat_power *bat_power)
+{
+	unsigned char tmp[2];
+	unsigned int res;
+
+	regmap_bulk_read(bat_power->regmap, AXP803_IBATH_REG, tmp, 2);
+	res = (tmp[0] << 8) | tmp[1];
+
+	return axp803_icharge_to_mA(res);
+}
+
+static int axp803_get_disibat(struct axp803_bat_power *bat_power)
+{
+	unsigned char tmp[2];
+	unsigned int dis_res;
+
+	regmap_bulk_read(bat_power->regmap, AXP803_DISIBATH_REG, tmp, 2);
+	dis_res = (tmp[0] << 8) | tmp[1];
+
+	return axp803_icharge_to_mA(dis_res);
+}
+
+static int axp803_set_bat_chg_cur(struct axp803_bat_power *bat_power, int cur)
+{
+	uint8_t tmp = 0;
+	struct regmap *map = bat_power->regmap;
+
+	if (cur == 0)
+		regmap_update_bits(map, AXP803_CHARGE1, 0x80, 0x00);
+	else
+		regmap_update_bits(map, AXP803_CHARGE1, 0x80, 0x80);
+
+	if (cur >= 200 && cur <= 2800) {
+		tmp = (cur - 200) / 200;
+		regmap_update_bits(map, AXP803_CHARGE1, 0x0f, tmp);
+	} else if (cur < 200) {
+		regmap_update_bits(map, AXP803_CHARGE1, 0x0f, 0x00);
+	} else {
+		regmap_update_bits(map, AXP803_CHARGE1, 0x0f, 0x0d);
+	}
+
+	return 0;
+}
+
+static int axp803_get_rest_cap(struct axp803_bat_power *bat_power)
+{
+	unsigned char temp_val[2];
+	unsigned int reg_value;
+	int batt_max_cap, coulumb_counter;
+	int rest_vol = 0;
+	int ocv_vol = 0;
+	int rdc = 0;
+	int ret = 0;
+
+	int charging = 0;
+	int ocv_pct = 0;
+	int coul_pct = 0;
+	int ac_valid = 0;
+	int usb_valid = 0;
+	static int pre_rest_vol, invalid_count;
+
+	struct axp_config_info *axp_config = &bat_power->dts_info;
+
+	ret = regmap_read(bat_power->regmap, AXP803_CAP, &reg_value);
+	if (ret)
+		return ret;
+
+	if (reg_value & 0x80) {
+		rest_vol = (int)(reg_value & 0x7F);
+		pre_rest_vol = rest_vol;
+		invalid_count = 0;
+	} else {
+		rest_vol = pre_rest_vol;
+		invalid_count++;
+
+		if (invalid_count == 30) {
+			invalid_count = 0;
+			rest_vol = 100;
+		}
+
+		return rest_vol;
+	}
+
+	/* read chatging status */
+	ret = regmap_read(bat_power->regmap, AXP803_MODE_CHGSTATUS, &reg_value);
+	if (ret)
+		return ret;
+	charging = (reg_value & (1 << 6)) ? 1 : 0;
+
+	/* read adaptor valid status */
+	ret = regmap_read(bat_power->regmap, AXP803_STATUS, &reg_value);
+	if (ret)
+		return ret;
+	ac_valid = (reg_value & (1 << 6)) ? 1 : 0;
+
+	ret = regmap_read(bat_power->regmap, AXP803_STATUS, &reg_value);
+	if (ret)
+		return ret;
+	usb_valid = (reg_value & (1 << 4)) ? 1 : 0;
+
+	/* read ocv percentage */
+	ret = regmap_read(bat_power->regmap, AXP803_OCV_PERCENT, &reg_value);
+	if (ret)
+		return ret;
+	if (reg_value & 0x80)
+		ocv_pct = (int)(reg_value & 0x7F);
+
+	/* read coul percentage */
+	ret = regmap_read(bat_power->regmap, AXP803_COU_PERCENT, &reg_value);
+	if (ret)
+		return ret;
+	if (reg_value & 0x80)
+		coul_pct = (int)(reg_value & 0x7F);
+
+	if (ocv_pct == 100 && charging == 0 && rest_vol == 99
+		&& (ac_valid == 1 || usb_valid == 1)) {
+
+		ret = regmap_read(bat_power->regmap, AXP803_COULOMB_CTL, &reg_value);
+		if (ret)
+			return ret;
+		regmap_write(bat_power->regmap, AXP803_COULOMB_CTL, (reg_value & 0x7f));
+		regmap_write(bat_power->regmap, AXP803_COULOMB_CTL, (reg_value | 0x80));
+		rest_vol = 100;
+	}
+	if (ocv_pct == 100 && coul_pct == 100 && axp_config->ocv_coulumb_100 == 1) {
+		rest_vol = 100;
+	}
+
+	ret = regmap_bulk_read(bat_power->regmap, AXP803_COUCNT0, temp_val, 2);
+	if (ret < 0)
+		return ret;
+	coulumb_counter = (((temp_val[0] & 0x7f) << 8) + temp_val[1])
+						* 1456 / 1000;
+
+	ret = regmap_bulk_read(bat_power->regmap, AXP803_BATCAP0, temp_val, 2);
+	if (ret < 0)
+		return ret;
+	batt_max_cap = (((temp_val[0] & 0x7f) << 8) + temp_val[1])
+						* 1456 / 1000;
+
+	if (charger_debug) {
+		ret = regmap_bulk_read(bat_power->regmap, AXP803_OCVBATH_RES, temp_val, 2);
+		if (ret < 0)
+			return ret;
+		ocv_vol  =  ((temp_val[0] << 4) | (temp_val[1] & 0xF)) * 1100 / 1000;
+
+		ret = regmap_bulk_read(bat_power->regmap, AXP803_RDC0, temp_val, 2);
+		if (ret < 0)
+			return ret;
+		rdc  =  (((temp_val[0] & 0x1f) << 8) + temp_val[1]) * 10742 / 10000;
+
+		pr_debug("calc_info: ocv_vol:%d rdc:%d coulumb_counter:%d batt_max_cap:%d\n",
+			ocv_vol, rdc, coulumb_counter, batt_max_cap);
+	}
+
+	return rest_vol;
+}
+
+static inline int axp_vts_to_mV(u16 reg)
+{
+	return ((int)(((reg >> 8) << 4) | (reg & 0x000F))) * 800 / 1000;
+}
+
+static inline int axp_vts_to_temp(int data,
+		const struct axp_config_info *axp_config)
+{
+	int temp;
+
+	if (data < 80 || !axp_config->pmu_bat_temp_enable)
+		return 30;
+	else if (data < axp_config->pmu_bat_temp_para16)
+		return 80;
+	else if (data <= axp_config->pmu_bat_temp_para15) {
+		temp = 70 + (axp_config->pmu_bat_temp_para15-data)*10/
+		(axp_config->pmu_bat_temp_para15-axp_config->pmu_bat_temp_para16);
+	} else if (data <= axp_config->pmu_bat_temp_para14) {
+		temp = 60 + (axp_config->pmu_bat_temp_para14-data)*10/
+		(axp_config->pmu_bat_temp_para14-axp_config->pmu_bat_temp_para15);
+	} else if (data <= axp_config->pmu_bat_temp_para13) {
+		temp = 55 + (axp_config->pmu_bat_temp_para13-data)*5/
+		(axp_config->pmu_bat_temp_para13-axp_config->pmu_bat_temp_para14);
+	} else if (data <= axp_config->pmu_bat_temp_para12) {
+		temp = 50 + (axp_config->pmu_bat_temp_para12-data)*5/
+		(axp_config->pmu_bat_temp_para12-axp_config->pmu_bat_temp_para13);
+	} else if (data <= axp_config->pmu_bat_temp_para11) {
+		temp = 45 + (axp_config->pmu_bat_temp_para11-data)*5/
+		(axp_config->pmu_bat_temp_para11-axp_config->pmu_bat_temp_para12);
+	} else if (data <= axp_config->pmu_bat_temp_para10) {
+		temp = 40 + (axp_config->pmu_bat_temp_para10-data)*5/
+		(axp_config->pmu_bat_temp_para10-axp_config->pmu_bat_temp_para11);
+	} else if (data <= axp_config->pmu_bat_temp_para9) {
+		temp = 30 + (axp_config->pmu_bat_temp_para9-data)*10/
+		(axp_config->pmu_bat_temp_para9-axp_config->pmu_bat_temp_para10);
+	} else if (data <= axp_config->pmu_bat_temp_para8) {
+		temp = 20 + (axp_config->pmu_bat_temp_para8-data)*10/
+		(axp_config->pmu_bat_temp_para8-axp_config->pmu_bat_temp_para9);
+	} else if (data <= axp_config->pmu_bat_temp_para7) {
+		temp = 10 + (axp_config->pmu_bat_temp_para7-data)*10/
+		(axp_config->pmu_bat_temp_para7-axp_config->pmu_bat_temp_para8);
+	} else if (data <= axp_config->pmu_bat_temp_para6) {
+		temp = 5 + (axp_config->pmu_bat_temp_para6-data)*5/
+		(axp_config->pmu_bat_temp_para6-axp_config->pmu_bat_temp_para7);
+	} else if (data <= axp_config->pmu_bat_temp_para5) {
+		temp = 0 + (axp_config->pmu_bat_temp_para5-data)*5/
+		(axp_config->pmu_bat_temp_para5-axp_config->pmu_bat_temp_para6);
+	} else if (data <= axp_config->pmu_bat_temp_para4) {
+		temp = -5 + (axp_config->pmu_bat_temp_para4-data)*5/
+		(axp_config->pmu_bat_temp_para4-axp_config->pmu_bat_temp_para5);
+	} else if (data <= axp_config->pmu_bat_temp_para3) {
+		temp = -10 + (axp_config->pmu_bat_temp_para3-data)*5/
+		(axp_config->pmu_bat_temp_para3-axp_config->pmu_bat_temp_para4);
+	} else if (data <= axp_config->pmu_bat_temp_para2) {
+		temp = -15 + (axp_config->pmu_bat_temp_para2-data)*5/
+		(axp_config->pmu_bat_temp_para2-axp_config->pmu_bat_temp_para3);
+	} else if (data <= axp_config->pmu_bat_temp_para1) {
+		temp = -25 + (axp_config->pmu_bat_temp_para1-data)*10/
+		(axp_config->pmu_bat_temp_para1-axp_config->pmu_bat_temp_para2);
+	} else
+		temp = -25;
+	return temp;
+}
+
+static int axp803_get_bat_temp(struct axp803_bat_power *bat_power)
+{
+	unsigned char temp_val[2];
+	unsigned short ts_res;
+	int bat_temp_mv, bat_temp;
+	int ret = 0;
+
+	struct axp_config_info *axp_config = &bat_power->dts_info;
+
+	ret = regmap_bulk_read(bat_power->regmap, AXP803_VTS_RES, temp_val, 2);
+	if (ret < 0)
+		return ret;
+
+	ts_res = ((unsigned short) temp_val[0] << 8) | temp_val[1];
+	bat_temp_mv = axp_vts_to_mV(ts_res);
+	bat_temp = axp_vts_to_temp(bat_temp_mv, axp_config);
+
+	pr_debug("bat_temp: %d\n", bat_temp);
+
+	return bat_temp;
+}
+
+static int axp803_bat_get_max_voltage(struct axp803_bat_power *bat_power)
+{
+	int ret, reg;
+	int val = 0;
+
+	ret = regmap_read(bat_power->regmap, AXP803_CHARGE1, &reg);
+	if (ret)
+		return ret;
+
+	switch (reg & AXP803_CHRG_CTRL1_TGT_VOLT) {
+	case AXP803_CHRG_CTRL1_TGT_4_1V:
+		val = 4100000;
+		break;
+	case AXP803_CHRG_CTRL1_TGT_4_15V:
+		val = 4150000;
+		break;
+	case AXP803_CHRG_CTRL1_TGT_4_2V:
+		val = 4200000;
+		break;
+	case AXP803_CHRG_CTRL1_TGT_4_35V:
+		val = 4350000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return val;
+}
+
+static int axp803_get_bat_status(struct power_supply *psy,
+					union power_supply_propval *val)
+{
+	bool bat_det, bat_charging;
+	bool ac_valid, vbus_valid;
+	unsigned int rest_vol;
+	unsigned int reg_value;
+	int ret;
+
+	struct axp803_bat_power *bat_power = power_supply_get_drvdata(psy);
+
+	ret = regmap_read(bat_power->regmap, AXP803_MODE_CHGSTATUS, &reg_value);
+	if (ret)
+		return ret;
+	bat_det = !!(reg_value & AXP803_CHGSTATUS_BAT_PST_VALID) &&
+		!!(reg_value & AXP803_CHGSTATUS_BAT_PRESENT);
+	bat_charging = !!(reg_value & AXP803_CHGSTATUS_BAT_CHARGING);
+
+	ret = regmap_read(bat_power->regmap, AXP803_STATUS, &reg_value);
+	if (ret)
+		return ret;
+	ac_valid = !!(reg_value & AXP803_STATUS_AC_USED);
+	vbus_valid = !!(reg_value & AXP803_STATUS_VBUS_USED);
+
+	rest_vol = axp803_get_rest_cap(bat_power);
+
+	if (ac_valid || vbus_valid) {
+		if (bat_det) {
+			if (rest_vol == 100)
+				val->intval = POWER_SUPPLY_STATUS_FULL;
+			else if (bat_charging)
+				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			else
+				val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		} else {
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		}
+	} else {
+		ret = regmap_read(bat_power->regmap, AXP803_MODE_CHGSTATUS, &reg_value);
+		if (ret)
+			return ret;
+		bat_det = !!(reg_value & AXP803_CHGSTATUS_BAT_PRESENT);
+		if (bat_det)
+			val->intval =  POWER_SUPPLY_STATUS_DISCHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+	}
+
+	return 0;
+}
+
+static enum power_supply_property axp803_bat_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+};
+
+static int axp803_bat_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	int ret = 0;
+	unsigned int reg_value;
+	unsigned char temp_val[2];
+	struct axp803_bat_power *bat_power = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = psy->desc->name;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		ret = axp803_get_bat_status(psy, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = axp803_get_bat_health(bat_power);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		ret = regmap_bulk_read(bat_power->regmap, AXP803_COUCNT0, temp_val, 2);
+		if (ret < 0)
+			return ret;
+		val->intval = (((temp_val[0] & 0x7f) << 8) + temp_val[1]) * 1456;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = axp803_bat_get_max_voltage(bat_power);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		ret = regmap_read(bat_power->regmap, AXP803_VOFF_SET, &reg_value);
+		if (ret)
+			return ret;
+		val->intval = 2600000 + 100000 * (reg_value & AXP803_V_OFF_MASK);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = regmap_read(bat_power->regmap, AXP803_STATUS, &reg_value);
+		if (ret)
+			return ret;
+		val->intval = !(reg_value & AXP803_STATUS_BAT_CUR_DIRCT);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		ret = regmap_read(bat_power->regmap, AXP803_MODE_CHGSTATUS, &reg_value);
+		if (ret)
+			return ret;
+		val->intval = (reg_value & AXP803_CHGSTATUS_BAT_PRESENT) >> 5;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = axp803_get_vbat(bat_power) * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = (axp803_get_ibat(bat_power)
+				- axp803_get_disibat(bat_power)) * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		ret = regmap_bulk_read(bat_power->regmap, AXP803_BATCAP0, temp_val, 2);
+		if (ret < 0)
+			return ret;
+		val->intval = (((temp_val[0] & 0x7f) << 8) + temp_val[1]) * 1456;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = axp803_get_rest_cap(bat_power);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = axp803_get_bat_temp(bat_power) * 10;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static const struct power_supply_desc axp803_bat_desc = {
+	.name = "axp803-battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.get_property = axp803_bat_get_property,
+	.properties = axp803_bat_props,
+	.num_properties = ARRAY_SIZE(axp803_bat_props),
+};
+
+static int axp803_bat_power_init(struct axp803_bat_power *bat_power)
+{
+	unsigned char ocv_cap[32];
+	unsigned int val;
+	int cur_coulomb_counter, rdc;
+	int rest_pct;
+	int i;
+	int update_min_times[8] = {30, 60, 120, 164, 0, 5, 10, 20};
+	int ocv_cou_adjust_time[4] = {60, 120, 15, 30};
+
+	struct axp_config_info *axp_config = &bat_power->dts_info;
+	struct regmap *map = bat_power->regmap;
+
+	if (axp_config->pmu_init_chgend_rate == 10)
+		val = 0;
+	else
+		val = 1;
+	val <<= 4;
+	regmap_update_bits(map, AXP803_CHARGE1, 0x10, val);
+
+	if (axp_config->pmu_init_chg_pretime < 40)
+		axp_config->pmu_init_chg_pretime = 40;
+
+	if (axp_config->pmu_init_chg_csttime < 360)
+		axp_config->pmu_init_chg_csttime = 360;
+
+	val = ((((axp_config->pmu_init_chg_pretime - 40) / 10) << 6)
+			| ((axp_config->pmu_init_chg_csttime - 360) / 120));
+	regmap_update_bits(map, AXP803_CHARGE2, 0xc2, val);
+
+	/* adc set */
+	val = AXP803_ADC_BATVOL_ENABLE | AXP803_ADC_BATCUR_ENABLE;
+	if (axp_config->pmu_bat_temp_enable != 0)
+		val = val | AXP803_ADC_TSVOL_ENABLE;
+	regmap_update_bits(map, AXP803_ADC_EN,
+			AXP803_ADC_BATVOL_ENABLE
+			| AXP803_ADC_BATCUR_ENABLE
+			| AXP803_ADC_TSVOL_ENABLE,
+			val);
+
+	regmap_read(map, AXP803_ADC_SPEED_SET, &val);
+	switch (axp_config->pmu_init_adc_freq / 100) {
+	case 1:
+		val &= ~(0x3 << 4);
+		break;
+	case 2:
+		val &= ~(0x3 << 4);
+		val |= 0x1 << 4;
+		break;
+	case 4:
+		val &= ~(0x3 << 4);
+		val |= 0x2 << 4;
+		break;
+	case 8:
+		val |= 0x3 << 4;
+		break;
+	default:
+		break;
+	}
+
+	if (axp_config->pmu_bat_temp_enable != 0)
+		val &= (~(0x1 << 2));
+	regmap_write(map, AXP803_ADC_SPEED_SET, val);
+
+	/* bat para */
+	regmap_write(map, AXP803_WARNING_LEVEL,
+		((axp_config->pmu_battery_warning_level1 - 5) << 4)
+		+ axp_config->pmu_battery_warning_level2);
+
+	/* set target voltage */
+	if (axp_config->pmu_init_chgvol < 4150) {
+		val = 0;
+	} else if (axp_config->pmu_init_chgvol < 4200) {
+		val = 1;
+	} else if (axp_config->pmu_init_chgvol < 4350) {
+		val = 2;
+	} else {
+		val = 3;
+	}
+	val <<= 5;
+	regmap_update_bits(map, AXP803_CHARGE1, 0x60, val);
+
+	ocv_cap[0]  = axp_config->pmu_bat_para1;
+	ocv_cap[1]  = axp_config->pmu_bat_para2;
+	ocv_cap[2]  = axp_config->pmu_bat_para3;
+	ocv_cap[3]  = axp_config->pmu_bat_para4;
+	ocv_cap[4]  = axp_config->pmu_bat_para5;
+	ocv_cap[5]  = axp_config->pmu_bat_para6;
+	ocv_cap[6]  = axp_config->pmu_bat_para7;
+	ocv_cap[7]  = axp_config->pmu_bat_para8;
+	ocv_cap[8]  = axp_config->pmu_bat_para9;
+	ocv_cap[9]  = axp_config->pmu_bat_para10;
+	ocv_cap[10] = axp_config->pmu_bat_para11;
+	ocv_cap[11] = axp_config->pmu_bat_para12;
+	ocv_cap[12] = axp_config->pmu_bat_para13;
+	ocv_cap[13] = axp_config->pmu_bat_para14;
+	ocv_cap[14] = axp_config->pmu_bat_para15;
+	ocv_cap[15] = axp_config->pmu_bat_para16;
+	ocv_cap[16] = axp_config->pmu_bat_para17;
+	ocv_cap[17] = axp_config->pmu_bat_para18;
+	ocv_cap[18] = axp_config->pmu_bat_para19;
+	ocv_cap[19] = axp_config->pmu_bat_para20;
+	ocv_cap[20] = axp_config->pmu_bat_para21;
+	ocv_cap[21] = axp_config->pmu_bat_para22;
+	ocv_cap[22] = axp_config->pmu_bat_para23;
+	ocv_cap[23] = axp_config->pmu_bat_para24;
+	ocv_cap[24] = axp_config->pmu_bat_para25;
+	ocv_cap[25] = axp_config->pmu_bat_para26;
+	ocv_cap[26] = axp_config->pmu_bat_para27;
+	ocv_cap[27] = axp_config->pmu_bat_para28;
+	ocv_cap[28] = axp_config->pmu_bat_para29;
+	ocv_cap[29] = axp_config->pmu_bat_para30;
+	ocv_cap[30] = axp_config->pmu_bat_para31;
+	ocv_cap[31] = axp_config->pmu_bat_para32;
+	regmap_bulk_write(map, AXP803_OCVCAP, ocv_cap, 32);
+
+	/* Init CHGLED function */
+	if (axp_config->ocv_coulumb_100 == 1) {
+		rest_pct = axp803_get_rest_cap(bat_power);
+		if (rest_pct == 100)
+			regmap_update_bits(map, AXP803_OFF_CTL, 0x08, 0x00); /* disable CHGLED when force 100 */
+		else {
+			if (axp_config->pmu_chgled_func)
+				regmap_update_bits(map, AXP803_OFF_CTL, 0x08, 0x08); /* by charger */
+			else
+				regmap_update_bits(map, AXP803_OFF_CTL, 0x08, 0x00); /* drive MOTO */
+		}
+	} else {
+		if (axp_config->pmu_chgled_func)
+			regmap_update_bits(map, AXP803_OFF_CTL, 0x08, 0x08); /* by charger */
+		else
+			regmap_update_bits(map, AXP803_OFF_CTL, 0x08, 0x00); /* drive MOTO */
+	}
+
+	/* set CHGLED Indication Type */
+	if (axp_config->pmu_chgled_type)
+		regmap_update_bits(map, AXP803_CHARGE2, 0x10, 0x10); /* Type B */
+	else
+		regmap_update_bits(map, AXP803_CHARGE2, 0x10, 0x00); /* Type A */
+
+	/* Init battery capacity correct function */
+	if (axp_config->pmu_batt_cap_correct)
+		regmap_update_bits(map, AXP803_COULOMB_CTL, 0x20, 0x20);
+	else
+		regmap_update_bits(map, AXP803_COULOMB_CTL, 0x20, 0x00);
+
+	/* Init battery regulator enable or not when charge finish */
+	if (axp_config->pmu_chg_end_on_en)
+		regmap_update_bits(map, AXP803_CHARGE2, 0x20, 0x20);
+	else
+		regmap_update_bits(map, AXP803_CHARGE2, 0x20, 0x00);
+
+	if (axp_config->pmu_batdeten)
+		regmap_update_bits(map, AXP803_OFF_CTL, 0x40, 0x40);
+	else
+		regmap_update_bits(map, AXP803_OFF_CTL, 0x40, 0x00);
+
+	/* RDC initial */
+	regmap_read(map, AXP803_RDC0, &val);
+	if ((axp_config->pmu_battery_rdc) && (!(val & 0x40))) {
+		rdc = (axp_config->pmu_battery_rdc * 10000 + 5371) / 10742;
+		regmap_write(map, AXP803_RDC0, ((rdc >> 8) & 0x1F)|0x80);
+		regmap_write(map, AXP803_RDC1, rdc & 0x00FF);
+	}
+
+	regmap_read(map, AXP803_BATCAP0, &val);
+	if ((axp_config->pmu_battery_cap) && (!(val & 0x80))) {
+		cur_coulomb_counter = axp_config->pmu_battery_cap
+					* 1000 / 1456;
+		regmap_write(map, AXP803_BATCAP0, ((cur_coulomb_counter >> 8) | 0x80));
+		regmap_write(map, AXP803_BATCAP1, cur_coulomb_counter & 0x00FF);
+	} else if (!axp_config->pmu_battery_cap) {
+		regmap_write(map, AXP803_BATCAP0, 0x00);
+		regmap_write(map, AXP803_BATCAP1, 0x00);
+	}
+
+	/*
+	 * As datasheet decripted:
+	 * TS_VOL = reg_value * 16 * 10K * 80ua
+	 */
+	if (axp_config->pmu_bat_temp_enable == 1) {
+		regmap_write(map, AXP803_VLTF_CHARGE,
+				axp_config->pmu_bat_charge_ltf * 10 / 128);
+		regmap_write(map, AXP803_VHTF_CHARGE,
+				axp_config->pmu_bat_charge_htf * 10 / 128);
+		regmap_write(map, AXP803_VLTF_WORK,
+				axp_config->pmu_bat_shutdown_ltf * 10 / 128);
+		regmap_write(map, AXP803_VHTF_WORK,
+				axp_config->pmu_bat_shutdown_htf * 10 / 128);
+	}
+
+	if (axp_config->pmu_ocv_en == 0) {
+		pr_warn("axp803 ocv must be enabled\n");
+		axp_config->pmu_ocv_en = 1;
+	}
+	if (axp_config->pmu_init_bc_en == 1) {
+		regmap_update_bits(map, AXP803_BC_CTL, 0x01, 0x01);
+	} else {
+		regmap_update_bits(map, AXP803_BC_CTL, 0x01, 0x00);
+	}
+
+	if (axp_config->pmu_cou_en == 1) {
+		/* use ocv and cou */
+		regmap_update_bits(map, AXP803_COULOMB_CTL, 0x80, 0x80);
+		regmap_update_bits(map, AXP803_COULOMB_CTL, 0x40, 0x40);
+	} else if (axp_config->pmu_cou_en == 0) {
+		/* only use ocv */
+		regmap_update_bits(map, AXP803_COULOMB_CTL, 0x80, 0x80);
+		regmap_update_bits(map, AXP803_COULOMB_CTL, 0x40, 0x00);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(update_min_times); i++) {
+		if (update_min_times[i] == axp_config->pmu_update_min_time)
+			break;
+	}
+	regmap_update_bits(map, AXP803_ADJUST_PARA, 0x07, i);
+	for (i = 0; i < ARRAY_SIZE(ocv_cou_adjust_time); i++) {
+		if (ocv_cou_adjust_time[i] == axp_config->pmu_ocv_cou_adjust_time)
+			break;
+	}
+	i <<= 6;
+	regmap_update_bits(map, AXP803_ADJUST_PARA1, 0xc0, i);
+
+	axp803_set_bat_chg_cur(bat_power, axp_config->pmu_runtime_chgcur);
+
+	return 0;
+}
+
+static irqreturn_t axp803_bat_power_irq(int irq, void *data)
+{
+	struct axp803_bat_power *bat_power = data;
+
+	power_supply_changed(bat_power->bat_supply);
+
+	return IRQ_HANDLED;
+}
+
+enum axp803_bat_power_virqs {
+	AXP803_VIRQ_CHAST,
+	AXP803_VIRQ_CHAOV,
+	AXP803_VIRQ_BATIN,
+	AXP803_VIRQ_BATRE,
+	AXP803_VIRQ_BATINWORK,
+	AXP803_VIRQ_BATOVWORK,
+	AXP803_VIRQ_BATINCHG,
+	AXP803_VIRQ_BATOVCHG,
+	AXP803_VIRQ_LOWN2,
+	AXP803_VIRQ_LOWN1,
+
+	AXP803_BAT_VIRQ_MAX_VIRQ,
+};
+
+static struct axp_interrupts axp803_bat_irq[] = {
+	[AXP803_VIRQ_CHAST] = {"charging", axp803_bat_power_irq},
+	[AXP803_VIRQ_CHAOV] = {"charge over", axp803_bat_power_irq},
+	[AXP803_VIRQ_BATIN] = {"bat in", axp803_bat_power_irq},
+	[AXP803_VIRQ_BATRE] = {"bat out", axp803_bat_power_irq},
+	[AXP803_VIRQ_BATINWORK] = {"bat untemp work", axp803_bat_power_irq},
+	[AXP803_VIRQ_BATOVWORK] = {"bat ovtemp work", axp803_bat_power_irq},
+	[AXP803_VIRQ_BATINCHG] = {"bat untemp chg", axp803_bat_power_irq},
+	[AXP803_VIRQ_BATOVCHG] = {"bat ovtemp chg", axp803_bat_power_irq},
+	[AXP803_VIRQ_LOWN2] = {"low warning2", axp803_bat_power_irq},
+	[AXP803_VIRQ_LOWN1] = {"low warning1", axp803_bat_power_irq},
+};
+
+static void axp803_bat_power_monitor(struct work_struct *work)
+{
+	int rest_pct;
+	unsigned int reg_value;
+
+	struct axp803_bat_power *bat_power =
+		container_of(work, typeof(*bat_power), bat_supply_mon.work);
+
+	struct axp_config_info *axp_config = &bat_power->dts_info;
+
+	power_supply_changed(bat_power->bat_supply);
+
+	rest_pct = axp803_get_rest_cap(bat_power);
+
+	/* force CHGLED disable when percentage is 100%, and turn on by else */
+	if (axp_config->ocv_coulumb_100 == 1) {
+		if (rest_pct == 100)
+			regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x00); /* disable CHGLED */
+		else {
+			if (axp_config->pmu_chgled_func)
+				regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x08); /* by charger */
+			else
+				regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x00); /* drive MOTO */
+		}
+	}
+
+	/* debug info */
+	if (unlikely(axp_debug_mask & AXP_CHG)) {
+
+		unsigned char temp_val[2];
+		unsigned int tmp;
+		unsigned int col_ctl_reg;
+		int ic_temp, vbat, ocv_vol;
+		int charge_ibat, dis_ibat, ibat;
+		int ocv_pct, col_pct;
+		int rdc, batt_max_cap, coulumb_counter;
+		bool bat_cur_dir, usb_det, ac_det, ext_valid;
+
+		regmap_bulk_read(bat_power->regmap, AXP803_INTTEMP, temp_val, 2);
+		tmp = (temp_val[0] << 4) + (temp_val[1] & 0x0F);
+		ic_temp = (int)(tmp * 1063 / 10000  - 2667 / 10);
+
+		vbat = axp803_get_vbat(bat_power);
+
+		charge_ibat = axp803_get_ibat(bat_power);
+		dis_ibat = axp803_get_disibat(bat_power);
+		ibat = charge_ibat - dis_ibat;
+
+		regmap_bulk_read(bat_power->regmap, AXP803_OCVBATH_RES, temp_val, 2);
+		ocv_vol = ((temp_val[0] << 4) | (temp_val[1] & 0xF)) * 1100 / 1000;
+
+		rest_pct = axp803_get_rest_cap(bat_power);
+
+		regmap_read(bat_power->regmap, AXP803_OCV_PERCENT, &reg_value);
+		if (reg_value & 0x80)
+			ocv_pct = (int)(reg_value & 0x7F);
+		else
+			ocv_pct = 0;
+
+		regmap_read(bat_power->regmap, AXP803_COU_PERCENT, &reg_value);
+		if (reg_value & 0x80)
+			col_pct = (int)(reg_value & 0x7F);
+		else
+			col_pct = 0;
+
+		regmap_bulk_read(bat_power->regmap, AXP803_RDC0, temp_val, 2);
+		rdc = (((temp_val[0] & 0x1f) << 8) + temp_val[1]) * 10742 / 10000;
+
+		regmap_bulk_read(bat_power->regmap, AXP803_BATCAP0, temp_val, 2);
+		batt_max_cap = (((temp_val[0] & 0x7f) << 8) + temp_val[1])
+							* 1456 / 1000;
+
+		regmap_bulk_read(bat_power->regmap, AXP803_COUCNT0, temp_val, 2);
+		coulumb_counter = (((temp_val[0] & 0x7f) << 8) + temp_val[1])
+							* 1456 / 1000;
+
+		regmap_read(bat_power->regmap, AXP803_STATUS, &reg_value);
+		bat_cur_dir = (reg_value & 0x04) ? 1 : 0;
+		ac_det = (reg_value & 0x80) ? 1 : 0;
+		usb_det = (reg_value & 0x20) ? 1 : 0;
+		ext_valid = ac_det || usb_det;
+
+		regmap_read(bat_power->regmap, AXP803_COULOMB_CTL, &reg_value);
+		col_ctl_reg = reg_value;
+
+		printk("ic_temp = %d\n", ic_temp);
+		printk("vbat = %d\n", vbat);
+		printk("ibat = %d\n", ibat);
+		printk("charge_ibat = %d\n", charge_ibat);
+		printk("dis_ibat = %d\n", dis_ibat);
+		printk("ocv = %d\n", ocv_vol);
+		printk("rest_vol = %d\n", rest_pct);
+		printk("rdc = %d\n", rdc);
+		printk("batt_max_cap = %d\n", batt_max_cap);
+		printk("coulumb_counter = %d\n", coulumb_counter);
+		printk("AXP803_COULOMB_CTL = 0x%x\n", col_ctl_reg);
+		printk("ocv_percentage = %d\n", ocv_pct);
+		printk("col_percentage = %d\n", col_pct);
+		printk("bat_current_direction = %d\n", bat_cur_dir);
+		printk("ext_valid = %d\n", ext_valid);
+	}
+
+	schedule_delayed_work(&bat_power->bat_supply_mon, msecs_to_jiffies(10 * 1000));
+}
+
+static int axp803_bat_power_dt_parse(struct axp803_bat_power *bat_power)
+{
+	struct axp_config_info *axp_config = &bat_power->dts_info;
+	struct device_node *node = bat_power->dev->of_node;
+
+	if (!of_device_is_available(node)) {
+		pr_err("%s: failed\n", __func__);
+		return -1;
+	}
+
+	AXP_OF_PROP_READ(pmu_battery_rdc,              BATRDC);
+	AXP_OF_PROP_READ(pmu_battery_cap,                4000);
+	AXP_OF_PROP_READ(pmu_batdeten,                      1);
+	AXP_OF_PROP_READ(pmu_chg_ic_temp,                   0);
+	AXP_OF_PROP_READ(pmu_runtime_chgcur, INTCHGCUR / 1000);
+	AXP_OF_PROP_READ(pmu_suspend_chgcur,             1200);
+	AXP_OF_PROP_READ(pmu_shutdown_chgcur,            1200);
+	AXP_OF_PROP_READ(pmu_init_chgvol,    INTCHGVOL / 1000);
+	AXP_OF_PROP_READ(pmu_init_chgend_rate,  INTCHGENDRATE);
+	AXP_OF_PROP_READ(pmu_init_chg_enabled,              1);
+	AXP_OF_PROP_READ(pmu_init_bc_en,                    0);
+	AXP_OF_PROP_READ(pmu_init_adc_freq,        INTADCFREQ);
+	AXP_OF_PROP_READ(pmu_init_adcts_freq,     INTADCFREQC);
+	AXP_OF_PROP_READ(pmu_init_chg_pretime,  INTCHGPRETIME);
+	AXP_OF_PROP_READ(pmu_init_chg_csttime,  INTCHGCSTTIME);
+	AXP_OF_PROP_READ(pmu_batt_cap_correct,              1);
+	AXP_OF_PROP_READ(pmu_chg_end_on_en,                 0);
+	AXP_OF_PROP_READ(ocv_coulumb_100,                   0);
+	AXP_OF_PROP_READ(pmu_bat_para1,               OCVREG0);
+	AXP_OF_PROP_READ(pmu_bat_para2,               OCVREG1);
+	AXP_OF_PROP_READ(pmu_bat_para3,               OCVREG2);
+	AXP_OF_PROP_READ(pmu_bat_para4,               OCVREG3);
+	AXP_OF_PROP_READ(pmu_bat_para5,               OCVREG4);
+	AXP_OF_PROP_READ(pmu_bat_para6,               OCVREG5);
+	AXP_OF_PROP_READ(pmu_bat_para7,               OCVREG6);
+	AXP_OF_PROP_READ(pmu_bat_para8,               OCVREG7);
+	AXP_OF_PROP_READ(pmu_bat_para9,               OCVREG8);
+	AXP_OF_PROP_READ(pmu_bat_para10,              OCVREG9);
+	AXP_OF_PROP_READ(pmu_bat_para11,              OCVREGA);
+	AXP_OF_PROP_READ(pmu_bat_para12,              OCVREGB);
+	AXP_OF_PROP_READ(pmu_bat_para13,              OCVREGC);
+	AXP_OF_PROP_READ(pmu_bat_para14,              OCVREGD);
+	AXP_OF_PROP_READ(pmu_bat_para15,              OCVREGE);
+	AXP_OF_PROP_READ(pmu_bat_para16,              OCVREGF);
+	AXP_OF_PROP_READ(pmu_bat_para17,             OCVREG10);
+	AXP_OF_PROP_READ(pmu_bat_para18,             OCVREG11);
+	AXP_OF_PROP_READ(pmu_bat_para19,             OCVREG12);
+	AXP_OF_PROP_READ(pmu_bat_para20,             OCVREG13);
+	AXP_OF_PROP_READ(pmu_bat_para21,             OCVREG14);
+	AXP_OF_PROP_READ(pmu_bat_para22,             OCVREG15);
+	AXP_OF_PROP_READ(pmu_bat_para23,             OCVREG16);
+	AXP_OF_PROP_READ(pmu_bat_para24,             OCVREG17);
+	AXP_OF_PROP_READ(pmu_bat_para25,             OCVREG18);
+	AXP_OF_PROP_READ(pmu_bat_para26,             OCVREG19);
+	AXP_OF_PROP_READ(pmu_bat_para27,             OCVREG1A);
+	AXP_OF_PROP_READ(pmu_bat_para28,             OCVREG1B);
+	AXP_OF_PROP_READ(pmu_bat_para29,             OCVREG1C);
+	AXP_OF_PROP_READ(pmu_bat_para30,             OCVREG1D);
+	AXP_OF_PROP_READ(pmu_bat_para31,             OCVREG1E);
+	AXP_OF_PROP_READ(pmu_bat_para32,             OCVREG1F);
+	AXP_OF_PROP_READ(pmu_pwroff_vol,                 3300);
+	AXP_OF_PROP_READ(pmu_pwron_vol,                  2900);
+	AXP_OF_PROP_READ(pmu_battery_warning_level1,       15);
+	AXP_OF_PROP_READ(pmu_battery_warning_level2,        0);
+	AXP_OF_PROP_READ(pmu_restvol_adjust_time,          30);
+	AXP_OF_PROP_READ(pmu_ocv_cou_adjust_time,          60);
+	AXP_OF_PROP_READ(pmu_chgled_func,                   0);
+	AXP_OF_PROP_READ(pmu_chgled_type,                   0);
+	AXP_OF_PROP_READ(pmu_bat_temp_enable,               0);
+	AXP_OF_PROP_READ(pmu_bat_charge_ltf,             0xA5);
+	AXP_OF_PROP_READ(pmu_bat_charge_htf,             0x1F);
+	AXP_OF_PROP_READ(pmu_bat_shutdown_ltf,           0xFC);
+	AXP_OF_PROP_READ(pmu_bat_shutdown_htf,           0x16);
+	AXP_OF_PROP_READ(pmu_bat_temp_para1,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para2,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para3,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para4,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para5,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para6,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para7,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para8,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para9,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para10,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para11,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para12,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para13,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para14,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para15,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para16,               0);
+	AXP_OF_PROP_READ(pmu_bat_unused,                    0);
+	AXP_OF_PROP_READ(power_start,                       0);
+	AXP_OF_PROP_READ(pmu_ocv_en,                        1);
+	AXP_OF_PROP_READ(pmu_cou_en,                        1);
+	AXP_OF_PROP_READ(pmu_update_min_time,   UPDATEMINTIME);
+
+	axp_config->wakeup_bat_in =
+		of_property_read_bool(node, "wakeup_bat_in");
+	axp_config->wakeup_bat_out =
+		of_property_read_bool(node, "wakeup_bat_out");
+	axp_config->wakeup_bat_charging =
+		of_property_read_bool(node, "wakeup_bat_charging");
+	axp_config->wakeup_bat_charge_over =
+		of_property_read_bool(node, "wakeup_bat_charge_over");
+	axp_config->wakeup_low_warning1 =
+		of_property_read_bool(node, "wakeup_low_warning1");
+	axp_config->wakeup_low_warning2 =
+		of_property_read_bool(node, "wakeup_low_warning2");
+	axp_config->wakeup_bat_untemp_work =
+		of_property_read_bool(node, "wakeup_bat_untemp_work");
+	axp_config->wakeup_bat_ovtemp_work =
+		of_property_read_bool(node, "wakeup_bat_ovtemp_work");
+	axp_config->wakeup_untemp_chg =
+		of_property_read_bool(node, "wakeup_bat_untemp_chg");
+	axp_config->wakeup_ovtemp_chg =
+		of_property_read_bool(node, "wakeup_bat_ovtemp_chg");
+
+	return 0;
+}
+
+static int axp803_bat_power_probe(struct platform_device *pdev)
+{
+	struct axp20x_dev *axp_dev = dev_get_drvdata(pdev->dev.parent);
+	struct power_supply_config psy_cfg = {};
+	struct axp803_bat_power *bat_power;
+	int i, irq;
+	int ret = 0;
+
+	if (!axp_dev->irq) {
+		pr_err("can not register axp803 bat without irq\n");
+		return -EINVAL;
+	}
+
+	bat_power = devm_kzalloc(&pdev->dev, sizeof(*bat_power), GFP_KERNEL);
+	if (!bat_power) {
+		pr_err("axp803 bat power alloc failed\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	bat_power->name = "axp803-bat-power";
+	bat_power->dev = &pdev->dev;
+	bat_power->regmap = axp_dev->regmap;
+
+	platform_set_drvdata(pdev, bat_power);
+
+	ret = axp803_bat_power_dt_parse(bat_power);
+	if (ret) {
+		pr_err("%s parse device tree err\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	ret = axp803_bat_power_init(bat_power);
+	if (ret < 0) {
+		pr_err("axp210x init bat fail!\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	psy_cfg.of_node = pdev->dev.of_node;
+	psy_cfg.drv_data = bat_power;
+
+	bat_power->bat_supply = devm_power_supply_register(bat_power->dev,
+			&axp803_bat_desc, &psy_cfg);
+
+	if (IS_ERR(bat_power->bat_supply)) {
+		pr_err("axp803 failed to register bat power\n");
+		ret = PTR_ERR(bat_power->bat_supply);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(axp803_bat_irq); i++) {
+		irq = platform_get_irq_byname(pdev, axp803_bat_irq[i].name);
+		if (irq < 0) {
+			dev_warn(&pdev->dev, "No IRQ for %s: %d\n",
+				 axp803_bat_irq[i].name, irq);
+			continue;
+		}
+		irq = regmap_irq_get_virq(axp_dev->regmap_irqc, irq);
+		ret = devm_request_any_context_irq(&pdev->dev, irq,
+						   axp803_bat_irq[i].isr, 0,
+						   axp803_bat_irq[i].name, bat_power);
+		if (ret < 0)
+			dev_warn(&pdev->dev, "Error requesting %s IRQ %d: %d\n",
+				axp803_bat_irq[i].name, irq, ret);
+
+		dev_dbg(&pdev->dev, "Requested %s IRQ %d: %d\n",
+			axp803_bat_irq[i].name, irq, ret);
+
+		/* we use this variable to suspend irq */
+		axp803_bat_irq[i].irq = irq;
+	}
+
+
+	INIT_DELAYED_WORK(&bat_power->bat_supply_mon, axp803_bat_power_monitor);
+	schedule_delayed_work(&bat_power->bat_supply_mon, msecs_to_jiffies(10 * 1000));
+
+	return 0;
+}
+
+static int axp803_bat_power_remove(struct platform_device *pdev)
+{
+	struct axp803_bat_power *bat_power = platform_get_drvdata(pdev);
+
+	cancel_delayed_work_sync(&bat_power->bat_supply_mon);
+
+	return 0;
+}
+
+static inline void axp_irq_set(unsigned int irq, bool enable)
+{
+	if (enable)
+		enable_irq(irq);
+	else
+		disable_irq(irq);
+}
+
+static void axp803_bat_virq_dts_set(struct axp803_bat_power *bat_power, bool enable)
+{
+	struct axp_config_info *dts_info = &bat_power->dts_info;
+
+	if (!dts_info->wakeup_bat_in)
+		axp_irq_set(axp803_bat_irq[AXP803_VIRQ_BATIN].irq,
+				enable);
+	if (!dts_info->wakeup_bat_out)
+		axp_irq_set(axp803_bat_irq[AXP803_VIRQ_BATRE].irq,
+				enable);
+	if (!dts_info->wakeup_bat_charging)
+		axp_irq_set(axp803_bat_irq[AXP803_VIRQ_CHAST].irq,
+				enable);
+	if (!dts_info->wakeup_bat_charge_over)
+		axp_irq_set(axp803_bat_irq[AXP803_VIRQ_CHAOV].irq,
+				enable);
+	if (!dts_info->wakeup_low_warning1)
+		axp_irq_set(axp803_bat_irq[AXP803_VIRQ_LOWN1].irq,
+				enable);
+	if (!dts_info->wakeup_low_warning2)
+		axp_irq_set(axp803_bat_irq[AXP803_VIRQ_LOWN2].irq,
+				enable);
+	if (!dts_info->wakeup_bat_untemp_work)
+		axp_irq_set(
+			axp803_bat_irq[AXP803_VIRQ_BATINWORK].irq,
+			enable);
+	if (!dts_info->wakeup_bat_ovtemp_work)
+		axp_irq_set(
+			axp803_bat_irq[AXP803_VIRQ_BATOVWORK].irq,
+			enable);
+	if (!dts_info->wakeup_untemp_chg)
+		axp_irq_set(
+			axp803_bat_irq[AXP803_VIRQ_BATINCHG].irq,
+			enable);
+	if (!dts_info->wakeup_ovtemp_chg)
+		axp_irq_set(
+			axp803_bat_irq[AXP803_VIRQ_BATOVCHG].irq,
+			enable);
+}
+
+static void axp803_bat_power_shutdown(struct platform_device *pdev)
+{
+	struct axp803_bat_power *bat_power = platform_get_drvdata(pdev);
+
+	axp803_set_bat_chg_cur(bat_power, bat_power->dts_info.pmu_shutdown_chgcur);
+}
+
+
+static int axp803_bat_power_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int rest_pct;
+
+	struct axp803_bat_power *bat_power = platform_get_drvdata(pdev);
+	struct axp_config_info *axp_config = &bat_power->dts_info;
+
+	rest_pct = axp803_get_rest_cap(bat_power);
+
+	/* force CHGLED disable when percentage is 100%, and turn on by else */
+	if (axp_config->ocv_coulumb_100 == 1) {
+		if (rest_pct == 100)
+			regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x00); /* disable CHGLED */
+		else {
+			if (axp_config->pmu_chgled_func)
+				regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x08); /* by charger */
+			else
+				regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x00); /* drive MOTO */
+		}
+	}
+
+	axp803_set_bat_chg_cur(bat_power, bat_power->dts_info.pmu_suspend_chgcur);
+
+	axp803_bat_virq_dts_set(bat_power, false);
+
+	return 0;
+}
+
+static int axp803_bat_power_resume(struct platform_device *pdev)
+{
+	int rest_pct;
+
+	struct axp803_bat_power *bat_power = platform_get_drvdata(pdev);
+	struct axp_config_info *axp_config = &bat_power->dts_info;
+
+	power_supply_changed(bat_power->bat_supply);
+
+	rest_pct = axp803_get_rest_cap(bat_power);
+
+	/* force CHGLED disable when percentage is 100%, and turn on by else */
+	if (axp_config->ocv_coulumb_100 == 1) {
+		if (rest_pct == 100)
+			regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x00); /* disable CHGLED */
+		else {
+			if (axp_config->pmu_chgled_func)
+				regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x08); /* by charger */
+			else
+				regmap_update_bits(bat_power->regmap, AXP803_OFF_CTL, 0x08, 0x00); /* drive MOTO */
+		}
+	}
+
+	axp803_set_bat_chg_cur(bat_power, bat_power->dts_info.pmu_runtime_chgcur);
+
+	axp803_bat_virq_dts_set(bat_power, true);
+
+	return 0;
+}
+
+static const struct of_device_id axp803_bat_power_match[] = {
+	{
+		.compatible = "x-powers,axp803-battery-power-supply",
+		.data = (void *)AXP803_ID,
+	}, { /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, axp803_bat_power_match);
+
+static struct platform_driver axp803_bat_power_driver = {
+	.driver = {
+		.name = "axp803-battery-power-supply",
+		.of_match_table = axp803_bat_power_match,
+	},
+	.probe = axp803_bat_power_probe,
+	.remove = axp803_bat_power_remove,
+	.shutdown = axp803_bat_power_shutdown,
+	.suspend = axp803_bat_power_suspend,
+	.resume = axp803_bat_power_resume,
+};
+
+module_platform_driver(axp803_bat_power_driver);
+
+MODULE_AUTHOR("wangxiaoliang <wangxiaoliang@x-powers.com>");
+MODULE_DESCRIPTION("axp803 bat power driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/supply/axp803_charger.h b/drivers/power/supply/axp803_charger.h
new file mode 100644
index 000000000..b420d1baa
--- /dev/null
+++ b/drivers/power/supply/axp803_charger.h
@@ -0,0 +1,238 @@
+#ifndef _AXP803_H_
+#define _AXP803_H_
+
+#include "linux/types.h"
+
+/* reg AXP803_STATUS */
+#define AXP803_STATUS_AC_PRESENT	BIT(7)
+#define AXP803_STATUS_AC_USED		BIT(6)
+#define AXP803_STATUS_VBUS_PRESENT	BIT(5)
+#define AXP803_STATUS_VBUS_USED		BIT(4)
+#define AXP803_STATUS_BAT_CUR_DIRCT	BIT(2)
+
+/* reg AXP803_MODE_CHGSTATUS */
+#define AXP803_CHGSTATUS_BAT_CHARGING	BIT(6)
+#define AXP803_CHGSTATUS_BAT_PRESENT	BIT(5)
+#define AXP803_CHGSTATUS_BAT_PST_VALID	BIT(4)
+
+/* reg AXP803_MODE_CHGSTATUS */
+#define AXP803_FAULT_LOG_COLD		BIT(0)
+#define AXP803_FAULT_LOG_CHA_CUR_LOW	BIT(2)
+#define AXP803_FAULT_LOG_BATINACT	BIT(3)
+#define AXP803_FAULT_LOG_OVER_TEMP	BIT(7)
+
+/* AXP803_ADC_EN */
+#define AXP803_ADC_BATVOL_ENABLE	BIT(7)
+#define AXP803_ADC_BATCUR_ENABLE	BIT(6)
+#define AXP803_ADC_TSVOL_ENABLE		BIT(0)
+
+#define AXP803_CHRG_CTRL1_TGT_VOLT	GENMASK(6, 5)
+#define AXP803_CHRG_CTRL1_TGT_4_1V	(0 << 5)
+#define AXP803_CHRG_CTRL1_TGT_4_15V	(1 << 5)
+#define AXP803_CHRG_CTRL1_TGT_4_2V	(2 << 5)
+#define AXP803_CHRG_CTRL1_TGT_4_35V	(3 << 5)
+
+#define AXP803_V_OFF_MASK		GENMASK(2, 0)
+
+struct axp_config_info {
+	u32 pmu_used;
+	u32 pmu_id;
+	u32 pmu_battery_rdc;
+	u32 pmu_battery_cap;
+	u32 pmu_batdeten;
+	u32 pmu_chg_ic_temp;
+	u32 pmu_runtime_chgcur;
+	u32 pmu_suspend_chgcur;
+	u32 pmu_shutdown_chgcur;
+	u32 pmu_init_chgvol;
+	u32 pmu_init_chgend_rate;
+	u32 pmu_init_chg_enabled;
+	u32 pmu_init_bc_en;
+	u32 pmu_init_adc_freq;
+	u32 pmu_init_adcts_freq;
+	u32 pmu_init_chg_pretime;
+	u32 pmu_init_chg_csttime;
+	u32 pmu_batt_cap_correct;
+	u32 pmu_chg_end_on_en;
+	u32 ocv_coulumb_100;
+
+	u32 pmu_bat_para1;
+	u32 pmu_bat_para2;
+	u32 pmu_bat_para3;
+	u32 pmu_bat_para4;
+	u32 pmu_bat_para5;
+	u32 pmu_bat_para6;
+	u32 pmu_bat_para7;
+	u32 pmu_bat_para8;
+	u32 pmu_bat_para9;
+	u32 pmu_bat_para10;
+	u32 pmu_bat_para11;
+	u32 pmu_bat_para12;
+	u32 pmu_bat_para13;
+	u32 pmu_bat_para14;
+	u32 pmu_bat_para15;
+	u32 pmu_bat_para16;
+	u32 pmu_bat_para17;
+	u32 pmu_bat_para18;
+	u32 pmu_bat_para19;
+	u32 pmu_bat_para20;
+	u32 pmu_bat_para21;
+	u32 pmu_bat_para22;
+	u32 pmu_bat_para23;
+	u32 pmu_bat_para24;
+	u32 pmu_bat_para25;
+	u32 pmu_bat_para26;
+	u32 pmu_bat_para27;
+	u32 pmu_bat_para28;
+	u32 pmu_bat_para29;
+	u32 pmu_bat_para30;
+	u32 pmu_bat_para31;
+	u32 pmu_bat_para32;
+
+	u32 pmu_ac_vol;
+	u32 pmu_ac_cur;
+	u32 pmu_usbpc_vol;
+	u32 pmu_usbpc_cur;
+	u32 pmu_usbad_vol;
+	u32 pmu_usbad_cur;
+	u32 pmu_pwroff_vol;
+	u32 pmu_pwron_vol;
+	u32 pmu_powkey_off_time;
+	u32 pmu_powkey_off_en;
+	u32 pmu_powkey_off_delay_time;
+	u32 pmu_powkey_off_func;
+	u32 pmu_powkey_long_time;
+	u32 pmu_powkey_on_time;
+	u32 pmu_powkey_wakeup_irq;
+	u32 pmu_pwrok_time;
+	u32 pmu_pwrnoe_time;
+	u32 pmu_reset_shutdown_en;
+	u32 pmu_battery_warning_level1;
+	u32 pmu_battery_warning_level2;
+	u32 pmu_restvol_adjust_time;
+	u32 pmu_ocv_cou_adjust_time;
+	u32 pmu_chgled_func;
+	u32 pmu_chgled_type;
+	u32 pmu_vbusen_func;
+	u32 pmu_reset;
+	u32 pmu_irq_wakeup;
+	u32 pmu_hot_shutdown;
+	u32 pmu_inshort;
+	u32 power_start;
+	u32 pmu_as_slave;
+	u32 pmu_bat_unused;
+	u32 pmu_ocv_en;
+	u32 pmu_cou_en;
+	u32 pmu_update_min_time;
+
+	u32 pmu_bat_temp_enable;
+	u32 pmu_bat_charge_ltf;
+	u32 pmu_bat_charge_htf;
+	u32 pmu_bat_shutdown_ltf;
+	u32 pmu_bat_shutdown_htf;
+	u32 pmu_bat_temp_para1;
+	u32 pmu_bat_temp_para2;
+	u32 pmu_bat_temp_para3;
+	u32 pmu_bat_temp_para4;
+	u32 pmu_bat_temp_para5;
+	u32 pmu_bat_temp_para6;
+	u32 pmu_bat_temp_para7;
+	u32 pmu_bat_temp_para8;
+	u32 pmu_bat_temp_para9;
+	u32 pmu_bat_temp_para10;
+	u32 pmu_bat_temp_para11;
+	u32 pmu_bat_temp_para12;
+	u32 pmu_bat_temp_para13;
+	u32 pmu_bat_temp_para14;
+	u32 pmu_bat_temp_para15;
+	u32 pmu_bat_temp_para16;
+
+	u32 wakeup_usb_in;
+	u32 wakeup_usb_out;
+	u32 wakeup_ac_in;
+	u32 wakeup_ac_out;
+	u32 wakeup_bat_in;
+	u32 wakeup_bat_out;
+	u32 wakeup_bat_charging;
+	u32 wakeup_bat_charge_over;
+	u32 wakeup_low_warning1;
+	u32 wakeup_low_warning2;
+	u32 wakeup_bat_untemp_work;
+	u32 wakeup_bat_ovtemp_work;
+	u32 wakeup_untemp_chg;
+	u32 wakeup_ovtemp_chg;
+};
+
+struct axp803_charger_ps {
+	char                      *name;
+	struct device             *dev;
+	struct axp_config_info     dts_info;
+	struct regmap             *regmap;
+	struct power_supply       *bat;
+	struct power_supply       *usb;
+	struct power_supply       *ac;
+	struct delayed_work        charger_mon;
+};
+
+#define BATRDC          100
+#define INTCHGCUR       300000      /* set initial charging current limite */
+#define SUSCHGCUR       1000000     /* set suspend charging current limite */
+#define RESCHGCUR       INTCHGCUR   /* set resume charging current limite */
+#define CLSCHGCUR       SUSCHGCUR   /* set shutdown charging current limite */
+#define INTCHGVOL       4200000     /* set initial charing target voltage */
+#define INTCHGENDRATE   10          /* set initial charing end current rate */
+#define INTCHGENABLED   1           /* set initial charing enabled */
+#define INTADCFREQ      25          /* set initial adc frequency */
+#define INTADCFREQC     100         /* set initial coulomb adc coufrequency */
+#define INTCHGPRETIME   50          /* set initial pre-charging time */
+#define INTCHGCSTTIME   480         /* set initial pre-charging time */
+#define BATMAXVOL       4200000     /* set battery max design volatge */
+#define BATMINVOL       3500000     /* set battery min design volatge */
+#define UPDATEMINTIME   30          /* set bat percent update min time */
+
+#define OCVREG0         0x00        /* 2.99V */
+#define OCVREG1         0x00        /* 3.13V */
+#define OCVREG2         0x00        /* 3.27V */
+#define OCVREG3         0x00        /* 3.34V */
+#define OCVREG4         0x00        /* 3.41V */
+#define OCVREG5         0x00        /* 3.48V */
+#define OCVREG6         0x00        /* 3.52V */
+#define OCVREG7         0x00        /* 3.55V */
+#define OCVREG8         0x04        /* 3.57V */
+#define OCVREG9         0x05        /* 3.59V */
+#define OCVREGA         0x06        /* 3.61V */
+#define OCVREGB         0x07        /* 3.63V */
+#define OCVREGC         0x0a        /* 3.64V */
+#define OCVREGD         0x0d        /* 3.66V */
+#define OCVREGE         0x1a        /* 3.70V */
+#define OCVREGF         0x24        /* 3.73V */
+#define OCVREG10        0x29        /* 3.77V */
+#define OCVREG11        0x2e        /* 3.78V */
+#define OCVREG12        0x32        /* 3.80V */
+#define OCVREG13        0x35        /* 3.84V */
+#define OCVREG14        0x39        /* 3.85V */
+#define OCVREG15        0x3d        /* 3.87V */
+#define OCVREG16        0x43        /* 3.91V */
+#define OCVREG17        0x49        /* 3.94V */
+#define OCVREG18        0x4f        /* 3.98V */
+#define OCVREG19        0x54        /* 4.01V */
+#define OCVREG1A        0x58        /* 4.05V */
+#define OCVREG1B        0x5c        /* 4.08V */
+#define OCVREG1C        0x5e        /* 4.10V */
+#define OCVREG1D        0x60        /* 4.12V */
+#define OCVREG1E        0x62        /* 4.14V */
+#define OCVREG1F        0x64        /* 4.15V */
+
+#define AXP_OF_PROP_READ(name, def_value)\
+do {\
+	if (of_property_read_u32(node, #name, &axp_config->name))\
+		axp_config->name = def_value;\
+} while (0)
+
+struct axp_interrupts {
+	char *name;
+	irq_handler_t isr;
+	int irq;
+};
+
+#endif
diff --git a/drivers/power/supply/axp803_usb_power.c b/drivers/power/supply/axp803_usb_power.c
new file mode 100644
index 000000000..ae47c22de
--- /dev/null
+++ b/drivers/power/supply/axp803_usb_power.c
@@ -0,0 +1,474 @@
+#define pr_fmt(x) KBUILD_MODNAME ": " x "\n"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/param.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/fs.h>
+#include <linux/ktime.h>
+#include <linux/of.h>
+#include <linux/timekeeping.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <asm/irq.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/err.h>
+#include <linux/mfd/axp2101.h>
+#include "axp803_charger.h"
+
+struct axp803_usb_power {
+	char                      *name;
+	struct device             *dev;
+	struct axp_config_info     dts_info;
+	struct regmap             *regmap;
+	struct power_supply       *usb_supply;
+	struct delayed_work        usb_supply_mon;
+	struct delayed_work        usb_chg_state;
+
+	atomic_t set_current_limit;
+};
+
+#ifdef CONFIG_AW_AXP_BC_EN
+static int axp803_usb_set_ihold(struct axp803_usb_power *usb_power, int cur)
+{
+	struct regmap *map = usb_power->regmap;
+
+	if (cur) {
+		if (cur < 1500)
+			regmap_update_bits(map, AXP803_IPS_SET, 0x03, 0x00);
+		else if (cur >= 1500 && cur < 2000)
+			regmap_update_bits(map, AXP803_IPS_SET, 0x03, 0x01);
+		else if (cur >= 2000 && cur < 2500)
+			regmap_update_bits(map, AXP803_IPS_SET, 0x03, 0x02);
+		else
+			regmap_update_bits(map, AXP803_IPS_SET, 0x03, 0x03);
+	} else {
+		regmap_update_bits(map, AXP803_IPS_SET, 0x03, 0x03);
+	}
+
+	return 0;
+}
+
+static int axp803_usb_get_ihold(struct axp803_usb_power *usb_power)
+{
+	unsigned int tmp;
+	struct regmap *map = usb_power->regmap;
+
+	regmap_read(map, AXP803_IPS_SET, &tmp);
+	tmp = tmp & 0x3;
+	if (tmp == 0x0)
+		return 900;
+	else if (tmp == 0x1)
+		return 1500;
+	else if (tmp == 0x2)
+		return 2000;
+	else
+		return 2500;
+}
+#else
+static int axp803_usb_set_ihold(struct axp803_usb_power *usb_power, int cur)
+{
+	struct regmap *map = usb_power->regmap;
+
+	if (cur) {
+		if (cur < 500)
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x00);
+		else if (cur < 900)
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x10);
+		else if (cur < 1500)
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x20);
+		else if (cur < 2000)
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x30);
+		else if (cur < 2500)
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x40);
+		else if (cur < 3000)
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x50);
+		else if (cur < 3500)
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x60);
+		else if (cur < 4000)
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x70);
+		else
+			regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x80);
+	} else {
+		regmap_update_bits(map, AXP803_CHARGE3, 0xf0, 0x30);
+	}
+
+	return 0;
+}
+
+static int axp803_usb_get_ihold(struct axp803_usb_power *usb_power)
+{
+	unsigned int tmp;
+	struct regmap *map = usb_power->regmap;
+
+	regmap_read(map, AXP803_CHARGE3, &tmp);
+	tmp = tmp & 0xf0;
+	if (tmp == 0x00)
+		return 100;
+	else if (tmp == 0x10)
+		return 500;
+	else if (tmp == 0x20)
+		return 900;
+	else if (tmp == 0x30)
+		return 1500;
+	else if (tmp == 0x40)
+		return 2000;
+	else if (tmp == 0x50)
+		return 2500;
+	else if (tmp == 0x60)
+		return 3000;
+	else if (tmp == 0x70)
+		return 3500;
+	else
+		return 4000;
+}
+#endif
+
+static void axp803_usb_set_current_fsm(struct work_struct *work)
+{
+	struct axp803_usb_power *usb_power =
+		container_of(work, typeof(*usb_power), usb_chg_state.work);
+	struct axp_config_info *axp_config = &usb_power->dts_info;
+
+	if (atomic_read(&usb_power->set_current_limit)) {
+		pr_info("current limit setted: usb pc type\n");
+	} else {
+		axp803_usb_set_ihold(usb_power, axp_config->pmu_usbad_cur);
+		pr_info("current limit not set: usb adapter type\n");
+	}
+}
+
+static enum power_supply_property axp803_usb_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+};
+
+static int axp803_usb_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	int ret = 0;
+	unsigned int reg_value;
+	struct axp803_usb_power *usb_power = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = psy->desc->name;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		ret = regmap_read(usb_power->regmap, AXP803_STATUS, &reg_value);
+		if (ret)
+			return ret;
+		val->intval = !!(reg_value & AXP803_STATUS_VBUS_PRESENT);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = regmap_read(usb_power->regmap, AXP803_STATUS, &reg_value);
+		if (ret)
+			return ret;
+		val->intval = !!(reg_value & AXP803_STATUS_VBUS_USED);
+		break;
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		ret = axp803_usb_get_ihold(usb_power);
+		if (ret < 0)
+			return ret;
+		val->intval = ret;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int axp803_usb_set_property(struct power_supply *psy,
+				    enum power_supply_property psp,
+				    const union power_supply_propval *val)
+{
+	int ret = 0;
+	struct axp803_usb_power *usb_power = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		ret = axp803_usb_set_ihold(usb_power, val->intval);
+		atomic_set(&usb_power->set_current_limit, 1);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int axp803_usb_power_property_is_writeable(struct power_supply *psy,
+		enum power_supply_property psp)
+{
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		ret = 1;
+		break;
+	default:
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static const struct power_supply_desc axp803_usb_desc = {
+	.name = "axp803-usb",
+	.type = POWER_SUPPLY_TYPE_USB,
+	.get_property = axp803_usb_get_property,
+	.properties = axp803_usb_props,
+	.set_property = axp803_usb_set_property,
+	.num_properties = ARRAY_SIZE(axp803_usb_props),
+	.property_is_writeable = axp803_usb_power_property_is_writeable,
+};
+
+static int axp803_usb_power_init(struct axp803_usb_power *usb_power)
+{
+	struct axp_config_info *axp_config = &usb_power->dts_info;
+
+	axp803_usb_set_ihold(usb_power, axp_config->pmu_usbad_cur);
+
+	return 0;
+}
+
+static irqreturn_t axp803_usb_power_in_irq(int irq, void *data)
+{
+	struct axp803_usb_power *usb_power = data;
+	struct axp_config_info *axp_config = &usb_power->dts_info;
+
+	power_supply_changed(usb_power->usb_supply);
+
+	axp803_usb_set_ihold(usb_power, axp_config->pmu_usbpc_cur);
+	atomic_set(&usb_power->set_current_limit, 0);
+
+	cancel_delayed_work_sync(&usb_power->usb_chg_state);
+	schedule_delayed_work(&usb_power->usb_chg_state, msecs_to_jiffies(5 * 1000));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t axp803_usb_power_out_irq(int irq, void *data)
+{
+	struct axp803_usb_power *usb_power = data;
+
+	power_supply_changed(usb_power->usb_supply);
+
+	return IRQ_HANDLED;
+}
+
+enum axp803_usb_power_virqs {
+	AXP803_VIRQ_USBIN,
+	AXP803_VIRQ_USBRE,
+
+	AXP803_USB_VIRQ_MAX_VIRQ,
+};
+
+static struct axp_interrupts axp803_usb_irq[] = {
+	[AXP803_VIRQ_USBIN] = {"usb in", axp803_usb_power_in_irq},
+	[AXP803_VIRQ_USBRE] = {"usb out", axp803_usb_power_out_irq},
+};
+
+static void axp803_usb_power_monitor(struct work_struct *work)
+{
+	struct axp803_usb_power *usb_power =
+		container_of(work, typeof(*usb_power), usb_supply_mon.work);
+
+	schedule_delayed_work(&usb_power->usb_supply_mon, msecs_to_jiffies(500));
+}
+
+static int axp803_usb_power_dt_parse(struct axp803_usb_power *usb_power)
+{
+	struct axp_config_info *axp_config = &usb_power->dts_info;
+	struct device_node *node = usb_power->dev->of_node;
+
+	if (!of_device_is_available(node)) {
+		pr_err("%s: failed\n", __func__);
+		return -1;
+	}
+
+	AXP_OF_PROP_READ(pmu_usbpc_vol,                  4400);
+	AXP_OF_PROP_READ(pmu_usbpc_cur,                     0);
+	AXP_OF_PROP_READ(pmu_usbad_vol,                  4400);
+	AXP_OF_PROP_READ(pmu_usbad_cur,                     0);
+
+	axp_config->wakeup_usb_in =
+		of_property_read_bool(node, "wakeup_usb_in");
+	axp_config->wakeup_usb_out =
+		of_property_read_bool(node, "wakeup_usb_out");
+
+	return 0;
+}
+
+static int axp803_usb_power_probe(struct platform_device *pdev)
+{
+	struct axp20x_dev *axp_dev = dev_get_drvdata(pdev->dev.parent);
+	struct power_supply_config psy_cfg = {};
+	struct axp803_usb_power *usb_power;
+	int i, irq;
+	int ret = 0;
+
+	if (!axp_dev->irq) {
+		pr_err("can not register axp803 usb without irq\n");
+		return -EINVAL;
+	}
+
+	usb_power = devm_kzalloc(&pdev->dev, sizeof(*usb_power), GFP_KERNEL);
+	if (!usb_power) {
+		pr_err("axp803 usb power alloc failed\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	usb_power->name = "axp803-usb-power";
+	usb_power->dev = &pdev->dev;
+	usb_power->regmap = axp_dev->regmap;
+
+	platform_set_drvdata(pdev, usb_power);
+
+	ret = axp803_usb_power_dt_parse(usb_power);
+	if (ret) {
+		pr_err("%s parse device tree err\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	ret = axp803_usb_power_init(usb_power);
+	if (ret < 0) {
+		pr_err("axp803 init usb power fail!\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	psy_cfg.of_node = pdev->dev.of_node;
+	psy_cfg.drv_data = usb_power;
+
+	usb_power->usb_supply = devm_power_supply_register(usb_power->dev,
+			&axp803_usb_desc, &psy_cfg);
+
+	if (IS_ERR(usb_power->usb_supply)) {
+		pr_err("axp803 failed to register usb power\n");
+		ret = PTR_ERR(usb_power->usb_supply);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(axp803_usb_irq); i++) {
+		irq = platform_get_irq_byname(pdev, axp803_usb_irq[i].name);
+		if (irq < 0) {
+			dev_warn(&pdev->dev, "No IRQ for %s: %d\n",
+				 axp803_usb_irq[i].name, irq);
+			continue;
+		}
+		irq = regmap_irq_get_virq(axp_dev->regmap_irqc, irq);
+		ret = devm_request_any_context_irq(&pdev->dev, irq,
+						   axp803_usb_irq[i].isr, 0,
+						   axp803_usb_irq[i].name, usb_power);
+		if (ret < 0)
+			dev_warn(&pdev->dev, "Error requesting %s IRQ %d: %d\n",
+				axp803_usb_irq[i].name, irq, ret);
+
+		dev_dbg(&pdev->dev, "Requested %s IRQ %d: %d\n",
+			axp803_usb_irq[i].name, irq, ret);
+
+		/* we use this variable to suspend irq */
+		axp803_usb_irq[i].irq = irq;
+	}
+
+	INIT_DELAYED_WORK(&usb_power->usb_supply_mon, axp803_usb_power_monitor);
+	schedule_delayed_work(&usb_power->usb_supply_mon, msecs_to_jiffies(500));
+
+	INIT_DELAYED_WORK(&usb_power->usb_chg_state, axp803_usb_set_current_fsm);
+	schedule_delayed_work(&usb_power->usb_chg_state, msecs_to_jiffies(20 * 1000));
+
+	return 0;
+}
+
+static int axp803_usb_power_remove(struct platform_device *pdev)
+{
+	struct axp803_usb_power *usb_power = platform_get_drvdata(pdev);
+
+	cancel_delayed_work_sync(&usb_power->usb_supply_mon);
+	cancel_delayed_work_sync(&usb_power->usb_chg_state);
+
+	return 0;
+}
+
+static inline void axp_irq_set(unsigned int irq, bool enable)
+{
+	if (enable)
+		enable_irq(irq);
+	else
+		disable_irq(irq);
+}
+
+static void axp803_usb_virq_dts_set(struct axp803_usb_power *usb_power, bool enable)
+{
+	struct axp_config_info *dts_info = &usb_power->dts_info;
+
+	if (!dts_info->wakeup_usb_in)
+		axp_irq_set(axp803_usb_irq[AXP803_VIRQ_USBIN].irq,
+				enable);
+	if (!dts_info->wakeup_usb_out)
+		axp_irq_set(axp803_usb_irq[AXP803_VIRQ_USBRE].irq,
+				enable);
+}
+
+static int axp803_usb_power_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct axp803_usb_power *usb_power = platform_get_drvdata(pdev);
+
+	axp803_usb_virq_dts_set(usb_power, false);
+
+	return 0;
+}
+
+static int axp803_usb_power_resume(struct platform_device *pdev)
+{
+	struct axp803_usb_power *usb_power = platform_get_drvdata(pdev);
+
+	axp803_usb_virq_dts_set(usb_power, true);
+
+	return 0;
+}
+
+static const struct of_device_id axp803_usb_power_match[] = {
+	{
+		.compatible = "x-powers,axp803-usb-power-supply",
+		.data = (void *)AXP803_ID,
+	}, { /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, axp803_usb_power_match);
+
+static struct platform_driver axp803_usb_power_driver = {
+	.driver = {
+		.name = "axp803-usb-power-supply",
+		.of_match_table = axp803_usb_power_match,
+	},
+	.probe = axp803_usb_power_probe,
+	.remove = axp803_usb_power_remove,
+	.suspend = axp803_usb_power_suspend,
+	.resume = axp803_usb_power_resume,
+};
+
+module_platform_driver(axp803_usb_power_driver);
+
+MODULE_AUTHOR("wangxiaoliang <wangxiaoliang@x-powers.com>");
+MODULE_DESCRIPTION("axp803 usb power driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/supply/power_supply_core.c b/drivers/power/supply/power_supply_core.c
index 5c36c430c..1a9a9fae7 100644
--- a/drivers/power/supply/power_supply_core.c
+++ b/drivers/power/supply/power_supply_core.c
@@ -565,9 +565,11 @@ EXPORT_SYMBOL_GPL(devm_power_supply_get_by_phandle);
 int power_supply_get_battery_info(struct power_supply *psy,
 				  struct power_supply_battery_info *info)
 {
+	struct power_supply_resistance_temp_table *resist_table;
 	struct device_node *battery_np;
 	const char *value;
 	int err, len, index;
+	const __be32 *list;
 
 	info->energy_full_design_uwh         = -EINVAL;
 	info->charge_full_design_uah         = -EINVAL;
@@ -578,6 +580,7 @@ int power_supply_get_battery_info(struct power_supply *psy,
 	info->constant_charge_current_max_ua = -EINVAL;
 	info->constant_charge_voltage_max_uv = -EINVAL;
 	info->factory_internal_resistance_uohm  = -EINVAL;
+	info->resist_table = NULL;
 
 	for (index = 0; index < POWER_SUPPLY_OCV_TEMP_MAX; index++) {
 		info->ocv_table[index]       = NULL;
@@ -644,7 +647,6 @@ int power_supply_get_battery_info(struct power_supply *psy,
 	for (index = 0; index < len; index++) {
 		struct power_supply_battery_ocv_table *table;
 		char *propname;
-		const __be32 *list;
 		int i, tab_len, size;
 
 		propname = kasprintf(GFP_KERNEL, "ocv-capacity-table-%d", index);
@@ -677,6 +679,26 @@ int power_supply_get_battery_info(struct power_supply *psy,
 		}
 	}
 
+	list = of_get_property(battery_np, "resistance-temp-table", &len);
+	if (!list || !len)
+		goto out_put_node;
+
+	info->resist_table_size = len / (2 * sizeof(__be32));
+	resist_table = info->resist_table = devm_kcalloc(&psy->dev,
+							 info->resist_table_size,
+							 sizeof(*resist_table),
+							 GFP_KERNEL);
+	if (!info->resist_table) {
+		power_supply_put_battery_info(psy, info);
+		err = -ENOMEM;
+		goto out_put_node;
+	}
+
+	for (index = 0; index < info->resist_table_size; index++) {
+		resist_table[index].temp = be32_to_cpu(*list++);
+		resist_table[index].resistance = be32_to_cpu(*list++);
+	}
+
 out_put_node:
 	of_node_put(battery_np);
 	return err;
@@ -692,9 +714,52 @@ void power_supply_put_battery_info(struct power_supply *psy,
 		if (info->ocv_table[i])
 			devm_kfree(&psy->dev, info->ocv_table[i]);
 	}
+
+	if (info->resist_table)
+		devm_kfree(&psy->dev, info->resist_table);
 }
 EXPORT_SYMBOL_GPL(power_supply_put_battery_info);
 
+/**
+ * power_supply_temp2resist_simple() - find the battery internal resistance
+ * percent
+ * @table: Pointer to battery resistance temperature table
+ * @table_len: The table length
+ * @ocv: Current temperature
+ *
+ * This helper function is used to look up battery internal resistance percent
+ * according to current temperature value from the resistance temperature table,
+ * and the table must be ordered descending. Then the actual battery internal
+ * resistance = the ideal battery internal resistance * percent / 100.
+ *
+ * Return: the battery internal resistance percent
+ */
+int power_supply_temp2resist_simple(struct power_supply_resistance_temp_table *table,
+				    int table_len, int temp)
+{
+	int i, resist;
+
+	for (i = 0; i < table_len; i++)
+		if (temp > table[i].temp)
+			break;
+
+	if (i > 0 && i < table_len) {
+		int tmp;
+
+		tmp = (table[i - 1].resistance - table[i].resistance) *
+			(temp - table[i].temp);
+		tmp /= table[i - 1].temp - table[i].temp;
+		resist = tmp + table[i].resistance;
+	} else if (i == 0) {
+		resist = table[0].resistance;
+	} else {
+		resist = table[table_len - 1].resistance;
+	}
+
+	return resist;
+}
+EXPORT_SYMBOL_GPL(power_supply_temp2resist_simple);
+
 /**
  * power_supply_ocv2cap_simple() - find the battery capacity
  * @table: Pointer to battery OCV lookup table
diff --git a/drivers/power/supply/power_supply_sysfs.c b/drivers/power/supply/power_supply_sysfs.c
index f37ad4eae..d6e88e8f5 100644
--- a/drivers/power/supply/power_supply_sysfs.c
+++ b/drivers/power/supply/power_supply_sysfs.c
@@ -18,68 +18,219 @@
 
 #include "power_supply.h"
 
-/*
- * This is because the name "current" breaks the device attr macro.
- * The "current" word resolves to "(get_current())" so instead of
- * "current" "(get_current())" appears in the sysfs.
- *
- * The source of this definition is the device.h which calls __ATTR
- * macro in sysfs.h which calls the __stringify macro.
- *
- * Only modification that the name is not tried to be resolved
- * (as a macro let's say).
- */
+#define MAX_PROP_NAME_LEN 30
+
+struct power_supply_attr {
+	const char *prop_name;
+	char attr_name[MAX_PROP_NAME_LEN + 1];
+	struct device_attribute dev_attr;
+	const char * const *text_values;
+	int text_values_len;
+};
 
-#define POWER_SUPPLY_ATTR(_name)					\
-{									\
-	.attr = { .name = #_name },					\
-	.show = power_supply_show_property,				\
-	.store = power_supply_store_property,				\
+#define _POWER_SUPPLY_ATTR(_name, _text, _len)	\
+[POWER_SUPPLY_PROP_ ## _name] =			\
+{						\
+	.prop_name = #_name,			\
+	.attr_name = #_name "\0",		\
+	.text_values = _text,			\
+	.text_values_len = _len,		\
 }
 
-static struct device_attribute power_supply_attrs[];
+#define POWER_SUPPLY_ATTR(_name) _POWER_SUPPLY_ATTR(_name, NULL, 0)
+#define _POWER_SUPPLY_ENUM_ATTR(_name, _text)	\
+	_POWER_SUPPLY_ATTR(_name, _text, ARRAY_SIZE(_text))
+#define POWER_SUPPLY_ENUM_ATTR(_name)	\
+	_POWER_SUPPLY_ENUM_ATTR(_name, POWER_SUPPLY_ ## _name ## _TEXT)
+
+static const char * const POWER_SUPPLY_TYPE_TEXT[] = {
+	[POWER_SUPPLY_TYPE_UNKNOWN]		= "Unknown",
+	[POWER_SUPPLY_TYPE_BATTERY]		= "Battery",
+	[POWER_SUPPLY_TYPE_UPS]			= "UPS",
+	[POWER_SUPPLY_TYPE_MAINS]		= "Mains",
+	[POWER_SUPPLY_TYPE_USB]			= "USB",
+	[POWER_SUPPLY_TYPE_USB_DCP]		= "USB_DCP",
+	[POWER_SUPPLY_TYPE_USB_CDP]		= "USB_CDP",
+	[POWER_SUPPLY_TYPE_USB_ACA]		= "USB_ACA",
+	[POWER_SUPPLY_TYPE_USB_TYPE_C]		= "USB_C",
+	[POWER_SUPPLY_TYPE_USB_PD]		= "USB_PD",
+	[POWER_SUPPLY_TYPE_USB_PD_DRP]		= "USB_PD_DRP",
+	[POWER_SUPPLY_TYPE_APPLE_BRICK_ID]	= "BrickID",
+	[POWER_SUPPLY_TYPE_WIRELESS]		= "Wireless",
+};
 
-static const char * const power_supply_type_text[] = {
-	"Unknown", "Battery", "UPS", "Mains", "USB",
-	"USB_DCP", "USB_CDP", "USB_ACA", "USB_C",
-	"USB_PD", "USB_PD_DRP", "BrickID"
+static const char * const POWER_SUPPLY_USB_TYPE_TEXT[] = {
+	[POWER_SUPPLY_USB_TYPE_UNKNOWN]		= "Unknown",
+	[POWER_SUPPLY_USB_TYPE_SDP]		= "SDP",
+	[POWER_SUPPLY_USB_TYPE_DCP]		= "DCP",
+	[POWER_SUPPLY_USB_TYPE_CDP]		= "CDP",
+	[POWER_SUPPLY_USB_TYPE_ACA]		= "ACA",
+	[POWER_SUPPLY_USB_TYPE_C]		= "C",
+	[POWER_SUPPLY_USB_TYPE_PD]		= "PD",
+	[POWER_SUPPLY_USB_TYPE_PD_DRP]		= "PD_DRP",
+	[POWER_SUPPLY_USB_TYPE_PD_PPS]		= "PD_PPS",
+	[POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID]	= "BrickID",
 };
 
-static const char * const power_supply_usb_type_text[] = {
-	"Unknown", "SDP", "DCP", "CDP", "ACA", "C",
-	"PD", "PD_DRP", "PD_PPS", "BrickID"
+static const char * const POWER_SUPPLY_STATUS_TEXT[] = {
+	[POWER_SUPPLY_STATUS_UNKNOWN]		= "Unknown",
+	[POWER_SUPPLY_STATUS_CHARGING]		= "Charging",
+	[POWER_SUPPLY_STATUS_DISCHARGING]	= "Discharging",
+	[POWER_SUPPLY_STATUS_NOT_CHARGING]	= "Not charging",
+	[POWER_SUPPLY_STATUS_FULL]		= "Full",
 };
 
-static const char * const power_supply_status_text[] = {
-	"Unknown", "Charging", "Discharging", "Not charging", "Full"
+static const char * const POWER_SUPPLY_CHARGE_TYPE_TEXT[] = {
+	[POWER_SUPPLY_CHARGE_TYPE_UNKNOWN]	= "Unknown",
+	[POWER_SUPPLY_CHARGE_TYPE_NONE]		= "N/A",
+	[POWER_SUPPLY_CHARGE_TYPE_TRICKLE]	= "Trickle",
+	[POWER_SUPPLY_CHARGE_TYPE_FAST]		= "Fast",
+	[POWER_SUPPLY_CHARGE_TYPE_STANDARD]	= "Standard",
+	[POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE]	= "Adaptive",
+	[POWER_SUPPLY_CHARGE_TYPE_CUSTOM]	= "Custom",
 };
 
-static const char * const power_supply_charge_type_text[] = {
-	"Unknown", "N/A", "Trickle", "Fast", "Standard", "Adaptive", "Custom"
+static const char * const POWER_SUPPLY_HEALTH_TEXT[] = {
+	[POWER_SUPPLY_HEALTH_UNKNOWN]		    = "Unknown",
+	[POWER_SUPPLY_HEALTH_GOOD]		    = "Good",
+	[POWER_SUPPLY_HEALTH_OVERHEAT]		    = "Overheat",
+	[POWER_SUPPLY_HEALTH_DEAD]		    = "Dead",
+	[POWER_SUPPLY_HEALTH_OVERVOLTAGE]	    = "Over voltage",
+	[POWER_SUPPLY_HEALTH_UNSPEC_FAILURE]	    = "Unspecified failure",
+	[POWER_SUPPLY_HEALTH_COLD]		    = "Cold",
+	[POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE] = "Watchdog timer expire",
+	[POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE]   = "Safety timer expire",
+	[POWER_SUPPLY_HEALTH_OVERCURRENT]	    = "Over current",
+	[POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED]  = "Calibration required",
+	[POWER_SUPPLY_HEALTH_WARM]		    = "Warm",
+	[POWER_SUPPLY_HEALTH_COOL]		    = "Cool",
+	[POWER_SUPPLY_HEALTH_HOT]		    = "Hot",
 };
 
-static const char * const power_supply_health_text[] = {
-	"Unknown", "Good", "Overheat", "Dead", "Over voltage",
-	"Unspecified failure", "Cold", "Watchdog timer expire",
-	"Safety timer expire", "Over current"
+static const char * const POWER_SUPPLY_TECHNOLOGY_TEXT[] = {
+	[POWER_SUPPLY_TECHNOLOGY_UNKNOWN]	= "Unknown",
+	[POWER_SUPPLY_TECHNOLOGY_NiMH]		= "NiMH",
+	[POWER_SUPPLY_TECHNOLOGY_LION]		= "Li-ion",
+	[POWER_SUPPLY_TECHNOLOGY_LIPO]		= "Li-poly",
+	[POWER_SUPPLY_TECHNOLOGY_LiFe]		= "LiFe",
+	[POWER_SUPPLY_TECHNOLOGY_NiCd]		= "NiCd",
+	[POWER_SUPPLY_TECHNOLOGY_LiMn]		= "LiMn",
 };
 
-static const char * const power_supply_technology_text[] = {
-	"Unknown", "NiMH", "Li-ion", "Li-poly", "LiFe", "NiCd",
-	"LiMn"
+static const char * const POWER_SUPPLY_CAPACITY_LEVEL_TEXT[] = {
+	[POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN]	= "Unknown",
+	[POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL]	= "Critical",
+	[POWER_SUPPLY_CAPACITY_LEVEL_LOW]	= "Low",
+	[POWER_SUPPLY_CAPACITY_LEVEL_NORMAL]	= "Normal",
+	[POWER_SUPPLY_CAPACITY_LEVEL_HIGH]	= "High",
+	[POWER_SUPPLY_CAPACITY_LEVEL_FULL]	= "Full",
 };
 
-static const char * const power_supply_capacity_level_text[] = {
-	"Unknown", "Critical", "Low", "Normal", "High", "Full"
+static const char * const POWER_SUPPLY_SCOPE_TEXT[] = {
+	[POWER_SUPPLY_SCOPE_UNKNOWN]	= "Unknown",
+	[POWER_SUPPLY_SCOPE_SYSTEM]	= "System",
+	[POWER_SUPPLY_SCOPE_DEVICE]	= "Device",
 };
 
-static const char * const power_supply_scope_text[] = {
-	"Unknown", "System", "Device"
+static struct power_supply_attr power_supply_attrs[] = {
+	/* Properties of type `int' */
+	POWER_SUPPLY_ENUM_ATTR(STATUS),
+	POWER_SUPPLY_ENUM_ATTR(CHARGE_TYPE),
+	POWER_SUPPLY_ENUM_ATTR(HEALTH),
+	POWER_SUPPLY_ATTR(PRESENT),
+	POWER_SUPPLY_ATTR(ONLINE),
+	POWER_SUPPLY_ATTR(AUTHENTIC),
+	POWER_SUPPLY_ENUM_ATTR(TECHNOLOGY),
+	POWER_SUPPLY_ATTR(CYCLE_COUNT),
+	POWER_SUPPLY_ATTR(VOLTAGE_MAX),
+	POWER_SUPPLY_ATTR(VOLTAGE_MIN),
+	POWER_SUPPLY_ATTR(VOLTAGE_MAX_DESIGN),
+	POWER_SUPPLY_ATTR(VOLTAGE_MIN_DESIGN),
+	POWER_SUPPLY_ATTR(VOLTAGE_NOW),
+	POWER_SUPPLY_ATTR(VOLTAGE_AVG),
+	POWER_SUPPLY_ATTR(VOLTAGE_OCV),
+	POWER_SUPPLY_ATTR(VOLTAGE_BOOT),
+	POWER_SUPPLY_ATTR(CURRENT_MAX),
+	POWER_SUPPLY_ATTR(CURRENT_NOW),
+	POWER_SUPPLY_ATTR(CURRENT_AVG),
+	POWER_SUPPLY_ATTR(CURRENT_BOOT),
+	POWER_SUPPLY_ATTR(POWER_NOW),
+	POWER_SUPPLY_ATTR(POWER_AVG),
+	POWER_SUPPLY_ATTR(CHARGE_FULL_DESIGN),
+	POWER_SUPPLY_ATTR(CHARGE_EMPTY_DESIGN),
+	POWER_SUPPLY_ATTR(CHARGE_FULL),
+	POWER_SUPPLY_ATTR(CHARGE_EMPTY),
+	POWER_SUPPLY_ATTR(CHARGE_NOW),
+	POWER_SUPPLY_ATTR(CHARGE_AVG),
+	POWER_SUPPLY_ATTR(CHARGE_COUNTER),
+	POWER_SUPPLY_ATTR(CONSTANT_CHARGE_CURRENT),
+	POWER_SUPPLY_ATTR(CONSTANT_CHARGE_CURRENT_MAX),
+	POWER_SUPPLY_ATTR(CONSTANT_CHARGE_VOLTAGE),
+	POWER_SUPPLY_ATTR(CONSTANT_CHARGE_VOLTAGE_MAX),
+	POWER_SUPPLY_ATTR(CHARGE_CONTROL_LIMIT),
+	POWER_SUPPLY_ATTR(CHARGE_CONTROL_LIMIT_MAX),
+	POWER_SUPPLY_ATTR(CHARGE_CONTROL_START_THRESHOLD),
+	POWER_SUPPLY_ATTR(CHARGE_CONTROL_END_THRESHOLD),
+	POWER_SUPPLY_ATTR(INPUT_CURRENT_LIMIT),
+	POWER_SUPPLY_ATTR(INPUT_VOLTAGE_LIMIT),
+	POWER_SUPPLY_ATTR(INPUT_POWER_LIMIT),
+	POWER_SUPPLY_ATTR(ENERGY_FULL_DESIGN),
+	POWER_SUPPLY_ATTR(ENERGY_EMPTY_DESIGN),
+	POWER_SUPPLY_ATTR(ENERGY_FULL),
+	POWER_SUPPLY_ATTR(ENERGY_EMPTY),
+	POWER_SUPPLY_ATTR(ENERGY_NOW),
+	POWER_SUPPLY_ATTR(ENERGY_AVG),
+	POWER_SUPPLY_ATTR(CAPACITY),
+	POWER_SUPPLY_ATTR(CAPACITY_ALERT_MIN),
+	POWER_SUPPLY_ATTR(CAPACITY_ALERT_MAX),
+	POWER_SUPPLY_ATTR(CAPACITY_ERROR_MARGIN),
+	POWER_SUPPLY_ENUM_ATTR(CAPACITY_LEVEL),
+	POWER_SUPPLY_ATTR(TEMP),
+	POWER_SUPPLY_ATTR(TEMP_MAX),
+	POWER_SUPPLY_ATTR(TEMP_MIN),
+	POWER_SUPPLY_ATTR(TEMP_ALERT_MIN),
+	POWER_SUPPLY_ATTR(TEMP_ALERT_MAX),
+	POWER_SUPPLY_ATTR(TEMP_AMBIENT),
+	POWER_SUPPLY_ATTR(TEMP_AMBIENT_ALERT_MIN),
+	POWER_SUPPLY_ATTR(TEMP_AMBIENT_ALERT_MAX),
+	POWER_SUPPLY_ATTR(TIME_TO_EMPTY_NOW),
+	POWER_SUPPLY_ATTR(TIME_TO_EMPTY_AVG),
+	POWER_SUPPLY_ATTR(TIME_TO_FULL_NOW),
+	POWER_SUPPLY_ATTR(TIME_TO_FULL_AVG),
+	POWER_SUPPLY_ENUM_ATTR(TYPE),
+	POWER_SUPPLY_ATTR(USB_TYPE),
+	POWER_SUPPLY_ENUM_ATTR(SCOPE),
+	POWER_SUPPLY_ATTR(PRECHARGE_CURRENT),
+	POWER_SUPPLY_ATTR(CHARGE_TERM_CURRENT),
+	POWER_SUPPLY_ATTR(CALIBRATE),
+	POWER_SUPPLY_ATTR(MANUFACTURE_YEAR),
+	POWER_SUPPLY_ATTR(MANUFACTURE_MONTH),
+	POWER_SUPPLY_ATTR(MANUFACTURE_DAY),
+	/* Properties of type `const char *' */
+	POWER_SUPPLY_ATTR(MODEL_NAME),
+	POWER_SUPPLY_ATTR(MANUFACTURER),
+	POWER_SUPPLY_ATTR(SERIAL_NUMBER),
+	POWER_SUPPLY_ATTR(QUICK_CHARGE_TYPE),
+	POWER_SUPPLY_ATTR(TX_ADAPTER),
+	POWER_SUPPLY_ATTR(SIGNAL_STRENGTH),
+	POWER_SUPPLY_ATTR(REVERSE_CHG_MODE),
 };
 
+static struct attribute *
+__power_supply_attrs[ARRAY_SIZE(power_supply_attrs) + 1];
+
+static struct power_supply_attr *to_ps_attr(struct device_attribute *attr)
+{
+	return container_of(attr, struct power_supply_attr, dev_attr);
+}
+
+static enum power_supply_property dev_attr_psp(struct device_attribute *attr)
+{
+	return  to_ps_attr(attr) - power_supply_attrs;
+}
+
 static ssize_t power_supply_show_usb_type(struct device *dev,
-					  enum power_supply_usb_type *usb_types,
-					  ssize_t num_usb_types,
+					  const struct power_supply_desc *desc,
 					  union power_supply_propval *value,
 					  char *buf)
 {
@@ -88,16 +239,16 @@ static ssize_t power_supply_show_usb_type(struct device *dev,
 	bool match = false;
 	int i;
 
-	for (i = 0; i < num_usb_types; ++i) {
-		usb_type = usb_types[i];
+	for (i = 0; i < desc->num_usb_types; ++i) {
+		usb_type = desc->usb_types[i];
 
 		if (value->intval == usb_type) {
 			count += sprintf(buf + count, "[%s] ",
-					 power_supply_usb_type_text[usb_type]);
+					 POWER_SUPPLY_USB_TYPE_TEXT[usb_type]);
 			match = true;
 		} else {
 			count += sprintf(buf + count, "%s ",
-					 power_supply_usb_type_text[usb_type]);
+					 POWER_SUPPLY_USB_TYPE_TEXT[usb_type]);
 		}
 	}
 
@@ -117,7 +268,8 @@ static ssize_t power_supply_show_property(struct device *dev,
 					  char *buf) {
 	ssize_t ret;
 	struct power_supply *psy = dev_get_drvdata(dev);
-	enum power_supply_property psp = attr - power_supply_attrs;
+	struct power_supply_attr *ps_attr = to_ps_attr(attr);
+	enum power_supply_property psp = dev_attr_psp(attr);
 	union power_supply_propval value;
 
 	if (psp == POWER_SUPPLY_PROP_TYPE) {
@@ -137,39 +289,15 @@ static ssize_t power_supply_show_property(struct device *dev,
 		}
 	}
 
+	if (ps_attr->text_values_len > 0 &&
+	    value.intval < ps_attr->text_values_len && value.intval >= 0) {
+		return sprintf(buf, "%s\n", ps_attr->text_values[value.intval]);
+	}
+
 	switch (psp) {
-	case POWER_SUPPLY_PROP_STATUS:
-		ret = sprintf(buf, "%s\n",
-			      power_supply_status_text[value.intval]);
-		break;
-	case POWER_SUPPLY_PROP_CHARGE_TYPE:
-		ret = sprintf(buf, "%s\n",
-			      power_supply_charge_type_text[value.intval]);
-		break;
-	case POWER_SUPPLY_PROP_HEALTH:
-		ret = sprintf(buf, "%s\n",
-			      power_supply_health_text[value.intval]);
-		break;
-	case POWER_SUPPLY_PROP_TECHNOLOGY:
-		ret = sprintf(buf, "%s\n",
-			      power_supply_technology_text[value.intval]);
-		break;
-	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
-		ret = sprintf(buf, "%s\n",
-			      power_supply_capacity_level_text[value.intval]);
-		break;
-	case POWER_SUPPLY_PROP_TYPE:
-		ret = sprintf(buf, "%s\n",
-			      power_supply_type_text[value.intval]);
-		break;
 	case POWER_SUPPLY_PROP_USB_TYPE:
-		ret = power_supply_show_usb_type(dev, psy->desc->usb_types,
-						 psy->desc->num_usb_types,
-						 &value, buf);
-		break;
-	case POWER_SUPPLY_PROP_SCOPE:
-		ret = sprintf(buf, "%s\n",
-			      power_supply_scope_text[value.intval]);
+		ret = power_supply_show_usb_type(dev, psy->desc,
+						&value, buf);
 		break;
 	case POWER_SUPPLY_PROP_MODEL_NAME ... POWER_SUPPLY_PROP_SERIAL_NUMBER:
 		ret = sprintf(buf, "%s\n", value.strval);
@@ -186,30 +314,14 @@ static ssize_t power_supply_store_property(struct device *dev,
 					   const char *buf, size_t count) {
 	ssize_t ret;
 	struct power_supply *psy = dev_get_drvdata(dev);
-	enum power_supply_property psp = attr - power_supply_attrs;
+	struct power_supply_attr *ps_attr = to_ps_attr(attr);
+	enum power_supply_property psp = dev_attr_psp(attr);
 	union power_supply_propval value;
 
-	switch (psp) {
-	case POWER_SUPPLY_PROP_STATUS:
-		ret = sysfs_match_string(power_supply_status_text, buf);
-		break;
-	case POWER_SUPPLY_PROP_CHARGE_TYPE:
-		ret = sysfs_match_string(power_supply_charge_type_text, buf);
-		break;
-	case POWER_SUPPLY_PROP_HEALTH:
-		ret = sysfs_match_string(power_supply_health_text, buf);
-		break;
-	case POWER_SUPPLY_PROP_TECHNOLOGY:
-		ret = sysfs_match_string(power_supply_technology_text, buf);
-		break;
-	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
-		ret = sysfs_match_string(power_supply_capacity_level_text, buf);
-		break;
-	case POWER_SUPPLY_PROP_SCOPE:
-		ret = sysfs_match_string(power_supply_scope_text, buf);
-		break;
-	default:
-		ret = -EINVAL;
+	ret = -EINVAL;
+	if (ps_attr->text_values_len > 0) {
+		ret = __sysfs_match_string(ps_attr->text_values,
+					   ps_attr->text_values_len, buf);
 	}
 
 	/*
@@ -235,86 +347,6 @@ static ssize_t power_supply_store_property(struct device *dev,
 	return count;
 }
 
-/* Must be in the same order as POWER_SUPPLY_PROP_* */
-static struct device_attribute power_supply_attrs[] = {
-	/* Properties of type `int' */
-	POWER_SUPPLY_ATTR(status),
-	POWER_SUPPLY_ATTR(charge_type),
-	POWER_SUPPLY_ATTR(health),
-	POWER_SUPPLY_ATTR(present),
-	POWER_SUPPLY_ATTR(online),
-	POWER_SUPPLY_ATTR(authentic),
-	POWER_SUPPLY_ATTR(technology),
-	POWER_SUPPLY_ATTR(cycle_count),
-	POWER_SUPPLY_ATTR(voltage_max),
-	POWER_SUPPLY_ATTR(voltage_min),
-	POWER_SUPPLY_ATTR(voltage_max_design),
-	POWER_SUPPLY_ATTR(voltage_min_design),
-	POWER_SUPPLY_ATTR(voltage_now),
-	POWER_SUPPLY_ATTR(voltage_avg),
-	POWER_SUPPLY_ATTR(voltage_ocv),
-	POWER_SUPPLY_ATTR(voltage_boot),
-	POWER_SUPPLY_ATTR(current_max),
-	POWER_SUPPLY_ATTR(current_now),
-	POWER_SUPPLY_ATTR(current_avg),
-	POWER_SUPPLY_ATTR(current_boot),
-	POWER_SUPPLY_ATTR(power_now),
-	POWER_SUPPLY_ATTR(power_avg),
-	POWER_SUPPLY_ATTR(charge_full_design),
-	POWER_SUPPLY_ATTR(charge_empty_design),
-	POWER_SUPPLY_ATTR(charge_full),
-	POWER_SUPPLY_ATTR(charge_empty),
-	POWER_SUPPLY_ATTR(charge_now),
-	POWER_SUPPLY_ATTR(charge_avg),
-	POWER_SUPPLY_ATTR(charge_counter),
-	POWER_SUPPLY_ATTR(constant_charge_current),
-	POWER_SUPPLY_ATTR(constant_charge_current_max),
-	POWER_SUPPLY_ATTR(constant_charge_voltage),
-	POWER_SUPPLY_ATTR(constant_charge_voltage_max),
-	POWER_SUPPLY_ATTR(charge_control_limit),
-	POWER_SUPPLY_ATTR(charge_control_limit_max),
-	POWER_SUPPLY_ATTR(charge_control_start_threshold),
-	POWER_SUPPLY_ATTR(charge_control_end_threshold),
-	POWER_SUPPLY_ATTR(input_current_limit),
-	POWER_SUPPLY_ATTR(input_voltage_limit),
-	POWER_SUPPLY_ATTR(input_power_limit),
-	POWER_SUPPLY_ATTR(energy_full_design),
-	POWER_SUPPLY_ATTR(energy_empty_design),
-	POWER_SUPPLY_ATTR(energy_full),
-	POWER_SUPPLY_ATTR(energy_empty),
-	POWER_SUPPLY_ATTR(energy_now),
-	POWER_SUPPLY_ATTR(energy_avg),
-	POWER_SUPPLY_ATTR(capacity),
-	POWER_SUPPLY_ATTR(capacity_alert_min),
-	POWER_SUPPLY_ATTR(capacity_alert_max),
-	POWER_SUPPLY_ATTR(capacity_level),
-	POWER_SUPPLY_ATTR(temp),
-	POWER_SUPPLY_ATTR(temp_max),
-	POWER_SUPPLY_ATTR(temp_min),
-	POWER_SUPPLY_ATTR(temp_alert_min),
-	POWER_SUPPLY_ATTR(temp_alert_max),
-	POWER_SUPPLY_ATTR(temp_ambient),
-	POWER_SUPPLY_ATTR(temp_ambient_alert_min),
-	POWER_SUPPLY_ATTR(temp_ambient_alert_max),
-	POWER_SUPPLY_ATTR(time_to_empty_now),
-	POWER_SUPPLY_ATTR(time_to_empty_avg),
-	POWER_SUPPLY_ATTR(time_to_full_now),
-	POWER_SUPPLY_ATTR(time_to_full_avg),
-	POWER_SUPPLY_ATTR(type),
-	POWER_SUPPLY_ATTR(usb_type),
-	POWER_SUPPLY_ATTR(scope),
-	POWER_SUPPLY_ATTR(precharge_current),
-	POWER_SUPPLY_ATTR(charge_term_current),
-	POWER_SUPPLY_ATTR(calibrate),
-	/* Properties of type `const char *' */
-	POWER_SUPPLY_ATTR(model_name),
-	POWER_SUPPLY_ATTR(manufacturer),
-	POWER_SUPPLY_ATTR(serial_number),
-};
-
-static struct attribute *
-__power_supply_attrs[ARRAY_SIZE(power_supply_attrs) + 1];
-
 static umode_t power_supply_attr_is_visible(struct kobject *kobj,
 					   struct attribute *attr,
 					   int attrno)
@@ -324,6 +356,9 @@ static umode_t power_supply_attr_is_visible(struct kobject *kobj,
 	umode_t mode = S_IRUSR | S_IRGRP | S_IROTH;
 	int i;
 
+	if (!power_supply_attrs[attrno].prop_name)
+		return 0;
+
 	if (attrno == POWER_SUPPLY_PROP_TYPE)
 		return mode;
 
@@ -352,31 +387,69 @@ static const struct attribute_group *power_supply_attr_groups[] = {
 	NULL,
 };
 
+static void str_to_lower(char *str)
+{
+	while (*str) {
+		*str = tolower(*str);
+		str++;
+	}
+}
+
 void power_supply_init_attrs(struct device_type *dev_type)
 {
 	int i;
 
 	dev_type->groups = power_supply_attr_groups;
 
-	for (i = 0; i < ARRAY_SIZE(power_supply_attrs); i++)
-		__power_supply_attrs[i] = &power_supply_attrs[i].attr;
-}
+	for (i = 0; i < ARRAY_SIZE(power_supply_attrs); i++) {
+		struct device_attribute *attr;
 
-static char *kstruprdup(const char *str, gfp_t gfp)
-{
-	char *ret, *ustr;
+		if (!power_supply_attrs[i].prop_name) {
+			pr_warn("%s: Property %d skipped because is is missing from power_supply_attrs\n",
+				__func__, i);
+			sprintf(power_supply_attrs[i].attr_name, "_err_%d", i);
+		} else {
+			str_to_lower(power_supply_attrs[i].attr_name);
+		}
 
-	ustr = ret = kmalloc(strlen(str) + 1, gfp);
+		attr = &power_supply_attrs[i].dev_attr;
 
-	if (!ret)
-		return NULL;
+		attr->attr.name = power_supply_attrs[i].attr_name;
+		attr->show = power_supply_show_property;
+		attr->store = power_supply_store_property;
+		__power_supply_attrs[i] = &attr->attr;
+	}
+}
+
+static int add_prop_uevent(struct device *dev, struct kobj_uevent_env *env,
+			   enum power_supply_property prop, char *prop_buf)
+{
+	int ret = 0;
+	struct power_supply_attr *pwr_attr;
+	struct device_attribute *dev_attr;
+	char *line;
+
+	pwr_attr = &power_supply_attrs[prop];
+	dev_attr = &pwr_attr->dev_attr;
+
+	ret = power_supply_show_property(dev, dev_attr, prop_buf);
+	if (ret == -ENODEV || ret == -ENODATA) {
+		/*
+		 * When a battery is absent, we expect -ENODEV. Don't abort;
+		 * send the uevent with at least the the PRESENT=0 property
+		 */
+		return 0;
+	}
 
-	while (*str)
-		*ustr++ = toupper(*str++);
+	if (ret < 0)
+		return ret;
 
-	*ustr = 0;
+	line = strchr(prop_buf, '\n');
+	if (line)
+		*line = 0;
 
-	return ret;
+	return add_uevent_var(env, "POWER_SUPPLY_%s=%s",
+			      pwr_attr->prop_name, prop_buf);
 }
 
 int power_supply_uevent(struct device *dev, struct kobj_uevent_env *env)
@@ -384,7 +457,6 @@ int power_supply_uevent(struct device *dev, struct kobj_uevent_env *env)
 	struct power_supply *psy = dev_get_drvdata(dev);
 	int ret = 0, j;
 	char *prop_buf;
-	char *attrname;
 
 	if (!psy || !psy->desc) {
 		dev_dbg(dev, "No power supply yet\n");
@@ -399,35 +471,13 @@ int power_supply_uevent(struct device *dev, struct kobj_uevent_env *env)
 	if (!prop_buf)
 		return -ENOMEM;
 
-	for (j = 0; j < psy->desc->num_properties; j++) {
-		struct device_attribute *attr;
-		char *line;
-
-		attr = &power_supply_attrs[psy->desc->properties[j]];
-
-		ret = power_supply_show_property(dev, attr, prop_buf);
-		if (ret == -ENODEV || ret == -ENODATA) {
-			/* When a battery is absent, we expect -ENODEV. Don't abort;
-			   send the uevent with at least the the PRESENT=0 property */
-			ret = 0;
-			continue;
-		}
-
-		if (ret < 0)
-			goto out;
-
-		line = strchr(prop_buf, '\n');
-		if (line)
-			*line = 0;
-
-		attrname = kstruprdup(attr->attr.name, GFP_KERNEL);
-		if (!attrname) {
-			ret = -ENOMEM;
-			goto out;
-		}
+	ret = add_prop_uevent(dev, env, POWER_SUPPLY_PROP_TYPE, prop_buf);
+	if (ret)
+		goto out;
 
-		ret = add_uevent_var(env, "POWER_SUPPLY_%s=%s", attrname, prop_buf);
-		kfree(attrname);
+	for (j = 0; j < psy->desc->num_properties; j++) {
+		ret = add_prop_uevent(dev, env, psy->desc->properties[j],
+				      prop_buf);
 		if (ret)
 			goto out;
 	}
diff --git a/drivers/power/supply/qcom_smbb.c b/drivers/power/supply/qcom_smbb.c
index c890e1cec..21ddfa39f 100644
--- a/drivers/power/supply/qcom_smbb.c
+++ b/drivers/power/supply/qcom_smbb.c
@@ -90,6 +90,12 @@
 #define STATUS_CHG_FAST		BIT(7) /* Fast charging */
 #define STATUS_CHG_GONE		BIT(8) /* No charger is connected */
 
+#define IMAX_NORMAL		2000000
+#define IMAX_FAST		4000000
+#define IMAX_FLASH		6000000
+#define IMAX_TURBE		10000000
+#define IMAX_SUPER		12000000
+
 enum smbb_attr {
 	ATTR_BAT_ISAFE,
 	ATTR_BAT_IMAX,
@@ -111,6 +117,7 @@ struct smbb_charger {
 
 	bool dc_disabled;
 	bool jeita_ext_temp;
+	bool pd_verifed;
 	unsigned long status;
 	struct mutex statlock;
 
@@ -485,6 +492,58 @@ static const struct smbb_irq {
 	{ "dc-valid", smbb_dc_valid_handler },
 };
 
+struct quick_charge {
+	enum power_supply_type adap_type;
+	enum power_supply_quick_charge_type adap_cap;
+};
+
+static struct quick_charge adapter_cap[10] = {
+	{ POWER_SUPPLY_TYPE_USB,		QUICK_CHARGE_NORMAL },
+	{ POWER_SUPPLY_TYPE_USB_DCP,		QUICK_CHARGE_NORMAL },
+	{ POWER_SUPPLY_TYPE_USB_CDP,		QUICK_CHARGE_NORMAL },
+	{ POWER_SUPPLY_TYPE_USB_ACA,		QUICK_CHARGE_NORMAL },
+	{ POWER_SUPPLY_TYPE_USB_FLOAT,		QUICK_CHARGE_NORMAL },
+	{ POWER_SUPPLY_TYPE_USB_PD,		QUICK_CHARGE_FAST },
+	{ POWER_SUPPLY_TYPE_USB_HVDCP,		QUICK_CHARGE_FAST },
+	{ POWER_SUPPLY_TYPE_USB_HVDCP_3,	QUICK_CHARGE_FAST },
+	{ POWER_SUPPLY_TYPE_USB_HVDCP_3P5,	QUICK_CHARGE_FAST },
+	{0, 0},
+};
+
+static int get_quick_charge_type(struct smbb_charger *chg)
+{
+	union power_supply_propval prop = {0, };
+	int charger_type, rc;
+	int i = 0;
+
+	rc = power_supply_get_property(chg->bat_psy,
+			POWER_SUPPLY_PROP_STATUS, &prop);
+	if (rc < 0)
+		return rc;
+	if (prop.intval == POWER_SUPPLY_STATUS_DISCHARGING)
+		return 0;
+
+	rc = power_supply_get_property(chg->usb_psy,
+			POWER_SUPPLY_PROP_USB_TYPE, &prop);
+	if (rc < 0)
+		return rc;
+	charger_type = prop.intval;
+
+	/* when pd adapter is authenticated successfully */
+	if ((charger_type == POWER_SUPPLY_TYPE_USB_PD) && chg->pd_verifed) {
+		return QUICK_CHARGE_TURBE;
+	}
+
+	while (adapter_cap[i].adap_type != 0) {
+		if (charger_type == adapter_cap[i].adap_type) {
+			return adapter_cap[i].adap_cap;
+		}
+		i++;
+	}
+
+	return 0;
+}
+
 static int smbb_usbin_get_property(struct power_supply *psy,
 		enum power_supply_property psp,
 		union power_supply_propval *val)
@@ -505,6 +564,9 @@ static int smbb_usbin_get_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
 		val->intval = 2500000;
 		break;
+	case POWER_SUPPLY_PROP_QUICK_CHARGE_TYPE:
+		val->intval = get_quick_charge_type(chg);
+		break;
 	default:
 		rc = -EINVAL;
 		break;
@@ -662,11 +724,27 @@ static int smbb_battery_set_property(struct power_supply *psy,
 		const union power_supply_propval *val)
 {
 	struct smbb_charger *chg = power_supply_get_drvdata(psy);
+	int charger_type, bat_imax;
 	int rc;
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_CURRENT_MAX:
-		rc = smbb_charger_attr_write(chg, ATTR_BAT_IMAX, val->intval);
+		charger_type = get_quick_charge_type(chg);
+		if (charger_type == QUICK_CHARGE_NORMAL)
+			bat_imax = IMAX_NORMAL;
+		else if (charger_type == QUICK_CHARGE_FAST)
+			bat_imax = IMAX_FAST;
+		else if (charger_type == QUICK_CHARGE_FLASH)
+			bat_imax = IMAX_FLASH;
+		else if (charger_type == QUICK_CHARGE_TURBE)
+			bat_imax = IMAX_TURBE;
+		else if (charger_type == QUICK_CHARGE_SUPER)
+			bat_imax = IMAX_SUPER;
+		else
+			bat_imax = IMAX_NORMAL;
+
+		bat_imax = min(val->intval, bat_imax);
+		rc = smbb_charger_attr_write(chg, ATTR_BAT_IMAX, bat_imax);
 		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
 		rc = smbb_charger_attr_write(chg, ATTR_BAT_VMAX, val->intval);
@@ -695,6 +773,7 @@ static enum power_supply_property smbb_charger_properties[] = {
 	POWER_SUPPLY_PROP_ONLINE,
 	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
 	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,
+	POWER_SUPPLY_PROP_QUICK_CHARGE_TYPE,
 };
 
 static enum power_supply_property smbb_battery_properties[] = {
diff --git a/drivers/power/supply/sc27xx_fuel_gauge.c b/drivers/power/supply/sc27xx_fuel_gauge.c
index bc8f5bda5..a7c8a8453 100644
--- a/drivers/power/supply/sc27xx_fuel_gauge.c
+++ b/drivers/power/supply/sc27xx_fuel_gauge.c
@@ -62,6 +62,8 @@
 
 #define SC27XX_FGU_CUR_BASIC_ADC	8192
 #define SC27XX_FGU_SAMPLE_HZ		2
+/* micro Ohms */
+#define SC27XX_FGU_IDEAL_RESISTANCE	20000
 
 /*
  * struct sc27xx_fgu_data: describe the FGU device
@@ -81,9 +83,12 @@
  * @max_volt: the maximum constant input voltage in millivolt
  * @min_volt: the minimum drained battery voltage in microvolt
  * @table_len: the capacity table length
+ * @resist_table_len: the resistance table length
  * @cur_1000ma_adc: ADC value corresponding to 1000 mA
  * @vol_1000mv_adc: ADC value corresponding to 1000 mV
+ * @calib_resist: the real resistance of coulomb counter chip in uOhm
  * @cap_table: capacity table with corresponding ocv
+ * @resist_table: resistance percent table with corresponding temperature
  */
 struct sc27xx_fgu_data {
 	struct regmap *regmap;
@@ -103,15 +108,19 @@ struct sc27xx_fgu_data {
 	int max_volt;
 	int min_volt;
 	int table_len;
+	int resist_table_len;
 	int cur_1000ma_adc;
 	int vol_1000mv_adc;
+	int calib_resist;
 	struct power_supply_battery_ocv_table *cap_table;
+	struct power_supply_resistance_temp_table *resist_table;
 };
 
 static int sc27xx_fgu_cap_to_clbcnt(struct sc27xx_fgu_data *data, int capacity);
 static void sc27xx_fgu_capacity_calibration(struct sc27xx_fgu_data *data,
 					    int cap, bool int_mode);
 static void sc27xx_fgu_adjust_cap(struct sc27xx_fgu_data *data, int cap);
+static int sc27xx_fgu_get_temp(struct sc27xx_fgu_data *data, int *temp);
 
 static const char * const sc27xx_charger_supply_name[] = {
 	"sc2731_charger",
@@ -434,7 +443,7 @@ static int sc27xx_fgu_get_current(struct sc27xx_fgu_data *data, int *val)
 
 static int sc27xx_fgu_get_vbat_ocv(struct sc27xx_fgu_data *data, int *val)
 {
-	int vol, cur, ret;
+	int vol, cur, ret, temp, resistance;
 
 	ret = sc27xx_fgu_get_vbat_vol(data, &vol);
 	if (ret)
@@ -444,8 +453,19 @@ static int sc27xx_fgu_get_vbat_ocv(struct sc27xx_fgu_data *data, int *val)
 	if (ret)
 		return ret;
 
+	resistance = data->internal_resist;
+	if (data->resist_table_len > 0) {
+		ret = sc27xx_fgu_get_temp(data, &temp);
+		if (ret)
+			return ret;
+
+		resistance = power_supply_temp2resist_simple(data->resist_table,
+						data->resist_table_len, temp);
+		resistance = data->internal_resist * resistance / 100;
+	}
+
 	/* Return the battery OCV in micro volts. */
-	*val = vol * 1000 - cur * data->internal_resist;
+	*val = vol * 1000 - cur * resistance;
 
 	return 0;
 }
@@ -594,6 +614,17 @@ static int sc27xx_fgu_get_property(struct power_supply *psy,
 		val->intval = data->total_cap * 1000;
 		break;
 
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		ret = sc27xx_fgu_get_clbcnt(data, &value);
+		if (ret)
+			goto error;
+
+		value = DIV_ROUND_CLOSEST(value * 10,
+					  36 * SC27XX_FGU_SAMPLE_HZ);
+		val->intval = sc27xx_fgu_adc_to_current(data, value);
+
+		break;
+
 	default:
 		ret = -EINVAL;
 		break;
@@ -662,6 +693,7 @@ static enum power_supply_property sc27xx_fgu_props[] = {
 	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
 	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
 	POWER_SUPPLY_PROP_CALIBRATE,
+	POWER_SUPPLY_PROP_CHARGE_NOW
 };
 
 static const struct power_supply_desc sc27xx_fgu_desc = {
@@ -884,7 +916,9 @@ static int sc27xx_fgu_calibration(struct sc27xx_fgu_data *data)
 	 */
 	cal_4200mv = (calib_data & 0x1ff) + 6963 - 4096 - 256;
 	data->vol_1000mv_adc = DIV_ROUND_CLOSEST(cal_4200mv * 10, 42);
-	data->cur_1000ma_adc = data->vol_1000mv_adc * 4;
+	data->cur_1000ma_adc =
+		DIV_ROUND_CLOSEST(data->vol_1000mv_adc * 4 * data->calib_resist,
+				  SC27XX_FGU_IDEAL_RESISTANCE);
 
 	kfree(buf);
 	return 0;
@@ -929,6 +963,18 @@ static int sc27xx_fgu_hw_init(struct sc27xx_fgu_data *data)
 	if (!data->alarm_cap)
 		data->alarm_cap += 1;
 
+	data->resist_table_len = info.resist_table_size;
+	if (data->resist_table_len > 0) {
+		data->resist_table = devm_kmemdup(data->dev, info.resist_table,
+						  data->resist_table_len *
+						  sizeof(struct power_supply_resistance_temp_table),
+						  GFP_KERNEL);
+		if (!data->resist_table) {
+			power_supply_put_battery_info(data->battery, &info);
+			return -ENOMEM;
+		}
+	}
+
 	power_supply_put_battery_info(data->battery, &info);
 
 	ret = sc27xx_fgu_calibration(data);
@@ -1051,6 +1097,15 @@ static int sc27xx_fgu_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	ret = device_property_read_u32(&pdev->dev,
+				       "sprd,calib-resistance-micro-ohms",
+				       &data->calib_resist);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"failed to get fgu calibration resistance\n");
+		return ret;
+	}
+
 	data->channel = devm_iio_channel_get(dev, "bat-temp");
 	if (IS_ERR(data->channel)) {
 		dev_err(dev, "failed to get IIO channel\n");
-- 
2.17.1

