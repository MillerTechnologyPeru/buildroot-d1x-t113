From 95c276821d03c5fe41c323be6fdb3df1b48cf3f6 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 17:15:48 +0800
Subject: [PATCH 66/93] add sunxi uart

---
 drivers/tty/serdev/core.c           |   82 +-
 drivers/tty/serdev/serdev-ttyport.c |   30 +-
 drivers/tty/serial/Kconfig          |   48 +-
 drivers/tty/serial/Makefile         |    3 +-
 drivers/tty/serial/samsung_tty.c    | 2743 +++++++++++++++++++++++++++
 drivers/tty/serial/serial_core.c    |    1 +
 drivers/tty/serial/sprd_serial.c    |   33 +
 drivers/tty/serial/sunxi-uart.c     | 2280 ++++++++++++++++++++++
 drivers/tty/serial/sunxi-uart.h     |  254 +++
 drivers/tty/sysrq.c                 |    4 +
 10 files changed, 5449 insertions(+), 29 deletions(-)
 create mode 100644 drivers/tty/serial/samsung_tty.c
 create mode 100644 drivers/tty/serial/sunxi-uart.c
 create mode 100644 drivers/tty/serial/sunxi-uart.h

diff --git a/drivers/tty/serdev/core.c b/drivers/tty/serdev/core.c
index a9719858c..3ed2fdbd7 100644
--- a/drivers/tty/serdev/core.c
+++ b/drivers/tty/serdev/core.c
@@ -31,7 +31,18 @@ static ssize_t modalias_show(struct device *dev,
 	if (len != -ENODEV)
 		return len;
 
-	return of_device_modalias(dev, buf, PAGE_SIZE);
+	len = of_device_modalias(dev, buf, PAGE_SIZE);
+	if (len != -ENODEV)
+		return len;
+
+	if (dev->parent->parent->bus == &platform_bus_type) {
+		struct platform_device *pdev =
+			to_platform_device(dev->parent->parent);
+
+		len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev->name);
+	}
+
+	return len;
 }
 static DEVICE_ATTR_RO(modalias);
 
@@ -45,13 +56,18 @@ static int serdev_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	int rc;
 
-	/* TODO: platform modalias */
-
 	rc = acpi_device_uevent_modalias(dev, env);
 	if (rc != -ENODEV)
 		return rc;
 
-	return of_device_uevent_modalias(dev, env);
+	rc = of_device_uevent_modalias(dev, env);
+	if (rc != -ENODEV)
+		return rc;
+
+	if (dev->parent->parent->bus == &platform_bus_type)
+		rc = dev->parent->parent->bus->uevent(dev->parent->parent, env);
+
+	return rc;
 }
 
 static void serdev_device_release(struct device *dev)
@@ -87,11 +103,17 @@ static int serdev_device_match(struct device *dev, struct device_driver *drv)
 	if (!is_serdev_device(dev))
 		return 0;
 
-	/* TODO: platform matching */
 	if (acpi_driver_match_device(dev, drv))
 		return 1;
 
-	return of_driver_match_device(dev, drv);
+	if (of_driver_match_device(dev, drv))
+		return 1;
+
+	if (dev->parent->parent->bus == &platform_bus_type &&
+	    dev->parent->parent->bus->match(dev->parent->parent, drv))
+		return 1;
+
+	return 0;
 }
 
 /**
@@ -630,16 +652,45 @@ static inline int acpi_serdev_register_devices(struct serdev_controller *ctrl)
 }
 #endif /* CONFIG_ACPI */
 
+static int platform_serdev_register_devices(struct serdev_controller *ctrl)
+{
+	struct serdev_device *serdev;
+	int err;
+
+	if (ctrl->dev.parent->bus != &platform_bus_type)
+		return -ENODEV;
+
+	serdev = serdev_device_alloc(ctrl);
+	if (!serdev) {
+		dev_err(&ctrl->dev, "failed to allocate serdev device for %s\n",
+				    dev_name(ctrl->dev.parent));
+		return -ENOMEM;
+	}
+
+	pm_runtime_no_callbacks(&serdev->dev);
+
+	err = serdev_device_add(serdev);
+	if (err) {
+		dev_err(&serdev->dev,
+			"failure adding device. status %d\n", err);
+		serdev_device_put(serdev);
+	}
+
+	return err;
+}
+
+
 /**
- * serdev_controller_add() - Add an serdev controller
+ * serdev_controller_add_platform() - Add an serdev controller
  * @ctrl:	controller to be registered.
+ * @platform:	whether to permit fallthrough to platform device probe
  *
  * Register a controller previously allocated via serdev_controller_alloc() with
- * the serdev core.
+ * the serdev core. Optionally permit probing via a platform device fallback.
  */
-int serdev_controller_add(struct serdev_controller *ctrl)
+int serdev_controller_add_platform(struct serdev_controller *ctrl, bool platform)
 {
-	int ret_of, ret_acpi, ret;
+	int ret, ret_of, ret_acpi, ret_platform = -ENODEV;
 
 	/* Can't register until after driver model init */
 	if (WARN_ON(!is_registered))
@@ -653,9 +704,12 @@ int serdev_controller_add(struct serdev_controller *ctrl)
 
 	ret_of = of_serdev_register_devices(ctrl);
 	ret_acpi = acpi_serdev_register_devices(ctrl);
-	if (ret_of && ret_acpi) {
-		dev_dbg(&ctrl->dev, "no devices registered: of:%d acpi:%d\n",
-			ret_of, ret_acpi);
+	if (platform)
+		ret_platform = platform_serdev_register_devices(ctrl);
+	if (ret_of && ret_acpi && ret_platform) {
+		dev_dbg(&ctrl->dev, "no devices registered: of:%d acpi:%d "
+				    "platform:%d\n",
+				    ret_of, ret_acpi, ret_platform);
 		ret = -ENODEV;
 		goto err_rpm_disable;
 	}
@@ -669,7 +723,7 @@ int serdev_controller_add(struct serdev_controller *ctrl)
 	device_del(&ctrl->dev);
 	return ret;
 };
-EXPORT_SYMBOL_GPL(serdev_controller_add);
+EXPORT_SYMBOL_GPL(serdev_controller_add_platform);
 
 /* Remove a device associated with a controller */
 static int serdev_remove_device(struct device *dev, void *data)
diff --git a/drivers/tty/serdev/serdev-ttyport.c b/drivers/tty/serdev/serdev-ttyport.c
index d367803e2..6cdffde2d 100644
--- a/drivers/tty/serdev/serdev-ttyport.c
+++ b/drivers/tty/serdev/serdev-ttyport.c
@@ -7,9 +7,15 @@
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/poll.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
 
 #define SERPORT_ACTIVE		1
 
+static char *pdev_tty_port;
+module_param(pdev_tty_port, charp, 0644);
+MODULE_PARM_DESC(pdev_tty_port, "platform device tty port to claim");
+
 struct serport {
 	struct tty_port *port;
 	struct tty_struct *tty;
@@ -267,6 +273,7 @@ struct device *serdev_tty_port_register(struct tty_port *port,
 {
 	struct serdev_controller *ctrl;
 	struct serport *serport;
+	bool platform = false;
 	int ret;
 
 	if (!port || !drv || !parent)
@@ -286,7 +293,28 @@ struct device *serdev_tty_port_register(struct tty_port *port,
 	port->client_ops = &client_ops;
 	port->client_data = ctrl;
 
-	ret = serdev_controller_add(ctrl);
+	/* There is not always a way to bind specific platform devices because
+	 * they may be defined on platforms without DT or ACPI. When dealing
+	 * with a platform devices, do not allow direct binding unless it is
+	 * whitelisted by module parameter. If a platform device is otherwise
+	 * described by DT or ACPI it will still be bound and this check will
+	 * be ignored.
+	 */
+	if (parent->bus == &platform_bus_type) {
+		if (pdev_tty_port) {
+			unsigned long pdev_idx;
+			int tty_len = strlen(drv->name);
+
+			if (!strncmp(pdev_tty_port, drv->name, tty_len)) {
+				if (!kstrtoul(pdev_tty_port + tty_len, 10,
+					     &pdev_idx) && pdev_idx == idx) {
+					platform = true;
+				}
+			}
+		}
+	}
+
+	ret = serdev_controller_add_platform(ctrl, platform);
 	if (ret)
 		goto err_reset_data;
 
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 67a9eb3f9..97cd3af04 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -237,7 +237,6 @@ config SERIAL_CLPS711X_CONSOLE
 
 config SERIAL_SAMSUNG
 	tristate "Samsung SoC serial support"
-	depends on PLAT_SAMSUNG || ARCH_EXYNOS
 	select SERIAL_CORE
 	help
 	  Support for the on-chip UARTs on the Samsung S3C24XX series CPUs,
@@ -260,15 +259,6 @@ config SERIAL_SAMSUNG_UARTS
 	help
 	  Select the number of available UART ports for the Samsung S3C
 	  serial driver
-	
-config SERIAL_SAMSUNG_DEBUG
-	bool "Samsung SoC serial debug"
-	depends on SERIAL_SAMSUNG && DEBUG_LL
-	help
-	  Add support for debugging the serial driver. Since this is
-	  generally being used as a console, we use our own output
-	  routines that go via the low-level debug printascii()
-	  function.
 
 config SERIAL_SAMSUNG_CONSOLE
 	bool "Support for console on Samsung SoC serial port"
@@ -741,7 +731,7 @@ config SERIAL_HS_LPC32XX_CONSOLE
 	  Y to this option.
 
 config SERIAL_CORE
-	tristate
+	bool
 
 config SERIAL_CORE_CONSOLE
 	bool
@@ -975,7 +965,7 @@ config SERIAL_QCOM_GENI
 
 config SERIAL_QCOM_GENI_CONSOLE
 	bool "QCOM GENI Serial Console support"
-	depends on SERIAL_QCOM_GENI=y
+	depends on SERIAL_QCOM_GENI
 	select SERIAL_CORE_CONSOLE
 	select SERIAL_EARLYCON
 	help
@@ -1452,7 +1442,6 @@ config SERIAL_MEN_Z135
 
 config SERIAL_SPRD
 	tristate "Support for Spreadtrum serial"
-	depends on ARCH_SPRD
 	select SERIAL_CORE
 	help
 	  This enables the driver for the Spreadtrum's serial.
@@ -1572,6 +1561,39 @@ config SERIAL_MILBEAUT_USIO_CONSOLE
 	  receives all kernel messages and warnings and which allows logins in
 	  single user mode).
 
+
+config SERIAL_SUNXI
+	tristate "SUNXI UART Controller"
+	depends on ARCH_SUNXI
+	select SERIAL_CORE
+	default y
+	help
+	  If you have an Allwinner SOC based board and want to use the
+	  built-in UART of the SoC, say Y to this option.
+
+config SERIAL_SUNXI_DMA
+	tristate "SUNXI UART USE DMA"
+	depends on SERIAL_SUNXI
+	depends on OF
+	default n
+	help
+	  If you have an Allwinner SOC based board and want to use the
+	  built-in UART DMA of the SoC, say Y to this option
+
+config SERIAL_SUNXI_CONSOLE
+	tristate "Console on SUNXI UART port"
+	select SERIAL_CORE_CONSOLE
+	default SERIAL_SUNXI
+	help
+	  Enable a built-in UART port of the Allinner SOC to be the system console.
+
+config SERIAL_SUNXI_EARLYCON
+	tristate "Enable sunxi earlycon."
+	select SERIAL_EARLYCON
+	default n
+	help
+	  Enable earlycon with boot step. If enable earlycon, kernel cmd (earlycon=uart0,addr) must be add.
+
 endmenu
 
 config SERIAL_MCTRL_GPIO
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 863f47056..daee88209 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -30,7 +30,7 @@ obj-$(CONFIG_SERIAL_PXA_NON8250) += pxa.o
 obj-$(CONFIG_SERIAL_PNX8XXX) += pnx8xxx_uart.o
 obj-$(CONFIG_SERIAL_SA1100) += sa1100.o
 obj-$(CONFIG_SERIAL_BCM63XX) += bcm63xx_uart.o
-obj-$(CONFIG_SERIAL_SAMSUNG) += samsung.o
+obj-$(CONFIG_SERIAL_SAMSUNG) += samsung_tty.o
 obj-$(CONFIG_SERIAL_MAX3100) += max3100.o
 obj-$(CONFIG_SERIAL_MAX310X) += max310x.o
 obj-$(CONFIG_SERIAL_IP22_ZILOG) += ip22zilog.o
@@ -89,6 +89,7 @@ obj-$(CONFIG_SERIAL_OWL)	+= owl-uart.o
 obj-$(CONFIG_SERIAL_RDA)	+= rda-uart.o
 obj-$(CONFIG_SERIAL_MILBEAUT_USIO) += milbeaut_usio.o
 obj-$(CONFIG_SERIAL_SIFIVE)	+= sifive.o
+obj-$(CONFIG_SERIAL_SUNXI)      += sunxi-uart.o
 
 # GPIOLIB helpers for modem control lines
 obj-$(CONFIG_SERIAL_MCTRL_GPIO)	+= serial_mctrl_gpio.o
diff --git a/drivers/tty/serial/samsung_tty.c b/drivers/tty/serial/samsung_tty.c
new file mode 100644
index 000000000..32446593f
--- /dev/null
+++ b/drivers/tty/serial/samsung_tty.c
@@ -0,0 +1,2743 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver core for Samsung SoC onboard UARTs.
+ *
+ * Ben Dooks, Copyright (c) 2003-2008 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ */
+
+/* Hote on 2410 error handling
+ *
+ * The s3c2410 manual has a love/hate affair with the contents of the
+ * UERSTAT register in the UART blocks, and keeps marking some of the
+ * error bits as reserved. Having checked with the s3c2410x01,
+ * it copes with BREAKs properly, so I am happy to ignore the RESERVED
+ * feature from the latter versions of the manual.
+ *
+ * If it becomes aparrent that latter versions of the 2410 remove these
+ * bits, then action will have to be taken to differentiate the versions
+ * and change the policy on BREAK
+ *
+ * BJD, 04-Nov-2004
+ */
+
+#if defined(CONFIG_SERIAL_SAMSUNG_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/sysrq.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_s3c.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/of.h>
+#include <asm/irq.h>
+
+/* UART name and device definitions */
+
+#define S3C24XX_SERIAL_NAME	"ttySAC"
+#define S3C24XX_SERIAL_MAJOR	204
+#define S3C24XX_SERIAL_MINOR	64
+
+#define S3C24XX_TX_PIO			1
+#define S3C24XX_TX_DMA			2
+#define S3C24XX_RX_PIO			1
+#define S3C24XX_RX_DMA			2
+
+/* flag to ignore all characters coming in */
+#define RXSTAT_DUMMY_READ (0x10000000)
+
+struct s3c24xx_uart_info {
+	char			*name;
+	unsigned int		type;
+	unsigned int		fifosize;
+	unsigned long		rx_fifomask;
+	unsigned long		rx_fifoshift;
+	unsigned long		rx_fifofull;
+	unsigned long		tx_fifomask;
+	unsigned long		tx_fifoshift;
+	unsigned long		tx_fifofull;
+	unsigned int		def_clk_sel;
+	unsigned long		num_clks;
+	unsigned long		clksel_mask;
+	unsigned long		clksel_shift;
+
+	/* uart port features */
+
+	unsigned int		has_divslot:1;
+};
+
+struct s3c24xx_serial_drv_data {
+	struct s3c24xx_uart_info	*info;
+	struct s3c2410_uartcfg		*def_cfg;
+	unsigned int			fifosize[CONFIG_SERIAL_SAMSUNG_UARTS];
+};
+
+struct s3c24xx_uart_dma {
+	unsigned int			rx_chan_id;
+	unsigned int			tx_chan_id;
+
+	struct dma_slave_config		rx_conf;
+	struct dma_slave_config		tx_conf;
+
+	struct dma_chan			*rx_chan;
+	struct dma_chan			*tx_chan;
+
+	dma_addr_t			rx_addr;
+	dma_addr_t			tx_addr;
+
+	dma_cookie_t			rx_cookie;
+	dma_cookie_t			tx_cookie;
+
+	char				*rx_buf;
+
+	dma_addr_t			tx_transfer_addr;
+
+	size_t				rx_size;
+	size_t				tx_size;
+
+	struct dma_async_tx_descriptor	*tx_desc;
+	struct dma_async_tx_descriptor	*rx_desc;
+
+	int				tx_bytes_requested;
+	int				rx_bytes_requested;
+};
+
+struct s3c24xx_uart_port {
+	unsigned char			rx_claimed;
+	unsigned char			tx_claimed;
+	unsigned char			rx_enabled;
+	unsigned char			tx_enabled;
+	unsigned int			pm_level;
+	unsigned long			baudclk_rate;
+	unsigned int			min_dma_size;
+
+	unsigned int			rx_irq;
+	unsigned int			tx_irq;
+
+	unsigned int			tx_in_progress;
+	unsigned int			tx_mode;
+	unsigned int			rx_mode;
+
+	struct s3c24xx_uart_info	*info;
+	struct clk			*clk;
+	struct clk			*baudclk;
+	struct uart_port		port;
+	struct s3c24xx_serial_drv_data	*drv_data;
+
+	/* reference to platform data */
+	struct s3c2410_uartcfg		*cfg;
+
+	struct s3c24xx_uart_dma		*dma;
+
+#ifdef CONFIG_ARM_S3C24XX_CPUFREQ
+	struct notifier_block		freq_transition;
+#endif
+};
+
+/* conversion functions */
+
+#define s3c24xx_dev_to_port(__dev) dev_get_drvdata(__dev)
+
+/* register access controls */
+
+#define portaddr(port, reg) ((port)->membase + (reg))
+#define portaddrl(port, reg) \
+	((unsigned long *)(unsigned long)((port)->membase + (reg)))
+
+static u32 rd_reg(struct uart_port *port, u32 reg)
+{
+	switch (port->iotype) {
+	case UPIO_MEM:
+		return readb_relaxed(portaddr(port, reg));
+	case UPIO_MEM32:
+		return readl_relaxed(portaddr(port, reg));
+	default:
+		return 0;
+	}
+	return 0;
+}
+
+#define rd_regl(port, reg) (readl_relaxed(portaddr(port, reg)))
+
+static void wr_reg(struct uart_port *port, u32 reg, u32 val)
+{
+	switch (port->iotype) {
+	case UPIO_MEM:
+		writeb_relaxed(val, portaddr(port, reg));
+		break;
+	case UPIO_MEM32:
+		writel_relaxed(val, portaddr(port, reg));
+		break;
+	}
+}
+
+#define wr_regl(port, reg, val) writel_relaxed(val, portaddr(port, reg))
+
+/* Byte-order aware bit setting/clearing functions. */
+
+static inline void s3c24xx_set_bit(struct uart_port *port, int idx,
+				   unsigned int reg)
+{
+	unsigned long flags;
+	u32 val;
+
+	local_irq_save(flags);
+	val = rd_regl(port, reg);
+	val |= (1 << idx);
+	wr_regl(port, reg, val);
+	local_irq_restore(flags);
+}
+
+static inline void s3c24xx_clear_bit(struct uart_port *port, int idx,
+				     unsigned int reg)
+{
+	unsigned long flags;
+	u32 val;
+
+	local_irq_save(flags);
+	val = rd_regl(port, reg);
+	val &= ~(1 << idx);
+	wr_regl(port, reg, val);
+	local_irq_restore(flags);
+}
+
+static inline struct s3c24xx_uart_port *to_ourport(struct uart_port *port)
+{
+	return container_of(port, struct s3c24xx_uart_port, port);
+}
+
+/* translate a port to the device name */
+
+static inline const char *s3c24xx_serial_portname(struct uart_port *port)
+{
+	return to_platform_device(port->dev)->name;
+}
+
+static int s3c24xx_serial_txempty_nofifo(struct uart_port *port)
+{
+	return rd_regl(port, S3C2410_UTRSTAT) & S3C2410_UTRSTAT_TXE;
+}
+
+/*
+ * s3c64xx and later SoC's include the interrupt mask and status registers in
+ * the controller itself, unlike the s3c24xx SoC's which have these registers
+ * in the interrupt controller. Check if the port type is s3c64xx or higher.
+ */
+static int s3c24xx_serial_has_interrupt_mask(struct uart_port *port)
+{
+	return to_ourport(port)->info->type == PORT_S3C6400;
+}
+
+static void s3c24xx_serial_rx_enable(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	unsigned long flags;
+	unsigned int ucon, ufcon;
+	int count = 10000;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	while (--count && !s3c24xx_serial_txempty_nofifo(port))
+		udelay(100);
+
+	ufcon = rd_regl(port, S3C2410_UFCON);
+	ufcon |= S3C2410_UFCON_RESETRX;
+	wr_regl(port, S3C2410_UFCON, ufcon);
+
+	ucon = rd_regl(port, S3C2410_UCON);
+	ucon |= S3C2410_UCON_RXIRQMODE;
+	wr_regl(port, S3C2410_UCON, ucon);
+
+	ourport->rx_enabled = 1;
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void s3c24xx_serial_rx_disable(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	unsigned long flags;
+	unsigned int ucon;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	ucon = rd_regl(port, S3C2410_UCON);
+	ucon &= ~S3C2410_UCON_RXIRQMODE;
+	wr_regl(port, S3C2410_UCON, ucon);
+
+	ourport->rx_enabled = 0;
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void s3c24xx_serial_stop_tx(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct s3c24xx_uart_dma *dma = ourport->dma;
+	struct circ_buf *xmit = &port->state->xmit;
+	struct dma_tx_state state;
+	int count;
+
+	if (!ourport->tx_enabled)
+		return;
+
+	if (s3c24xx_serial_has_interrupt_mask(port))
+		s3c24xx_set_bit(port, S3C64XX_UINTM_TXD, S3C64XX_UINTM);
+	else
+		disable_irq_nosync(ourport->tx_irq);
+
+	if (dma && dma->tx_chan && ourport->tx_in_progress == S3C24XX_TX_DMA) {
+		dmaengine_pause(dma->tx_chan);
+		dmaengine_tx_status(dma->tx_chan, dma->tx_cookie, &state);
+		dmaengine_terminate_all(dma->tx_chan);
+		dma_sync_single_for_cpu(ourport->port.dev,
+			dma->tx_transfer_addr, dma->tx_size, DMA_TO_DEVICE);
+		async_tx_ack(dma->tx_desc);
+		count = dma->tx_bytes_requested - state.residue;
+		xmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);
+		port->icount.tx += count;
+	}
+
+	ourport->tx_enabled = 0;
+	ourport->tx_in_progress = 0;
+
+	if (port->flags & UPF_CONS_FLOW)
+		s3c24xx_serial_rx_enable(port);
+
+	ourport->tx_mode = 0;
+}
+
+static void s3c24xx_serial_start_next_tx(struct s3c24xx_uart_port *ourport);
+
+static void s3c24xx_serial_tx_dma_complete(void *args)
+{
+	struct s3c24xx_uart_port *ourport = args;
+	struct uart_port *port = &ourport->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	struct s3c24xx_uart_dma *dma = ourport->dma;
+	struct dma_tx_state state;
+	unsigned long flags;
+	int count;
+
+
+	dmaengine_tx_status(dma->tx_chan, dma->tx_cookie, &state);
+	count = dma->tx_bytes_requested - state.residue;
+	async_tx_ack(dma->tx_desc);
+
+	dma_sync_single_for_cpu(ourport->port.dev, dma->tx_transfer_addr,
+				dma->tx_size, DMA_TO_DEVICE);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	xmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);
+	port->icount.tx += count;
+	ourport->tx_in_progress = 0;
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	s3c24xx_serial_start_next_tx(ourport);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void enable_tx_dma(struct s3c24xx_uart_port *ourport)
+{
+	struct uart_port *port = &ourport->port;
+	u32 ucon;
+
+	/* Mask Tx interrupt */
+	if (s3c24xx_serial_has_interrupt_mask(port))
+		s3c24xx_set_bit(port, S3C64XX_UINTM_TXD, S3C64XX_UINTM);
+	else
+		disable_irq_nosync(ourport->tx_irq);
+
+	/* Enable tx dma mode */
+	ucon = rd_regl(port, S3C2410_UCON);
+	ucon &= ~(S3C64XX_UCON_TXBURST_MASK | S3C64XX_UCON_TXMODE_MASK);
+	ucon |= (dma_get_cache_alignment() >= 16) ?
+		S3C64XX_UCON_TXBURST_16 : S3C64XX_UCON_TXBURST_1;
+	ucon |= S3C64XX_UCON_TXMODE_DMA;
+	wr_regl(port,  S3C2410_UCON, ucon);
+
+	ourport->tx_mode = S3C24XX_TX_DMA;
+}
+
+static void enable_tx_pio(struct s3c24xx_uart_port *ourport)
+{
+	struct uart_port *port = &ourport->port;
+	u32 ucon, ufcon;
+
+	/* Set ufcon txtrig */
+	ourport->tx_in_progress = S3C24XX_TX_PIO;
+	ufcon = rd_regl(port, S3C2410_UFCON);
+	wr_regl(port,  S3C2410_UFCON, ufcon);
+
+	/* Enable tx pio mode */
+	ucon = rd_regl(port, S3C2410_UCON);
+	ucon &= ~(S3C64XX_UCON_TXMODE_MASK);
+	ucon |= S3C64XX_UCON_TXMODE_CPU;
+	wr_regl(port,  S3C2410_UCON, ucon);
+
+	/* Unmask Tx interrupt */
+	if (s3c24xx_serial_has_interrupt_mask(port))
+		s3c24xx_clear_bit(port, S3C64XX_UINTM_TXD,
+				  S3C64XX_UINTM);
+	else
+		enable_irq(ourport->tx_irq);
+
+	ourport->tx_mode = S3C24XX_TX_PIO;
+}
+
+static void s3c24xx_serial_start_tx_pio(struct s3c24xx_uart_port *ourport)
+{
+	if (ourport->tx_mode != S3C24XX_TX_PIO)
+		enable_tx_pio(ourport);
+}
+
+static int s3c24xx_serial_start_tx_dma(struct s3c24xx_uart_port *ourport,
+				      unsigned int count)
+{
+	struct uart_port *port = &ourport->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	struct s3c24xx_uart_dma *dma = ourport->dma;
+
+
+	if (ourport->tx_mode != S3C24XX_TX_DMA)
+		enable_tx_dma(ourport);
+
+	dma->tx_size = count & ~(dma_get_cache_alignment() - 1);
+	dma->tx_transfer_addr = dma->tx_addr + xmit->tail;
+
+	dma_sync_single_for_device(ourport->port.dev, dma->tx_transfer_addr,
+				dma->tx_size, DMA_TO_DEVICE);
+
+	dma->tx_desc = dmaengine_prep_slave_single(dma->tx_chan,
+				dma->tx_transfer_addr, dma->tx_size,
+				DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);
+	if (!dma->tx_desc) {
+		dev_err(ourport->port.dev, "Unable to get desc for Tx\n");
+		return -EIO;
+	}
+
+	dma->tx_desc->callback = s3c24xx_serial_tx_dma_complete;
+	dma->tx_desc->callback_param = ourport;
+	dma->tx_bytes_requested = dma->tx_size;
+
+	ourport->tx_in_progress = S3C24XX_TX_DMA;
+	dma->tx_cookie = dmaengine_submit(dma->tx_desc);
+	dma_async_issue_pending(dma->tx_chan);
+	return 0;
+}
+
+static void s3c24xx_serial_start_next_tx(struct s3c24xx_uart_port *ourport)
+{
+	struct uart_port *port = &ourport->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned long count;
+
+	/* Get data size up to the end of buffer */
+	count = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
+
+	if (!count) {
+		s3c24xx_serial_stop_tx(port);
+		return;
+	}
+
+	if (!ourport->dma || !ourport->dma->tx_chan ||
+	    count < ourport->min_dma_size ||
+	    xmit->tail & (dma_get_cache_alignment() - 1))
+		s3c24xx_serial_start_tx_pio(ourport);
+	else
+		s3c24xx_serial_start_tx_dma(ourport, count);
+}
+
+static void s3c24xx_serial_start_tx(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct circ_buf *xmit = &port->state->xmit;
+
+	if (!ourport->tx_enabled) {
+		if (port->flags & UPF_CONS_FLOW)
+			s3c24xx_serial_rx_disable(port);
+
+		ourport->tx_enabled = 1;
+		if (!ourport->dma || !ourport->dma->tx_chan)
+			s3c24xx_serial_start_tx_pio(ourport);
+	}
+
+	if (ourport->dma && ourport->dma->tx_chan) {
+		if (!uart_circ_empty(xmit) && !ourport->tx_in_progress)
+			s3c24xx_serial_start_next_tx(ourport);
+	}
+}
+
+static void s3c24xx_uart_copy_rx_to_tty(struct s3c24xx_uart_port *ourport,
+		struct tty_port *tty, int count)
+{
+	struct s3c24xx_uart_dma *dma = ourport->dma;
+	int copied;
+
+	if (!count)
+		return;
+
+	dma_sync_single_for_cpu(ourport->port.dev, dma->rx_addr,
+				dma->rx_size, DMA_FROM_DEVICE);
+
+	ourport->port.icount.rx += count;
+	if (!tty) {
+		dev_err(ourport->port.dev, "No tty port\n");
+		return;
+	}
+	copied = tty_insert_flip_string(tty,
+			((unsigned char *)(ourport->dma->rx_buf)), count);
+	if (copied != count) {
+		WARN_ON(1);
+		dev_err(ourport->port.dev, "RxData copy to tty layer failed\n");
+	}
+}
+
+static void s3c24xx_serial_stop_rx(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct s3c24xx_uart_dma *dma = ourport->dma;
+	struct tty_port *t = &port->state->port;
+	struct dma_tx_state state;
+	enum dma_status dma_status;
+	unsigned int received;
+
+	if (ourport->rx_enabled) {
+		dev_dbg(port->dev, "stopping rx\n");
+		if (s3c24xx_serial_has_interrupt_mask(port))
+			s3c24xx_set_bit(port, S3C64XX_UINTM_RXD,
+					S3C64XX_UINTM);
+		else
+			disable_irq_nosync(ourport->rx_irq);
+		ourport->rx_enabled = 0;
+	}
+	if (dma && dma->rx_chan) {
+		dmaengine_pause(dma->tx_chan);
+		dma_status = dmaengine_tx_status(dma->rx_chan,
+				dma->rx_cookie, &state);
+		if (dma_status == DMA_IN_PROGRESS ||
+			dma_status == DMA_PAUSED) {
+			received = dma->rx_bytes_requested - state.residue;
+			dmaengine_terminate_all(dma->rx_chan);
+			s3c24xx_uart_copy_rx_to_tty(ourport, t, received);
+		}
+	}
+}
+
+static inline struct s3c24xx_uart_info
+	*s3c24xx_port_to_info(struct uart_port *port)
+{
+	return to_ourport(port)->info;
+}
+
+static inline struct s3c2410_uartcfg
+	*s3c24xx_port_to_cfg(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport;
+
+	if (port->dev == NULL)
+		return NULL;
+
+	ourport = container_of(port, struct s3c24xx_uart_port, port);
+	return ourport->cfg;
+}
+
+static int s3c24xx_serial_rx_fifocnt(struct s3c24xx_uart_port *ourport,
+				     unsigned long ufstat)
+{
+	struct s3c24xx_uart_info *info = ourport->info;
+
+	if (ufstat & info->rx_fifofull)
+		return ourport->port.fifosize;
+
+	return (ufstat & info->rx_fifomask) >> info->rx_fifoshift;
+}
+
+static void s3c64xx_start_rx_dma(struct s3c24xx_uart_port *ourport);
+static void s3c24xx_serial_rx_dma_complete(void *args)
+{
+	struct s3c24xx_uart_port *ourport = args;
+	struct uart_port *port = &ourport->port;
+
+	struct s3c24xx_uart_dma *dma = ourport->dma;
+	struct tty_port *t = &port->state->port;
+	struct tty_struct *tty = tty_port_tty_get(&ourport->port.state->port);
+
+	struct dma_tx_state state;
+	unsigned long flags;
+	int received;
+
+	dmaengine_tx_status(dma->rx_chan,  dma->rx_cookie, &state);
+	received  = dma->rx_bytes_requested - state.residue;
+	async_tx_ack(dma->rx_desc);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	if (received)
+		s3c24xx_uart_copy_rx_to_tty(ourport, t, received);
+
+	if (tty) {
+		tty_flip_buffer_push(t);
+		tty_kref_put(tty);
+	}
+
+	s3c64xx_start_rx_dma(ourport);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void s3c64xx_start_rx_dma(struct s3c24xx_uart_port *ourport)
+{
+	struct s3c24xx_uart_dma *dma = ourport->dma;
+
+	dma_sync_single_for_device(ourport->port.dev, dma->rx_addr,
+				dma->rx_size, DMA_FROM_DEVICE);
+
+	dma->rx_desc = dmaengine_prep_slave_single(dma->rx_chan,
+				dma->rx_addr, dma->rx_size, DMA_DEV_TO_MEM,
+				DMA_PREP_INTERRUPT);
+	if (!dma->rx_desc) {
+		dev_err(ourport->port.dev, "Unable to get desc for Rx\n");
+		return;
+	}
+
+	dma->rx_desc->callback = s3c24xx_serial_rx_dma_complete;
+	dma->rx_desc->callback_param = ourport;
+	dma->rx_bytes_requested = dma->rx_size;
+
+	dma->rx_cookie = dmaengine_submit(dma->rx_desc);
+	dma_async_issue_pending(dma->rx_chan);
+}
+
+/* ? - where has parity gone?? */
+#define S3C2410_UERSTAT_PARITY (0x1000)
+
+static void enable_rx_dma(struct s3c24xx_uart_port *ourport)
+{
+	struct uart_port *port = &ourport->port;
+	unsigned int ucon;
+
+	/* set Rx mode to DMA mode */
+	ucon = rd_regl(port, S3C2410_UCON);
+	ucon &= ~(S3C64XX_UCON_RXBURST_MASK |
+			S3C64XX_UCON_TIMEOUT_MASK |
+			S3C64XX_UCON_EMPTYINT_EN |
+			S3C64XX_UCON_DMASUS_EN |
+			S3C64XX_UCON_TIMEOUT_EN |
+			S3C64XX_UCON_RXMODE_MASK);
+	ucon |= S3C64XX_UCON_RXBURST_16 |
+			0xf << S3C64XX_UCON_TIMEOUT_SHIFT |
+			S3C64XX_UCON_EMPTYINT_EN |
+			S3C64XX_UCON_TIMEOUT_EN |
+			S3C64XX_UCON_RXMODE_DMA;
+	wr_regl(port, S3C2410_UCON, ucon);
+
+	ourport->rx_mode = S3C24XX_RX_DMA;
+}
+
+static void enable_rx_pio(struct s3c24xx_uart_port *ourport)
+{
+	struct uart_port *port = &ourport->port;
+	unsigned int ucon;
+
+	/* set Rx mode to DMA mode */
+	ucon = rd_regl(port, S3C2410_UCON);
+	ucon &= ~(S3C64XX_UCON_TIMEOUT_MASK |
+			S3C64XX_UCON_EMPTYINT_EN |
+			S3C64XX_UCON_DMASUS_EN |
+			S3C64XX_UCON_TIMEOUT_EN |
+			S3C64XX_UCON_RXMODE_MASK);
+	ucon |= 0xf << S3C64XX_UCON_TIMEOUT_SHIFT |
+			S3C64XX_UCON_TIMEOUT_EN |
+			S3C64XX_UCON_RXMODE_CPU;
+	wr_regl(port, S3C2410_UCON, ucon);
+
+	ourport->rx_mode = S3C24XX_RX_PIO;
+}
+
+static void s3c24xx_serial_rx_drain_fifo(struct s3c24xx_uart_port *ourport);
+
+static irqreturn_t s3c24xx_serial_rx_chars_dma(void *dev_id)
+{
+	unsigned int utrstat, received;
+	struct s3c24xx_uart_port *ourport = dev_id;
+	struct uart_port *port = &ourport->port;
+	struct s3c24xx_uart_dma *dma = ourport->dma;
+	struct tty_struct *tty = tty_port_tty_get(&ourport->port.state->port);
+	struct tty_port *t = &port->state->port;
+	unsigned long flags;
+	struct dma_tx_state state;
+
+	utrstat = rd_regl(port, S3C2410_UTRSTAT);
+	rd_regl(port, S3C2410_UFSTAT);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	if (!(utrstat & S3C2410_UTRSTAT_TIMEOUT)) {
+		s3c64xx_start_rx_dma(ourport);
+		if (ourport->rx_mode == S3C24XX_RX_PIO)
+			enable_rx_dma(ourport);
+		goto finish;
+	}
+
+	if (ourport->rx_mode == S3C24XX_RX_DMA) {
+		dmaengine_pause(dma->rx_chan);
+		dmaengine_tx_status(dma->rx_chan, dma->rx_cookie, &state);
+		dmaengine_terminate_all(dma->rx_chan);
+		received = dma->rx_bytes_requested - state.residue;
+		s3c24xx_uart_copy_rx_to_tty(ourport, t, received);
+
+		enable_rx_pio(ourport);
+	}
+
+	s3c24xx_serial_rx_drain_fifo(ourport);
+
+	if (tty) {
+		tty_flip_buffer_push(t);
+		tty_kref_put(tty);
+	}
+
+	wr_regl(port, S3C2410_UTRSTAT, S3C2410_UTRSTAT_TIMEOUT);
+
+finish:
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static void s3c24xx_serial_rx_drain_fifo(struct s3c24xx_uart_port *ourport)
+{
+	struct uart_port *port = &ourport->port;
+	unsigned int ufcon, ch, flag, ufstat, uerstat;
+	unsigned int fifocnt = 0;
+	int max_count = port->fifosize;
+
+	while (max_count-- > 0) {
+		/*
+		 * Receive all characters known to be in FIFO
+		 * before reading FIFO level again
+		 */
+		if (fifocnt == 0) {
+			ufstat = rd_regl(port, S3C2410_UFSTAT);
+			fifocnt = s3c24xx_serial_rx_fifocnt(ourport, ufstat);
+			if (fifocnt == 0)
+				break;
+		}
+		fifocnt--;
+
+		uerstat = rd_regl(port, S3C2410_UERSTAT);
+		ch = rd_reg(port, S3C2410_URXH);
+
+		if (port->flags & UPF_CONS_FLOW) {
+			int txe = s3c24xx_serial_txempty_nofifo(port);
+
+			if (ourport->rx_enabled) {
+				if (!txe) {
+					ourport->rx_enabled = 0;
+					continue;
+				}
+			} else {
+				if (txe) {
+					ufcon = rd_regl(port, S3C2410_UFCON);
+					ufcon |= S3C2410_UFCON_RESETRX;
+					wr_regl(port, S3C2410_UFCON, ufcon);
+					ourport->rx_enabled = 1;
+					return;
+				}
+				continue;
+			}
+		}
+
+		/* insert the character into the buffer */
+
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (unlikely(uerstat & S3C2410_UERSTAT_ANY)) {
+			dev_dbg(port->dev,
+				"rxerr: port ch=0x%02x, rxs=0x%08x\n",
+				ch, uerstat);
+
+			/* check for break */
+			if (uerstat & S3C2410_UERSTAT_BREAK) {
+				dev_dbg(port->dev, "break!\n");
+				port->icount.brk++;
+				if (uart_handle_break(port))
+					continue; /* Ignore character */
+			}
+
+			if (uerstat & S3C2410_UERSTAT_FRAME)
+				port->icount.frame++;
+			if (uerstat & S3C2410_UERSTAT_OVERRUN)
+				port->icount.overrun++;
+
+			uerstat &= port->read_status_mask;
+
+			if (uerstat & S3C2410_UERSTAT_BREAK)
+				flag = TTY_BREAK;
+			else if (uerstat & S3C2410_UERSTAT_PARITY)
+				flag = TTY_PARITY;
+			else if (uerstat & (S3C2410_UERSTAT_FRAME |
+					    S3C2410_UERSTAT_OVERRUN))
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			continue; /* Ignore character */
+
+		uart_insert_char(port, uerstat, S3C2410_UERSTAT_OVERRUN,
+				 ch, flag);
+	}
+
+	tty_flip_buffer_push(&port->state->port);
+}
+
+static irqreturn_t s3c24xx_serial_rx_chars_pio(void *dev_id)
+{
+	struct s3c24xx_uart_port *ourport = dev_id;
+	struct uart_port *port = &ourport->port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	s3c24xx_serial_rx_drain_fifo(ourport);
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+
+static irqreturn_t s3c24xx_serial_rx_chars(int irq, void *dev_id)
+{
+	struct s3c24xx_uart_port *ourport = dev_id;
+
+	if (ourport->dma && ourport->dma->rx_chan)
+		return s3c24xx_serial_rx_chars_dma(dev_id);
+	return s3c24xx_serial_rx_chars_pio(dev_id);
+}
+
+static irqreturn_t s3c24xx_serial_tx_chars(int irq, void *id)
+{
+	struct s3c24xx_uart_port *ourport = id;
+	struct uart_port *port = &ourport->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned long flags;
+	int count, dma_count = 0;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	count = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
+
+	if (ourport->dma && ourport->dma->tx_chan &&
+	    count >= ourport->min_dma_size) {
+		int align = dma_get_cache_alignment() -
+			(xmit->tail & (dma_get_cache_alignment() - 1));
+		if (count-align >= ourport->min_dma_size) {
+			dma_count = count-align;
+			count = align;
+		}
+	}
+
+	if (port->x_char) {
+		wr_reg(port, S3C2410_UTXH, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		goto out;
+	}
+
+	/* if there isn't anything more to transmit, or the uart is now
+	 * stopped, disable the uart and exit
+	 */
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		s3c24xx_serial_stop_tx(port);
+		goto out;
+	}
+
+	/* try and drain the buffer... */
+
+	if (count > port->fifosize) {
+		count = port->fifosize;
+		dma_count = 0;
+	}
+
+	while (!uart_circ_empty(xmit) && count > 0) {
+		if (rd_regl(port, S3C2410_UFSTAT) & ourport->info->tx_fifofull)
+			break;
+
+		wr_reg(port, S3C2410_UTXH, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		count--;
+	}
+
+	if (!count && dma_count) {
+		s3c24xx_serial_start_tx_dma(ourport, dma_count);
+		goto out;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		spin_unlock(&port->lock);
+		uart_write_wakeup(port);
+		spin_lock(&port->lock);
+	}
+
+	if (uart_circ_empty(xmit))
+		s3c24xx_serial_stop_tx(port);
+
+out:
+	spin_unlock_irqrestore(&port->lock, flags);
+	return IRQ_HANDLED;
+}
+
+/* interrupt handler for s3c64xx and later SoC's.*/
+static irqreturn_t s3c64xx_serial_handle_irq(int irq, void *id)
+{
+	struct s3c24xx_uart_port *ourport = id;
+	struct uart_port *port = &ourport->port;
+	unsigned int pend = rd_regl(port, S3C64XX_UINTP);
+	irqreturn_t ret = IRQ_HANDLED;
+
+	if (pend & S3C64XX_UINTM_RXD_MSK) {
+		ret = s3c24xx_serial_rx_chars(irq, id);
+		wr_regl(port, S3C64XX_UINTP, S3C64XX_UINTM_RXD_MSK);
+	}
+	if (pend & S3C64XX_UINTM_TXD_MSK) {
+		ret = s3c24xx_serial_tx_chars(irq, id);
+		wr_regl(port, S3C64XX_UINTP, S3C64XX_UINTM_TXD_MSK);
+	}
+	return ret;
+}
+
+static unsigned int s3c24xx_serial_tx_empty(struct uart_port *port)
+{
+	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	unsigned long ufstat = rd_regl(port, S3C2410_UFSTAT);
+	unsigned long ufcon = rd_regl(port, S3C2410_UFCON);
+
+	if (ufcon & S3C2410_UFCON_FIFOMODE) {
+		if ((ufstat & info->tx_fifomask) != 0 ||
+		    (ufstat & info->tx_fifofull))
+			return 0;
+
+		return 1;
+	}
+
+	return s3c24xx_serial_txempty_nofifo(port);
+}
+
+/* no modem control lines */
+static unsigned int s3c24xx_serial_get_mctrl(struct uart_port *port)
+{
+	unsigned int umstat = rd_reg(port, S3C2410_UMSTAT);
+
+	if (umstat & S3C2410_UMSTAT_CTS)
+		return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+	else
+		return TIOCM_CAR | TIOCM_DSR;
+}
+
+static void s3c24xx_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	unsigned int umcon = rd_regl(port, S3C2410_UMCON);
+
+	if (mctrl & TIOCM_RTS)
+		umcon |= S3C2410_UMCOM_RTS_LOW;
+	else
+		umcon &= ~S3C2410_UMCOM_RTS_LOW;
+
+	wr_regl(port, S3C2410_UMCON, umcon);
+}
+
+static void s3c24xx_serial_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned long flags;
+	unsigned int ucon;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	ucon = rd_regl(port, S3C2410_UCON);
+
+	if (break_state)
+		ucon |= S3C2410_UCON_SBREAK;
+	else
+		ucon &= ~S3C2410_UCON_SBREAK;
+
+	wr_regl(port, S3C2410_UCON, ucon);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int s3c24xx_serial_request_dma(struct s3c24xx_uart_port *p)
+{
+	struct s3c24xx_uart_dma	*dma = p->dma;
+	struct dma_slave_caps dma_caps;
+	const char *reason = NULL;
+	int ret;
+
+	/* Default slave configuration parameters */
+	dma->rx_conf.direction		= DMA_DEV_TO_MEM;
+	dma->rx_conf.src_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
+	dma->rx_conf.src_addr		= p->port.mapbase + S3C2410_URXH;
+	dma->rx_conf.src_maxburst	= 1;
+
+	dma->tx_conf.direction		= DMA_MEM_TO_DEV;
+	dma->tx_conf.dst_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
+	dma->tx_conf.dst_addr		= p->port.mapbase + S3C2410_UTXH;
+	dma->tx_conf.dst_maxburst	= 1;
+
+	dma->rx_chan = dma_request_chan(p->port.dev, "rx");
+
+	if (IS_ERR(dma->rx_chan)) {
+		reason = "DMA RX channel request failed";
+		ret = PTR_ERR(dma->rx_chan);
+		goto err_warn;
+	}
+
+	ret = dma_get_slave_caps(dma->rx_chan, &dma_caps);
+	if (ret < 0 ||
+	    dma_caps.residue_granularity < DMA_RESIDUE_GRANULARITY_BURST) {
+		reason = "insufficient DMA RX engine capabilities";
+		ret = -EOPNOTSUPP;
+		goto err_release_rx;
+	}
+
+	dmaengine_slave_config(dma->rx_chan, &dma->rx_conf);
+
+	dma->tx_chan = dma_request_chan(p->port.dev, "tx");
+	if (IS_ERR(dma->tx_chan)) {
+		reason = "DMA TX channel request failed";
+		ret = PTR_ERR(dma->tx_chan);
+		goto err_release_rx;
+	}
+
+	ret = dma_get_slave_caps(dma->tx_chan, &dma_caps);
+	if (ret < 0 ||
+	    dma_caps.residue_granularity < DMA_RESIDUE_GRANULARITY_BURST) {
+		reason = "insufficient DMA TX engine capabilities";
+		ret = -EOPNOTSUPP;
+		goto err_release_tx;
+	}
+
+	dmaengine_slave_config(dma->tx_chan, &dma->tx_conf);
+
+	/* RX buffer */
+	dma->rx_size = PAGE_SIZE;
+
+	dma->rx_buf = kmalloc(dma->rx_size, GFP_KERNEL);
+	if (!dma->rx_buf) {
+		ret = -ENOMEM;
+		goto err_release_tx;
+	}
+
+	dma->rx_addr = dma_map_single(p->port.dev, dma->rx_buf,
+				dma->rx_size, DMA_FROM_DEVICE);
+	if (dma_mapping_error(p->port.dev, dma->rx_addr)) {
+		reason = "DMA mapping error for RX buffer";
+		ret = -EIO;
+		goto err_free_rx;
+	}
+
+	/* TX buffer */
+	dma->tx_addr = dma_map_single(p->port.dev, p->port.state->xmit.buf,
+				UART_XMIT_SIZE, DMA_TO_DEVICE);
+	if (dma_mapping_error(p->port.dev, dma->tx_addr)) {
+		reason = "DMA mapping error for TX buffer";
+		ret = -EIO;
+		goto err_unmap_rx;
+	}
+
+	return 0;
+
+err_unmap_rx:
+	dma_unmap_single(p->port.dev, dma->rx_addr, dma->rx_size,
+			 DMA_FROM_DEVICE);
+err_free_rx:
+	kfree(dma->rx_buf);
+err_release_tx:
+	dma_release_channel(dma->tx_chan);
+err_release_rx:
+	dma_release_channel(dma->rx_chan);
+err_warn:
+	if (reason)
+		dev_warn(p->port.dev, "%s, DMA will not be used\n", reason);
+	return ret;
+}
+
+static void s3c24xx_serial_release_dma(struct s3c24xx_uart_port *p)
+{
+	struct s3c24xx_uart_dma	*dma = p->dma;
+
+	if (dma->rx_chan) {
+		dmaengine_terminate_all(dma->rx_chan);
+		dma_unmap_single(p->port.dev, dma->rx_addr,
+				dma->rx_size, DMA_FROM_DEVICE);
+		kfree(dma->rx_buf);
+		dma_release_channel(dma->rx_chan);
+		dma->rx_chan = NULL;
+	}
+
+	if (dma->tx_chan) {
+		dmaengine_terminate_all(dma->tx_chan);
+		dma_unmap_single(p->port.dev, dma->tx_addr,
+				UART_XMIT_SIZE, DMA_TO_DEVICE);
+		dma_release_channel(dma->tx_chan);
+		dma->tx_chan = NULL;
+	}
+}
+
+static void s3c24xx_serial_shutdown(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+
+	if (ourport->tx_claimed) {
+		if (!s3c24xx_serial_has_interrupt_mask(port))
+			free_irq(ourport->tx_irq, ourport);
+		ourport->tx_enabled = 0;
+		ourport->tx_claimed = 0;
+		ourport->tx_mode = 0;
+	}
+
+	if (ourport->rx_claimed) {
+		if (!s3c24xx_serial_has_interrupt_mask(port))
+			free_irq(ourport->rx_irq, ourport);
+		ourport->rx_claimed = 0;
+		ourport->rx_enabled = 0;
+	}
+
+	/* Clear pending interrupts and mask all interrupts */
+	if (s3c24xx_serial_has_interrupt_mask(port)) {
+		free_irq(port->irq, ourport);
+
+		wr_regl(port, S3C64XX_UINTP, 0xf);
+		wr_regl(port, S3C64XX_UINTM, 0xf);
+	}
+
+	if (ourport->dma)
+		s3c24xx_serial_release_dma(ourport);
+
+	ourport->tx_in_progress = 0;
+}
+
+static int s3c24xx_serial_startup(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	int ret;
+
+	ourport->rx_enabled = 1;
+
+	ret = request_irq(ourport->rx_irq, s3c24xx_serial_rx_chars, 0,
+			  s3c24xx_serial_portname(port), ourport);
+
+	if (ret != 0) {
+		dev_err(port->dev, "cannot get irq %d\n", ourport->rx_irq);
+		return ret;
+	}
+
+	ourport->rx_claimed = 1;
+
+	dev_dbg(port->dev, "requesting tx irq...\n");
+
+	ourport->tx_enabled = 1;
+
+	ret = request_irq(ourport->tx_irq, s3c24xx_serial_tx_chars, 0,
+			  s3c24xx_serial_portname(port), ourport);
+
+	if (ret) {
+		dev_err(port->dev, "cannot get irq %d\n", ourport->tx_irq);
+		goto err;
+	}
+
+	ourport->tx_claimed = 1;
+
+	/* the port reset code should have done the correct
+	 * register setup for the port controls
+	 */
+
+	return ret;
+
+err:
+	s3c24xx_serial_shutdown(port);
+	return ret;
+}
+
+static int s3c64xx_serial_startup(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	unsigned long flags;
+	unsigned int ufcon;
+	int ret;
+
+	wr_regl(port, S3C64XX_UINTM, 0xf);
+	if (ourport->dma) {
+		ret = s3c24xx_serial_request_dma(ourport);
+		if (ret < 0) {
+			devm_kfree(port->dev, ourport->dma);
+			ourport->dma = NULL;
+		}
+	}
+
+	ret = request_irq(port->irq, s3c64xx_serial_handle_irq, IRQF_SHARED,
+			  s3c24xx_serial_portname(port), ourport);
+	if (ret) {
+		dev_err(port->dev, "cannot get irq %d\n", port->irq);
+		return ret;
+	}
+
+	/* For compatibility with s3c24xx Soc's */
+	ourport->rx_enabled = 1;
+	ourport->rx_claimed = 1;
+	ourport->tx_enabled = 0;
+	ourport->tx_claimed = 1;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	ufcon = rd_regl(port, S3C2410_UFCON);
+	ufcon |= S3C2410_UFCON_RESETRX | S5PV210_UFCON_RXTRIG8;
+	if (!uart_console(port))
+		ufcon |= S3C2410_UFCON_RESETTX;
+	wr_regl(port, S3C2410_UFCON, ufcon);
+
+	enable_rx_pio(ourport);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	/* Enable Rx Interrupt */
+	s3c24xx_clear_bit(port, S3C64XX_UINTM_RXD, S3C64XX_UINTM);
+
+	return ret;
+}
+
+/* power power management control */
+
+static void s3c24xx_serial_pm(struct uart_port *port, unsigned int level,
+			      unsigned int old)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	int timeout = 10000;
+
+	ourport->pm_level = level;
+
+	switch (level) {
+	case 3:
+		while (--timeout && !s3c24xx_serial_txempty_nofifo(port))
+			udelay(100);
+
+		if (!IS_ERR(ourport->baudclk))
+			clk_disable_unprepare(ourport->baudclk);
+
+		clk_disable_unprepare(ourport->clk);
+		break;
+
+	case 0:
+		clk_prepare_enable(ourport->clk);
+
+		if (!IS_ERR(ourport->baudclk))
+			clk_prepare_enable(ourport->baudclk);
+
+		break;
+	default:
+		dev_err(port->dev, "s3c24xx_serial: unknown pm %d\n", level);
+	}
+}
+
+/* baud rate calculation
+ *
+ * The UARTs on the S3C2410/S3C2440 can take their clocks from a number
+ * of different sources, including the peripheral clock ("pclk") and an
+ * external clock ("uclk"). The S3C2440 also adds the core clock ("fclk")
+ * with a programmable extra divisor.
+ *
+ * The following code goes through the clock sources, and calculates the
+ * baud clocks (and the resultant actual baud rates) and then tries to
+ * pick the closest one and select that.
+ *
+ */
+
+#define MAX_CLK_NAME_LENGTH 15
+
+static inline int s3c24xx_serial_getsource(struct uart_port *port)
+{
+	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	unsigned int ucon;
+
+	if (info->num_clks == 1)
+		return 0;
+
+	ucon = rd_regl(port, S3C2410_UCON);
+	ucon &= info->clksel_mask;
+	return ucon >> info->clksel_shift;
+}
+
+static void s3c24xx_serial_setsource(struct uart_port *port,
+			unsigned int clk_sel)
+{
+	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	unsigned int ucon;
+
+	if (info->num_clks == 1)
+		return;
+
+	ucon = rd_regl(port, S3C2410_UCON);
+	if ((ucon & info->clksel_mask) >> info->clksel_shift == clk_sel)
+		return;
+
+	ucon &= ~info->clksel_mask;
+	ucon |= clk_sel << info->clksel_shift;
+	wr_regl(port, S3C2410_UCON, ucon);
+}
+
+static unsigned int s3c24xx_serial_getclk(struct s3c24xx_uart_port *ourport,
+			unsigned int req_baud, struct clk **best_clk,
+			unsigned int *clk_num)
+{
+	struct s3c24xx_uart_info *info = ourport->info;
+	struct clk *clk;
+	unsigned long rate;
+	unsigned int cnt, baud, quot, clk_sel, best_quot = 0;
+	char clkname[MAX_CLK_NAME_LENGTH];
+	int calc_deviation, deviation = (1 << 30) - 1;
+
+	clk_sel = (ourport->cfg->clk_sel) ? ourport->cfg->clk_sel :
+			ourport->info->def_clk_sel;
+	for (cnt = 0; cnt < info->num_clks; cnt++) {
+		if (!(clk_sel & (1 << cnt)))
+			continue;
+
+		sprintf(clkname, "clk_uart_baud%d", cnt);
+		clk = clk_get(ourport->port.dev, clkname);
+		if (IS_ERR(clk))
+			continue;
+
+		rate = clk_get_rate(clk);
+		if (!rate)
+			continue;
+
+		if (ourport->info->has_divslot) {
+			unsigned long div = rate / req_baud;
+
+			/* The UDIVSLOT register on the newer UARTs allows us to
+			 * get a divisor adjustment of 1/16th on the baud clock.
+			 *
+			 * We don't keep the UDIVSLOT value (the 16ths we
+			 * calculated by not multiplying the baud by 16) as it
+			 * is easy enough to recalculate.
+			 */
+
+			quot = div / 16;
+			baud = rate / div;
+		} else {
+			quot = (rate + (8 * req_baud)) / (16 * req_baud);
+			baud = rate / (quot * 16);
+		}
+		quot--;
+
+		calc_deviation = req_baud - baud;
+		if (calc_deviation < 0)
+			calc_deviation = -calc_deviation;
+
+		if (calc_deviation < deviation) {
+			*best_clk = clk;
+			best_quot = quot;
+			*clk_num = cnt;
+			deviation = calc_deviation;
+		}
+	}
+
+	return best_quot;
+}
+
+/* udivslot_table[]
+ *
+ * This table takes the fractional value of the baud divisor and gives
+ * the recommended setting for the UDIVSLOT register.
+ */
+static u16 udivslot_table[16] = {
+	[0] = 0x0000,
+	[1] = 0x0080,
+	[2] = 0x0808,
+	[3] = 0x0888,
+	[4] = 0x2222,
+	[5] = 0x4924,
+	[6] = 0x4A52,
+	[7] = 0x54AA,
+	[8] = 0x5555,
+	[9] = 0xD555,
+	[10] = 0xD5D5,
+	[11] = 0xDDD5,
+	[12] = 0xDDDD,
+	[13] = 0xDFDD,
+	[14] = 0xDFDF,
+	[15] = 0xFFDF,
+};
+
+static void s3c24xx_serial_set_termios(struct uart_port *port,
+				       struct ktermios *termios,
+				       struct ktermios *old)
+{
+	struct s3c2410_uartcfg *cfg = s3c24xx_port_to_cfg(port);
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct clk *clk = ERR_PTR(-EINVAL);
+	unsigned long flags;
+	unsigned int baud, quot, clk_sel = 0;
+	unsigned int ulcon;
+	unsigned int umcon;
+	unsigned int udivslot = 0;
+
+	/*
+	 * We don't support modem control lines.
+	 */
+	termios->c_cflag &= ~(HUPCL | CMSPAR);
+	termios->c_cflag |= CLOCAL;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+
+	baud = uart_get_baud_rate(port, termios, old, 0, 3000000);
+	quot = s3c24xx_serial_getclk(ourport, baud, &clk, &clk_sel);
+	if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)
+		quot = port->custom_divisor;
+	if (IS_ERR(clk))
+		return;
+
+	/* check to see if we need  to change clock source */
+
+	if (ourport->baudclk != clk) {
+		clk_prepare_enable(clk);
+
+		s3c24xx_serial_setsource(port, clk_sel);
+
+		if (!IS_ERR(ourport->baudclk)) {
+			clk_disable_unprepare(ourport->baudclk);
+			ourport->baudclk = ERR_PTR(-EINVAL);
+		}
+
+		ourport->baudclk = clk;
+		ourport->baudclk_rate = clk ? clk_get_rate(clk) : 0;
+	}
+
+	if (ourport->info->has_divslot) {
+		unsigned int div = ourport->baudclk_rate / baud;
+
+		if (cfg->has_fracval) {
+			udivslot = (div & 15);
+			dev_dbg(port->dev, "fracval = %04x\n", udivslot);
+		} else {
+			udivslot = udivslot_table[div & 15];
+			dev_dbg(port->dev, "udivslot = %04x (div %d)\n",
+				udivslot, div & 15);
+		}
+	}
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		dev_dbg(port->dev, "config: 5bits/char\n");
+		ulcon = S3C2410_LCON_CS5;
+		break;
+	case CS6:
+		dev_dbg(port->dev, "config: 6bits/char\n");
+		ulcon = S3C2410_LCON_CS6;
+		break;
+	case CS7:
+		dev_dbg(port->dev, "config: 7bits/char\n");
+		ulcon = S3C2410_LCON_CS7;
+		break;
+	case CS8:
+	default:
+		dev_dbg(port->dev, "config: 8bits/char\n");
+		ulcon = S3C2410_LCON_CS8;
+		break;
+	}
+
+	/* preserve original lcon IR settings */
+	ulcon |= (cfg->ulcon & S3C2410_LCON_IRM);
+
+	if (termios->c_cflag & CSTOPB)
+		ulcon |= S3C2410_LCON_STOPB;
+
+	if (termios->c_cflag & PARENB) {
+		if (termios->c_cflag & PARODD)
+			ulcon |= S3C2410_LCON_PODD;
+		else
+			ulcon |= S3C2410_LCON_PEVEN;
+	} else {
+		ulcon |= S3C2410_LCON_PNONE;
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	dev_dbg(port->dev,
+		"setting ulcon to %08x, brddiv to %d, udivslot %08x\n",
+		ulcon, quot, udivslot);
+
+	wr_regl(port, S3C2410_ULCON, ulcon);
+	wr_regl(port, S3C2410_UBRDIV, quot);
+
+	port->status &= ~UPSTAT_AUTOCTS;
+
+	umcon = rd_regl(port, S3C2410_UMCON);
+	if (termios->c_cflag & CRTSCTS) {
+		umcon |= S3C2410_UMCOM_AFC;
+		/* Disable RTS when RX FIFO contains 63 bytes */
+		umcon &= ~S3C2412_UMCON_AFC_8;
+		port->status = UPSTAT_AUTOCTS;
+	} else {
+		umcon &= ~S3C2410_UMCOM_AFC;
+	}
+	wr_regl(port, S3C2410_UMCON, umcon);
+
+	if (ourport->info->has_divslot)
+		wr_regl(port, S3C2443_DIVSLOT, udivslot);
+
+	dev_dbg(port->dev,
+		"uart: ulcon = 0x%08x, ucon = 0x%08x, ufcon = 0x%08x\n",
+		rd_regl(port, S3C2410_ULCON),
+		rd_regl(port, S3C2410_UCON),
+		rd_regl(port, S3C2410_UFCON));
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/*
+	 * Which character status flags are we interested in?
+	 */
+	port->read_status_mask = S3C2410_UERSTAT_OVERRUN;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= S3C2410_UERSTAT_FRAME |
+			S3C2410_UERSTAT_PARITY;
+	/*
+	 * Which character status flags should we ignore?
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= S3C2410_UERSTAT_OVERRUN;
+	if (termios->c_iflag & IGNBRK && termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= S3C2410_UERSTAT_FRAME;
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= RXSTAT_DUMMY_READ;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *s3c24xx_serial_type(struct uart_port *port)
+{
+	switch (port->type) {
+	case PORT_S3C2410:
+		return "S3C2410";
+	case PORT_S3C2440:
+		return "S3C2440";
+	case PORT_S3C2412:
+		return "S3C2412";
+	case PORT_S3C6400:
+		return "S3C6400/10";
+	default:
+		return NULL;
+	}
+}
+
+#define MAP_SIZE (0x100)
+
+static void s3c24xx_serial_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, MAP_SIZE);
+}
+
+static int s3c24xx_serial_request_port(struct uart_port *port)
+{
+	const char *name = s3c24xx_serial_portname(port);
+
+	return request_mem_region(port->mapbase, MAP_SIZE, name) ? 0 : -EBUSY;
+}
+
+static void s3c24xx_serial_config_port(struct uart_port *port, int flags)
+{
+	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+
+	if (flags & UART_CONFIG_TYPE &&
+	    s3c24xx_serial_request_port(port) == 0)
+		port->type = info->type;
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int
+s3c24xx_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+
+	if (ser->type != PORT_UNKNOWN && ser->type != info->type)
+		return -EINVAL;
+
+	return 0;
+}
+
+
+#ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE
+
+static struct console s3c24xx_serial_console;
+
+static int __init s3c24xx_serial_console_init(void)
+{
+	register_console(&s3c24xx_serial_console);
+	return 0;
+}
+console_initcall(s3c24xx_serial_console_init);
+
+#define S3C24XX_SERIAL_CONSOLE &s3c24xx_serial_console
+#else
+#define S3C24XX_SERIAL_CONSOLE NULL
+#endif
+
+#if defined(CONFIG_SERIAL_SAMSUNG_CONSOLE) && defined(CONFIG_CONSOLE_POLL)
+static int s3c24xx_serial_get_poll_char(struct uart_port *port);
+static void s3c24xx_serial_put_poll_char(struct uart_port *port,
+			 unsigned char c);
+#endif
+
+static struct uart_ops s3c24xx_serial_ops = {
+	.pm		= s3c24xx_serial_pm,
+	.tx_empty	= s3c24xx_serial_tx_empty,
+	.get_mctrl	= s3c24xx_serial_get_mctrl,
+	.set_mctrl	= s3c24xx_serial_set_mctrl,
+	.stop_tx	= s3c24xx_serial_stop_tx,
+	.start_tx	= s3c24xx_serial_start_tx,
+	.stop_rx	= s3c24xx_serial_stop_rx,
+	.break_ctl	= s3c24xx_serial_break_ctl,
+	.startup	= s3c24xx_serial_startup,
+	.shutdown	= s3c24xx_serial_shutdown,
+	.set_termios	= s3c24xx_serial_set_termios,
+	.type		= s3c24xx_serial_type,
+	.release_port	= s3c24xx_serial_release_port,
+	.request_port	= s3c24xx_serial_request_port,
+	.config_port	= s3c24xx_serial_config_port,
+	.verify_port	= s3c24xx_serial_verify_port,
+#if defined(CONFIG_SERIAL_SAMSUNG_CONSOLE) && defined(CONFIG_CONSOLE_POLL)
+	.poll_get_char = s3c24xx_serial_get_poll_char,
+	.poll_put_char = s3c24xx_serial_put_poll_char,
+#endif
+};
+
+static struct uart_driver s3c24xx_uart_drv = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "s3c2410_serial",
+	.nr		= CONFIG_SERIAL_SAMSUNG_UARTS,
+	.cons		= S3C24XX_SERIAL_CONSOLE,
+	.dev_name	= S3C24XX_SERIAL_NAME,
+	.major		= S3C24XX_SERIAL_MAJOR,
+	.minor		= S3C24XX_SERIAL_MINOR,
+};
+
+#define __PORT_LOCK_UNLOCKED(i) \
+	__SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[i].port.lock)
+static struct s3c24xx_uart_port
+s3c24xx_serial_ports[CONFIG_SERIAL_SAMSUNG_UARTS] = {
+	[0] = {
+		.port = {
+			.lock		= __PORT_LOCK_UNLOCKED(0),
+			.iotype		= UPIO_MEM,
+			.uartclk	= 0,
+			.fifosize	= 16,
+			.ops		= &s3c24xx_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 0,
+		}
+	},
+	[1] = {
+		.port = {
+			.lock		= __PORT_LOCK_UNLOCKED(1),
+			.iotype		= UPIO_MEM,
+			.uartclk	= 0,
+			.fifosize	= 16,
+			.ops		= &s3c24xx_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 1,
+		}
+	},
+#if CONFIG_SERIAL_SAMSUNG_UARTS > 2
+
+	[2] = {
+		.port = {
+			.lock		= __PORT_LOCK_UNLOCKED(2),
+			.iotype		= UPIO_MEM,
+			.uartclk	= 0,
+			.fifosize	= 16,
+			.ops		= &s3c24xx_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 2,
+		}
+	},
+#endif
+#if CONFIG_SERIAL_SAMSUNG_UARTS > 3
+	[3] = {
+		.port = {
+			.lock		= __PORT_LOCK_UNLOCKED(3),
+			.iotype		= UPIO_MEM,
+			.uartclk	= 0,
+			.fifosize	= 16,
+			.ops		= &s3c24xx_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 3,
+		}
+	}
+#endif
+};
+#undef __PORT_LOCK_UNLOCKED
+
+/* s3c24xx_serial_resetport
+ *
+ * reset the fifos and other the settings.
+ */
+
+static void s3c24xx_serial_resetport(struct uart_port *port,
+				   struct s3c2410_uartcfg *cfg)
+{
+	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	unsigned long ucon = rd_regl(port, S3C2410_UCON);
+	unsigned int ucon_mask;
+
+	ucon_mask = info->clksel_mask;
+	if (info->type == PORT_S3C2440)
+		ucon_mask |= S3C2440_UCON0_DIVMASK;
+
+	ucon &= ucon_mask;
+	wr_regl(port, S3C2410_UCON,  ucon | cfg->ucon);
+
+	/* reset both fifos */
+	wr_regl(port, S3C2410_UFCON, cfg->ufcon | S3C2410_UFCON_RESETBOTH);
+	wr_regl(port, S3C2410_UFCON, cfg->ufcon);
+
+	/* some delay is required after fifo reset */
+	udelay(1);
+}
+
+
+#ifdef CONFIG_ARM_S3C24XX_CPUFREQ
+
+static int s3c24xx_serial_cpufreq_transition(struct notifier_block *nb,
+					     unsigned long val, void *data)
+{
+	struct s3c24xx_uart_port *port;
+	struct uart_port *uport;
+
+	port = container_of(nb, struct s3c24xx_uart_port, freq_transition);
+	uport = &port->port;
+
+	/* check to see if port is enabled */
+
+	if (port->pm_level != 0)
+		return 0;
+
+	/* try and work out if the baudrate is changing, we can detect
+	 * a change in rate, but we do not have support for detecting
+	 * a disturbance in the clock-rate over the change.
+	 */
+
+	if (IS_ERR(port->baudclk))
+		goto exit;
+
+	if (port->baudclk_rate == clk_get_rate(port->baudclk))
+		goto exit;
+
+	if (val == CPUFREQ_PRECHANGE) {
+		/* we should really shut the port down whilst the
+		 * frequency change is in progress.
+		 */
+
+	} else if (val == CPUFREQ_POSTCHANGE) {
+		struct ktermios *termios;
+		struct tty_struct *tty;
+
+		if (uport->state == NULL)
+			goto exit;
+
+		tty = uport->state->port.tty;
+
+		if (tty == NULL)
+			goto exit;
+
+		termios = &tty->termios;
+
+		if (termios == NULL) {
+			dev_warn(uport->dev, "%s: no termios?\n", __func__);
+			goto exit;
+		}
+
+		s3c24xx_serial_set_termios(uport, termios, NULL);
+	}
+
+exit:
+	return 0;
+}
+
+static inline int
+s3c24xx_serial_cpufreq_register(struct s3c24xx_uart_port *port)
+{
+	port->freq_transition.notifier_call = s3c24xx_serial_cpufreq_transition;
+
+	return cpufreq_register_notifier(&port->freq_transition,
+					 CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+static inline void
+s3c24xx_serial_cpufreq_deregister(struct s3c24xx_uart_port *port)
+{
+	cpufreq_unregister_notifier(&port->freq_transition,
+				    CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+#else
+static inline int
+s3c24xx_serial_cpufreq_register(struct s3c24xx_uart_port *port)
+{
+	return 0;
+}
+
+static inline void
+s3c24xx_serial_cpufreq_deregister(struct s3c24xx_uart_port *port)
+{
+}
+#endif
+
+static int s3c24xx_serial_enable_baudclk(struct s3c24xx_uart_port *ourport)
+{
+	struct device *dev = ourport->port.dev;
+	struct s3c24xx_uart_info *info = ourport->info;
+	char clk_name[MAX_CLK_NAME_LENGTH];
+	unsigned int clk_sel;
+	struct clk *clk;
+	int clk_num;
+	int ret;
+
+	clk_sel = ourport->cfg->clk_sel ? : info->def_clk_sel;
+	for (clk_num = 0; clk_num < info->num_clks; clk_num++) {
+		if (!(clk_sel & (1 << clk_num)))
+			continue;
+
+		sprintf(clk_name, "clk_uart_baud%d", clk_num);
+		clk = clk_get(dev, clk_name);
+		if (IS_ERR(clk))
+			continue;
+
+		ret = clk_prepare_enable(clk);
+		if (ret) {
+			clk_put(clk);
+			continue;
+		}
+
+		ourport->baudclk = clk;
+		ourport->baudclk_rate = clk_get_rate(clk);
+		s3c24xx_serial_setsource(&ourport->port, clk_num);
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+/* s3c24xx_serial_init_port
+ *
+ * initialise a single serial port from the platform device given
+ */
+
+static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,
+				    struct platform_device *platdev)
+{
+	struct uart_port *port = &ourport->port;
+	struct s3c2410_uartcfg *cfg = ourport->cfg;
+	struct resource *res;
+	int ret;
+
+	if (platdev == NULL)
+		return -ENODEV;
+
+	if (port->mapbase != 0)
+		return -EINVAL;
+
+	/* setup info for port */
+	port->dev	= &platdev->dev;
+
+	/* Startup sequence is different for s3c64xx and higher SoC's */
+	if (s3c24xx_serial_has_interrupt_mask(port))
+		s3c24xx_serial_ops.startup = s3c64xx_serial_startup;
+
+	port->uartclk = 1;
+
+	if (cfg->uart_flags & UPF_CONS_FLOW) {
+		dev_dbg(port->dev, "enabling flow control\n");
+		port->flags |= UPF_CONS_FLOW;
+	}
+
+	/* sort our the physical and virtual addresses for each UART */
+
+	res = platform_get_resource(platdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(port->dev, "failed to find memory resource for uart\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(port->dev, "resource %pR)\n", res);
+
+	port->membase = devm_ioremap(port->dev, res->start, resource_size(res));
+	if (!port->membase) {
+		dev_err(port->dev, "failed to remap controller address\n");
+		return -EBUSY;
+	}
+
+	port->mapbase = res->start;
+	ret = platform_get_irq(platdev, 0);
+	if (ret < 0)
+		port->irq = 0;
+	else {
+		port->irq = ret;
+		ourport->rx_irq = ret;
+		ourport->tx_irq = ret + 1;
+	}
+
+	ret = platform_get_irq(platdev, 1);
+	if (ret > 0)
+		ourport->tx_irq = ret;
+	/*
+	 * DMA is currently supported only on DT platforms, if DMA properties
+	 * are specified.
+	 */
+	if (platdev->dev.of_node && of_find_property(platdev->dev.of_node,
+						     "dmas", NULL)) {
+		ourport->dma = devm_kzalloc(port->dev,
+					    sizeof(*ourport->dma),
+					    GFP_KERNEL);
+		if (!ourport->dma) {
+			ret = -ENOMEM;
+			goto err;
+		}
+	}
+
+	ourport->clk	= clk_get(&platdev->dev, "uart");
+	if (IS_ERR(ourport->clk)) {
+		pr_err("%s: Controller clock not found\n",
+				dev_name(&platdev->dev));
+		ret = PTR_ERR(ourport->clk);
+		goto err;
+	}
+
+	ret = clk_prepare_enable(ourport->clk);
+	if (ret) {
+		pr_err("uart: clock failed to prepare+enable: %d\n", ret);
+		clk_put(ourport->clk);
+		goto err;
+	}
+
+	ret = s3c24xx_serial_enable_baudclk(ourport);
+	if (ret)
+		pr_warn("uart: failed to enable baudclk\n");
+
+	/* Keep all interrupts masked and cleared */
+	if (s3c24xx_serial_has_interrupt_mask(port)) {
+		wr_regl(port, S3C64XX_UINTM, 0xf);
+		wr_regl(port, S3C64XX_UINTP, 0xf);
+		wr_regl(port, S3C64XX_UINTSP, 0xf);
+	}
+
+	dev_dbg(port->dev, "port: map=%pa, mem=%p, irq=%d (%d,%d), clock=%u\n",
+		&port->mapbase, port->membase, port->irq,
+		ourport->rx_irq, ourport->tx_irq, port->uartclk);
+
+	/* reset the fifos (and setup the uart) */
+	s3c24xx_serial_resetport(port, cfg);
+
+	return 0;
+
+err:
+	port->mapbase = 0;
+	return ret;
+}
+
+/* Device driver serial port probe */
+
+#ifdef CONFIG_OF
+static const struct of_device_id s3c24xx_uart_dt_match[];
+#endif
+
+static int probe_index;
+
+static inline struct s3c24xx_serial_drv_data *s3c24xx_get_driver_data(
+			struct platform_device *pdev)
+{
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+
+		match = of_match_node(s3c24xx_uart_dt_match, pdev->dev.of_node);
+		return (struct s3c24xx_serial_drv_data *)match->data;
+	}
+#endif
+	return (struct s3c24xx_serial_drv_data *)
+			platform_get_device_id(pdev)->driver_data;
+}
+
+static int s3c24xx_serial_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct s3c24xx_uart_port *ourport;
+	int index = probe_index;
+	int ret, prop = 0;
+
+	if (np) {
+		ret = of_alias_get_id(np, "serial");
+		if (ret >= 0)
+			index = ret;
+	}
+
+	if (index >= ARRAY_SIZE(s3c24xx_serial_ports)) {
+		dev_err(&pdev->dev, "serial%d out of range\n", index);
+		return -EINVAL;
+	}
+	ourport = &s3c24xx_serial_ports[index];
+
+	ourport->drv_data = s3c24xx_get_driver_data(pdev);
+	if (!ourport->drv_data) {
+		dev_err(&pdev->dev, "could not find driver data\n");
+		return -ENODEV;
+	}
+
+	ourport->baudclk = ERR_PTR(-EINVAL);
+	ourport->info = ourport->drv_data->info;
+	ourport->cfg = (dev_get_platdata(&pdev->dev)) ?
+			dev_get_platdata(&pdev->dev) :
+			ourport->drv_data->def_cfg;
+
+	if (np) {
+		of_property_read_u32(np,
+			"samsung,uart-fifosize", &ourport->port.fifosize);
+
+		if (of_property_read_u32(np, "reg-io-width", &prop) == 0) {
+			switch (prop) {
+			case 1:
+				ourport->port.iotype = UPIO_MEM;
+				break;
+			case 4:
+				ourport->port.iotype = UPIO_MEM32;
+				break;
+			default:
+				dev_warn(&pdev->dev, "unsupported reg-io-width (%d)\n",
+						prop);
+				ret = -EINVAL;
+				break;
+			}
+		}
+	}
+
+	if (ourport->drv_data->fifosize[index])
+		ourport->port.fifosize = ourport->drv_data->fifosize[index];
+	else if (ourport->info->fifosize)
+		ourport->port.fifosize = ourport->info->fifosize;
+
+	/*
+	 * DMA transfers must be aligned at least to cache line size,
+	 * so find minimal transfer size suitable for DMA mode
+	 */
+	ourport->min_dma_size = max_t(int, ourport->port.fifosize,
+				    dma_get_cache_alignment());
+
+	dev_dbg(&pdev->dev, "%s: initialising port %p...\n", __func__, ourport);
+
+	ret = s3c24xx_serial_init_port(ourport, pdev);
+	if (ret < 0)
+		return ret;
+
+	if (!s3c24xx_uart_drv.state) {
+		ret = uart_register_driver(&s3c24xx_uart_drv);
+		if (ret < 0) {
+			pr_err("Failed to register Samsung UART driver\n");
+			return ret;
+		}
+	}
+
+	dev_dbg(&pdev->dev, "%s: adding port\n", __func__);
+	uart_add_one_port(&s3c24xx_uart_drv, &ourport->port);
+	platform_set_drvdata(pdev, &ourport->port);
+
+	/*
+	 * Deactivate the clock enabled in s3c24xx_serial_init_port here,
+	 * so that a potential re-enablement through the pm-callback overlaps
+	 * and keeps the clock enabled in this case.
+	 */
+	clk_disable_unprepare(ourport->clk);
+	if (!IS_ERR(ourport->baudclk))
+		clk_disable_unprepare(ourport->baudclk);
+
+	ret = s3c24xx_serial_cpufreq_register(ourport);
+	if (ret < 0)
+		dev_err(&pdev->dev, "failed to add cpufreq notifier\n");
+
+	probe_index++;
+
+	return 0;
+}
+
+static int s3c24xx_serial_remove(struct platform_device *dev)
+{
+	struct uart_port *port = s3c24xx_dev_to_port(&dev->dev);
+
+	if (port) {
+		s3c24xx_serial_cpufreq_deregister(to_ourport(port));
+		uart_remove_one_port(&s3c24xx_uart_drv, port);
+	}
+
+	uart_unregister_driver(&s3c24xx_uart_drv);
+
+	return 0;
+}
+
+/* UART power management code */
+#ifdef CONFIG_PM_SLEEP
+static int s3c24xx_serial_suspend(struct device *dev)
+{
+	struct uart_port *port = s3c24xx_dev_to_port(dev);
+
+	if (port)
+		uart_suspend_port(&s3c24xx_uart_drv, port);
+
+	return 0;
+}
+
+static int s3c24xx_serial_resume(struct device *dev)
+{
+	struct uart_port *port = s3c24xx_dev_to_port(dev);
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+
+	if (port) {
+		clk_prepare_enable(ourport->clk);
+		if (!IS_ERR(ourport->baudclk))
+			clk_prepare_enable(ourport->baudclk);
+		s3c24xx_serial_resetport(port, s3c24xx_port_to_cfg(port));
+		if (!IS_ERR(ourport->baudclk))
+			clk_disable_unprepare(ourport->baudclk);
+		clk_disable_unprepare(ourport->clk);
+
+		uart_resume_port(&s3c24xx_uart_drv, port);
+	}
+
+	return 0;
+}
+
+static int s3c24xx_serial_resume_noirq(struct device *dev)
+{
+	struct uart_port *port = s3c24xx_dev_to_port(dev);
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+
+	if (port) {
+		/* restore IRQ mask */
+		if (s3c24xx_serial_has_interrupt_mask(port)) {
+			unsigned int uintm = 0xf;
+
+			if (ourport->tx_enabled)
+				uintm &= ~S3C64XX_UINTM_TXD_MSK;
+			if (ourport->rx_enabled)
+				uintm &= ~S3C64XX_UINTM_RXD_MSK;
+			clk_prepare_enable(ourport->clk);
+			if (!IS_ERR(ourport->baudclk))
+				clk_prepare_enable(ourport->baudclk);
+			wr_regl(port, S3C64XX_UINTM, uintm);
+			if (!IS_ERR(ourport->baudclk))
+				clk_disable_unprepare(ourport->baudclk);
+			clk_disable_unprepare(ourport->clk);
+		}
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops s3c24xx_serial_pm_ops = {
+	.suspend = s3c24xx_serial_suspend,
+	.resume = s3c24xx_serial_resume,
+	.resume_noirq = s3c24xx_serial_resume_noirq,
+};
+#define SERIAL_SAMSUNG_PM_OPS	(&s3c24xx_serial_pm_ops)
+
+#else /* !CONFIG_PM_SLEEP */
+
+#define SERIAL_SAMSUNG_PM_OPS	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+/* Console code */
+
+#ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE
+
+static struct uart_port *cons_uart;
+
+static int
+s3c24xx_serial_console_txrdy(struct uart_port *port, unsigned int ufcon)
+{
+	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	unsigned long ufstat, utrstat;
+
+	if (ufcon & S3C2410_UFCON_FIFOMODE) {
+		/* fifo mode - check amount of data in fifo registers... */
+
+		ufstat = rd_regl(port, S3C2410_UFSTAT);
+		return (ufstat & info->tx_fifofull) ? 0 : 1;
+	}
+
+	/* in non-fifo mode, we go and use the tx buffer empty */
+
+	utrstat = rd_regl(port, S3C2410_UTRSTAT);
+	return (utrstat & S3C2410_UTRSTAT_TXE) ? 1 : 0;
+}
+
+static bool
+s3c24xx_port_configured(unsigned int ucon)
+{
+	/* consider the serial port configured if the tx/rx mode set */
+	return (ucon & 0xf) != 0;
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+/*
+ * Console polling routines for writing and reading from the uart while
+ * in an interrupt or debug context.
+ */
+
+static int s3c24xx_serial_get_poll_char(struct uart_port *port)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	unsigned int ufstat;
+
+	ufstat = rd_regl(port, S3C2410_UFSTAT);
+	if (s3c24xx_serial_rx_fifocnt(ourport, ufstat) == 0)
+		return NO_POLL_CHAR;
+
+	return rd_reg(port, S3C2410_URXH);
+}
+
+static void s3c24xx_serial_put_poll_char(struct uart_port *port,
+		unsigned char c)
+{
+	unsigned int ufcon = rd_regl(port, S3C2410_UFCON);
+	unsigned int ucon = rd_regl(port, S3C2410_UCON);
+
+	/* not possible to xmit on unconfigured port */
+	if (!s3c24xx_port_configured(ucon))
+		return;
+
+	while (!s3c24xx_serial_console_txrdy(port, ufcon))
+		cpu_relax();
+	wr_reg(port, S3C2410_UTXH, c);
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
+static void
+s3c24xx_serial_console_putchar(struct uart_port *port, int ch)
+{
+	unsigned int ufcon = rd_regl(port, S3C2410_UFCON);
+
+	while (!s3c24xx_serial_console_txrdy(port, ufcon))
+		cpu_relax();
+	wr_reg(port, S3C2410_UTXH, ch);
+}
+
+static void
+s3c24xx_serial_console_write(struct console *co, const char *s,
+			     unsigned int count)
+{
+	unsigned int ucon = rd_regl(cons_uart, S3C2410_UCON);
+
+	/* not possible to xmit on unconfigured port */
+	if (!s3c24xx_port_configured(ucon))
+		return;
+
+	uart_console_write(cons_uart, s, count, s3c24xx_serial_console_putchar);
+}
+
+static void __init
+s3c24xx_serial_get_options(struct uart_port *port, int *baud,
+			   int *parity, int *bits)
+{
+	struct clk *clk;
+	unsigned int ulcon;
+	unsigned int ucon;
+	unsigned int ubrdiv;
+	unsigned long rate;
+	unsigned int clk_sel;
+	char clk_name[MAX_CLK_NAME_LENGTH];
+
+	ulcon  = rd_regl(port, S3C2410_ULCON);
+	ucon   = rd_regl(port, S3C2410_UCON);
+	ubrdiv = rd_regl(port, S3C2410_UBRDIV);
+
+	if (s3c24xx_port_configured(ucon)) {
+		switch (ulcon & S3C2410_LCON_CSMASK) {
+		case S3C2410_LCON_CS5:
+			*bits = 5;
+			break;
+		case S3C2410_LCON_CS6:
+			*bits = 6;
+			break;
+		case S3C2410_LCON_CS7:
+			*bits = 7;
+			break;
+		case S3C2410_LCON_CS8:
+		default:
+			*bits = 8;
+			break;
+		}
+
+		switch (ulcon & S3C2410_LCON_PMASK) {
+		case S3C2410_LCON_PEVEN:
+			*parity = 'e';
+			break;
+
+		case S3C2410_LCON_PODD:
+			*parity = 'o';
+			break;
+
+		case S3C2410_LCON_PNONE:
+		default:
+			*parity = 'n';
+		}
+
+		/* now calculate the baud rate */
+
+		clk_sel = s3c24xx_serial_getsource(port);
+		sprintf(clk_name, "clk_uart_baud%d", clk_sel);
+
+		clk = clk_get(port->dev, clk_name);
+		if (!IS_ERR(clk))
+			rate = clk_get_rate(clk);
+		else
+			rate = 1;
+
+		*baud = rate / (16 * (ubrdiv + 1));
+		dev_dbg(port->dev, "calculated baud %d\n", *baud);
+	}
+
+}
+
+static int __init
+s3c24xx_serial_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/* is this a valid port */
+
+	if (co->index == -1 || co->index >= CONFIG_SERIAL_SAMSUNG_UARTS)
+		co->index = 0;
+
+	port = &s3c24xx_serial_ports[co->index].port;
+
+	/* is the port configured? */
+
+	if (port->mapbase == 0x0)
+		return -ENODEV;
+
+	cons_uart = port;
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		s3c24xx_serial_get_options(port, &baud, &parity, &bits);
+
+	dev_dbg(port->dev, "baud %d\n", baud);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct console s3c24xx_serial_console = {
+	.name		= S3C24XX_SERIAL_NAME,
+	.device		= uart_console_device,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.write		= s3c24xx_serial_console_write,
+	.setup		= s3c24xx_serial_console_setup,
+	.data		= &s3c24xx_uart_drv,
+};
+#endif /* CONFIG_SERIAL_SAMSUNG_CONSOLE */
+
+#ifdef CONFIG_CPU_S3C2410
+static struct s3c24xx_serial_drv_data s3c2410_serial_drv_data = {
+	.info = &(struct s3c24xx_uart_info) {
+		.name		= "Samsung S3C2410 UART",
+		.type		= PORT_S3C2410,
+		.fifosize	= 16,
+		.rx_fifomask	= S3C2410_UFSTAT_RXMASK,
+		.rx_fifoshift	= S3C2410_UFSTAT_RXSHIFT,
+		.rx_fifofull	= S3C2410_UFSTAT_RXFULL,
+		.tx_fifofull	= S3C2410_UFSTAT_TXFULL,
+		.tx_fifomask	= S3C2410_UFSTAT_TXMASK,
+		.tx_fifoshift	= S3C2410_UFSTAT_TXSHIFT,
+		.def_clk_sel	= S3C2410_UCON_CLKSEL0,
+		.num_clks	= 2,
+		.clksel_mask	= S3C2410_UCON_CLKMASK,
+		.clksel_shift	= S3C2410_UCON_CLKSHIFT,
+	},
+	.def_cfg = &(struct s3c2410_uartcfg) {
+		.ucon		= S3C2410_UCON_DEFAULT,
+		.ufcon		= S3C2410_UFCON_DEFAULT,
+	},
+};
+#define S3C2410_SERIAL_DRV_DATA ((kernel_ulong_t)&s3c2410_serial_drv_data)
+#else
+#define S3C2410_SERIAL_DRV_DATA (kernel_ulong_t)NULL
+#endif
+
+#ifdef CONFIG_CPU_S3C2412
+static struct s3c24xx_serial_drv_data s3c2412_serial_drv_data = {
+	.info = &(struct s3c24xx_uart_info) {
+		.name		= "Samsung S3C2412 UART",
+		.type		= PORT_S3C2412,
+		.fifosize	= 64,
+		.has_divslot	= 1,
+		.rx_fifomask	= S3C2440_UFSTAT_RXMASK,
+		.rx_fifoshift	= S3C2440_UFSTAT_RXSHIFT,
+		.rx_fifofull	= S3C2440_UFSTAT_RXFULL,
+		.tx_fifofull	= S3C2440_UFSTAT_TXFULL,
+		.tx_fifomask	= S3C2440_UFSTAT_TXMASK,
+		.tx_fifoshift	= S3C2440_UFSTAT_TXSHIFT,
+		.def_clk_sel	= S3C2410_UCON_CLKSEL2,
+		.num_clks	= 4,
+		.clksel_mask	= S3C2412_UCON_CLKMASK,
+		.clksel_shift	= S3C2412_UCON_CLKSHIFT,
+	},
+	.def_cfg = &(struct s3c2410_uartcfg) {
+		.ucon		= S3C2410_UCON_DEFAULT,
+		.ufcon		= S3C2410_UFCON_DEFAULT,
+	},
+};
+#define S3C2412_SERIAL_DRV_DATA ((kernel_ulong_t)&s3c2412_serial_drv_data)
+#else
+#define S3C2412_SERIAL_DRV_DATA (kernel_ulong_t)NULL
+#endif
+
+#if defined(CONFIG_CPU_S3C2440) || defined(CONFIG_CPU_S3C2416) || \
+	defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2442)
+static struct s3c24xx_serial_drv_data s3c2440_serial_drv_data = {
+	.info = &(struct s3c24xx_uart_info) {
+		.name		= "Samsung S3C2440 UART",
+		.type		= PORT_S3C2440,
+		.fifosize	= 64,
+		.has_divslot	= 1,
+		.rx_fifomask	= S3C2440_UFSTAT_RXMASK,
+		.rx_fifoshift	= S3C2440_UFSTAT_RXSHIFT,
+		.rx_fifofull	= S3C2440_UFSTAT_RXFULL,
+		.tx_fifofull	= S3C2440_UFSTAT_TXFULL,
+		.tx_fifomask	= S3C2440_UFSTAT_TXMASK,
+		.tx_fifoshift	= S3C2440_UFSTAT_TXSHIFT,
+		.def_clk_sel	= S3C2410_UCON_CLKSEL2,
+		.num_clks	= 4,
+		.clksel_mask	= S3C2412_UCON_CLKMASK,
+		.clksel_shift	= S3C2412_UCON_CLKSHIFT,
+	},
+	.def_cfg = &(struct s3c2410_uartcfg) {
+		.ucon		= S3C2410_UCON_DEFAULT,
+		.ufcon		= S3C2410_UFCON_DEFAULT,
+	},
+};
+#define S3C2440_SERIAL_DRV_DATA ((kernel_ulong_t)&s3c2440_serial_drv_data)
+#else
+#define S3C2440_SERIAL_DRV_DATA (kernel_ulong_t)NULL
+#endif
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+static struct s3c24xx_serial_drv_data s3c6400_serial_drv_data = {
+	.info = &(struct s3c24xx_uart_info) {
+		.name		= "Samsung S3C6400 UART",
+		.type		= PORT_S3C6400,
+		.fifosize	= 64,
+		.has_divslot	= 1,
+		.rx_fifomask	= S3C2440_UFSTAT_RXMASK,
+		.rx_fifoshift	= S3C2440_UFSTAT_RXSHIFT,
+		.rx_fifofull	= S3C2440_UFSTAT_RXFULL,
+		.tx_fifofull	= S3C2440_UFSTAT_TXFULL,
+		.tx_fifomask	= S3C2440_UFSTAT_TXMASK,
+		.tx_fifoshift	= S3C2440_UFSTAT_TXSHIFT,
+		.def_clk_sel	= S3C2410_UCON_CLKSEL2,
+		.num_clks	= 4,
+		.clksel_mask	= S3C6400_UCON_CLKMASK,
+		.clksel_shift	= S3C6400_UCON_CLKSHIFT,
+	},
+	.def_cfg = &(struct s3c2410_uartcfg) {
+		.ucon		= S3C2410_UCON_DEFAULT,
+		.ufcon		= S3C2410_UFCON_DEFAULT,
+	},
+};
+#define S3C6400_SERIAL_DRV_DATA ((kernel_ulong_t)&s3c6400_serial_drv_data)
+#else
+#define S3C6400_SERIAL_DRV_DATA (kernel_ulong_t)NULL
+#endif
+
+#ifdef CONFIG_CPU_S5PV210
+static struct s3c24xx_serial_drv_data s5pv210_serial_drv_data = {
+	.info = &(struct s3c24xx_uart_info) {
+		.name		= "Samsung S5PV210 UART",
+		.type		= PORT_S3C6400,
+		.has_divslot	= 1,
+		.rx_fifomask	= S5PV210_UFSTAT_RXMASK,
+		.rx_fifoshift	= S5PV210_UFSTAT_RXSHIFT,
+		.rx_fifofull	= S5PV210_UFSTAT_RXFULL,
+		.tx_fifofull	= S5PV210_UFSTAT_TXFULL,
+		.tx_fifomask	= S5PV210_UFSTAT_TXMASK,
+		.tx_fifoshift	= S5PV210_UFSTAT_TXSHIFT,
+		.def_clk_sel	= S3C2410_UCON_CLKSEL0,
+		.num_clks	= 2,
+		.clksel_mask	= S5PV210_UCON_CLKMASK,
+		.clksel_shift	= S5PV210_UCON_CLKSHIFT,
+	},
+	.def_cfg = &(struct s3c2410_uartcfg) {
+		.ucon		= S5PV210_UCON_DEFAULT,
+		.ufcon		= S5PV210_UFCON_DEFAULT,
+	},
+	.fifosize = { 256, 64, 16, 16 },
+};
+#define S5PV210_SERIAL_DRV_DATA ((kernel_ulong_t)&s5pv210_serial_drv_data)
+#else
+#define S5PV210_SERIAL_DRV_DATA	(kernel_ulong_t)NULL
+#endif
+
+#if defined(CONFIG_ARCH_EXYNOS)
+#define EXYNOS_COMMON_SERIAL_DRV_DATA				\
+	.info = &(struct s3c24xx_uart_info) {			\
+		.name		= "Samsung Exynos UART",	\
+		.type		= PORT_S3C6400,			\
+		.has_divslot	= 1,				\
+		.rx_fifomask	= S5PV210_UFSTAT_RXMASK,	\
+		.rx_fifoshift	= S5PV210_UFSTAT_RXSHIFT,	\
+		.rx_fifofull	= S5PV210_UFSTAT_RXFULL,	\
+		.tx_fifofull	= S5PV210_UFSTAT_TXFULL,	\
+		.tx_fifomask	= S5PV210_UFSTAT_TXMASK,	\
+		.tx_fifoshift	= S5PV210_UFSTAT_TXSHIFT,	\
+		.def_clk_sel	= S3C2410_UCON_CLKSEL0,		\
+		.num_clks	= 1,				\
+		.clksel_mask	= 0,				\
+		.clksel_shift	= 0,				\
+	},							\
+	.def_cfg = &(struct s3c2410_uartcfg) {			\
+		.ucon		= S5PV210_UCON_DEFAULT,		\
+		.ufcon		= S5PV210_UFCON_DEFAULT,	\
+		.has_fracval	= 1,				\
+	}							\
+
+static struct s3c24xx_serial_drv_data exynos4210_serial_drv_data = {
+	EXYNOS_COMMON_SERIAL_DRV_DATA,
+	.fifosize = { 256, 64, 16, 16 },
+};
+
+static struct s3c24xx_serial_drv_data exynos5433_serial_drv_data = {
+	EXYNOS_COMMON_SERIAL_DRV_DATA,
+	.fifosize = { 64, 256, 16, 256 },
+};
+
+#define EXYNOS4210_SERIAL_DRV_DATA ((kernel_ulong_t)&exynos4210_serial_drv_data)
+#define EXYNOS5433_SERIAL_DRV_DATA ((kernel_ulong_t)&exynos5433_serial_drv_data)
+#else
+#define EXYNOS4210_SERIAL_DRV_DATA (kernel_ulong_t)NULL
+#define EXYNOS5433_SERIAL_DRV_DATA (kernel_ulong_t)NULL
+#endif
+
+static const struct platform_device_id s3c24xx_serial_driver_ids[] = {
+	{
+		.name		= "s3c2410-uart",
+		.driver_data	= S3C2410_SERIAL_DRV_DATA,
+	}, {
+		.name		= "s3c2412-uart",
+		.driver_data	= S3C2412_SERIAL_DRV_DATA,
+	}, {
+		.name		= "s3c2440-uart",
+		.driver_data	= S3C2440_SERIAL_DRV_DATA,
+	}, {
+		.name		= "s3c6400-uart",
+		.driver_data	= S3C6400_SERIAL_DRV_DATA,
+	}, {
+		.name		= "s5pv210-uart",
+		.driver_data	= S5PV210_SERIAL_DRV_DATA,
+	}, {
+		.name		= "exynos4210-uart",
+		.driver_data	= EXYNOS4210_SERIAL_DRV_DATA,
+	}, {
+		.name		= "exynos5433-uart",
+		.driver_data	= EXYNOS5433_SERIAL_DRV_DATA,
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(platform, s3c24xx_serial_driver_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id s3c24xx_uart_dt_match[] = {
+	{ .compatible = "samsung,s3c2410-uart",
+		.data = (void *)S3C2410_SERIAL_DRV_DATA },
+	{ .compatible = "samsung,s3c2412-uart",
+		.data = (void *)S3C2412_SERIAL_DRV_DATA },
+	{ .compatible = "samsung,s3c2440-uart",
+		.data = (void *)S3C2440_SERIAL_DRV_DATA },
+	{ .compatible = "samsung,s3c6400-uart",
+		.data = (void *)S3C6400_SERIAL_DRV_DATA },
+	{ .compatible = "samsung,s5pv210-uart",
+		.data = (void *)S5PV210_SERIAL_DRV_DATA },
+	{ .compatible = "samsung,exynos4210-uart",
+		.data = (void *)EXYNOS4210_SERIAL_DRV_DATA },
+	{ .compatible = "samsung,exynos5433-uart",
+		.data = (void *)EXYNOS5433_SERIAL_DRV_DATA },
+	{},
+};
+MODULE_DEVICE_TABLE(of, s3c24xx_uart_dt_match);
+#endif
+
+static struct platform_driver samsung_serial_driver = {
+	.probe		= s3c24xx_serial_probe,
+	.remove		= s3c24xx_serial_remove,
+	.id_table	= s3c24xx_serial_driver_ids,
+	.driver		= {
+		.name	= "samsung-uart",
+		.pm	= SERIAL_SAMSUNG_PM_OPS,
+		.of_match_table	= of_match_ptr(s3c24xx_uart_dt_match),
+	},
+};
+
+module_platform_driver(samsung_serial_driver);
+
+#ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE
+/*
+ * Early console.
+ */
+
+static void wr_reg_barrier(struct uart_port *port, u32 reg, u32 val)
+{
+	switch (port->iotype) {
+	case UPIO_MEM:
+		writeb(val, portaddr(port, reg));
+		break;
+	case UPIO_MEM32:
+		writel(val, portaddr(port, reg));
+		break;
+	}
+}
+
+struct samsung_early_console_data {
+	u32 txfull_mask;
+};
+
+static void samsung_early_busyuart(struct uart_port *port)
+{
+	while (!(readl(port->membase + S3C2410_UTRSTAT) & S3C2410_UTRSTAT_TXFE))
+		;
+}
+
+static void samsung_early_busyuart_fifo(struct uart_port *port)
+{
+	struct samsung_early_console_data *data = port->private_data;
+
+	while (readl(port->membase + S3C2410_UFSTAT) & data->txfull_mask)
+		;
+}
+
+static void samsung_early_putc(struct uart_port *port, int c)
+{
+	if (readl(port->membase + S3C2410_UFCON) & S3C2410_UFCON_FIFOMODE)
+		samsung_early_busyuart_fifo(port);
+	else
+		samsung_early_busyuart(port);
+
+	wr_reg_barrier(port, S3C2410_UTXH, c);
+}
+
+static void samsung_early_write(struct console *con, const char *s,
+				unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+
+	uart_console_write(&dev->port, s, n, samsung_early_putc);
+}
+
+static int __init samsung_early_console_setup(struct earlycon_device *device,
+					      const char *opt)
+{
+	if (!device->port.membase)
+		return -ENODEV;
+
+	device->con->write = samsung_early_write;
+	return 0;
+}
+
+/* S3C2410 */
+static struct samsung_early_console_data s3c2410_early_console_data = {
+	.txfull_mask = S3C2410_UFSTAT_TXFULL,
+};
+
+static int __init s3c2410_early_console_setup(struct earlycon_device *device,
+					      const char *opt)
+{
+	device->port.private_data = &s3c2410_early_console_data;
+	return samsung_early_console_setup(device, opt);
+}
+OF_EARLYCON_DECLARE(s3c2410, "samsung,s3c2410-uart",
+			s3c2410_early_console_setup);
+
+/* S3C2412, S3C2440, S3C64xx */
+static struct samsung_early_console_data s3c2440_early_console_data = {
+	.txfull_mask = S3C2440_UFSTAT_TXFULL,
+};
+
+static int __init s3c2440_early_console_setup(struct earlycon_device *device,
+					      const char *opt)
+{
+	device->port.private_data = &s3c2440_early_console_data;
+	return samsung_early_console_setup(device, opt);
+}
+OF_EARLYCON_DECLARE(s3c2412, "samsung,s3c2412-uart",
+			s3c2440_early_console_setup);
+OF_EARLYCON_DECLARE(s3c2440, "samsung,s3c2440-uart",
+			s3c2440_early_console_setup);
+OF_EARLYCON_DECLARE(s3c6400, "samsung,s3c6400-uart",
+			s3c2440_early_console_setup);
+
+/* S5PV210, EXYNOS */
+static struct samsung_early_console_data s5pv210_early_console_data = {
+	.txfull_mask = S5PV210_UFSTAT_TXFULL,
+};
+
+static int __init s5pv210_early_console_setup(struct earlycon_device *device,
+					      const char *opt)
+{
+	device->port.private_data = &s5pv210_early_console_data;
+	return samsung_early_console_setup(device, opt);
+}
+OF_EARLYCON_DECLARE(s5pv210, "samsung,s5pv210-uart",
+			s5pv210_early_console_setup);
+OF_EARLYCON_DECLARE(exynos4210, "samsung,exynos4210-uart",
+			s5pv210_early_console_setup);
+#endif
+
+MODULE_ALIAS("platform:samsung-uart");
+MODULE_DESCRIPTION("Samsung SoC Serial port driver");
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 7c2782785..7b87c08f5 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -2603,6 +2603,7 @@ struct tty_driver *uart_console_device(struct console *co, int *index)
 	*index = co->index;
 	return p->tty_driver;
 }
+EXPORT_SYMBOL_GPL(uart_console_device);
 
 static ssize_t uart_get_attr_uartclk(struct device *dev,
 	struct device_attribute *attr, char *buf)
diff --git a/drivers/tty/serial/sprd_serial.c b/drivers/tty/serial/sprd_serial.c
index 07573de70..685041d14 100644
--- a/drivers/tty/serial/sprd_serial.c
+++ b/drivers/tty/serial/sprd_serial.c
@@ -922,6 +922,34 @@ static void sprd_pm(struct uart_port *port, unsigned int state,
 	}
 }
 
+#ifdef CONFIG_CONSOLE_POLL
+static int sprd_poll_init(struct uart_port *port)
+{
+	if (port->state->pm_state != UART_PM_STATE_ON) {
+		sprd_pm(port, UART_PM_STATE_ON, 0);
+		port->state->pm_state = UART_PM_STATE_ON;
+	}
+
+	return 0;
+}
+
+static int sprd_poll_get_char(struct uart_port *port)
+{
+	while (!(serial_in(port, SPRD_STS1) & SPRD_RX_FIFO_CNT_MASK))
+		cpu_relax();
+
+	return serial_in(port, SPRD_RXD);
+}
+
+static void sprd_poll_put_char(struct uart_port *port, unsigned char ch)
+{
+	while (serial_in(port, SPRD_STS1) & SPRD_TX_FIFO_CNT_MASK)
+		cpu_relax();
+
+	serial_out(port, SPRD_TXD, ch);
+}
+#endif
+
 static const struct uart_ops serial_sprd_ops = {
 	.tx_empty = sprd_tx_empty,
 	.get_mctrl = sprd_get_mctrl,
@@ -939,6 +967,11 @@ static const struct uart_ops serial_sprd_ops = {
 	.config_port = sprd_config_port,
 	.verify_port = sprd_verify_port,
 	.pm = sprd_pm,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_init	= sprd_poll_init,
+	.poll_get_char	= sprd_poll_get_char,
+	.poll_put_char	= sprd_poll_put_char,
+#endif
 };
 
 #ifdef CONFIG_SERIAL_SPRD_CONSOLE
diff --git a/drivers/tty/serial/sunxi-uart.c b/drivers/tty/serial/sunxi-uart.c
new file mode 100644
index 000000000..d3eba12a3
--- /dev/null
+++ b/drivers/tty/serial/sunxi-uart.c
@@ -0,0 +1,2280 @@
+/*
+ * drivers/tty/serial/sunxi-uart.c
+ * (C) Copyright 2007-2013
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * Aaron.Maoye <leafy.myeh@reuuimllatech.com>
+ *
+ * Driver of Allwinner UART controller.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * 2013.6.6 Mintow <duanmintao@allwinnertech.com>
+ *    Adapt to support sun8i/sun9i of Allwinner.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/consumer.h>
+
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clk/sunxi.h>
+
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include "sunxi-uart.h"
+
+#if defined(CONFIG_SERIAL_SUNXI_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+
+/* #define CONFIG_SW_UART_DUMP_DATA */
+/*
+ * ********************* Note **********************
+ * CONFIG_SW_UART_DUMP_DATA may cause some problems
+ * with some commands of 'dmesg', 'logcat', and
+ * 'cat /proc/kmsg' in the console. This problem may
+ * cause kernel to dead. These commands will work fine
+ * in the adb shell. So you must be very clear with
+ * this problem if you want define this macro to debug.
+ */
+
+/* debug control */
+#define SERIAL_DBG(fmt, arg...)	\
+			do { \
+				if (sw_uport->port.line != 0) \
+					pr_debug("%s()%d - "fmt, __func__, __LINE__, ##arg); \
+			} while (0)
+#define SERIAL_MSG(fmt, arg...)	pr_warn("%s()%d - "fmt, __func__, __LINE__, ##arg)
+
+#define TX_DMA		1
+#define RX_DMA		2
+#define DMA_SERIAL_BUFFER_SIZE	(PAGE_SIZE)
+#define DMA_TX_TRRIGE_LEVEL   (SUNXI_UART_FIFO_SIZE/2)
+#define SERIAL_CIRC_CNT_TO_END(xmit) \
+	CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE)
+
+enum uart_time_use {
+	UART_NO_USE_TIMER = 0,
+	UART_USE_TIMER,
+};
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+static void sw_uart_stop_dma_tx(struct sw_uart_port *sw_uport);
+static void sw_uart_release_dma_tx(struct sw_uart_port *sw_uport);
+static int sw_uart_init_dma_tx(struct sw_uart_port *sw_uport);
+static void dma_tx_callback(void *data);
+static int sw_uart_start_dma_tx(struct sw_uart_port *sw_uport);
+static void sw_uart_stop_dma_tx(struct sw_uart_port *sw_uport);
+static void sw_uart_release_dma_rx(struct sw_uart_port *sw_uport);
+static int sw_uart_init_dma_rx(struct sw_uart_port *sw_uport);
+static int sw_uart_start_dma_rx(struct sw_uart_port *sw_uport);
+static void sw_uart_update_rb_addr(struct sw_uart_port *sw_uport);
+static enum hrtimer_restart  sw_uart_report_dma_rx(struct hrtimer *rx_hrtimer);
+#endif
+
+#if IS_ENABLED(CONFIG_SW_UART_DUMP_DATA)
+static void sw_uart_dump_data(struct sw_uart_port *sw_uport, char *prompt)
+{
+	int i, j;
+	int head = 0;
+	char *buf = sw_uport->dump_buff;
+	u32 len = sw_uport->dump_len;
+	static char pbuff[128];
+	u32 idx = 0;
+
+	BUG_ON(sw_uport->dump_len > MAX_DUMP_SIZE);
+	BUG_ON(!sw_uport->dump_buff);
+	#define MAX_DUMP_PER_LINE	(16)
+	#define MAX_DUMP_PER_LINE_HALF	(MAX_DUMP_PER_LINE >> 1)
+	printk(KERN_DEBUG "%s len %d\n", prompt, len);
+	for (i = 0; i < len;) {
+		if ((i & (MAX_DUMP_PER_LINE-1)) == 0) {
+			idx += sprintf(&pbuff[idx], "%04x: ", i);
+			head = i;
+		}
+		idx += sprintf(&pbuff[idx], "%02x ", buf[i]&0xff);
+		if ((i & (MAX_DUMP_PER_LINE-1)) == MAX_DUMP_PER_LINE-1 || i == len-1) {
+			for (j = i-head+1; j < MAX_DUMP_PER_LINE; j++)
+				idx += sprintf(&pbuff[idx], "   ");
+			idx += sprintf(&pbuff[idx], " |");
+			for (j = head; j <= i; j++) {
+				if (isascii(buf[j]) && isprint(buf[j]))
+					idx += sprintf(&pbuff[idx], "%c", buf[j]);
+				else
+					idx += sprintf(&pbuff[idx], ".");
+			}
+			idx += sprintf(&pbuff[idx], "|\n");
+			pbuff[idx] = '\0';
+			printk(KERN_DEBUG "%s", pbuff);
+			idx = 0;
+		}
+		i++;
+	}
+	sw_uport->dump_len = 0;
+}
+#define SERIAL_DUMP(up, ...) do { \
+				if (DEBUG_CONDITION) \
+					sw_uart_dump_data(up, __VA_ARGS__); \
+			} while (0)
+#else
+#define SERIAL_DUMP(up, ...)	{ up->dump_len = 0; }
+#endif
+
+#define UART_TO_SPORT(port)	((struct sw_uart_port *)port)
+
+static inline unsigned char serial_in(struct uart_port *port, int offs)
+{
+	return readb_relaxed(port->membase + offs);
+}
+
+static inline void serial_out(struct uart_port *port, unsigned char value, int offs)
+{
+	writeb_relaxed(value, port->membase + offs);
+}
+
+static inline bool sw_is_console_port(struct uart_port *port)
+{
+	return port->cons && port->cons->index == port->line;
+}
+
+static inline void sw_uart_reset(struct sw_uart_port *sw_uport)
+{
+#if IS_ENABLED(CONFIG_EVB_PLATFORM)
+	int ret;
+	ret = reset_control_assert(sw_uport->reset);
+	ret = reset_control_deassert(sw_uport->reset);
+#endif
+}
+
+static inline void sw_uart_enable_ier_thri(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	if (!(sw_uport->ier & SUNXI_UART_IER_THRI)) {
+		sw_uport->ier |= SUNXI_UART_IER_THRI;
+		SERIAL_DBG("start tx, ier %x\n", sw_uport->ier);
+		serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	}
+}
+
+static inline void sw_uart_disable_ier_thri(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	if (sw_uport->ier & SUNXI_UART_IER_THRI) {
+		sw_uport->ier &= ~SUNXI_UART_IER_THRI;
+		SERIAL_DBG("stop tx, ier %x\n", sw_uport->ier);
+		serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	}
+}
+
+static unsigned int sw_uart_handle_rx(struct sw_uart_port *sw_uport, unsigned int lsr)
+{
+	unsigned char ch = 0;
+	int max_count = 256;
+	char flag;
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	if ((sw_uport->dma->use_dma & RX_DMA)) {
+		if (lsr & SUNXI_UART_LSR_RXFIFOE) {
+			dev_info(sw_uport->port.dev, "error:lsr=0x%x\n", lsr);
+			lsr = serial_in(&sw_uport->port, SUNXI_UART_LSR);
+			return lsr;
+		}
+	}
+#endif
+	do {
+		if (likely(lsr & SUNXI_UART_LSR_DR)) {
+			ch = serial_in(&sw_uport->port, SUNXI_UART_RBR);
+#if IS_ENABLED(CONFIG_SW_UART_DUMP_DATA)
+			sw_uport->dump_buff[sw_uport->dump_len++] = ch;
+#endif
+		} else
+			ch = 0;
+
+		flag = TTY_NORMAL;
+		sw_uport->port.icount.rx++;
+
+		if (unlikely(lsr & SUNXI_UART_LSR_BRK_ERROR_BITS)) {
+			/*
+			 * For statistics only
+			 */
+			if (lsr & SUNXI_UART_LSR_BI) {
+				lsr &= ~(SUNXI_UART_LSR_FE | SUNXI_UART_LSR_PE);
+				sw_uport->port.icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (!ch && uart_handle_break(&sw_uport->port))
+					goto ignore_char;
+			} else if (lsr & SUNXI_UART_LSR_PE)
+				sw_uport->port.icount.parity++;
+			else if (lsr & SUNXI_UART_LSR_FE)
+				sw_uport->port.icount.frame++;
+			if (lsr & SUNXI_UART_LSR_OE)
+				sw_uport->port.icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+			lsr &= sw_uport->port.read_status_mask;
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_CONSOLE)
+			if (sw_is_console_port(&sw_uport->port)) {
+				/* Recover the break flag from console xmit */
+				lsr |= sw_uport->lsr_break_flag;
+			}
+#endif
+			if (lsr & SUNXI_UART_LSR_BI)
+				flag = TTY_BREAK;
+			else if (lsr & SUNXI_UART_LSR_PE)
+				flag = TTY_PARITY;
+			else if (lsr & SUNXI_UART_LSR_FE)
+				flag = TTY_FRAME;
+		}
+		if (uart_handle_sysrq_char(&sw_uport->port, ch))
+			goto ignore_char;
+		uart_insert_char(&sw_uport->port, lsr, SUNXI_UART_LSR_OE, ch, flag);
+ignore_char:
+		lsr = serial_in(&sw_uport->port, SUNXI_UART_LSR);
+	} while ((lsr & (SUNXI_UART_LSR_DR | SUNXI_UART_LSR_BI)) && (max_count-- > 0));
+
+	SERIAL_DUMP(sw_uport, "Rx");
+	spin_unlock(&sw_uport->port.lock);
+	tty_flip_buffer_push(&sw_uport->port.state->port);
+	spin_lock(&sw_uport->port.lock);
+
+	return lsr;
+}
+
+static void sw_uart_stop_tx(struct uart_port *port)
+{
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+
+	if (uart_dma->use_dma & TX_DMA)
+		sw_uart_stop_dma_tx(sw_uport);
+#endif
+	sw_uart_disable_ier_thri(port);
+}
+
+static void sw_uart_start_tx(struct uart_port *port)
+{
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	if (!((sw_uport->dma->use_dma & TX_DMA) && sw_uport->dma->tx_dma_used))
+#endif
+		sw_uart_enable_ier_thri(port);
+}
+
+static void sw_uart_handle_tx(struct sw_uart_port *sw_uport)
+{
+	struct circ_buf *xmit = &sw_uport->port.state->xmit;
+	int count;
+
+	if (sw_uport->port.x_char) {
+		serial_out(&sw_uport->port, sw_uport->port.x_char, SUNXI_UART_THR);
+		sw_uport->port.icount.tx++;
+		sw_uport->port.x_char = 0;
+#if IS_ENABLED(CONFIG_SW_UART_DUMP_DATA)
+		sw_uport->dump_buff[sw_uport->dump_len++] = sw_uport->port.x_char;
+		SERIAL_DUMP(sw_uport, "Tx");
+#endif
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&sw_uport->port)) {
+		sw_uart_stop_tx(&sw_uport->port);
+		return;
+	}
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	if (sw_uport->dma->use_dma & TX_DMA) {
+		if (SERIAL_CIRC_CNT_TO_END(xmit) >= DMA_TX_TRRIGE_LEVEL) {
+			sw_uart_start_dma_tx(sw_uport);
+			return;
+		}
+	}
+#endif
+
+	count = sw_uport->port.fifosize / 2;
+	do {
+#if IS_ENABLED(CONFIG_SW_UART_DUMP_DATA)
+		sw_uport->dump_buff[sw_uport->dump_len++] = xmit->buf[xmit->tail];
+#endif
+		serial_out(&sw_uport->port, xmit->buf[xmit->tail], SUNXI_UART_THR);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		sw_uport->port.icount.tx++;
+		if (uart_circ_empty(xmit)) {
+			break;
+		}
+	} while (--count > 0);
+
+	SERIAL_DUMP(sw_uport, "Tx");
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		spin_unlock(&sw_uport->port.lock);
+		uart_write_wakeup(&sw_uport->port);
+		spin_lock(&sw_uport->port.lock);
+	}
+	if (uart_circ_empty(xmit))
+		sw_uart_stop_tx(&sw_uport->port);
+}
+
+static unsigned int sw_uart_modem_status(struct sw_uart_port *sw_uport)
+{
+	unsigned int status = serial_in(&sw_uport->port, SUNXI_UART_MSR);
+
+	status |= sw_uport->msr_saved_flags;
+	sw_uport->msr_saved_flags = 0;
+
+	if (status & SUNXI_UART_MSR_ANY_DELTA && sw_uport->ier & SUNXI_UART_IER_MSI &&
+	    sw_uport->port.state != NULL) {
+		if (status & SUNXI_UART_MSR_TERI)
+			sw_uport->port.icount.rng++;
+		if (status & SUNXI_UART_MSR_DDSR)
+			sw_uport->port.icount.dsr++;
+		if (status & SUNXI_UART_MSR_DDCD)
+			uart_handle_dcd_change(&sw_uport->port, status & SUNXI_UART_MSR_DCD);
+		if (!(sw_uport->mcr & SUNXI_UART_MCR_AFE) && status & SUNXI_UART_MSR_DCTS)
+			uart_handle_cts_change(&sw_uport->port, status & SUNXI_UART_MSR_CTS);
+
+		wake_up_interruptible(&sw_uport->port.state->port.delta_msr_wait);
+	}
+
+	SERIAL_DBG("modem status: %x\n", status);
+	return status;
+}
+
+static void sw_uart_force_lcr(struct sw_uart_port *sw_uport, unsigned msecs)
+{
+	unsigned long expire = jiffies + msecs_to_jiffies(msecs);
+	struct uart_port *port = &sw_uport->port;
+
+	/* hold tx so that uart will update lcr and baud in the gap of rx */
+	serial_out(port, SUNXI_UART_HALT_HTX|SUNXI_UART_HALT_FORCECFG, SUNXI_UART_HALT);
+	serial_out(port, sw_uport->lcr|SUNXI_UART_LCR_DLAB, SUNXI_UART_LCR);
+	serial_out(port, sw_uport->dll, SUNXI_UART_DLL);
+	serial_out(port, sw_uport->dlh, SUNXI_UART_DLH);
+	serial_out(port, SUNXI_UART_HALT_HTX|SUNXI_UART_HALT_FORCECFG|SUNXI_UART_HALT_LCRUP, SUNXI_UART_HALT);
+	while (time_before(jiffies, expire) && (serial_in(port, SUNXI_UART_HALT) & SUNXI_UART_HALT_LCRUP))
+		;
+
+	/*
+	 * In fact there are two DLABs(DLAB and DLAB_BAK) in the hardware implementation.
+	 * The DLAB_BAK is sellected only when SW_UART_HALT_FORCECFG is set to 1,
+	 * and this bit can be access no matter uart is busy or not.
+	 * So we select the DLAB_BAK always by leaving SW_UART_HALT_FORCECFG to be 1.
+	 */
+	serial_out(port, sw_uport->lcr, SUNXI_UART_LCR);
+	serial_out(port, SUNXI_UART_HALT_FORCECFG, SUNXI_UART_HALT);
+}
+
+static void sw_uart_force_idle(struct sw_uart_port *sw_uport)
+{
+	struct uart_port *port = &sw_uport->port;
+
+	if (sw_uport->fcr & SUNXI_UART_FCR_FIFO_EN) {
+		serial_out(port, SUNXI_UART_FCR_FIFO_EN, SUNXI_UART_FCR);
+		serial_out(port, SUNXI_UART_FCR_TXFIFO_RST
+				| SUNXI_UART_FCR_RXFIFO_RST
+				| SUNXI_UART_FCR_FIFO_EN, SUNXI_UART_FCR);
+		serial_out(port, 0, SUNXI_UART_FCR);
+	}
+
+	serial_out(port, sw_uport->fcr, SUNXI_UART_FCR);
+	(void)serial_in(port, SUNXI_UART_FCR);
+}
+
+/*
+ * We should clear busy interupt, busy state and reset lcr,
+ * but we should be careful not to introduce a new busy interrupt.
+ */
+static void sw_uart_handle_busy(struct sw_uart_port *sw_uport)
+{
+	struct uart_port *port = &sw_uport->port;
+
+	(void)serial_in(port, SUNXI_UART_USR);
+
+	/*
+	 * Before reseting lcr, we should ensure than uart is not in busy
+	 * state. Otherwise, a new busy interrupt will be introduced.
+	 * It is wise to set uart into loopback mode, since it can cut down the
+	 * serial in, then we should reset fifo(in my test, busy state
+	 * (SUNXI_UART_USR_BUSY) can't be cleard until the fifo is empty).
+	 */
+	serial_out(port, sw_uport->mcr | SUNXI_UART_MCR_LOOP, SUNXI_UART_MCR);
+	sw_uart_force_idle(sw_uport);
+	serial_out(port, sw_uport->lcr, SUNXI_UART_LCR);
+	serial_out(port, sw_uport->mcr, SUNXI_UART_MCR);
+}
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+static void sw_uart_stop_dma_tx(struct sw_uart_port *sw_uport)
+{
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+
+	if (uart_dma && uart_dma->tx_dma_used) {
+		dmaengine_terminate_all(uart_dma->dma_chan_tx);
+		uart_dma->tx_dma_used = 0;
+	}
+}
+
+static void sw_uart_release_dma_tx(struct sw_uart_port *sw_uport)
+{
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+
+	if (uart_dma && uart_dma->tx_dma_inited) {
+		sw_uart_stop_dma_tx(sw_uport);
+		dma_free_coherent(sw_uport->port.dev, sw_uport->dma->tb_size,
+			sw_uport->dma->tx_buffer, sw_uport->dma->tx_phy_addr);
+		sw_uport->port.state->xmit.buf = NULL;
+		dma_release_channel(uart_dma->dma_chan_tx);
+		uart_dma->dma_chan_tx = NULL;
+		uart_dma->tx_dma_inited = 0;
+	}
+}
+
+static int sw_uart_init_dma_tx(struct sw_uart_port *sw_uport)
+{
+	struct dma_slave_config slave_config;
+	struct uart_port *port = &sw_uport->port;
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+	int ret;
+
+	if (!uart_dma) {
+		dev_info(sw_uport->port.dev, "sw_uart_init_dma_tx fail\n");
+		return -1;
+	}
+
+	if (uart_dma->tx_dma_inited)
+		return 0;
+
+	uart_dma->dma_chan_tx = dma_request_chan(sw_uport->port.dev, "tx");
+	if (!uart_dma->dma_chan_tx) {
+		dev_err(port->dev, "cannot get the TX DMA channel!\n");
+		ret = -EINVAL;
+	}
+
+	slave_config.direction = DMA_MEM_TO_DEV;
+	slave_config.dst_addr = port->mapbase + SUNXI_UART_THR;
+	slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	slave_config.src_maxburst = 1;
+	slave_config.dst_maxburst = 1;
+	ret = dmaengine_slave_config(uart_dma->dma_chan_tx, &slave_config);
+	if (ret) {
+		dev_err(port->dev, "error in TX dma configuration.");
+		return ret;
+	}
+
+	uart_dma->tx_dma_inited = 1;
+	dev_info(port->dev, "sw_uart_init_dma_tx sucess\n");
+	return 0;
+}
+
+static void dma_tx_callback(void *data)
+{
+	struct uart_port *port = data;
+	struct sw_uart_port *sw_uport = container_of(port,
+						struct sw_uart_port, port);
+	struct circ_buf *xmit = &port->state->xmit;
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+	struct scatterlist *sgl = &uart_dma->tx_sgl;
+
+	dma_unmap_sg(sw_uport->port.dev, sgl, 1, DMA_TO_DEVICE);
+
+	xmit->tail = (xmit->tail + uart_dma->tx_bytes) & (UART_XMIT_SIZE - 1);
+	port->icount.tx += uart_dma->tx_bytes;
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	uart_dma->tx_dma_used = 0;
+	sw_uart_enable_ier_thri(port);
+}
+
+static int sw_uart_start_dma_tx(struct sw_uart_port *sw_uport)
+{
+	int count = 0;
+	struct uart_port *port = &sw_uport->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+	struct scatterlist *sgl = &uart_dma->tx_sgl;
+	struct dma_async_tx_descriptor *desc;
+	int ret;
+
+	if (!uart_dma->use_dma)
+		goto err_out;
+
+	if (-1 == sw_uart_init_dma_tx(sw_uport))
+		goto err_out;
+
+	if (1 == uart_dma->tx_dma_used)
+		return 1;
+
+	/**********************************/
+	/* mask the stop now */
+	sw_uart_disable_ier_thri(port);
+
+	count = SERIAL_CIRC_CNT_TO_END(xmit);
+	count -= count%16;
+	if (count >= DMA_TX_TRRIGE_LEVEL) {
+		uart_dma->tx_bytes = count;
+		sg_init_one(sgl, phys_to_virt(uart_dma->tx_phy_addr) + xmit->tail, count);
+		ret = dma_map_sg(port->dev, sgl, 1, DMA_TO_DEVICE);
+
+		if (ret == 0) {
+			dev_err(port->dev, "DMA mapping error for TX.\n");
+			return -1;
+		}
+		desc = dmaengine_prep_slave_sg(uart_dma->dma_chan_tx, sgl, 1,
+			DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);
+
+		if (!desc) {
+			dev_err(port->dev, "We cannot prepare for the TX slave dma!\n");
+			return -1;
+		}
+		desc->callback = dma_tx_callback;
+		desc->callback_param = port;
+		dmaengine_submit(desc);
+		dma_async_issue_pending(uart_dma->dma_chan_tx);
+		uart_dma->tx_dma_used = 1;
+	}
+	return 1;
+err_out:
+	dev_info(sw_uport->port.dev, "-sw_uart_start_dma_tx-error-\n");
+	return -1;
+}
+
+static void sw_uart_stop_dma_rx(struct sw_uart_port *sw_uport)
+{
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+
+	if (uart_dma && uart_dma->rx_dma_used) {
+		hrtimer_cancel(&sw_uport->rx_hrtimer);
+		dmaengine_terminate_all(uart_dma->dma_chan_rx);
+		uart_dma->rb_tail = 0;
+		uart_dma->rx_dma_used = 0;
+	}
+}
+
+static void sw_uart_release_dma_rx(struct sw_uart_port *sw_uport)
+{
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+
+	if (uart_dma && uart_dma->rx_dma_inited) {
+		sw_uart_stop_dma_rx(sw_uport);
+		dma_free_coherent(sw_uport->port.dev, sw_uport->dma->rb_size,
+			sw_uport->dma->rx_buffer, sw_uport->dma->rx_phy_addr);
+		dma_release_channel(uart_dma->dma_chan_rx);
+		uart_dma->dma_chan_rx = NULL;
+		uart_dma->rx_dma_inited = 0;
+	}
+}
+
+static int sw_uart_init_dma_rx(struct sw_uart_port *sw_uport)
+{
+	int ret;
+	struct uart_port *port = &sw_uport->port;
+	struct dma_slave_config slave_config;
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+
+	if (!uart_dma) {
+		dev_info(port->dev, "sw_uart_init_dma_rx: port fail\n");
+		return -1;
+	}
+
+	if (uart_dma->rx_dma_inited)
+		return 0;
+
+	uart_dma->dma_chan_tx = dma_request_chan(sw_uport->port.dev, "rx");
+	if (!uart_dma->dma_chan_rx) {
+		dev_err(port->dev, "cannot get the DMA channel.\n");
+		return -1;
+	}
+
+	slave_config.direction = DMA_DEV_TO_MEM;
+	slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	slave_config.src_maxburst = 1;
+	slave_config.dst_maxburst = 1;
+	slave_config.src_addr = port->mapbase + SUNXI_UART_RBR;
+
+	ret = dmaengine_slave_config(uart_dma->dma_chan_rx, &slave_config);
+	if (ret) {
+		dev_err(port->dev, "error in RX dma configuration.\n");
+		return ret;
+	}
+
+	uart_dma->rx_dma_inited = 1;
+	dev_info(port->dev, "sw_uart_init_dma_rx sucess\n");
+	return 0;
+}
+
+static int sw_uart_start_dma_rx(struct sw_uart_port *sw_uport)
+{
+	struct uart_port *port = &sw_uport->port;
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+	struct dma_async_tx_descriptor *desc;
+
+	if (!uart_dma->use_dma)
+		return 0;
+
+	if (uart_dma->rx_dma_used == 1)
+		return 0;
+
+	if (-1 == sw_uart_init_dma_rx(sw_uport)) {
+		dev_info(sw_uport->port.dev, "sw_uart_init_dma_rx error!\n");
+		return -1;
+	}
+	desc = dmaengine_prep_dma_cyclic(uart_dma->dma_chan_rx,
+				uart_dma->rx_phy_addr, uart_dma->rb_size, 1,
+					DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);
+
+	if (!desc) {
+		dev_err(port->dev, "get rx dma descriptor failed!\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(port->dev, "RX: prepare for the DMA.\n");
+	uart_dma->rx_cookie = dmaengine_submit(desc);
+	dma_async_issue_pending(uart_dma->dma_chan_rx);
+
+	uart_dma->rx_dma_used = 1;
+	if (uart_dma->use_timer == 1) {
+		hrtimer_start(&sw_uport->rx_hrtimer,
+			ns_to_ktime(uart_dma->rx_timeout), HRTIMER_MODE_REL);
+	}
+	return 1;
+}
+
+static void sw_uart_update_rb_addr(struct sw_uart_port *sw_uport)
+{
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+	struct dma_tx_state state;
+	uart_dma->rx_size = 0;
+	if (uart_dma->rx_dma_used == 1) {
+		dmaengine_tx_status(uart_dma->dma_chan_rx, uart_dma->rx_cookie,
+									&state);
+		if ((uart_dma->rb_size - state.residue) !=
+						sw_uport->rx_last_pos) {
+			uart_dma->rb_head = uart_dma->rb_size - state.residue;
+			sw_uport->rx_last_pos = uart_dma->rb_head;
+		}
+	}
+}
+
+static enum hrtimer_restart sw_uart_report_dma_rx(struct hrtimer *rx_hrtimer)
+{
+	int count, flip = 0;
+	struct sw_uart_port *sw_uport = container_of(rx_hrtimer,
+						struct sw_uart_port, rx_hrtimer);
+	struct uart_port *port = &sw_uport->port;
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+
+	if (!uart_dma->rx_dma_used || !port->state->port.tty)
+		return HRTIMER_NORESTART;
+
+	sw_uart_update_rb_addr(sw_uport);
+	while (1) {
+		count = CIRC_CNT_TO_END(uart_dma->rb_head, uart_dma->rb_tail,
+							uart_dma->rb_size);
+		if (count <= 0)
+			break;
+		port->icount.rx += count;
+		flip = tty_insert_flip_string(&port->state->port,
+				uart_dma->rx_buffer + uart_dma->rb_tail, count);
+		tty_flip_buffer_push(&port->state->port);
+		uart_dma->rb_tail =
+			(uart_dma->rb_tail + count) & (uart_dma->rb_size - 1);
+	}
+
+	if (uart_dma->use_timer == 1) {
+		hrtimer_forward_now(&sw_uport->rx_hrtimer,
+				ns_to_ktime(uart_dma->rx_timeout));
+	}
+
+	return HRTIMER_RESTART;
+}
+
+#endif
+
+static irqreturn_t sw_uart_irq(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned int iir = 0, lsr = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	iir = serial_in(port, SUNXI_UART_IIR) & SUNXI_UART_IIR_IID_MASK;
+	lsr = serial_in(port, SUNXI_UART_LSR);
+	SERIAL_DBG("irq: iir %x lsr %x\n", iir, lsr);
+
+	if (iir == SUNXI_UART_IIR_IID_BUSBSY) {
+		sw_uart_handle_busy(sw_uport);
+	} else {
+		if (lsr & (SUNXI_UART_LSR_DR | SUNXI_UART_LSR_BI))
+			lsr = sw_uart_handle_rx(sw_uport, lsr);
+		/* has charto irq but no dr lsr? just read and ignore */
+		else if (iir & SUNXI_UART_IIR_IID_CHARTO)
+			serial_in(&sw_uport->port, SUNXI_UART_RBR);
+		sw_uart_modem_status(sw_uport);
+#if IS_ENABLED(CONFIG_SW_UART_PTIME_MODE)
+		if (iir == SUNXI_UART_IIR_IID_THREMP)
+#else
+		if (lsr & SUNXI_UART_LSR_THRE)
+#endif
+			sw_uart_handle_tx(sw_uport);
+	}
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * uart buadrate and apb2 clock config selection
+ * We should select an apb2 clock as low as possible
+ * for lower power comsumpition, which can satisfy the
+ * different baudrates of different ttyS applications.
+ *
+ * the reference table as follows:
+ * pll6 600M
+ * apb2div      0        20       19       18       17       16       15       14       13       12       11       10       9        8        7        6         5
+ * apbclk       24000000 30000000 31578947 33333333 35294117 37500000 40000000 42857142 46153846 50000000 54545454 60000000 66666666 75000000 85714285 100000000 120000000
+ * 115200            *      *         *        *        *        *        *        *        *        *        *        *        *        *       *         *         *
+ * 230400                   *         *        *        *        *        *        *        *        *        *        *        *        *       *         *         *
+ * 380400            *      *         *                 *        *                 *        *        *        *        *        *        *       *         *         *
+ * 460800                   *                                    *                 *        *        *        *        *        *        *       *         *         *
+ * 921600                   *                                                      *        *                          *                 *       *         *         *
+ * 1000000                            *        *                                            *        *                          *                          *
+ * 1500000           *                                                                      *        *                                   *                 *         *
+ * 1750000                                                                                                    *                                  *
+ * 2000000                            *        *                                                                                *                          *
+ * 2500000                                                                *                                                                                          *
+ * 3000000                                                                                  *        *                                                     *
+ * 3250000                                                                                                    *                                            *
+ * 3500000                                                                                                    *
+ * 4000000                                                                                                                      *
+ */
+struct baudset {
+	u32 baud;
+	u32 uartclk_min;
+	u32 uartclk_max;
+};
+
+static inline int sw_uart_check_baudset(struct uart_port *port, unsigned int baud)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	static struct baudset baud_set[] = {
+		{115200, 24000000, 120000000},
+		{230400, 30000000, 120000000},
+		{380400, 24000000, 120000000},
+		{460800, 30000000, 120000000},
+		{921600, 30000000, 120000000},
+		{1000000, 31000000, 120000000}, /* 31578947 */
+		{1500000, 24000000, 120000000},
+		{1750000, 54000000, 120000000}, /* 54545454 */
+		{2000000, 31000000, 120000000}, /* 31578947 */
+		{2500000, 40000000, 120000000}, /* 40000000 */
+		{3000000, 46000000, 120000000}, /* 46153846 */
+		{3250000, 54000000, 120000000}, /* 54545454 */
+		{3500000, 54000000, 120000000}, /* 54545454 */
+		{4000000, 66000000, 120000000}, /* 66666666 */
+	};
+	struct baudset *setsel;
+	int i;
+
+	if (baud < 115200) {
+		if (port->uartclk < 24000000) {
+			SERIAL_MSG("uart%d, uartclk(%d) too small for baud %d\n",
+				sw_uport->id, port->uartclk, baud);
+			return -1;
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(baud_set); i++) {
+			if (baud == baud_set[i].baud)
+				break;
+		}
+
+		if (i == ARRAY_SIZE(baud_set)) {
+			SERIAL_MSG("uart%d, baud %d beyond rance\n", sw_uport->id, baud);
+			return -1;
+		}
+
+		setsel = &baud_set[i];
+		if (port->uartclk < setsel->uartclk_min
+			|| port->uartclk > setsel->uartclk_max) {
+			SERIAL_MSG("uart%d, select set %d, baud %d, uartclk %d beyond rance[%d, %d]\n",
+				sw_uport->id, i, baud, port->uartclk,
+				setsel->uartclk_min, setsel->uartclk_max);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+#define BOTH_EMPTY    (SUNXI_UART_LSR_TEMT | SUNXI_UART_LSR_THRE)
+static inline void wait_for_xmitr(struct sw_uart_port *sw_uport)
+{
+	unsigned int status, tmout = 10000;
+#if IS_ENABLED(CONFIG_SW_UART_PTIME_MODE)
+	unsigned int offs = SUNXI_UART_USR;
+	unsigned char mask = SUNXI_UART_USR_TFNF;
+#else
+	unsigned int offs = SUNXI_UART_LSR;
+	unsigned char mask = BOTH_EMPTY;
+#endif
+
+	/* Wait up to 10ms for the character(s) to be sent. */
+	do {
+		status = serial_in(&sw_uport->port, offs);
+		if (serial_in(&sw_uport->port, SUNXI_UART_LSR) & SUNXI_UART_LSR_BI)
+			sw_uport->lsr_break_flag = SUNXI_UART_LSR_BI;
+		if (--tmout == 0)
+			break;
+		udelay(1);
+	} while ((status & mask) != mask);
+
+	/* CTS is unsupported by the 2-line UART, so ignore it. */
+	if (sw_uport->pdata->io_num == 2)
+		return;
+
+	/* Wait up to 500ms for flow control if necessary */
+	if (sw_uport->port.flags & UPF_CONS_FLOW) {
+		tmout = 500000;
+		for (tmout = 1000000; tmout; tmout--) {
+			unsigned int msr = serial_in(&sw_uport->port, SUNXI_UART_MSR);
+
+			sw_uport->msr_saved_flags |= msr & MSR_SAVE_FLAGS;
+			if (msr & SUNXI_UART_MSR_CTS)
+				break;
+
+			udelay(1);
+		}
+	}
+}
+
+/* Enable or disable the RS485 support */
+static void sw_uart_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	sw_uport->rs485conf = *rs485conf;
+
+	sw_uport->mcr &= ~SUNXI_UART_MCR_MODE_MASK;
+	if (rs485conf->flags & SER_RS485_ENABLED) {
+		SERIAL_DBG("setting to rs485\n");
+		sw_uport->mcr |= SUNXI_UART_MCR_MODE_RS485;
+
+		/*
+		 * In NMM mode and no 9th bit(default RS485 mode), uart receive
+		 * all the bytes into FIFO before receveing an address byte
+		 */
+		sw_uport->rs485 |= SUNXI_UART_RS485_RXBFA;
+	} else {
+		SERIAL_DBG("setting to uart\n");
+		sw_uport->mcr |= SUNXI_UART_MCR_MODE_UART;
+		sw_uport->rs485 = 0;
+	}
+
+	serial_out(port, sw_uport->mcr, SUNXI_UART_MCR);
+	serial_out(port, sw_uport->rs485, SUNXI_UART_RS485);
+}
+
+static unsigned int sw_uart_tx_empty(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned long flags = 0;
+	unsigned int ret = 0;
+
+	spin_lock_irqsave(&sw_uport->port.lock, flags);
+	ret = (serial_in(port, SUNXI_UART_USR) & SUNXI_UART_USR_TFE) ? TIOCSER_TEMT : 0;
+	spin_unlock_irqrestore(&sw_uport->port.lock, flags);
+	return ret;
+}
+
+static void sw_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned int mcr = 0;
+
+	if (mctrl & TIOCM_RTS)
+		mcr |= SUNXI_UART_MCR_RTS;
+	if (mctrl & TIOCM_DTR)
+		mcr |= SUNXI_UART_MCR_DTR;
+	if (mctrl & TIOCM_LOOP)
+		mcr |= SUNXI_UART_MCR_LOOP;
+	sw_uport->mcr &= ~(SUNXI_UART_MCR_RTS|SUNXI_UART_MCR_DTR|SUNXI_UART_MCR_LOOP);
+	sw_uport->mcr |= mcr;
+	SERIAL_DBG("set mcr %x\n", mcr);
+	serial_out(port, sw_uport->mcr, SUNXI_UART_MCR);
+}
+
+static unsigned int sw_uart_get_mctrl(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned int msr;
+	unsigned int ret = 0;
+
+	msr = sw_uart_modem_status(sw_uport);
+	if (msr & SUNXI_UART_MSR_DCD)
+		ret |= TIOCM_CAR;
+	if (msr & SUNXI_UART_MSR_RI)
+		ret |= TIOCM_RNG;
+	if (msr & SUNXI_UART_MSR_DSR)
+		ret |= TIOCM_DSR;
+	if (msr & SUNXI_UART_MSR_CTS)
+		ret |= TIOCM_CTS;
+	SERIAL_DBG("get msr %x\n", msr);
+	return ret;
+}
+
+static void sw_uart_stop_rx(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	struct sw_uart_dma *uart_dma = sw_uport->dma;
+	if (uart_dma->use_dma & RX_DMA) {
+		sw_uart_stop_dma_rx(sw_uport);
+	}
+#endif
+	if (sw_uport->ier & SUNXI_UART_IER_RLSI) {
+		sw_uport->ier &= ~SUNXI_UART_IER_RLSI;
+		SERIAL_DBG("stop rx, ier %x\n", sw_uport->ier);
+		sw_uport->port.read_status_mask &= ~SUNXI_UART_LSR_DR;
+		serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	}
+}
+
+static void sw_uart_enable_ms(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	if (!(sw_uport->ier & SUNXI_UART_IER_MSI)) {
+		sw_uport->ier |= SUNXI_UART_IER_MSI;
+		SERIAL_DBG("en msi, ier %x\n", sw_uport->ier);
+		serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	}
+}
+
+static void sw_uart_break_ctl(struct uart_port *port, int break_state)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	if (break_state == -1)
+		sw_uport->lcr |= SUNXI_UART_LCR_SBC;
+	else
+		sw_uport->lcr &= ~SUNXI_UART_LCR_SBC;
+	serial_out(port, sw_uport->lcr, SUNXI_UART_LCR);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int sw_uart_startup(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	int ret;
+
+	SERIAL_DBG("start up ...\n");
+
+	ret = request_irq(port->irq, sw_uart_irq, 0, sw_uport->name, port);
+	if (unlikely(ret)) {
+		SERIAL_MSG("uart%d cannot get irq %d\n", sw_uport->id, port->irq);
+		return ret;
+	}
+
+	sw_uport->msr_saved_flags = 0;
+	/*
+	 * PTIME mode to select the THRE trigger condition:
+	 * if PTIME=1(IER[7]), the THRE interrupt will be generated when the
+	 * the water level of the TX FIFO is lower than the threshold of the
+	 * TX FIFO. and if PTIME=0, the THRE interrupt will be generated when
+	 * the TX FIFO is empty.
+	 * In addition, when PTIME=1, the THRE bit of the LSR register will not
+	 * be set when the THRE interrupt is generated. You must check the
+	 * interrupt id of the IIR register to decide whether some data need to
+	 * send.
+	 */
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	if (sw_uport->dma->use_dma & TX_DMA) {
+		if (sw_uport->port.state->xmit.buf !=
+						sw_uport->dma->tx_buffer){
+			free_page((unsigned long)sw_uport->port.state->xmit.buf);
+			sw_uport->port.state->xmit.buf =
+						sw_uport->dma->tx_buffer;
+		}
+	} else
+#endif
+	{
+		sw_uport->ier = 0;
+		serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	}
+
+	sw_uart_config_rs485(port, &sw_uport->rs485conf);
+
+	return 0;
+}
+
+static void sw_uart_shutdown(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	SERIAL_DBG("shut down ...\n");
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	if (sw_uport->dma->use_dma & TX_DMA)
+		sw_uport->port.state->xmit.buf = NULL;
+#endif
+	sw_uport->ier = 0;
+	sw_uport->lcr = 0;
+	sw_uport->mcr = 0;
+	sw_uport->fcr = 0;
+	serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	free_irq(port->irq, port);
+}
+
+static void sw_uart_flush_buffer(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	SERIAL_DBG("flush buffer...\n");
+	serial_out(port, sw_uport->fcr|SUNXI_UART_FCR_TXFIFO_RST, SUNXI_UART_FCR);
+}
+
+static void sw_uart_filter_lsr_err(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	static bool uart_lb[SUNXI_UART_NUM] = {false};
+	/*note:For some memory fifo, first receive data,LSR will error make data abnormal.
+	 *UART config loopback mode self-receiving data can filter this exception.
+	 *Only need to config loopback mode once.
+	 */
+	if (sw_uport->port.line != 0 && !uart_lb[sw_uport->port.line]) {
+		uart_lb[sw_uport->port.line] = true;
+		/* set loopback mode*/
+		serial_out(port, sw_uport->mcr | SUNXI_UART_MCR_LOOP,
+				SUNXI_UART_MCR);
+		serial_out(&sw_uport->port, 0xff, SUNXI_UART_THR);//write 0xff
+		sw_uart_start_tx(port);
+		serial_in(&sw_uport->port, SUNXI_UART_RBR);//read 0xff
+		sw_uart_stop_tx(port);
+		/* disabled loopback mode*/
+		serial_out(port, sw_uport->mcr, SUNXI_UART_MCR);
+	}
+}
+
+static void sw_uart_set_termios(struct uart_port *port, struct ktermios *termios,
+			    struct ktermios *old)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned long flags;
+	unsigned int baud, quot, lcr = 0, dll, dlh;
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	/* stop dma tx, which might make the uart be busy while some
+	 * registers are set
+	 */
+	if (sw_uport->dma->tx_dma_used)
+		sw_uart_stop_dma_tx(sw_uport);
+#endif
+	SERIAL_DBG("set termios ...\n");
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr |= SUNXI_UART_LCR_WLEN5;
+		break;
+	case CS6:
+		lcr |= SUNXI_UART_LCR_WLEN6;
+		break;
+	case CS7:
+		lcr |= SUNXI_UART_LCR_WLEN7;
+		break;
+	case CS8:
+	default:
+		lcr |= SUNXI_UART_LCR_WLEN8;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		lcr |= SUNXI_UART_LCR_STOP;
+	if (termios->c_cflag & PARENB)
+		lcr |= SUNXI_UART_LCR_PARITY;
+	if (!(termios->c_cflag & PARODD))
+		lcr |= SUNXI_UART_LCR_EPAR;
+
+	/* set buadrate */
+	baud = uart_get_baud_rate(port, termios, old,
+				  port->uartclk / 16 / 0xffff,
+				  port->uartclk / 16);
+	sw_uart_check_baudset(port, baud);
+	quot = uart_get_divisor(port, baud);
+	dll = quot & 0xff;
+	dlh = quot >> 8;
+	SERIAL_DBG("set baudrate %d, quot %d\n", baud, quot);
+
+	spin_lock_irqsave(&port->lock, flags);
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/* Update the per-port timeout. */
+	port->read_status_mask = SUNXI_UART_LSR_OE | SUNXI_UART_LSR_THRE | SUNXI_UART_LSR_DR;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= SUNXI_UART_LSR_FE | SUNXI_UART_LSR_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= SUNXI_UART_LSR_BI;
+
+	/* Characteres to ignore */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= SUNXI_UART_LSR_PE | SUNXI_UART_LSR_FE;
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= SUNXI_UART_LSR_BI;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= SUNXI_UART_LSR_OE;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= SUNXI_UART_LSR_DR;
+
+	/*
+	 * reset controller
+	 */
+	sw_uart_reset(sw_uport);
+
+	if (baud <= 9600)
+		sw_uport->fcr = SUNXI_UART_FCR_RXTRG_1CH
+				| SUNXI_UART_FCR_TXTRG_1_2
+				| SUNXI_UART_FCR_FIFO_EN;
+	else
+		sw_uport->fcr = SUNXI_UART_FCR_RXTRG_1_2
+				| SUNXI_UART_FCR_TXTRG_1_2
+				| SUNXI_UART_FCR_FIFO_EN;
+
+	serial_out(port, sw_uport->fcr, SUNXI_UART_FCR);
+
+
+	sw_uport->lcr = lcr;
+	sw_uport->dll = dll;
+	sw_uport->dlh = dlh;
+	sw_uart_force_lcr(sw_uport, 50);
+
+	/* clear rxfifo after set lcr & baud to discard redundant data */
+	serial_out(port, sw_uport->fcr|SUNXI_UART_FCR_RXFIFO_RST, SUNXI_UART_FCR);
+	port->ops->set_mctrl(port, port->mctrl);
+
+	sw_uport->ier = SUNXI_UART_IER_RLSI | SUNXI_UART_IER_RDI;
+#if IS_ENABLED(CONFIG_SW_UART_PTIME_MODE)
+	sw_uport->ier |= SUNXI_UART_IER_PTIME;
+#endif
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	if (sw_uport->dma->use_dma & RX_DMA) {
+		/* disable the receive data interrupt */
+		sw_uport->ier &= ~SUNXI_UART_IER_RDI;
+		sw_uart_start_dma_rx(sw_uport);
+	}
+#endif
+	/* flow control */
+	sw_uport->mcr &= ~SUNXI_UART_MCR_AFE;
+	port->status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS);
+	if (termios->c_cflag & CRTSCTS) {
+		port->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;
+		sw_uport->mcr |= SUNXI_UART_MCR_AFE;
+	}
+	serial_out(port, sw_uport->mcr, SUNXI_UART_MCR);
+
+	/*
+	 * CTS flow control flag and modem status interrupts
+	 */
+	sw_uport->ier &= ~SUNXI_UART_IER_MSI;
+	if (UART_ENABLE_MS(port, termios->c_cflag))
+		sw_uport->ier |= SUNXI_UART_IER_MSI;
+	serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	/* Must save the current config for the resume of console(no tty user). */
+	if (sw_is_console_port(port))
+		port->cons->cflag = termios->c_cflag;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	/* Don't rewrite B0 */
+	if (tty_termios_baud_rate(termios))
+		tty_termios_encode_baud_rate(termios, baud, baud);
+	SERIAL_DBG("termios lcr 0x%x fcr 0x%x mcr 0x%x dll 0x%x dlh 0x%x\n",
+			sw_uport->lcr, sw_uport->fcr, sw_uport->mcr,
+			sw_uport->dll, sw_uport->dlh);
+
+	sw_uart_filter_lsr_err(port);
+}
+
+static const char *sw_uart_type(struct uart_port *port)
+{
+	return "SUNXI";
+}
+
+static int sw_uart_select_gpio_state(struct pinctrl *pctrl, char *name, u32 no)
+{
+	int ret = 0;
+	struct pinctrl_state *pctrl_state = NULL;
+
+	pctrl_state = pinctrl_lookup_state(pctrl, name);
+	if (IS_ERR(pctrl_state)) {
+		SERIAL_MSG("UART%d pinctrl_lookup_state(%s) failed! return %p \n", no, name, pctrl_state);
+		return -1;
+	}
+
+	ret = pinctrl_select_state(pctrl, pctrl_state);
+	if (ret < 0)
+		SERIAL_MSG("UART%d pinctrl_select_state(%s) failed! return %d \n", no, name, ret);
+
+	return ret;
+}
+
+static int sw_uart_request_gpio(struct sw_uart_port *sw_uport)
+{
+	if (sw_uport->card_print)
+		return 0;
+
+	sw_uport->pctrl = devm_pinctrl_get(sw_uport->port.dev);
+
+	if (IS_ERR_OR_NULL(sw_uport->pctrl)) {
+		SERIAL_MSG("UART%d devm_pinctrl_get() failed! return %ld\n", sw_uport->id, PTR_ERR(sw_uport->pctrl));
+		return -1;
+	}
+
+	return sw_uart_select_gpio_state(sw_uport->pctrl, PINCTRL_STATE_DEFAULT, sw_uport->id);
+}
+
+static void sw_uart_release_gpio(struct sw_uart_port *sw_uport)
+{
+	if (sw_uport->card_print)
+		return;
+
+	devm_pinctrl_put(sw_uport->pctrl);
+	sw_uport->pctrl = NULL;
+}
+
+static void sw_uart_release_port(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	struct platform_device *pdev;
+	struct resource	*mem_res;
+
+	SERIAL_DBG("release port(iounmap & release io)\n");
+
+	pdev = to_platform_device(port->dev);
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (mem_res == NULL) {
+		SERIAL_MSG("uart%d, get MEM resource failed\n", sw_uport->id);
+		return;
+	}
+
+	/* release memory resource */
+	release_mem_region(mem_res->start, resource_size(mem_res));
+	iounmap(port->membase);
+	port->membase = NULL;
+
+	/* release io resource */
+	sw_uart_release_gpio(sw_uport);
+}
+
+static int sw_uart_request_port(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	struct platform_device *pdev;
+	struct resource	*mem_res;
+	int ret;
+
+	SERIAL_DBG("request port(ioremap & request io) %d\n", sw_uport->id);
+
+	pdev = to_platform_device(port->dev);
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (mem_res == NULL) {
+		SERIAL_MSG("uart%d, get MEM resource failed\n", sw_uport->id);
+		ret = -ENXIO;
+	}
+
+	/* request memory resource */
+	if (!request_mem_region(mem_res->start, resource_size(mem_res), SUNXI_UART_DEV_NAME)) {
+		SERIAL_MSG("uart%d, request mem region failed\n", sw_uport->id);
+		return -EBUSY;
+	}
+
+	port->membase = ioremap(mem_res->start, resource_size(mem_res));
+	if (!port->membase) {
+		SERIAL_MSG("uart%d, ioremap failed\n", sw_uport->id);
+		release_mem_region(mem_res->start, resource_size(mem_res));
+		return -EBUSY;
+	}
+
+	/* request io resource */
+	ret = sw_uart_request_gpio(sw_uport);
+	if (ret < 0) {
+		release_mem_region(mem_res->start, resource_size(mem_res));
+		return ret;
+	}
+
+	return 0;
+}
+
+static void sw_uart_config_port(struct uart_port *port, int flags)
+{
+	int ret;
+
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_SUNXI;
+		ret = sw_uart_request_port(port);
+		if (ret)
+			return;
+	}
+}
+
+static int sw_uart_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (unlikely(ser->type != PORT_UNKNOWN && ser->type != PORT_SUNXI))
+		return -EINVAL;
+	if (unlikely(port->irq != ser->irq))
+		return -EINVAL;
+	return 0;
+}
+
+static int sw_uart_ioctl(struct uart_port *port, unsigned int cmd,
+			 unsigned long arg)
+{
+	struct serial_rs485 rs485conf;
+	unsigned long flags = 0;
+
+	switch (cmd) {
+	case TIOCSRS485:
+		if (copy_from_user(&rs485conf, (struct serial_rs485 *)arg,
+				   sizeof(rs485conf)))
+			return -EFAULT;
+
+		spin_lock_irqsave(&port->lock, flags);
+		sw_uart_config_rs485(port, &rs485conf);
+		spin_unlock_irqrestore(&port->lock, flags);
+		break;
+
+	case TIOCGRS485:
+		if (copy_to_user((struct serial_rs485 *) arg,
+				 &(UART_TO_SPORT(port)->rs485conf),
+				 sizeof(rs485conf)))
+			return -EFAULT;
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+static void sw_uart_pm(struct uart_port *port, unsigned int state,
+		      unsigned int oldstate)
+{
+#if IS_ENABLED(CONFIG_EVB_PLATFORM)
+	int ret;
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	SERIAL_DBG("PM state %d -> %d\n", oldstate, state);
+
+	switch (state) {
+	case UART_PM_STATE_ON: /* Power up */
+		ret = clk_prepare_enable(sw_uport->mclk);
+		if (ret) {
+			SERIAL_MSG("uart%d release reset failed\n", sw_uport->id);
+		}
+		break;
+	case UART_PM_STATE_OFF: /* Power down */
+		clk_disable_unprepare(sw_uport->mclk);
+		break;
+	default:
+		SERIAL_MSG("uart%d, Unknown PM state %d\n", sw_uport->id, state);
+	}
+#endif
+}
+
+#if IS_ENABLED(CONFIG_CONSOLE_POLL)
+/*
+ * Console polling routines for writing and reading from the uart while
+ * in an interrupt or debug context.
+ */
+
+static int sw_get_poll_char(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned int lsr = serial_in(port, SUNXI_UART_LSR);
+
+	if (!(lsr & SUNXI_UART_LSR_DR)) {
+		return NO_POLL_CHAR;
+	}
+
+	return serial_in(port, SUNXI_UART_RBR);
+}
+
+
+static void sw_put_poll_char(struct uart_port *port,
+			unsigned char c)
+{
+	unsigned int ier;
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	/*
+	 * First save the IER then disable the interrupts.
+	 */
+	ier = serial_in(port, SUNXI_UART_IER);
+
+	serial_out(port, 0, SUNXI_UART_IER);
+	wait_for_xmitr(sw_uport);
+
+	serial_out(port, c, SUNXI_UART_THR);
+	if (c == 10) {
+		wait_for_xmitr(sw_uport);
+		serial_out(port, 13, SUNXI_UART_THR);
+	}
+	/*
+	 * Finally, wait for transmitter to become empty
+	 * and restore the IER
+	 */
+	wait_for_xmitr(sw_uport);
+	serial_out(port, ier, SUNXI_UART_IER);
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
+/* Disable receive interrupts to throttle receive data, which could
+* avoid receive data overrun*/
+static void sw_uart_throttle(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	sw_uport->ier &= ~(SUNXI_UART_IER_RLSI | SUNXI_UART_IER_RDI);
+	serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	sw_uport->throttled = true;
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void sw_uart_unthrottle(struct uart_port *port)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	sw_uport->ier |= SUNXI_UART_IER_RLSI | SUNXI_UART_IER_RDI;
+	serial_out(port, sw_uport->ier, SUNXI_UART_IER);
+	sw_uport->throttled = false;
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static struct uart_ops sw_uart_ops = {
+	.tx_empty = sw_uart_tx_empty,
+	.set_mctrl = sw_uart_set_mctrl,
+	.get_mctrl = sw_uart_get_mctrl,
+	.stop_tx = sw_uart_stop_tx,
+	.start_tx = sw_uart_start_tx,
+	.stop_rx = sw_uart_stop_rx,
+	.enable_ms = sw_uart_enable_ms,
+	.break_ctl = sw_uart_break_ctl,
+	.startup = sw_uart_startup,
+	.shutdown = sw_uart_shutdown,
+	.flush_buffer = sw_uart_flush_buffer,
+	.set_termios = sw_uart_set_termios,
+	.type = sw_uart_type,
+	.release_port = sw_uart_release_port,
+	.request_port = sw_uart_request_port,
+	.config_port = sw_uart_config_port,
+	.verify_port = sw_uart_verify_port,
+	.ioctl = sw_uart_ioctl,
+	.pm = sw_uart_pm,
+#if IS_ENABLED(CONFIG_CONSOLE_POLL)
+	.poll_get_char = sw_get_poll_char,
+	.poll_put_char = sw_put_poll_char,
+#endif
+	.throttle = sw_uart_throttle,
+	.unthrottle = sw_uart_unthrottle,
+};
+
+static int sw_uart_regulator_request(struct sw_uart_port *sw_uport, struct sw_uart_pdata *pdata,
+		struct device *dev)
+{
+	struct regulator *regu = NULL;
+
+	/* Consider "n***" as nocare. Support "none", "nocare", "null", "" etc. */
+	if ((pdata->regulator_id[0] == 'n') || (pdata->regulator_id[0] == 0)) {
+		/* if regulator_id not exist, use dt way to get regulator */
+		regu = regulator_get(dev, "uart");
+		if (IS_ERR(regu)) {
+			dev_warn(dev, "get regulator by dt way failed!\n");
+			return 0;
+		}
+		pdata->regulator = regu;
+		return 0;
+	}
+
+	regu = regulator_get(NULL, pdata->regulator_id);
+	if (IS_ERR(regu)) {
+		SERIAL_MSG("get regulator %s failed!\n", pdata->regulator_id);
+		return -1;
+	}
+	pdata->regulator = regu;
+	return 0;
+}
+
+static void sw_uart_regulator_release(struct sw_uart_pdata *pdata)
+{
+	if (pdata->regulator == NULL)
+		return;
+
+	regulator_put(pdata->regulator);
+	pdata->regulator = NULL;
+}
+
+static int sw_uart_regulator_enable(struct sw_uart_pdata *pdata)
+{
+	if (pdata->regulator == NULL)
+		return 0;
+
+	if (regulator_enable(pdata->regulator) != 0)
+		return -1;
+
+	return 0;
+}
+
+static int sw_uart_regulator_disable(struct sw_uart_pdata *pdata)
+{
+	if (pdata->regulator == NULL)
+		return 0;
+
+	if (regulator_disable(pdata->regulator) != 0)
+		return -1;
+
+	return 0;
+}
+
+static struct sw_uart_port sw_uart_ports[SUNXI_UART_NUM];
+static struct sw_uart_pdata sw_uport_pdata[SUNXI_UART_NUM];
+
+static ssize_t sunxi_uart_dev_info_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct uart_port *port = dev_get_drvdata(dev);
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	struct sw_uart_pdata *pdata = (struct sw_uart_pdata *)dev->platform_data;
+
+	return snprintf(buf, PAGE_SIZE,
+		"id     = %u \n"
+		"name   = %s \n"
+		"irq    = %u \n"
+		"io_num = %u \n"
+		"port->mapbase = %pa \n"
+		"port->membase = 0x%p \n"
+		"port->iobase  = 0x%08lx \n"
+		"port->fifosize = %d\n"
+		"pdata->regulator    = 0x%p \n"
+		"pdata->regulator_id = %s \n",
+		sw_uport->id, sw_uport->name, port->irq,
+		sw_uport->pdata->io_num,
+		&port->mapbase, port->membase, port->iobase,
+		port->fifosize, pdata->regulator, pdata->regulator_id);
+}
+
+static struct device_attribute sunxi_uart_dev_info_attr =
+	__ATTR(dev_info, S_IRUGO, sunxi_uart_dev_info_show, NULL);
+
+static ssize_t sunxi_uart_status_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct uart_port *port = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE,
+		"uartclk = %d \n"
+		"The Uart controller register[Base: 0x%p]: \n"
+		"[RTX] 0x%02x = 0x%08x, [IER] 0x%02x = 0x%08x, [FCR] 0x%02x = 0x%08x \n"
+		"[LCR] 0x%02x = 0x%08x, [MCR] 0x%02x = 0x%08x, [LSR] 0x%02x = 0x%08x \n"
+		"[MSR] 0x%02x = 0x%08x, [SCH] 0x%02x = 0x%08x, [USR] 0x%02x = 0x%08x \n"
+		"[TFL] 0x%02x = 0x%08x, [RFL] 0x%02x = 0x%08x, [HALT] 0x%02x = 0x%08x \n",
+	port->uartclk, port->membase,
+		SUNXI_UART_RBR, readl(port->membase + SUNXI_UART_RBR),
+		SUNXI_UART_IER, readl(port->membase + SUNXI_UART_IER),
+		SUNXI_UART_FCR, readl(port->membase + SUNXI_UART_FCR),
+		SUNXI_UART_LCR, readl(port->membase + SUNXI_UART_LCR),
+		SUNXI_UART_MCR, readl(port->membase + SUNXI_UART_MCR),
+		SUNXI_UART_LSR, readl(port->membase + SUNXI_UART_LSR),
+		SUNXI_UART_MSR, readl(port->membase + SUNXI_UART_MSR),
+		SUNXI_UART_SCH, readl(port->membase + SUNXI_UART_SCH),
+		SUNXI_UART_USR, readl(port->membase + SUNXI_UART_USR),
+		SUNXI_UART_TFL, readl(port->membase + SUNXI_UART_TFL),
+		SUNXI_UART_RFL, readl(port->membase + SUNXI_UART_RFL),
+		SUNXI_UART_HALT, readl(port->membase + SUNXI_UART_HALT));
+}
+static struct device_attribute sunxi_uart_status_attr =
+	__ATTR(status, S_IRUGO, sunxi_uart_status_show, NULL);
+
+static ssize_t sunxi_uart_loopback_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int mcr = 0;
+	struct uart_port *port = dev_get_drvdata(dev);
+
+	mcr = readl(port->membase + SUNXI_UART_MCR);
+	return snprintf(buf, PAGE_SIZE,
+		"MCR: 0x%08x, Loopback: %d\n", mcr, mcr&SUNXI_UART_MCR_LOOP ? 1 : 0);
+}
+
+static ssize_t sunxi_uart_loopback_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	int mcr = 0;
+	int enable = 0;
+	struct uart_port *port = dev_get_drvdata(dev);
+
+	if (!strncmp(buf, "enable", 6))
+		enable = 1;
+
+	pr_debug("Set loopback: %d \n", enable);
+
+	mcr = readl(port->membase + SUNXI_UART_MCR);
+	if (enable)
+		writel(mcr|SUNXI_UART_MCR_LOOP, port->membase + SUNXI_UART_MCR);
+	else
+		writel(mcr&(~SUNXI_UART_MCR_LOOP), port->membase + SUNXI_UART_MCR);
+
+	return count;
+}
+static struct device_attribute sunxi_uart_loopback_attr =
+	__ATTR(loopback, S_IRUGO|S_IWUSR, sunxi_uart_loopback_show, sunxi_uart_loopback_store);
+
+static ssize_t sunxi_uart_ctrl_info_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct uart_port *port = dev_get_drvdata(dev);
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+	u32 dl = (u32)sw_uport->dlh << 8 | (u32)sw_uport->dll;
+
+	if (dl == 0)
+		dl = 1000;
+
+	return snprintf(buf, PAGE_SIZE,
+		" ier  : 0x%02x\n"
+		" lcr  : 0x%02x\n"
+		" mcr  : 0x%02x\n"
+		" fcr  : 0x%02x\n"
+		" dll  : 0x%02x\n"
+		" dlh  : 0x%02x\n"
+		" last baud : %d (dl = %d)\n\n"
+		"TxRx Statistics:\n"
+		" tx     : %d\n"
+		" rx     : %d\n"
+		" parity : %d\n"
+		" frame  : %d\n"
+		" overrun: %d\n"
+		" throttled: %d\n",
+		sw_uport->ier, sw_uport->lcr, sw_uport->mcr,
+		sw_uport->fcr, sw_uport->dll, sw_uport->dlh,
+		(sw_uport->port.uartclk>>4)/dl, dl,
+		sw_uport->port.icount.tx,
+		sw_uport->port.icount.rx,
+		sw_uport->port.icount.parity,
+		sw_uport->port.icount.frame,
+		sw_uport->port.icount.overrun,
+		sw_uport->throttled);
+}
+static struct device_attribute sunxi_uart_ctrl_info_attr =
+	__ATTR(ctrl_info, S_IRUGO, sunxi_uart_ctrl_info_show, NULL);
+
+static void sunxi_uart_sysfs(struct platform_device *_pdev)
+{
+	device_create_file(&_pdev->dev, &sunxi_uart_dev_info_attr);
+	device_create_file(&_pdev->dev, &sunxi_uart_status_attr);
+	device_create_file(&_pdev->dev, &sunxi_uart_loopback_attr);
+	device_create_file(&_pdev->dev, &sunxi_uart_ctrl_info_attr);
+}
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_CONSOLE)
+static struct uart_port *sw_console_get_port(struct console *co)
+{
+	struct uart_port *port = NULL;
+	int i, used;
+
+	for (i = 0; i < SUNXI_UART_NUM; i++) {
+		used = sw_uport_pdata[i].used;
+		port = &sw_uart_ports[i].port;
+		if ((used == 1) && (port->line == co->index)) {
+			break;
+		}
+	}
+	return port;
+}
+
+static void sw_console_putchar(struct uart_port *port, int c)
+{
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	wait_for_xmitr(sw_uport);
+	serial_out(port, c, SUNXI_UART_THR);
+}
+
+static void sw_console_write(struct console *co, const char *s,
+			      unsigned int count)
+{
+	struct uart_port *port = NULL;
+	struct sw_uart_port *sw_uport;
+	unsigned long flags;
+	unsigned int ier;
+	int locked = 1;
+
+	BUG_ON(co->index < 0 || co->index >= SUNXI_UART_NUM);
+
+	port = sw_console_get_port(co);
+	if (port == NULL)
+		return;
+	sw_uport = UART_TO_SPORT(port);
+
+	if (port->sysrq || oops_in_progress)
+		locked = spin_trylock_irqsave(&port->lock, flags);
+	else
+		spin_lock_irqsave(&port->lock, flags);
+
+	ier = serial_in(port, SUNXI_UART_IER);
+	serial_out(port, 0, SUNXI_UART_IER);
+
+	uart_console_write(port, s, count, sw_console_putchar);
+	wait_for_xmitr(sw_uport);
+	serial_out(port, ier, SUNXI_UART_IER);
+
+	if (locked)
+		spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int sw_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port = NULL;
+	struct sw_uart_port *sw_uport;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (unlikely(co->index >= SUNXI_UART_NUM || co->index < 0))
+		return -ENXIO;
+
+	port = sw_console_get_port(co);
+	if (port == NULL)
+		return -ENODEV;
+	sw_uport = UART_TO_SPORT(port);
+	if (!port->iobase && !port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	SERIAL_MSG("console setup baud %d parity %c bits %d, flow %c\n",
+			baud, parity, bits, flow);
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver sw_uart_driver;
+static struct console sw_console = {
+#if IS_ENABLED(CONFIG_SERIAL_8250)
+	.name = "ttyAS",
+#else
+	.name = "ttyS",
+#endif
+	.write = sw_console_write,
+	.device = uart_console_device,
+	.setup = sw_console_setup,
+	.flags = CON_PRINTBUFFER,
+	.index = -1,
+	.data = &sw_uart_driver,
+};
+
+#define SW_CONSOLE	(&sw_console)
+#else
+#define SW_CONSOLE	NULL
+#endif
+
+static struct uart_driver sw_uart_driver = {
+	.owner = THIS_MODULE,
+	.driver_name = SUNXI_UART_DEV_NAME,
+#if IS_ENABLED(CONFIG_SERIAL_8250)
+	.dev_name = "ttyAS",
+#else
+	.dev_name = "ttyS",
+#endif
+	.nr = SUNXI_UART_NUM,
+	.cons = SW_CONSOLE,
+};
+
+static int sw_uart_request_resource(struct sw_uart_port *sw_uport, struct sw_uart_pdata *pdata,
+		struct device *dev)
+{
+	SERIAL_DBG("get system resource(clk & IO)\n");
+
+	if (sw_uart_regulator_request(sw_uport, pdata, dev) < 0) {
+		SERIAL_MSG("uart%d request regulator failed!\n", sw_uport->id);
+		return -ENXIO;
+	}
+	sw_uart_regulator_enable(pdata);
+
+#if IS_ENABLED(CONFIG_SW_UART_DUMP_DATA)
+	sw_uport->dump_buff = (char *)kmalloc(MAX_DUMP_SIZE, GFP_KERNEL);
+	if (!sw_uport->dump_buff) {
+		SERIAL_MSG("uart%d fail to alloc dump buffer\n", sw_uport->id);
+	}
+#endif
+
+	return 0;
+}
+
+static int sw_uart_release_resource(struct sw_uart_port *sw_uport, struct sw_uart_pdata *pdata)
+{
+	SERIAL_DBG("put system resource(clk & IO)\n");
+
+#if IS_ENABLED(CONFIG_SW_UART_DUMP_DATA)
+	kfree(sw_uport->dump_buff);
+	sw_uport->dump_buff = NULL;
+	sw_uport->dump_len = 0;
+#endif
+
+	clk_disable_unprepare(sw_uport->mclk);
+	clk_put(sw_uport->mclk);
+
+	sw_uart_regulator_disable(pdata);
+	sw_uart_regulator_release(pdata);
+
+	return 0;
+}
+
+struct platform_device *sw_uart_get_pdev(int uart_id)
+{
+	if (sw_uart_ports[uart_id].port.dev)
+		return to_platform_device(sw_uart_ports[uart_id].port.dev);
+	else
+		return NULL;
+}
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_EARLYCON)
+
+#define SUNXI_UART_USR_NF    0x02    /* Tansmit fifo not full */
+
+static void sunxi_serial_console_putchar(struct uart_port *port, int ch)
+{
+	int value = 0;
+
+	do {
+		value = readl_relaxed(port->membase + SUNXI_UART_USR);
+	} while (!(value & SUNXI_UART_USR_NF));
+
+	writel_relaxed(ch, port->membase + SUNXI_UART_THR);
+}
+
+static __init void sunxi_early_serial_write(struct console *con, const char *s,
+					  unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+
+	uart_console_write(&dev->port, s, n, sunxi_serial_console_putchar);
+}
+
+static int __init sunxi_early_console_setup(struct earlycon_device *dev,
+					  const char *opt)
+{
+	if (!dev->port.membase)
+		return -ENODEV;
+	dev->con->write = sunxi_early_serial_write;
+	return 0;
+}
+OF_EARLYCON_DECLARE(uart0, "", sunxi_early_console_setup);
+#endif	/* CONFIG_SERIAL_SUNXI_EARLYCON */
+
+static int sw_uart_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct uart_port *port;
+	struct sw_uart_port *sw_uport;
+	struct sw_uart_pdata *pdata;
+	struct resource *res;
+	char uart_para[16] = {0};
+	const char *uart_string;
+	int ret = -1;
+	struct device_node *apk_np = of_find_node_by_name(NULL, "auto_print");
+	const char *apk_sta = NULL;
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	int use_dma = 0;
+#endif
+
+	pdev->id = of_alias_get_id(np, "serial");
+	if (pdev->id < 0 || pdev->id >= SUNXI_UART_NUM) {
+		SERIAL_MSG("get alias id err or exceed supported uart controllers\n");
+		return -EINVAL;
+	}
+
+	port = &sw_uart_ports[pdev->id].port;
+	port->dev = &pdev->dev;
+	pdata = &sw_uport_pdata[pdev->id];
+	sw_uport = UART_TO_SPORT(port);
+	sw_uport->pdata = pdata;
+	sw_uport->id = pdev->id;
+	sw_uport->ier = 0;
+	sw_uport->lcr = 0;
+	sw_uport->mcr = 0;
+	sw_uport->fcr = 0;
+	sw_uport->dll = 0;
+	sw_uport->dlh = 0;
+	snprintf(sw_uport->name, 16, SUNXI_UART_DEV_NAME"%d", pdev->id);
+	pdev->dev.init_name = sw_uport->name;
+	pdev->dev.platform_data = sw_uport->pdata;
+
+	snprintf(uart_para, sizeof(uart_para), "uart%d_regulator", pdev->id);
+	ret = of_property_read_string(np, uart_para, &uart_string);
+	if (ret)
+		dev_err(&pdev->dev, "get regulator failed\n");
+	else
+		strncpy(pdata->regulator_id, uart_string, 16);
+
+	/* request system resource and init them */
+	ret = sw_uart_request_resource(sw_uport, pdev->dev.platform_data, &pdev->dev);
+	if (unlikely(ret)) {
+		SERIAL_MSG("uart%d error to get resource\n", pdev->id);
+		return -ENXIO;
+	}
+
+
+#if IS_ENABLED(CONFIG_EVB_PLATFORM)
+	sw_uport->reset = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(sw_uport->reset)) {
+		printk("get reset clk error\n");
+		return -EINVAL;
+	}
+	sw_uport->mclk = of_clk_get(np, 0);
+	if (IS_ERR(sw_uport->mclk)) {
+		SERIAL_MSG("uart%d error to get clk\n", pdev->id);
+		return -EINVAL;
+	}
+
+	ret = reset_control_deassert(sw_uport->reset);
+	if (ret) {
+		printk("deassert clk error, ret:%d\n", ret);
+		return ret;
+	}
+
+	/* uart clk come from apb2, apb2 default clk is hosc. if change rate
+	 * needed, must switch apb2's source clk first and then set its rate
+	 * */
+	sw_uport->sclk = of_clk_get(np, 1);
+	if (!IS_ERR(sw_uport->sclk)) {
+		sw_uport->pclk = of_clk_get(np, 2);
+		port->uartclk = clk_get_rate(sw_uport->sclk);
+		/*config a fixed divider before switch source clk for apb2 */
+		clk_set_rate(sw_uport->sclk, port->uartclk/6);
+		/* switch source clock for apb2 */
+		clk_set_parent(sw_uport->sclk, sw_uport->pclk);
+		ret = of_property_read_u32(np, "clock-frequency",
+					&port->uartclk);
+		if (ret) {
+			SERIAL_MSG("uart%d get clock-freq failed\n", pdev->id);
+			return -EINVAL;
+		}
+		/* set apb2 clock frequency now */
+		clk_set_rate(sw_uport->sclk, port->uartclk);
+	}
+
+	port->uartclk = clk_get_rate(sw_uport->mclk);
+#else
+	port->uartclk = 24000000;
+#endif
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "uart%d error to get MEM resource\n", pdev->id);
+		return -EINVAL;
+	}
+	port->mapbase = res->start;
+
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	sw_uport->dma = devm_kzalloc(&pdev->dev, sizeof(struct sw_uart_dma), GFP_KERNEL);
+	if (!sw_uport->dma) {
+		dev_err(&pdev->dev, "unable to allocate mem\n");
+		return -ENOMEM;
+	}
+	ret = of_property_read_u32(np, "use_dma", &use_dma);
+	if (ret)
+		use_dma = 0;
+	sw_uport->dma->use_dma = use_dma;
+	sw_uport->dma->rx_dma_inited = 0;
+	sw_uport->dma->rx_dma_used = 0;
+	sw_uport->dma->tx_dma_inited = 0;
+	sw_uport->dma->tx_dma_used = 0;
+#endif
+
+	port->irq = platform_get_irq(pdev, 0);
+	if (port->irq < 0) {
+		dev_err(&pdev->dev, "uart%d error to get irq\n", pdev->id);
+		return -EINVAL;
+	}
+
+
+	snprintf(uart_para, sizeof(uart_para), "uart%d_port", pdev->id);
+	ret = of_property_read_u32(np, uart_para, &port->line);
+	if (ret) {
+		dev_err(&pdev->dev, "uart%d error to get port property\n", pdev->id);
+		return -EINVAL;
+	}
+
+
+	snprintf(uart_para, sizeof(uart_para), "uart%d_type", pdev->id);
+	ret = of_property_read_u32(np, uart_para, &pdata->io_num);
+	if (ret) {
+		dev_err(&pdev->dev, "uart%d error to get type property\n", pdev->id);
+		return -EINVAL;
+	}
+
+
+	if (of_property_read_bool(np, "linux,rs485-enabled-at-boot-time"))
+		sw_uport->rs485conf.flags |= SER_RS485_ENABLED;
+
+	if (apk_np && !of_property_read_string(apk_np, "status", &apk_sta)
+						&& !strcmp(apk_sta, "okay"))
+		sw_uport->card_print = true;
+	else
+		sw_uport->card_print = false;
+
+	pdata->used = 1;
+	port->iotype = UPIO_MEM;
+	port->type = PORT_SUNXI;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->ops = &sw_uart_ops;
+
+	ret = of_property_read_u32(np, "sunxi,uart-fifosize", &port->fifosize);
+	if (ret) {
+		dev_err(&pdev->dev, "uart%d error to get fifo size property\n", pdev->id);
+		port->fifosize = SUNXI_UART_FIFO_SIZE;
+	}
+
+	platform_set_drvdata(pdev, port);
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	/* set dma config */
+	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	if (sw_uport->dma->use_dma & RX_DMA) {
+		/* timer */
+		sw_uport->dma->use_timer = UART_USE_TIMER;
+		sw_uport->dma->rx_timeout = 2000000;
+		hrtimer_init(&sw_uport->rx_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		sw_uport->rx_hrtimer.function = sw_uart_report_dma_rx;
+
+		/* rx buffer */
+		sw_uport->dma->rb_size = DMA_SERIAL_BUFFER_SIZE;
+		sw_uport->dma->rx_buffer = dma_alloc_coherent(
+				sw_uport->port.dev, sw_uport->dma->rb_size,
+				&sw_uport->dma->rx_phy_addr, GFP_KERNEL);
+		sw_uport->dma->rb_tail = 0;
+
+		if (!sw_uport->dma->rx_buffer) {
+			dev_err(sw_uport->port.dev,
+				"dmam_alloc_coherent dma_rx_buffer fail\n");
+			return -ENOMEM;
+		} else {
+			dev_info(sw_uport->port.dev,
+				"dma_rx_buffer %p\n", sw_uport->dma->rx_buffer);
+			dev_info(sw_uport->port.dev,
+		"dma_rx_phy 0x%08x\n", (unsigned)sw_uport->dma->rx_phy_addr);
+		}
+		sw_uart_init_dma_rx(sw_uport);
+	}
+
+	if (sw_uport->dma->use_dma & TX_DMA) {
+		/* tx buffer */
+		sw_uport->dma->tb_size = UART_XMIT_SIZE;
+		sw_uport->dma->tx_buffer = dma_alloc_coherent(
+				sw_uport->port.dev, sw_uport->dma->tb_size,
+				&sw_uport->dma->tx_phy_addr, GFP_KERNEL);
+		if (!sw_uport->dma->tx_buffer) {
+			dev_info(sw_uport->port.dev,
+				"dmam_alloc_coherent dma_tx_buffer fail\n");
+		} else {
+			dev_info(sw_uport->port.dev, "dma_tx_buffer %p\n",
+						sw_uport->dma->tx_buffer);
+			dev_info(sw_uport->port.dev, "dma_tx_phy 0x%08x\n",
+					(unsigned) sw_uport->dma->tx_phy_addr);
+		}
+		sw_uart_init_dma_tx(sw_uport);
+	}
+
+#endif
+
+	sunxi_uart_sysfs(pdev);
+
+
+	SERIAL_DBG("add uart%d port, port_type %d, uartclk %d\n",
+			pdev->id, port->type, port->uartclk);
+	return uart_add_one_port(&sw_uart_driver, port);
+}
+
+static int sw_uart_remove(struct platform_device *pdev)
+{
+	struct sw_uart_port *sw_uport = platform_get_drvdata(pdev);
+
+	SERIAL_DBG("release uart%d port\n", sw_uport->id);
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	sw_uart_release_dma_tx(sw_uport);
+	sw_uart_release_dma_rx(sw_uport);
+#endif
+	sw_uart_release_resource(sw_uport, pdev->dev.platform_data);
+	return 0;
+}
+
+/* UART power management code */
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+
+#define SW_UART_NEED_SUSPEND(port) \
+	((sw_is_console_port(port) && (console_suspend_enabled)) \
+		|| !sw_is_console_port(port))
+
+static int sw_uart_suspend(struct device *dev)
+{
+	struct uart_port *port = dev_get_drvdata(dev);
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	if (port) {
+		SERIAL_MSG("uart%d suspend\n", sw_uport->id);
+		uart_suspend_port(&sw_uart_driver, port);
+
+		if (SW_UART_NEED_SUSPEND(port)) {
+			if (!sw_uport->card_print)
+				sw_uart_select_gpio_state(sw_uport->pctrl,
+					PINCTRL_STATE_SLEEP, sw_uport->id);
+			sw_uart_regulator_disable(dev->platform_data);
+		}
+	}
+
+	return 0;
+}
+
+static int sw_uart_resume(struct device *dev)
+{
+	struct uart_port *port = dev_get_drvdata(dev);
+	struct sw_uart_port *sw_uport = UART_TO_SPORT(port);
+
+	if (port) {
+		if (SW_UART_NEED_SUSPEND(port)) {
+			sw_uart_regulator_enable(dev->platform_data);
+			if (!sw_uport->card_print)
+				sw_uart_select_gpio_state(sw_uport->pctrl,
+					PINCTRL_STATE_DEFAULT, sw_uport->id);
+		}
+		uart_resume_port(&sw_uart_driver, port);
+		SERIAL_MSG("uart%d resume. DLH: %d, DLL: %d. \n", sw_uport->id, sw_uport->dlh, sw_uport->dll);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops sw_uart_pm_ops = {
+	.suspend = sw_uart_suspend,
+	.resume = sw_uart_resume,
+};
+#define SERIAL_SW_PM_OPS	(&sw_uart_pm_ops)
+
+#else /* !CONFIG_PM_SLEEP */
+
+#define SERIAL_SW_PM_OPS	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct of_device_id sunxi_uart_match[] = {
+#if IS_ENABLED(CONFIG_ARCH_SUN8I)
+	{ .compatible = "allwinner,sun8i-uart", },
+#endif
+#if IS_ENABLED(CONFIG_ARCH_SUN50I)
+	{ .compatible = "allwinner,sun50i-uart", },
+#endif
+#if IS_ENABLED(CONFIG_ARCH_SUN20I)
+	{ .compatible = "allwinner,sun20i-uart", },
+#endif
+
+#if IS_ENABLED(CONFIG_ARCH_SUN55I)
+	{ .compatible = "allwinner,sun55i-uart", },
+#endif
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_uart_match);
+
+
+static struct platform_driver sw_uport_platform_driver = {
+	.probe  = sw_uart_probe,
+	.remove = sw_uart_remove,
+	.driver = {
+		.name  = SUNXI_UART_DEV_NAME,
+		.pm    = SERIAL_SW_PM_OPS,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_uart_match,
+	},
+};
+
+static int __init sunxi_uart_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&sw_uart_driver);
+	if (unlikely(ret)) {
+		SERIAL_MSG("driver initializied\n");
+		return ret;
+	}
+
+	return platform_driver_register(&sw_uport_platform_driver);
+}
+
+static void __exit sunxi_uart_exit(void)
+{
+	SERIAL_MSG("driver exit\n");
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_CONSOLE)
+	unregister_console(&sw_console);
+#endif
+	platform_driver_unregister(&sw_uport_platform_driver);
+	uart_unregister_driver(&sw_uart_driver);
+}
+
+module_init(sunxi_uart_init);
+module_exit(sunxi_uart_exit);
+
+MODULE_AUTHOR("Aaron<leafy.myeh@allwinnertech.com>");
+MODULE_DESCRIPTION("Driver for Allwinner UART controller");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/tty/serial/sunxi-uart.h b/drivers/tty/serial/sunxi-uart.h
new file mode 100644
index 000000000..96c2e26b6
--- /dev/null
+++ b/drivers/tty/serial/sunxi-uart.h
@@ -0,0 +1,254 @@
+/*
+ * drivers/tty/serial/sunxi-uart.h
+ * (C) Copyright 2007-2013
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * Aaron.Maoye <leafy.myeh@reuuimllatech.com>
+ *
+ * Some macro and struct of Allwinner UART controller.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * 2013.6.6 Mintow <duanmintao@allwinnertech.com>
+ *    Adapt to support sun8i/sun9i of Allwinner.
+ */
+
+#ifndef _SUNXI_UART_H_
+#define _SUNXI_UART_H_
+
+#include <linux/regulator/consumer.h>
+#include <linux/dmaengine.h>
+#include <linux/reset.h>
+//include <linux/serial_core.h>
+
+/* SUNXI UART PORT definition*/
+#define PORT_MAX_USED	PORT_LINFLEXUART  /* see include/uapi/linux/serial_core.h */
+#define PORT_SUNXI	(PORT_MAX_USED + 1)
+
+struct sw_uart_pdata {
+	unsigned int used;
+	unsigned int io_num;
+	unsigned int port_no;
+	char regulator_id[16];
+	struct regulator *regulator;
+};
+
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+struct sw_uart_dma {
+	u32 use_dma; /* 1:used */
+
+	/* receive and transfer buffer */
+	char *rx_buffer; /* visual memory */
+	char *tx_buffer;
+	dma_addr_t rx_phy_addr; /* physical memory */
+	dma_addr_t tx_phy_addr;
+	u32 rb_size; /* buffer size */
+	u32 tb_size;
+
+	/* regard the rx buffer as a circular buffer */
+	u32 rb_head;
+	u32 rb_tail;
+	u32 rx_size;
+
+	dma_cookie_t rx_cookie;
+
+	char tx_dma_inited; /* 1:dma tx channel has been init */
+	char rx_dma_inited; /* 1:dma rx channel has been init */
+	char tx_dma_used;   /* 1:dma tx is working */
+	char rx_dma_used;   /* 1:dma rx is working */
+
+	/* timer to poll activity on rx dma */
+	char use_timer;
+	int rx_timeout;
+
+	struct dma_chan *dma_chan_rx, *dma_chan_tx;
+	struct scatterlist rx_sgl, tx_sgl;
+	unsigned int		rx_bytes, tx_bytes;
+};
+#endif
+
+struct sw_uart_port {
+	struct uart_port port;
+	char   name[16];
+	struct clk *mclk;
+	struct clk *sclk;
+	struct clk *pclk;
+	struct reset_control *reset;
+	unsigned char id;
+	unsigned char ier;
+	unsigned char lcr;
+	unsigned char mcr;
+	unsigned char fcr;
+	unsigned char dll;
+	unsigned char dlh;
+	unsigned char rs485;
+	unsigned char msr_saved_flags;
+	unsigned int lsr_break_flag;
+	struct sw_uart_pdata *pdata;
+#if IS_ENABLED(CONFIG_SERIAL_SUNXI_DMA)
+	struct sw_uart_dma *dma;
+	struct hrtimer rx_hrtimer;
+	u32 rx_last_pos;
+#define SUNXI_UART_DRQ_RX(ch)		(DRQSRC_UART0_RX + ch)
+#define SUNXI_UART_DRQ_TX(ch)		(DRQDST_UART0_TX + ch)
+#endif
+
+	/* for debug */
+#define MAX_DUMP_SIZE	1024
+	unsigned int dump_len;
+	char *dump_buff;
+	struct proc_dir_entry *proc_root;
+	struct proc_dir_entry *proc_info;
+
+	struct pinctrl *pctrl;
+	struct serial_rs485 rs485conf;
+	bool card_print;
+	bool throttled;
+};
+
+/* register offset define */
+#define SUNXI_UART_RBR (0x00) 		/* receive buffer register */
+#define SUNXI_UART_THR (0x00) 		/* transmit holding register */
+#define SUNXI_UART_DLL (0x00) 		/* divisor latch low register */
+#define SUNXI_UART_DLH (0x04) 		/* diviso latch high register */
+#define SUNXI_UART_IER (0x04) 		/* interrupt enable register */
+#define SUNXI_UART_IIR (0x08) 		/* interrupt identity register */
+#define SUNXI_UART_FCR (0x08) 		/* FIFO control register */
+#define SUNXI_UART_LCR (0x0c) 		/* line control register */
+#define SUNXI_UART_MCR (0x10) 		/* modem control register */
+#define SUNXI_UART_LSR (0x14) 		/* line status register */
+#define SUNXI_UART_MSR (0x18) 		/* modem status register */
+#define SUNXI_UART_SCH (0x1c) 		/* scratch register */
+#define SUNXI_UART_USR (0x7c) 		/* status register */
+#define SUNXI_UART_TFL (0x80) 		/* transmit FIFO level */
+#define SUNXI_UART_RFL (0x84) 		/* RFL */
+#define SUNXI_UART_HALT (0xa4) 		/* halt tx register */
+#define SUNXI_UART_RS485 (0xc0)		/* RS485 control and status register */
+
+/* register bit field define */
+/* Interrupt Enable Register */
+#define SUNXI_UART_IER_PTIME (BIT(7))
+#define SUNXI_UART_IER_RS485 (BIT(4))
+#define SUNXI_UART_IER_MSI   (BIT(3))
+#define SUNXI_UART_IER_RLSI  (BIT(2))
+#define SUNXI_UART_IER_THRI  (BIT(1))
+#define SUNXI_UART_IER_RDI   (BIT(0))
+/* Interrupt ID Register */
+#define SUNXI_UART_IIR_FEFLAG_MASK (BIT(6)|BIT(7))
+#define SUNXI_UART_IIR_IID_MASK    (BIT(0)|BIT(1)|BIT(2)|BIT(3))
+ #define SUNXI_UART_IIR_IID_MSTA    (0)
+ #define SUNXI_UART_IIR_IID_NOIRQ   (1)
+ #define SUNXI_UART_IIR_IID_THREMP  (2)
+ #define SUNXI_UART_IIR_IID_RXDVAL  (4)
+ #define SUNXI_UART_IIR_IID_LINESTA (6)
+ #define SUNXI_UART_IIR_IID_BUSBSY  (7)
+ #define SUNXI_UART_IIR_IID_CHARTO  (12)
+/* FIFO Control Register */
+#define SUNXI_UART_FCR_RXTRG_MASK  (BIT(6)|BIT(7))
+ #define SUNXI_UART_FCR_RXTRG_1CH   (0 << 6)
+ #define SUNXI_UART_FCR_RXTRG_1_4   (1 << 6)
+ #define SUNXI_UART_FCR_RXTRG_1_2   (2 << 6)
+ #define SUNXI_UART_FCR_RXTRG_FULL  (3 << 6)
+#define SUNXI_UART_FCR_TXTRG_MASK  (BIT(4)|BIT(5))
+ #define SUNXI_UART_FCR_TXTRG_EMP   (0 << 4)
+ #define SUNXI_UART_FCR_TXTRG_2CH   (1 << 4)
+ #define SUNXI_UART_FCR_TXTRG_1_4   (2 << 4)
+ #define SUNXI_UART_FCR_TXTRG_1_2   (3 << 4)
+#define SUNXI_UART_FCR_TXFIFO_RST  (BIT(2))
+#define SUNXI_UART_FCR_RXFIFO_RST  (BIT(1))
+#define SUNXI_UART_FCR_FIFO_EN     (BIT(0))
+/* Line Control Register */
+#define SUNXI_UART_LCR_DLAB        (BIT(7))
+#define SUNXI_UART_LCR_SBC         (BIT(6))
+#define SUNXI_UART_LCR_PARITY_MASK (BIT(5)|BIT(4))
+ #define SUNXI_UART_LCR_EPAR        (1 << 4)
+ #define SUNXI_UART_LCR_OPAR        (0 << 4)
+#define SUNXI_UART_LCR_PARITY      (BIT(3))
+#define SUNXI_UART_LCR_STOP        (BIT(2))
+#define SUNXI_UART_LCR_DLEN_MASK   (BIT(1)|BIT(0))
+ #define SUNXI_UART_LCR_WLEN5       (0)
+ #define SUNXI_UART_LCR_WLEN6       (1)
+ #define SUNXI_UART_LCR_WLEN7       (2)
+ #define SUNXI_UART_LCR_WLEN8       (3)
+/* Modem Control Register */
+#define SUNXI_UART_MCR_MODE_MASK  (BIT(7)|BIT(6))
+ #define SUNXI_UART_MCR_MODE_RS485 (2 << 6)
+ #define SUNXI_UART_MCR_MODE_SIRE  (1 << 6)
+ #define SUNXI_UART_MCR_MODE_UART  (0 << 6)
+#define SUNXI_UART_MCR_AFE        (BIT(5))
+#define SUNXI_UART_MCR_LOOP       (BIT(4))
+#define SUNXI_UART_MCR_RTS        (BIT(1))
+#define SUNXI_UART_MCR_DTR        (BIT(0))
+/* Line Status Rigster */
+#define SUNXI_UART_LSR_RXFIFOE    (BIT(7))
+#define SUNXI_UART_LSR_TEMT       (BIT(6))
+#define SUNXI_UART_LSR_THRE       (BIT(5))
+#define SUNXI_UART_LSR_BI         (BIT(4))
+#define SUNXI_UART_LSR_FE         (BIT(3))
+#define SUNXI_UART_LSR_PE         (BIT(2))
+#define SUNXI_UART_LSR_OE         (BIT(1))
+#define SUNXI_UART_LSR_DR         (BIT(0))
+#define SUNXI_UART_LSR_BRK_ERROR_BITS 0x1E /* BI, FE, PE, OE bits */
+/* Modem Status Register */
+#define SUNXI_UART_MSR_DCD        (BIT(7))
+#define SUNXI_UART_MSR_RI         (BIT(6))
+#define SUNXI_UART_MSR_DSR        (BIT(5))
+#define SUNXI_UART_MSR_CTS        (BIT(4))
+#define SUNXI_UART_MSR_DDCD       (BIT(3))
+#define SUNXI_UART_MSR_TERI       (BIT(2))
+#define SUNXI_UART_MSR_DDSR       (BIT(1))
+#define SUNXI_UART_MSR_DCTS       (BIT(0))
+#define SUNXI_UART_MSR_ANY_DELTA  0x0F
+#define MSR_SAVE_FLAGS SUNXI_UART_MSR_ANY_DELTA
+/* Status Register */
+#define SUNXI_UART_USR_RFF        (BIT(4))
+#define SUNXI_UART_USR_RFNE       (BIT(3))
+#define SUNXI_UART_USR_TFE        (BIT(2))
+#define SUNXI_UART_USR_TFNF       (BIT(1))
+#define SUNXI_UART_USR_BUSY       (BIT(0))
+/* Halt Register */
+#define SUNXI_UART_HALT_LCRUP     (BIT(2))
+#define SUNXI_UART_HALT_FORCECFG  (BIT(1))
+#define SUNXI_UART_HALT_HTX       (BIT(0))
+/* RS485 Control and Status Register */
+#define SUNXI_UART_RS485_RXBFA    (BIT(3))
+#define SUNXI_UART_RS485_RXAFA    (BIT(2))
+
+/* The global infor of UART channel. */
+
+#if IS_ENABLED(CONFIG_ARCH_SUN50IW10)
+#define SUNXI_UART_NUM			8
+#endif
+
+#if IS_ENABLED(CONFIG_ARCH_SUN8IW20) || IS_ENABLED(CONFIG_ARCH_SUN20IW1) || IS_ENABLED(CONFIG_ARCH_SUN50IW9)
+#define SUNXI_UART_NUM			6
+#endif
+
+#if IS_ENABLED(CONFIG_ARCH_SUN8IW15)
+#define SUNXI_UART_NUM			5
+#endif
+
+#if IS_ENABLED(CONFIG_ARCH_SUN55IW3)
+#define SUNXI_UART_NUM			9
+#endif
+
+#ifndef SUNXI_UART_NUM
+#define SUNXI_UART_NUM			1
+#endif
+
+/* In 50/39 FPGA, two UART is available, but they share one IRQ.
+   So we define the number of UART port as 1. */
+#if !IS_ENABLED(CONFIG_EVB_PLATFORM)
+#undef SUNXI_UART_NUM
+#define SUNXI_UART_NUM			1
+#endif
+
+#define SUNXI_UART_FIFO_SIZE		64
+
+#define SUNXI_UART_DEV_NAME		"uart"
+
+struct platform_device *sw_uart_get_pdev(int uart_id);
+
+#endif /* end of _SUNXI_UART_H_ */
diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c
index 573b20551..0329f5ec0 100644
--- a/drivers/tty/sysrq.c
+++ b/drivers/tty/sysrq.c
@@ -54,6 +54,8 @@
 #include <asm/ptrace.h>
 #include <asm/irq_regs.h>
 
+#include <trace/hooks/sysrqcrash.h>
+
 /* Whether we react on sysrq keys or just ignore them */
 static int __read_mostly sysrq_enabled = CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE;
 static bool __read_mostly sysrq_always_enabled;
@@ -137,6 +139,8 @@ static void sysrq_handle_crash(int key)
 	/* release the RCU read lock before crashing */
 	rcu_read_unlock();
 
+	trace_android_vh_sysrq_crash(current);
+
 	panic("sysrq triggered crash\n");
 }
 static struct sysrq_key_op sysrq_crash_op = {
-- 
2.17.1

